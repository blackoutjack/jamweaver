function v1409() {
  function v1408(soruceFiles) {
    function v1407(sf$$1) {
      JAM.call(resolvedFiles.push, resolvedFiles, [sf$$1.path]);
      addWatcher(sf$$1.path);
      return
    }
    function onWatchedFileChange() {
      function v1406(f$$1) {
        var v1412 = _this$$24.ioHost;
        return JAM.call(v1412.printLine, v1412, ["    " + f$$1])
      }
      function v1405(sf) {
        return JAM.call(newFiles.push, newFiles, [sf.path])
      }
      _this$$24.compilationEnvironment.code = soruceFiles;
      var v1416 = _this$$24;
      var v12376;
      if(_this$$24.compilationSettings.resolve) {
        v12376 = _this$$24.resolve()
      }else {
        v12376 = _this$$24.compilationEnvironment
      }
      v1416.resolvedEnvironment = v12376;
      var oldFiles = resolvedFiles;
      var newFiles = [];
      _this$$24.resolvedEnvironment.code.forEach(v1405);
      newFiles = newFiles.sort();
      var i$$149 = 0;
      var j$$21 = 0;
      var v12378 = i$$149 < oldFiles.length;
      if(v12378) {
        v12378 = j$$21 < newFiles.length
      }
      var v1424 = v12378;
      for(;v1424;) {
        introspect(JAM.policy.p1) {
          var v1418 = oldFiles[i$$149]
        }
        introspect(JAM.policy.p1) {
          var v1419 = newFiles[j$$21]
        }
        var compareResult = v1418.localeCompare(v1419);
        if(compareResult == 0) {
          i$$149 = i$$149 + 1;
          j$$21 = j$$21 + 1
        }else {
          if(compareResult < 0) {
            introspect(JAM.policy.p1) {
              var v1420 = oldFiles[i$$149]
            }
            removeWatcher(v1420);
            i$$149 = i$$149 + 1
          }else {
            introspect(JAM.policy.p1) {
              var v1421 = newFiles[j$$21]
            }
            addWatcher(v1421);
            j$$21 = j$$21 + 1
          }
        }
        var v12379 = i$$149 < oldFiles.length;
        if(v12379) {
          v12379 = j$$21 < newFiles.length
        }
        v1424 = v12379
      }
      var k$$15 = i$$149;
      var v1426 = k$$15 < oldFiles.length;
      for(;v1426;) {
        introspect(JAM.policy.p1) {
          var v1425 = oldFiles[k$$15]
        }
        removeWatcher(v1425);
        k$$15 = k$$15 + 1;
        v1426 = k$$15 < oldFiles.length
      }
      k$$15 = j$$21;
      var v1428 = k$$15 < newFiles.length;
      for(;v1428;) {
        introspect(JAM.policy.p1) {
          var v1427 = newFiles[k$$15]
        }
        addWatcher(v1427);
        k$$15 = k$$15 + 1;
        v1428 = k$$15 < newFiles.length
      }
      resolvedFiles = newFiles;
      var v1429 = _this$$24.ioHost;
      JAM.call(v1429.printLine, v1429, [""]);
      var v1430 = _this$$24.ioHost;
      JAM.call(v1430.printLine, v1430, ["Recompiling (" + new Date + "): "]);
      resolvedFiles.forEach(v1406);
      var hasCompileErrors$$1 = _this$$24.compile();
      var v1432 = hasCompileErrors$$1;
      if(!v1432) {
        v1432 = _this$$24.hasResolveErrors
      }
      var hasErrors$$1 = v1432;
      if(!hasErrors$$1) {
        if(_this$$24.compilationSettings.exec) {
          _this$$24.run()
        }
      }
      return
    }
    function removeWatcher(filename$$14) {
      introspect(JAM.policy.p1) {
        var v1436 = watchers[filename$$14]
      }
      if(v1436) {
        introspect(JAM.policy.p1) {
          var v1435 = watchers[filename$$14]
        }
        v1435.close();
        delete watchers[filename$$14]
      }else {
        throw new Error("Cannot stop watching file, it is not being watched.");
      }
      return
    }
    function addWatcher(filename$$13) {
      introspect(JAM.policy.p1) {
        var v12387 = watchers[filename$$13]
      }
      if(!v12387) {
        var v1437 = _this$$24.ioHost;
        var watcher = JAM.call(v1437.watchFile, v1437, [filename$$13, onWatchedFileChange]);
        JAM.set(watchers, filename$$13, watcher)
      }else {
        throw new Error("Cannot watch file, it is already watched.");
      }
      return
    }
    var _this$$24 = this;
    if(!this.ioHost.watchFile) {
      var v1439 = this.ioHost;
      JAM.call(v1439.printLine, v1439, ["Error: Current host does not support -w[atch] option"]);
      return
    }
    var resolvedFiles = [];
    var watchers = {};
    this.ioHost.stderr = this.ioHost.stdout;
    this.resolvedEnvironment.code.forEach(v1407);
    resolvedFiles.sort();
    return
  }
  function v1404() {
    if(!this.printedVersion) {
      var v1443 = this.ioHost;
      JAM.call(v1443.printLine, v1443, ["Version " + this.compilerVersion]);
      this.printedVersion = true
    }
    return
  }
  function v1403() {
    function v1402() {
      _this$$23.printVersion();
      return
    }
    function v1401() {
      _this$$23.compilationSettings.useCaseSensitiveFileResolution = true;
      return
    }
    function v1400() {
      _this$$23.printVersion();
      opts$$1.printUsage();
      printedUsage = true;
      return
    }
    function v1399(type$$63) {
      type$$63 = type$$63.toLowerCase();
      var v12393 = type$$63 === "commonjs";
      if(!v12393) {
        v12393 = type$$63 === "node"
      }
      if(v12393) {
        TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous
      }else {
        if(type$$63 === "amd") {
          TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Asynchronous
        }else {
          var v1449 = _this$$23.ioHost;
          JAM.call(v1449.printLine, v1449, ["Module code generation '" + type$$63 + "' not supported.  Using default 'commonjs' code generation"])
        }
      }
      return
    }
    function v1398(type$$62) {
      type$$62 = type$$62.toLowerCase();
      if(type$$62 === "es3") {
        _this$$23.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES3
      }else {
        if(type$$62 === "es5") {
          _this$$23.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES5
        }else {
          var v1455 = _this$$23.ioHost;
          JAM.call(v1455.printLine, v1455, ["ECMAScript target version '" + type$$62 + "' not supported.  Using default 'ES3' code generation"])
        }
      }
      return
    }
    function v1397() {
      _this$$23.compilationSettings.inferPropertiesFromThisAssignment = true;
      return
    }
    function v1396() {
      _this$$23.compilationSettings.useDefaultLib = false;
      return
    }
    function v1395() {
      TypeScript.optimizeModuleCodeGen = false;
      return
    }
    function v1394() {
      _this$$23.compilationSettings.canCallDefinitionSignature = true;
      return
    }
    function v1393() {
      TypeScript.CompilerDiagnostics.debug = true;
      return
    }
    function v1392() {
      _this$$23.compilationSettings.resolve = false;
      _this$$23.compilationSettings.preprocess = false;
      return
    }
    function v1391() {
      _this$$23.compilationSettings.errorOnWith = false;
      return
    }
    function v1390() {
      _this$$23.compilationSettings.controlFlow = true;
      _this$$23.compilationSettings.controlFlowUseDef = true;
      return
    }
    function v1389() {
      _this$$23.compilationSettings.controlFlow = true;
      _this$$23.compilationSettings.printControlFlow = true;
      return
    }
    function v1388() {
      _this$$23.compilationSettings.controlFlow = true;
      return
    }
    function v1387() {
      _this$$23.compilationSettings.emitComments = true;
      return
    }
    function v1386() {
      _this$$23.compilationSettings.errorRecovery = true;
      return
    }
    function v1385() {
      _this$$23.compilationSettings.propagateConstants = true;
      return
    }
    function v1384() {
      _this$$23.compilationSettings.minWhitespace = true;
      return
    }
    function v1383() {
      _this$$23.compilationSettings.parseOnly = true;
      return
    }
    function v1382() {
      _this$$23.compilationSettings.exec = true;
      return
    }
    function v1381() {
      _this$$23.compilationSettings.watch = true;
      return
    }
    function v1380() {
      _this$$23.compilationSettings.generateDeclarationFiles = true;
      return
    }
    function v1379() {
      _this$$23.compilationSettings.mapSourceFiles = true;
      return
    }
    function v1378(str$$27) {
      var v1480 = _this$$23.compilationSettings;
      JAM.call(v1480.setStyleOptions, v1480, [str$$27]);
      return
    }
    function v1377(str$$26) {
      _this$$23.compilationSettings.outputOption = str$$26;
      return
    }
    function v1376(s$$42) {
      var v1482 = _this$$23.ioHost;
      JAM.call(v1482.printLine, v1482, [s$$42]);
      return
    }
    var _this$$23 = this;
    TypeScript.CompilerDiagnostics.diagnosticWriter = {Alert:v1376};
    var code$$12;
    var opts$$1 = JAM.new(OptionsParser, [this.ioHost]);
    JAM.call(opts$$1.option, opts$$1, ["out", {usage:"Concatenate and emit output to single file | Redirect output structure to the directory", type:"file|directory", set:v1377}]);
    JAM.call(opts$$1.option, opts$$1, ["style", {usage:'Select style checking options (examples --style requireSemi:off or --style "eqeqeq;bitwise:off")', experimental:true, set:v1378}]);
    JAM.call(opts$$1.flag, opts$$1, ["sourcemap", {usage:"Generates corresponding .map file", set:v1379}]);
    JAM.call(opts$$1.flag, opts$$1, ["declaration", {usage:"Generates corresponding .d.ts file", set:v1380}]);
    if(this.ioHost.watchFile) {
      JAM.call(opts$$1.flag, opts$$1, ["watch", {usage:"Watch output files", set:v1381}, "w"])
    }
    JAM.call(opts$$1.flag, opts$$1, ["exec", {usage:"Execute the script after compilation", set:v1382}, "e"]);
    JAM.call(opts$$1.flag, opts$$1, ["parse", {usage:"Parse only", experimental:true, set:v1383}]);
    JAM.call(opts$$1.flag, opts$$1, ["minw", {usage:"Minimize whitespace", experimental:true, set:v1384}, "mw"]);
    JAM.call(opts$$1.flag, opts$$1, ["const", {usage:"Propagate constants to emitted code", experimental:true, set:v1385}]);
    JAM.call(opts$$1.flag, opts$$1, ["errorrecovery", {usage:"Enable error recovery", experimental:true, set:v1386}, "er"]);
    JAM.call(opts$$1.flag, opts$$1, ["comments", {usage:"Emit comments to output", set:v1387}, "c"]);
    JAM.call(opts$$1.flag, opts$$1, ["cflow", {usage:"Control flow", experimental:true, set:v1388}]);
    JAM.call(opts$$1.flag, opts$$1, ["cflowp", {usage:"Print control flow", experimental:true, set:v1389}]);
    JAM.call(opts$$1.flag, opts$$1, ["cflowu", {usage:"Print Use Def control flow", experimental:true, set:v1390}]);
    JAM.call(opts$$1.flag, opts$$1, ["noerroronwith", {usage:"Allow with statements", experimental:true, set:v1391}]);
    JAM.call(opts$$1.flag, opts$$1, ["noresolve", {usage:"Skip resolution and preprocessing", experimental:true, set:v1392}]);
    JAM.call(opts$$1.flag, opts$$1, ["debug", {usage:"Print debug output", experimental:true, set:v1393}]);
    JAM.call(opts$$1.flag, opts$$1, ["canCallDefinitionSignature", {usage:"Allows you to call the definition signature of an overload group", experimental:true, set:v1394}]);
    JAM.call(opts$$1.flag, opts$$1, ["nooptimizemodules", {usage:"Do not optimize module codegen", experimental:true, set:v1395}]);
    JAM.call(opts$$1.flag, opts$$1, ["nolib", {usage:"Do not include a default lib.d.ts with global declarations", set:v1396}]);
    JAM.call(opts$$1.flag, opts$$1, ["inferProperties", {usage:"Infer class properties from top-level assignments to 'this'", experimental:true, set:v1397}]);
    JAM.call(opts$$1.option, opts$$1, ["target", {usage:'Specify ECMAScript target version: "ES3" (default), or "ES5"', type:"VER", set:v1398}]);
    JAM.call(opts$$1.option, opts$$1, ["module", {usage:'Specify module code generation: "commonjs" (default) or "amd"', type:"kind", set:v1399}]);
    var printedUsage = false;
    JAM.call(opts$$1.flag, opts$$1, ["help", {usage:"Print this message", set:v1400}, "h"]);
    JAM.call(opts$$1.flag, opts$$1, ["useCaseSensitiveFileResolution", {usage:"Force file resolution to be case sensitive", experimental:true, set:v1401}]);
    JAM.call(opts$$1.flag, opts$$1, ["version", {usage:"Print the compiler's version: " + this.compilerVersion, set:v1402}, "v"]);
    JAM.call(opts$$1.parse, opts$$1, [this.ioHost.arguments]);
    if(this.compilationSettings.useDefaultLib) {
      var compilerFilePath = this.ioHost.getExecutingFilePath();
      var v1514 = this.ioHost;
      var binDirPath = JAM.call(v1514.dirName, v1514, [compilerFilePath]);
      var v1515 = this.ioHost;
      var libStrPath = JAM.call(v1515.resolvePath, v1515, [binDirPath + "/lib.d.ts"]);
      code$$12 = JAM.new(TypeScript.SourceUnit, [libStrPath, null]);
      var v1518 = this.compilationEnvironment.code;
      JAM.call(v1518.push, v1518, [code$$12])
    }
    var i$$148 = 0;
    var v1523 = i$$148 < opts$$1.unnamed.length;
    for(;v1523;) {
      var v1520 = TypeScript.SourceUnit;
      var v12404 = opts$$1.unnamed;
      introspect(JAM.policy.p1) {
        var v1521 = v12404[i$$148]
      }
      code$$12 = JAM.new(v1520, [v1521, null]);
      var v1522 = this.compilationEnvironment.code;
      JAM.call(v1522.push, v1522, [code$$12]);
      i$$148 = i$$148 + 1;
      v1523 = i$$148 < opts$$1.unnamed.length
    }
    var v12407 = this.compilationEnvironment.code.length;
    var v18839;
    if(this.compilationSettings.useDefaultLib) {
      v18839 = 1
    }else {
      v18839 = 0
    }
    if(v12407 == v18839) {
      var v12409 = !printedUsage;
      if(v12409) {
        v12409 = !this.printedVersion
      }
      if(v12409) {
        this.printVersion();
        opts$$1.printUsage();
        var v1524 = this.ioHost;
        JAM.call(v1524.quit, v1524, [1])
      }
      return
    }
    var sourceFiles = [];
    if(this.compilationSettings.watch) {
      sourceFiles = this.compilationEnvironment.code.slice(0)
    }
    var v1529;
    if(this.compilationSettings.resolve) {
      v1529 = this.resolve()
    }else {
      v1529 = this.compilationEnvironment
    }
    this.resolvedEnvironment = v1529;
    var hasCompileErrors = this.compile();
    var v1530 = hasCompileErrors;
    if(!v1530) {
      v1530 = this.hasResolveErrors
    }
    var hasErrors = v1530;
    if(!hasErrors) {
      if(this.compilationSettings.exec) {
        this.run()
      }
    }
    if(this.compilationSettings.watch) {
      JAM.call(this.watchFiles, this, [sourceFiles])
    }else {
      var v1533 = this.ioHost;
      var v12416;
      if(hasErrors) {
        v12416 = 1
      }else {
        v12416 = 0
      }
      JAM.call(v1533.quit, v1533, [v12416])
    }
    return
  }
  function v1375() {
    var i$$147 = 0;
    var v1542 = i$$147 < this.compilationEnvironment.code.length;
    for(;v1542;) {
      var v1536 = this.compilationEnvironment.code;
      introspect(JAM.policy.p1) {
        var unit = v1536[i$$147]
      }
      var outputFileName = unit.path;
      if(JAM.call(TypeScript.isTSFile, TypeScript, [outputFileName])) {
        outputFileName = outputFileName.replace(/\.ts$/, ".js")
      }else {
        if(JAM.call(TypeScript.isSTRFile, TypeScript, [outputFileName])) {
          outputFileName = outputFileName.replace(/\.str$/, ".js")
        }
      }
      var v12419 = this.ioHost;
      if(JAM.call(v12419.fileExists, v12419, [outputFileName])) {
        var v1539 = this.ioHost;
        var unitRes = JAM.call(v1539.readFile, v1539, [outputFileName]);
        var v1540 = this.ioHost;
        JAM.call(v1540.run, v1540, [unitRes, outputFileName])
      }
      i$$147 = i$$147 + 1;
      v1542 = i$$147 < this.compilationEnvironment.code.length
    }
    return
  }
  function v1374() {
    function v1373(fileName$$10, useUTF8$$5) {
      return JAM.call(IOUtils.createFileAndFolderStructure, IOUtils, [_this$$22.ioHost, fileName$$10, useUTF8$$5])
    }
    function v1372(minChar$$37, charLen$$2, message$$24, unitIndex$$15) {
      compiler$$3.errorReporter.hasErrors = true;
      var v12421 = _this$$22.resolvedEnvironment.code;
      introspect(JAM.policy.p1) {
        var v1545 = v12421[unitIndex$$15]
      }
      var fname$$9 = v1545.path;
      var lineCol$$6 = {line:-1, col:-1};
      var v1546 = compiler$$3.parser;
      JAM.call(v1546.getSourceLineCol, v1546, [lineCol$$6, minChar$$37]);
      var msg$$4 = fname$$9 + " (" + lineCol$$6.line + "," + (lineCol$$6.col + 1) + "): " + message$$24;
      if(_this$$22.compilationSettings.errorRecovery) {
        var v1548 = _this$$22.ioHost.stderr;
        JAM.call(v1548.WriteLine, v1548, [msg$$4])
      }else {
        throw new SyntaxError(msg$$4);
      }
      return
    }
    function consumeUnit(code$$11, addAsResident) {
      try {
        if(!_this$$22.compilationSettings.resolve) {
          var v1550 = code$$11;
          var v12426 = _this$$22.ioHost;
          var v26770 = JAM.call(v12426.readFile, v12426, [code$$11.path]);
          v1550.content = v26770;
          if(_this$$22.compilationSettings.generateDeclarationFiles) {
            var v1551 = TypeScript.CompilerDiagnostics;
            JAM.call(v1551.assert, v1551, [code$$11.referencedFiles == null, "With no resolve option, referenced files need to null"]);
            var v1553 = code$$11;
            var v26771 = JAM.call(TypeScript.getReferencedFiles, TypeScript, [code$$11]);
            v1553.referencedFiles = v26771
          }
        }
        if(code$$11.content) {
          if(_this$$22.compilationSettings.parseOnly) {
            JAM.call(compiler$$3.parseUnit, compiler$$3, [code$$11.content, code$$11.path])
          }else {
            if(_this$$22.compilationSettings.errorRecovery) {
              var v1558 = compiler$$3.parser;
              JAM.call(v1558.setErrorRecovery, v1558, [_this$$22.ioHost.stderr])
            }
            JAM.call(compiler$$3.addUnit, compiler$$3, [code$$11.content, code$$11.path, addAsResident, code$$11.referencedFiles])
          }
        }
      }catch(err$$7) {
        compiler$$3.errorReporter.hasErrors = true;
        var v1567 = _this$$22.ioHost.stderr;
        JAM.call(v1567.WriteLine, v1567, [err$$7.message])
      }
      return
    }
    var _this$$22 = this;
    var compiler$$3;
    compiler$$3 = JAM.new(TypeScript.TypeScriptCompiler, [this.ioHost.stderr, new TypeScript.NullLogger, this.compilationSettings]);
    JAM.call(compiler$$3.setErrorOutput, compiler$$3, [this.ioHost.stderr]);
    JAM.call(compiler$$3.setErrorCallback, compiler$$3, [v1372]);
    if(this.compilationSettings.emitComments) {
      compiler$$3.emitCommentsToOutput()
    }
    var iCode = 0;
    var v1577 = iCode < this.resolvedEnvironment.code.length;
    for(;v1577;) {
      var v12439 = !this.compilationSettings.parseOnly;
      if(!v12439) {
        v12439 = iCode > 0
      }
      if(v12439) {
        var v12440 = this.resolvedEnvironment.code;
        introspect(JAM.policy.p1) {
          var v1575 = v12440[iCode]
        }
        consumeUnit(v1575, false)
      }
      iCode = iCode + 1;
      v1577 = iCode < this.resolvedEnvironment.code.length
    }
    var emitterIOHost = {createFile:v1373, directoryExists:this.ioHost.directoryExists, fileExists:this.ioHost.fileExists, resolvePath:this.ioHost.resolvePath};
    try {
      if(!this.compilationSettings.parseOnly) {
        compiler$$3.typeCheck();
        JAM.call(compiler$$3.emit, compiler$$3, [emitterIOHost]);
        compiler$$3.emitDeclarations()
      }else {
        JAM.call(compiler$$3.emitAST, compiler$$3, [emitterIOHost])
      }
    }catch(err$$8) {
      compiler$$3.errorReporter.hasErrors = true;
      if(err$$8.message != "EmitError") {
        throw err$$8;
      }
    }
    return compiler$$3.errorReporter.hasErrors
  }
  function v1371() {
    var resolver$$1 = JAM.new(TypeScript.CodeResolver, [this.compilationEnvironment]);
    var commandLineHost = JAM.new(CommandLineHost, [this.compilationSettings]);
    var ret$$2 = JAM.call(commandLineHost.resolveCompilationEnvironment, commandLineHost, [this.compilationEnvironment, resolver$$1, true]);
    this.hasResolveErrors = false;
    var i$$146 = 0;
    var v1596 = i$$146 < this.compilationEnvironment.code.length;
    for(;v1596;) {
      var v24782 = this.compilationEnvironment.code;
      introspect(JAM.policy.p1) {
        var v22838 = v24782[i$$146]
      }
      if(!JAM.call(commandLineHost.isResolved, commandLineHost, [v22838.path])) {
        this.hasResolveErrors = true;
        var v12449 = this.compilationEnvironment.code;
        introspect(JAM.policy.p1) {
          var v1589 = v12449[i$$146]
        }
        var path$$45 = v1589.path;
        var v12450 = !JAM.call(TypeScript.isSTRFile, TypeScript, [path$$45]);
        if(v12450) {
          var v18858 = !JAM.call(TypeScript.isDSTRFile, TypeScript, [path$$45]);
          if(v18858) {
            var v22840 = !JAM.call(TypeScript.isTSFile, TypeScript, [path$$45]);
            if(v22840) {
              v22840 = !JAM.call(TypeScript.isDTSFile, TypeScript, [path$$45])
            }
            v18858 = v22840
          }
          v12450 = v18858
        }
        if(v12450) {
          var v1590 = this.ioHost.stderr;
          JAM.call(v1590.WriteLine, v1590, ['Unknown extension for file: "' + path$$45 + '". Only .ts and .d.ts extensions are allowed.'])
        }else {
          var v1592 = this.ioHost.stderr;
          JAM.call(v1592.WriteLine, v1592, ['Error reading file "' + path$$45 + '": File not found'])
        }
      }
      i$$146 = i$$146 + 1;
      v1596 = i$$146 < this.compilationEnvironment.code.length
    }
    return ret$$2
  }
  function BatchCompiler$$1(ioHost$$7) {
    this.ioHost = ioHost$$7;
    this.resolvedEnvironment = null;
    this.hasResolveErrors = false;
    this.compilerVersion = "0.8.2.0";
    this.printedVersion = false;
    var v26772 = new TypeScript.CompilationSettings;
    this.compilationSettings = v26772;
    var v26773 = JAM.new(TypeScript.CompilationEnvironment, [this.compilationSettings, this.ioHost]);
    this.compilationEnvironment = v26773;
    return
  }
  BatchCompiler$$1.prototype.resolve = v1371;
  BatchCompiler$$1.prototype.compile = v1374;
  BatchCompiler$$1.prototype.run = v1375;
  BatchCompiler$$1.prototype.batchCompile = v1403;
  BatchCompiler$$1.prototype.printVersion = v1404;
  BatchCompiler$$1.prototype.watchFiles = v1408;
  return BatchCompiler$$1
}
function v1370() {
  function v1369(preEnv, resolver, traceDependencies) {
    function v1368(path$$44, code$$10) {
      var pathId = JAM.call(_this$$21.getPathIdentifier, _this$$21, [path$$44]);
      var v18860 = _this$$21.resolvedPaths;
      introspect(JAM.policy.p1) {
        var v12456 = v18860[pathId]
      }
      if(!v12456) {
        var v1607 = resolvedEnv.code;
        JAM.call(v1607.push, v1607, [code$$10]);
        JAM.set(_this$$21.resolvedPaths, pathId, true)
      }
      return
    }
    function postResolutionError(errorFile, errorMessage$$1) {
      var v1610 = TypeScript.CompilerDiagnostics;
      var v12457 = "Could not resolve file '" + errorFile + "'";
      var v18862;
      if(errorMessage$$1 == "") {
        v18862 = ""
      }else {
        v18862 = ": " + errorMessage$$1
      }
      JAM.call(v1610.debugPrint, v1610, [v12457 + v18862]);
      return
    }
    var _this$$21 = this;
    var resolvedEnv = JAM.new(TypeScript.CompilationEnvironment, [preEnv.compilationSettings, preEnv.ioHost]);
    var nCode = preEnv.code.length;
    var path$$43 = "";
    var resolutionDispatcher$$1 = {postResolutionError:postResolutionError, postResolution:v1368};
    var i$$145 = 0;
    var v1619 = i$$145 < nCode;
    for(;v1619;) {
      var v12459 = preEnv.ioHost;
      var v22843 = preEnv.code;
      introspect(JAM.policy.p1) {
        var v18863 = v22843[i$$145]
      }
      path$$43 = JAM.call(TypeScript.switchToForwardSlashes, TypeScript, [JAM.call(v12459.resolvePath, v12459, [v18863.path])]);
      var v1617 = this.pathMap;
      var v18864 = preEnv.code;
      introspect(JAM.policy.p1) {
        var v12461 = v18864[i$$145]
      }
      JAM.set(v1617, v12461.path, path$$43);
      JAM.call(resolver.resolveCode, resolver, [path$$43, "", false, resolutionDispatcher$$1]);
      i$$145 = i$$145 + 1;
      v1619 = i$$145 < nCode
    }
    return resolvedEnv
  }
  function v1367(path$$42) {
    var v12462 = this.resolvedPaths;
    var v22844 = this.pathMap;
    introspect(JAM.policy.p1) {
      var v18865 = v22844[path$$42]
    }
    var v12463 = JAM.call(this.getPathIdentifier, this, [v18865]);
    introspect(JAM.policy.p1) {
      var v1620 = v12462[v12463]
    }
    return v1620 != undefined
  }
  function v1366(path$$41) {
    var v1621;
    if(this.compilationSettings.useCaseSensitiveFileResolution) {
      v1621 = path$$41
    }else {
      v1621 = path$$41.toLocaleUpperCase()
    }
    return v1621
  }
  function CommandLineHost$$1(compilationSettings$$1) {
    this.compilationSettings = compilationSettings$$1;
    this.pathMap = {};
    this.resolvedPaths = {};
    return
  }
  CommandLineHost$$1.prototype.getPathIdentifier = v1366;
  CommandLineHost$$1.prototype.isResolved = v1367;
  CommandLineHost$$1.prototype.resolveCompilationEnvironment = v1369;
  return CommandLineHost$$1
}
function v1365() {
  function v1364(args$$19) {
    var position$$5 = 0;
    var v1635 = position$$5 < args$$19.length;
    for(;v1635;) {
      var v1625 = position$$5;
      position$$5 = position$$5 + 1;
      introspect(JAM.policy.p1) {
        var current$$4 = args$$19[v1625]
      }
      var match$$3 = current$$4.match(/^(--?|@)(.*)/);
      var value$$45 = null;
      if(match$$3) {
        if(match$$3[1] === "@") {
          var v12467 = this.host;
          JAM.call(this.parseString, this, [JAM.call(v12467.readFile, v12467, [match$$3[2]])])
        }else {
          var arg$$14 = match$$3[2];
          var option$$1 = JAM.call(this.findOption, this, [arg$$14]);
          if(option$$1 === null) {
            var v1627 = this.host;
            JAM.call(v1627.printLine, v1627, ["Unknown option '" + arg$$14 + "'"]);
            var v1629 = this.host;
            JAM.call(v1629.printLine, v1629, ["Use the '--help' flag to see options"])
          }else {
            if(!option$$1.flag) {
              var v1630 = position$$5;
              position$$5 = position$$5 + 1;
              value$$45 = args$$19[v1630]
            }
            JAM.call(option$$1.set, option$$1, [value$$45])
          }
        }
      }else {
        var v1634 = this.unnamed;
        JAM.call(v1634.push, v1634, [current$$4])
      }
      v1635 = position$$5 < args$$19.length
    }
    return
  }
  function v1363(argString) {
    var position$$4 = 0;
    var tokens = argString.match(/\s+|"|[^\s"]+/g);
    var args$$18 = [];
    var currentArg = "";
    var v1645 = position$$4 < tokens.length;
    for(;v1645;) {
      introspect(JAM.policy.p1) {
        var token$$7 = tokens[position$$4]
      }
      if(token$$7 === '"') {
        var JSCompiler_temp_const$$34 = currentArg;
        var JSCompiler_inline_result$$35;
        var value$$inline_36 = "";
        var v1636 = position$$4;
        position$$4 = position$$4 + 1;
        tokens[v1636];
        introspect(JAM.policy.p1) {
          var token$$inline_37 = tokens[position$$4]
        }
        var v12473 = token$$inline_37;
        if(v12473) {
          v12473 = token$$inline_37 !== '"'
        }
        var v1638 = v12473;
        for(;v1638;) {
          var v1637 = position$$4;
          position$$4 = position$$4 + 1;
          tokens[v1637];
          value$$inline_36 = value$$inline_36 + token$$inline_37;
          token$$inline_37 = tokens[position$$4];
          var v12474 = token$$inline_37;
          if(v12474) {
            v12474 = token$$inline_37 !== '"'
          }
          v1638 = v12474
        }
        var v1639 = position$$4;
        position$$4 = position$$4 + 1;
        tokens[v1639];
        JSCompiler_inline_result$$35 = value$$inline_36;
        currentArg = JSCompiler_temp_const$$34 + JSCompiler_inline_result$$35
      }else {
        if(token$$7.match(/\s/)) {
          if(currentArg.length > 0) {
            JAM.call(args$$18.push, args$$18, [currentArg]);
            currentArg = ""
          }
          var v1641 = position$$4;
          position$$4 = position$$4 + 1;
          tokens[v1641]
        }else {
          var v1642 = position$$4;
          position$$4 = position$$4 + 1;
          tokens[v1642];
          currentArg = currentArg + token$$7
        }
      }
      v1645 = position$$4 < tokens.length
    }
    if(currentArg.length > 0) {
      JAM.call(args$$18.push, args$$18, [currentArg])
    }
    JAM.call(this.parse, this, [args$$18]);
    return
  }
  function v1362(name$$92, config$$2, short$$1) {
    if(!config$$2) {
      config$$2 = short$$1;
      short$$1 = null
    }
    config$$2.name = name$$92;
    config$$2.short = short$$1;
    config$$2.flag = true;
    var v1648 = this.options;
    JAM.call(v1648.push, v1648, [config$$2]);
    return
  }
  function v1361(name$$91, config$$1, short) {
    if(!config$$1) {
      config$$1 = short;
      short = null
    }
    config$$1.name = name$$91;
    config$$1.short = short;
    config$$1.flag = false;
    var v1650 = this.options;
    JAM.call(v1650.push, v1650, [config$$1]);
    return
  }
  function v1360() {
    function v1359(a$$9, b$$15) {
      var aName = a$$9.name.toLowerCase();
      var bName = b$$15.name.toLowerCase();
      if(aName > bName) {
        return 1
      }else {
        if(aName < bName) {
          return-1
        }else {
          return 0
        }
      }
      return
    }
    var v1655 = this.host;
    JAM.call(v1655.printLine, v1655, ["Syntax:   tsc [options] [file ..]"]);
    var v1656 = this.host;
    JAM.call(v1656.printLine, v1656, [""]);
    var v1657 = this.host;
    JAM.call(v1657.printLine, v1657, ["Examples: tsc hello.ts"]);
    var v1658 = this.host;
    JAM.call(v1658.printLine, v1658, ["          tsc --out foo.js foo.ts"]);
    var v1659 = this.host;
    JAM.call(v1659.printLine, v1659, ["          tsc @args.txt"]);
    var v1660 = this.host;
    JAM.call(v1660.printLine, v1660, [""]);
    var v1661 = this.host;
    JAM.call(v1661.printLine, v1661, ["Options:"]);
    var output$$1 = [];
    var maxLength = 0;
    var v26774 = this.options.sort(v1359);
    this.options = v26774;
    var i$$144 = 0;
    var v1670 = i$$144 < this.options.length;
    for(;v1670;) {
      var v1663 = this.options;
      introspect(JAM.policy.p1) {
        var option = v1663[i$$144]
      }
      if(option.experimental) {
        i$$144 = i$$144 + 1;
        v1670 = i$$144 < this.options.length;
        continue
      }
      if(!option.usage) {
        break
      }
      var usageString = "  ";
      var v1666;
      if(option.type) {
        v1666 = " " + option.type.toUpperCase()
      }else {
        v1666 = ""
      }
      var type$$61 = v1666;
      if(option.short) {
        usageString = usageString + (this.DEFAULT_SHORT_FLAG + option.short + type$$61 + ", ")
      }
      usageString = usageString + (this.DEFAULT_LONG_FLAG + option.name + type$$61);
      JAM.call(output$$1.push, output$$1, [[usageString, option.usage]]);
      if(usageString.length > maxLength) {
        maxLength = usageString.length
      }
      i$$144 = i$$144 + 1;
      v1670 = i$$144 < this.options.length
    }
    JAM.call(output$$1.push, output$$1, [["  @<file>", "Insert command line options and files from a file."]]);
    i$$144 = 0;
    var v1674 = i$$144 < output$$1.length;
    for(;v1674;) {
      var v1672 = this.host;
      introspect(JAM.policy.p1) {
        var v22848 = output$$1[i$$144]
      }
      var v18873 = v22848[0];
      introspect(JAM.policy.p1) {
        var v26620 = output$$1[i$$144]
      }
      var v12489 = v18873 + (new Array(maxLength - v26620[0].length + 3)).join(" ");
      introspect(JAM.policy.p1) {
        var v18875 = output$$1[i$$144]
      }
      JAM.call(v1672.printLine, v1672, [v12489 + v18875[1]]);
      i$$144 = i$$144 + 1;
      v1674 = i$$144 < output$$1.length
    }
    return
  }
  function v1358(arg$$13) {
    var i$$143 = 0;
    var v1677 = i$$143 < this.options.length;
    for(;v1677;) {
      var v24788 = this.options;
      introspect(JAM.policy.p1) {
        var v22850 = v24788[i$$143]
      }
      var v12493 = arg$$13 === v22850.short;
      if(!v12493) {
        var v24789 = this.options;
        introspect(JAM.policy.p1) {
          var v22851 = v24789[i$$143]
        }
        v12493 = arg$$13 === v22851.name
      }
      if(v12493) {
        var v1675 = this.options;
        introspect(JAM.policy.p1) {
          return v1675[i$$143]
        }
      }
      i$$143 = i$$143 + 1;
      v1677 = i$$143 < this.options.length
    }
    return null
  }
  function OptionsParser$$1(host) {
    this.host = host;
    this.DEFAULT_SHORT_FLAG = "-";
    this.DEFAULT_LONG_FLAG = "--";
    this.unnamed = [];
    this.options = [];
    return
  }
  OptionsParser$$1.prototype.findOption = v1358;
  OptionsParser$$1.prototype.printUsage = v1360;
  OptionsParser$$1.prototype.option = v1361;
  OptionsParser$$1.prototype.flag = v1362;
  OptionsParser$$1.prototype.parseString = v1363;
  OptionsParser$$1.prototype.parse = v1364;
  return OptionsParser$$1
}
function v1357() {
  function getWindowsScriptHostIO() {
    function v1331(exitCode) {
      if(typeof exitCode === "undefined") {
        exitCode = 0
      }
      try {
        JAM.call(WScript.Quit, WScript, [exitCode])
      }catch(e$$16) {
      }
      return
    }
    function v1330() {
      return WScript.ScriptFullName
    }
    function v1329(source$$4, filename$$10) {
      try {
        if(JAM.isEval(eval)) {
          eval("introspect(JAM.policy.pFull) { " + source$$4 + " }")
        }else {
          JAM.call(eval, null, [source$$4])
        }
      }catch(e$$15) {
        JAM.call(IOUtils.throwIOError, IOUtils, ["Error while executing file '" + filename$$10 + "'.", e$$15])
      }
      return
    }
    function v1328(str$$17) {
      JAM.call(WScript.Echo, WScript, [str$$17]);
      return
    }
    function v1327(str$$16) {
      var v1686 = WScript.StdOut;
      JAM.call(v1686.Write, v1686, [str$$16]);
      return
    }
    function v1326(path$$30, spec, options$$8) {
      function filesInFolder(folder$$1, root) {
        var paths$$1 = [];
        var fc;
        if(options$$8.recursive) {
          fc = JAM.new(Enumerator, [folder$$1.subfolders]);
          var v1689 = !fc.atEnd();
          for(;v1689;) {
            paths$$1 = paths$$1.concat(filesInFolder(fc.item(), root + "/" + fc.item().Name));
            fc.moveNext();
            v1689 = !fc.atEnd()
          }
        }
        fc = JAM.new(Enumerator, [folder$$1.files]);
        var v1694 = !fc.atEnd();
        for(;v1694;) {
          var v12502 = !spec;
          if(!v12502) {
            v12502 = fc.item().Name.match(spec)
          }
          if(v12502) {
            JAM.call(paths$$1.push, paths$$1, [root + "/" + fc.item().Name])
          }
          fc.moveNext();
          v1694 = !fc.atEnd()
        }
        return paths$$1
      }
      options$$8 = options$$8 || {};
      var folder = JAM.call(fso.GetFolder, fso, [path$$30]);
      var paths = [];
      return filesInFolder(folder, path$$30)
    }
    function v1325(path$$29) {
      try {
        if(!JAM.call(this.directoryExists, this, [path$$29])) {
          JAM.call(fso.CreateFolder, fso, [path$$29])
        }
      }catch(e$$14) {
        JAM.call(IOUtils.throwIOError, IOUtils, ["Couldn't create directory '" + path$$29 + "'.", e$$14])
      }
      return
    }
    function v1324(path$$28) {
      return JAM.call(fso.FolderExists, fso, [path$$28])
    }
    function v1323(path$$27, useUTF8$$3) {
      function v1322() {
        try {
          JAM.call(streamObj$$1.SaveToFile, streamObj$$1, [path$$27, 2])
        }catch(saveError) {
          JAM.call(IOUtils.throwIOError, IOUtils, ["Couldn't write to file '" + path$$27 + "'.", saveError])
        }finally {
          if(streamObj$$1.State != 0) {
            streamObj$$1.Close()
          }
          JAM.call(streamObjectPool.push, streamObjectPool, [streamObj$$1])
        }
        return
      }
      function v1321(str$$15) {
        JAM.call(streamObj$$1.WriteText, streamObj$$1, [str$$15, 1]);
        return
      }
      function v1320(str$$14) {
        JAM.call(streamObj$$1.WriteText, streamObj$$1, [str$$14, 0]);
        return
      }
      try {
        var streamObj$$1 = getStreamObject();
        var v1699;
        if(useUTF8$$3) {
          v1699 = "utf-8"
        }else {
          v1699 = "x-ansi"
        }
        streamObj$$1.Charset = v1699;
        streamObj$$1.Open();
        return{Write:v1320, WriteLine:v1321, Close:v1322}
      }catch(creationError) {
        JAM.call(IOUtils.throwIOError, IOUtils, ["Couldn't write to file '" + path$$27 + "'.", creationError])
      }
      return
    }
    function v1319(path$$26) {
      try {
        if(JAM.call(fso.FileExists, fso, [path$$26])) {
          JAM.call(fso.DeleteFile, fso, [path$$26, true])
        }
      }catch(e$$13) {
        JAM.call(IOUtils.throwIOError, IOUtils, ["Couldn't delete file '" + path$$26 + "'.", e$$13])
      }
      return
    }
    function v1318(rootPath, partialFilePath) {
      var path$$25 = JAM.call(fso.GetAbsolutePathName, fso, [rootPath]) + "/" + partialFilePath;
      for(;true;) {
        if(JAM.call(fso.FileExists, fso, [path$$25])) {
          try {
            var content$$6 = JAM.call(this.readFile, this, [path$$25]);
            return{content:content$$6, path:path$$25}
          }catch(err$$5) {
          }
        }else {
          rootPath = JAM.call(fso.GetParentFolderName, fso, [JAM.call(fso.GetAbsolutePathName, fso, [rootPath])]);
          if(rootPath == "") {
            return null
          }else {
            path$$25 = JAM.call(fso.BuildPath, fso, [rootPath, partialFilePath])
          }
        }
      }
      return
    }
    function v1317(path$$24) {
      return JAM.call(fso.GetParentFolderName, fso, [path$$24])
    }
    function v1316(path$$23) {
      return JAM.call(fso.GetAbsolutePathName, fso, [path$$23])
    }
    function v1315(path$$22) {
      return JAM.call(fso.FileExists, fso, [path$$22])
    }
    function v1314(path$$21, contents) {
      var file$$1 = JAM.call(this.createFile, this, [path$$21]);
      JAM.call(file$$1.Write, file$$1, [contents]);
      file$$1.Close();
      return
    }
    function v1313(path$$20) {
      try {
        var streamObj = getStreamObject();
        streamObj.Open();
        streamObj.Type = 2;
        streamObj.Charset = "x-ansi";
        JAM.call(streamObj.LoadFromFile, streamObj, [path$$20]);
        var bomChar = JAM.call(streamObj.ReadText, streamObj, [2]);
        streamObj.Position = 0;
        var v18886 = JAM.call(bomChar.charCodeAt, bomChar, [0]) == 254;
        if(v18886) {
          v18886 = JAM.call(bomChar.charCodeAt, bomChar, [1]) == 255
        }
        var v12513 = v18886;
        if(!v12513) {
          var v18887 = JAM.call(bomChar.charCodeAt, bomChar, [0]) == 255;
          if(v18887) {
            v18887 = JAM.call(bomChar.charCodeAt, bomChar, [1]) == 254
          }
          v12513 = v18887
        }
        if(v12513) {
          streamObj.Charset = "unicode"
        }else {
          var v12514 = JAM.call(bomChar.charCodeAt, bomChar, [0]) == 239;
          if(v12514) {
            v12514 = JAM.call(bomChar.charCodeAt, bomChar, [1]) == 187
          }
          if(v12514) {
            streamObj.Charset = "utf-8"
          }
        }
        var str$$13 = JAM.call(streamObj.ReadText, streamObj, [-1]);
        streamObj.Close();
        JAM.call(streamObjectPool.push, streamObjectPool, [streamObj]);
        return str$$13
      }catch(err$$4) {
        JAM.call(IOUtils.throwIOError, IOUtils, ['Error reading file "' + path$$20 + '".', err$$4])
      }
      return
    }
    function getStreamObject() {
      if(streamObjectPool.length > 0) {
        return streamObjectPool.pop()
      }else {
        return JAM.new(ActiveXObject, ["ADODB.Stream"])
      }
      return
    }
    var fso = JAM.new(ActiveXObject, ["Scripting.FileSystemObject"]);
    var streamObjectPool = [];
    var args$$17 = [];
    var i$$140 = 0;
    var v1713 = i$$140 < WScript.Arguments.length;
    for(;v1713;) {
      var v1711 = args$$17;
      var v1712 = i$$140;
      var v12518 = WScript.Arguments;
      var v26775 = JAM.call(v12518.Item, v12518, [i$$140]);
      v1711[v1712] = v26775;
      i$$140 = i$$140 + 1;
      v1713 = i$$140 < WScript.Arguments.length
    }
    return{readFile:v1313, writeFile:v1314, fileExists:v1315, resolvePath:v1316, dirName:v1317, findFile:v1318, deleteFile:v1319, createFile:v1323, directoryExists:v1324, createDirectory:v1325, dir:v1326, print:v1327, printLine:v1328, arguments:args$$17, stderr:WScript.StdErr, stdout:WScript.StdOut, watchFile:null, run:v1329, getExecutingFilePath:v1330, quit:v1331}
  }
  function getNodeIO() {
    function v1356() {
      return process.mainModule.filename
    }
    function v1355(source$$5, filename$$12) {
      require.main.filename = filename$$12;
      var v1718 = require.main;
      var v26776 = JAM.call(_module._nodeModulePaths, _module, [JAM.call(_path.dirname, _path, [JAM.call(_fs.realpathSync, _fs, [filename$$12])])]);
      v1718.paths = v26776;
      var v1719 = require.main;
      JAM.call(v1719._compile, v1719, [source$$5, filename$$12]);
      return
    }
    function v1354(filename$$11, callback$$28) {
      function v1353() {
        JAM.call(_fs.unwatchFile, _fs, [filename$$11, fileChanged]);
        return
      }
      function fileChanged(curr, prev$$1) {
        function v1352() {
          processingChange = false;
          return
        }
        if(!firstRun) {
          if(curr.mtime < prev$$1.mtime) {
            return
          }
          JAM.call(_fs.unwatchFile, _fs, [filename$$11, fileChanged]);
          if(!processingChange) {
            processingChange = true;
            JAM.call(callback$$28, null, [filename$$11]);
            JAM.call(setTimeout, null, [v1352, 100])
          }
        }
        firstRun = false;
        JAM.call(_fs.watchFile, _fs, [filename$$11, {persistent:true, interval:500}, fileChanged]);
        return
      }
      var firstRun = true;
      var processingChange = false;
      fileChanged();
      return{filename:filename$$11, close:v1353}
    }
    function v1351() {
      return
    }
    function v1350(str$$25) {
      var v1724 = process.stdout;
      JAM.call(v1724.write, v1724, [str$$25 + "\n"]);
      return
    }
    function v1349(str$$24) {
      var v1726 = process.stdout;
      JAM.call(v1726.write, v1726, [str$$24]);
      return
    }
    function v1348() {
      return
    }
    function v1347(str$$23) {
      var v1727 = process.stderr;
      JAM.call(v1727.write, v1727, [str$$23 + "\n"]);
      return
    }
    function v1346(str$$22) {
      var v1729 = process.stderr;
      JAM.call(v1729.write, v1729, [str$$22]);
      return
    }
    function v1345(str$$21) {
      var v1730 = process.stdout;
      JAM.call(v1730.write, v1730, [str$$21 + "\n"]);
      return
    }
    function v1344(str$$20) {
      var v1732 = process.stdout;
      JAM.call(v1732.write, v1732, [str$$20]);
      return
    }
    function v1343(rootPath$$1, partialFilePath$$1) {
      var path$$40 = rootPath$$1 + "/" + partialFilePath$$1;
      for(;true;) {
        if(JAM.call(_fs.existsSync, _fs, [path$$40])) {
          try {
            var content$$7 = JAM.call(this.readFile, this, [path$$40]);
            return{content:content$$7, path:path$$40}
          }catch(err$$6) {
          }
        }else {
          var parentPath$$1 = JAM.call(_path.resolve, _path, [rootPath$$1, ".."]);
          if(rootPath$$1 === parentPath$$1) {
            return null
          }else {
            rootPath$$1 = parentPath$$1;
            path$$40 = JAM.call(_path.resolve, _path, [rootPath$$1, partialFilePath$$1])
          }
        }
      }
      return
    }
    function v1342(path$$39) {
      return JAM.call(_path.dirname, _path, [path$$39])
    }
    function v1341(path$$38) {
      return JAM.call(_path.resolve, _path, [path$$38])
    }
    function v1340(path$$37) {
      var v1736 = JAM.call(_fs.existsSync, _fs, [path$$37]);
      if(v1736) {
        v1736 = JAM.call(_fs.lstatSync, _fs, [path$$37]).isDirectory()
      }
      return v1736
    }
    function v1339(path$$36) {
      try {
        if(!JAM.call(this.directoryExists, this, [path$$36])) {
          JAM.call(_fs.mkdirSync, _fs, [path$$36])
        }
      }catch(e$$20) {
        JAM.call(IOUtils.throwIOError, IOUtils, ["Couldn't create directory '" + path$$36 + "'.", e$$20])
      }
      return
    }
    function dir(path$$35, spec$$1, options$$9) {
      function filesInFolder$$1(folder$$2) {
        var paths$$2 = [];
        var files = JAM.call(_fs.readdirSync, _fs, [folder$$2]);
        var i$$142 = 0;
        var v1744 = i$$142 < files.length;
        for(;v1744;) {
          var v12527 = folder$$2 + "/";
          introspect(JAM.policy.p1) {
            var v12528 = files[i$$142]
          }
          var stat = JAM.call(_fs.statSync, _fs, [v12527 + v12528]);
          var v12529 = options$$9.recursive;
          if(v12529) {
            v12529 = stat.isDirectory()
          }
          if(v12529) {
            var v18894 = folder$$2 + "/";
            introspect(JAM.policy.p1) {
              var v18895 = files[i$$142]
            }
            paths$$2 = paths$$2.concat(filesInFolder$$1(v18894 + v18895))
          }else {
            var v12531 = stat.isFile();
            if(v12531) {
              var v18896 = !spec$$1;
              if(!v18896) {
                introspect(JAM.policy.p1) {
                  var v22858 = files[i$$142]
                }
                v18896 = v22858.match(spec$$1)
              }
              v12531 = v18896
            }
            if(v12531) {
              var v12532 = folder$$2 + "/";
              introspect(JAM.policy.p1) {
                var v12533 = files[i$$142]
              }
              JAM.call(paths$$2.push, paths$$2, [v12532 + v12533])
            }
          }
          i$$142 = i$$142 + 1;
          v1744 = i$$142 < files.length
        }
        return paths$$2
      }
      options$$9 = options$$9 || {};
      return filesInFolder$$1(path$$35)
    }
    function v1338(path$$33, useUTF8$$4) {
      function v1337() {
        JAM.call(_fs.closeSync, _fs, [fd]);
        fd = null;
        return
      }
      function v1336(str$$19) {
        JAM.call(_fs.writeSync, _fs, [fd, str$$19 + "\r\n"]);
        return
      }
      function v1335(str$$18) {
        JAM.call(_fs.writeSync, _fs, [fd, str$$18]);
        return
      }
      function mkdirRecursiveSync(path$$34) {
        var stats = JAM.call(_fs.statSync, _fs, [path$$34]);
        if(stats.isFile()) {
          JAM.call(IOUtils.throwIOError, IOUtils, ['"' + path$$34 + "\" exists but isn't a directory.", null])
        }else {
          if(stats.isDirectory()) {
          }else {
            mkdirRecursiveSync(JAM.call(_path.dirname, _path, [path$$34]));
            JAM.call(_fs.mkdirSync, _fs, [path$$34, 509])
          }
        }
        return
      }
      mkdirRecursiveSync(JAM.call(_path.dirname, _path, [path$$33]));
      try {
        var fd = JAM.call(_fs.openSync, _fs, [path$$33, "w"])
      }catch(e$$19) {
        JAM.call(IOUtils.throwIOError, IOUtils, ["Couldn't write to file '" + path$$33 + "'.", e$$19])
      }
      return{Write:v1335, WriteLine:v1336, Close:v1337}
    }
    function v1334(path$$32) {
      return JAM.call(_fs.existsSync, _fs, [path$$32])
    }
    function v1333(path$$31) {
      try {
        JAM.call(_fs.unlinkSync, _fs, [path$$31])
      }catch(e$$18) {
        JAM.call(IOUtils.throwIOError, IOUtils, ["Couldn't delete file '" + path$$31 + "'.", e$$18])
      }
      return
    }
    function v1332(file$$2) {
      try {
        var buffer$$8 = JAM.call(_fs.readFileSync, _fs, [file$$2]);
        switch(buffer$$8[0]) {
          case 254:
            if(buffer$$8[1] == 255) {
              var i$$141 = 0;
              var v1755 = i$$141 + 1 < buffer$$8.length;
              for(;v1755;) {
                introspect(JAM.policy.p1) {
                  var temp$$17 = buffer$$8[i$$141]
                }
                buffer$$8[i$$141] = buffer$$8[i$$141 + 1];
                buffer$$8[i$$141 + 1] = temp$$17;
                i$$141 = i$$141 + 2;
                v1755 = i$$141 + 1 < buffer$$8.length
              }
              return JAM.call(buffer$$8.toString, buffer$$8, ["ucs2", 2])
            }
            break;
          case 255:
            if(buffer$$8[1] == 254) {
              return JAM.call(buffer$$8.toString, buffer$$8, ["ucs2", 2])
            }
            break;
          case 239:
            if(buffer$$8[1] == 187) {
              return JAM.call(buffer$$8.toString, buffer$$8, ["utf8", 3])
            }
        }
        return buffer$$8.toString()
      }catch(e$$17) {
        JAM.call(IOUtils.throwIOError, IOUtils, ['Error reading file "' + file$$2 + '".', e$$17])
      }
      return
    }
    var _fs = JAM.call(require, null, ["fs"]);
    var _path = JAM.call(require, null, ["path"]);
    var _module = JAM.call(require, null, ["module"]);
    return{readFile:v1332, writeFile:_fs.writeFileSync, deleteFile:v1333, fileExists:v1334, createFile:v1338, dir:dir, createDirectory:v1339, directoryExists:v1340, resolvePath:v1341, dirName:v1342, findFile:v1343, print:v1344, printLine:v1345, arguments:process.argv.slice(2), stderr:{Write:v1346, WriteLine:v1347, Close:v1348}, stdout:{Write:v1349, WriteLine:v1350, Close:v1351}, watchFile:v1354, run:v1355, getExecutingFilePath:v1356, quit:process.exit}
  }
  if(typeof ActiveXObject === "function") {
    return getWindowsScriptHostIO()
  }else {
    if(typeof require === "function") {
      return getNodeIO()
    }else {
      return null
    }
  }
  return
}
function v1312(IOUtils$$1) {
  function createDirectoryStructure(ioHost$$5, dirName) {
    if(JAM.call(ioHost$$5.directoryExists, ioHost$$5, [dirName])) {
      return
    }
    var parentDirectory = JAM.call(ioHost$$5.dirName, ioHost$$5, [dirName]);
    if(parentDirectory != "") {
      createDirectoryStructure(ioHost$$5, parentDirectory)
    }
    JAM.call(ioHost$$5.createDirectory, ioHost$$5, [dirName]);
    return
  }
  function createFileAndFolderStructure(ioHost$$6, fileName$$9, useUTF8$$2) {
    var path$$19 = JAM.call(ioHost$$6.resolvePath, ioHost$$6, [fileName$$9]);
    var dirName$$1 = JAM.call(ioHost$$6.dirName, ioHost$$6, [path$$19]);
    createDirectoryStructure(ioHost$$6, dirName$$1);
    return JAM.call(ioHost$$6.createFile, ioHost$$6, [path$$19, useUTF8$$2])
  }
  function throwIOError(message$$23, error$$3) {
    var errorMessage = message$$23;
    var v12549 = error$$3;
    if(v12549) {
      v12549 = error$$3.message
    }
    if(v12549) {
      errorMessage = errorMessage + (" " + error$$3.message)
    }
    throw new Error(errorMessage);
  }
  IOUtils$$1.createFileAndFolderStructure = createFileAndFolderStructure;
  IOUtils$$1.throwIOError = throwIOError;
  return
}
function v1311(TypeScript$$33) {
  function v1310() {
    function v1309(s$$41) {
      var v1771 = this.logContents;
      JAM.call(v1771.push, v1771, [s$$41]);
      return
    }
    function v1308() {
      return false
    }
    function v1307() {
      return false
    }
    function v1306() {
      return false
    }
    function v1305() {
      return false
    }
    function v1304() {
      return false
    }
    function BufferedLogger$$1() {
      this.logContents = [];
      return
    }
    BufferedLogger$$1.prototype.information = v1304;
    BufferedLogger$$1.prototype.debug = v1305;
    BufferedLogger$$1.prototype.warning = v1306;
    BufferedLogger$$1.prototype.error = v1307;
    BufferedLogger$$1.prototype.fatal = v1308;
    BufferedLogger$$1.prototype.log = v1309;
    return BufferedLogger$$1
  }
  function v1303() {
    function v1302(s$$40) {
      var v1778 = this.logger;
      JAM.call(v1778.log, v1778, [s$$40]);
      return
    }
    function v1301() {
      return this._fatal
    }
    function v1300() {
      return this._error
    }
    function v1299() {
      return this._warning
    }
    function v1298() {
      return this._debug
    }
    function v1297() {
      return this._information
    }
    function LoggerAdapter$$1(logger$$8) {
      this.logger = logger$$8;
      var v26777 = this.logger.information();
      this._information = v26777;
      var v26778 = this.logger.debug();
      this._debug = v26778;
      var v26779 = this.logger.warning();
      this._warning = v26779;
      var v26780 = this.logger.error();
      this._error = v26780;
      var v26781 = this.logger.fatal();
      this._fatal = v26781;
      return
    }
    LoggerAdapter$$1.prototype.information = v1297;
    LoggerAdapter$$1.prototype.debug = v1298;
    LoggerAdapter$$1.prototype.warning = v1299;
    LoggerAdapter$$1.prototype.error = v1300;
    LoggerAdapter$$1.prototype.fatal = v1301;
    LoggerAdapter$$1.prototype.log = v1302;
    return LoggerAdapter$$1
  }
  function v1296() {
    function v1295(s$$39) {
      return
    }
    function v1294() {
      return false
    }
    function v1293() {
      return false
    }
    function v1292() {
      return false
    }
    function v1291() {
      return false
    }
    function v1290() {
      return false
    }
    function NullLogger$$1() {
      return
    }
    NullLogger$$1.prototype.information = v1290;
    NullLogger$$1.prototype.debug = v1291;
    NullLogger$$1.prototype.warning = v1292;
    NullLogger$$1.prototype.error = v1293;
    NullLogger$$1.prototype.fatal = v1294;
    NullLogger$$1.prototype.log = v1295;
    return NullLogger$$1
  }
  function v1289(CompilerDiagnostics$$1) {
    function Alert(output) {
      if(CompilerDiagnostics$$1.diagnosticWriter) {
        var v1796 = CompilerDiagnostics$$1.diagnosticWriter;
        JAM.call(v1796.Alert, v1796, [output])
      }
      return
    }
    function debugPrint(s$$37) {
      if(CompilerDiagnostics$$1.debug) {
        Alert(s$$37)
      }
      return
    }
    function assert(condition$$1, s$$38) {
      if(CompilerDiagnostics$$1.debug) {
        if(!condition$$1) {
          Alert(s$$38)
        }
      }
      return
    }
    CompilerDiagnostics$$1.debug = false;
    CompilerDiagnostics$$1.diagnosticWriter = null;
    CompilerDiagnostics$$1.analysisPass = 0;
    CompilerDiagnostics$$1.Alert = Alert;
    CompilerDiagnostics$$1.debugPrint = debugPrint;
    CompilerDiagnostics$$1.assert = assert;
    return
  }
  function timeFunction(logger$$7, funcDescription$$1, func$$5) {
    var start$$14 = +new Date;
    var result$$39 = func$$5();
    var end$$7 = +new Date;
    JAM.call(logger$$7.log, logger$$7, [funcDescription$$1 + " completed in " + (end$$7 - start$$14) + " msec"]);
    return result$$39
  }
  function stringToLiteral(value$$43, length$$18) {
    function addChar(index$$65) {
      var ch$$1 = JAM.call(value$$43.charCodeAt, value$$43, [index$$65]);
      switch(ch$$1) {
        case 9:
          result$$40 = result$$40 + "\\t";
          break;
        case 10:
          result$$40 = result$$40 + "\\n";
          break;
        case 11:
          result$$40 = result$$40 + "\\v";
          break;
        case 12:
          result$$40 = result$$40 + "\\f";
          break;
        case 13:
          result$$40 = result$$40 + "\\r";
          break;
        case 34:
          result$$40 = result$$40 + '\\"';
          break;
        case 39:
          result$$40 = result$$40 + "\\'";
          break;
        case 92:
          result$$40 = result$$40 + "\\";
          break;
        default:
          result$$40 = result$$40 + value$$43.charAt(index$$65)
      }
      return
    }
    var result$$40 = "";
    var tooLong = value$$43.length > length$$18;
    if(tooLong) {
      var mid$$1 = length$$18 >> 1;
      var i$$139 = 0;
      var v1805 = i$$139 < mid$$1;
      for(;v1805;) {
        addChar(i$$139);
        i$$139 = i$$139 + 1;
        v1805 = i$$139 < mid$$1
      }
      result$$40 = result$$40 + "(...)";
      i$$139 = value$$43.length - mid$$1;
      var v1807 = i$$139 < value$$43.length;
      for(;v1807;) {
        addChar(i$$139);
        i$$139 = i$$139 + 1;
        v1807 = i$$139 < value$$43.length
      }
    }else {
      length$$18 = value$$43.length;
      i$$139 = 0;
      var v1808 = i$$139 < length$$18;
      for(;v1808;) {
        addChar(i$$139);
        i$$139 = i$$139 + 1;
        v1808 = i$$139 < length$$18
      }
    }
    return result$$40
  }
  var v12556 = TypeScript$$33.CompilerDiagnostics;
  if(!v12556) {
    v12556 = TypeScript$$33.CompilerDiagnostics = {}
  }
  v1289(v12556);
  var CompilerDiagnostics = TypeScript$$33.CompilerDiagnostics;
  var NullLogger = v1296();
  TypeScript$$33.NullLogger = NullLogger;
  var LoggerAdapter = v1303();
  TypeScript$$33.LoggerAdapter = LoggerAdapter;
  var BufferedLogger = v1310();
  TypeScript$$33.BufferedLogger = BufferedLogger;
  TypeScript$$33.timeFunction = timeFunction;
  TypeScript$$33.stringToLiteral = stringToLiteral;
  return
}
function v1288(TypeScript$$32) {
  function v1287() {
    function v1286(enclosingScopeContext$$5, allNames, scope$$36) {
      var result$$38 = [];
      var enclosingScope$$2 = enclosingScopeContext$$5.getScope();
      var i$$138 = 0;
      var v1818 = i$$138 < allNames.length;
      for(;v1818;) {
        introspect(JAM.policy.p1) {
          var name$$90 = allNames[i$$138]
        }
        var v1810 = enclosingScopeContext$$5.publicsOnly;
        if(v1810) {
          v1810 = enclosingScopeContext$$5.isMemberCompletion
        }
        var publicsOnly = v1810;
        var symbol$$23 = JAM.call(scope$$36.find, scope$$36, [name$$90, publicsOnly, false]);
        if(symbol$$23 == null) {
          symbol$$23 = JAM.call(scope$$36.find, scope$$36, [name$$90, publicsOnly, true])
        }
        var v1812;
        var v18901 = symbol$$23;
        if(v18901) {
          v18901 = symbol$$23.flags & TypeScript$$32.SymbolFlags.Private
        }
        if(v18901) {
          v1812 = symbol$$23.container == scope$$36.container
        }else {
          v1812 = true
        }
        var displayThisMember = v1812;
        if(symbol$$23) {
          var v12561 = displayThisMember;
          if(v12561) {
            var v18902 = !JAM.call(TypeScript$$32.isQuoted, TypeScript$$32, [symbol$$23.name]);
            if(v18902) {
              v18902 = !JAM.call(TypeScript$$32.isRelative, TypeScript$$32, [symbol$$23.name])
            }
            v12561 = v18902
          }
          if(v12561) {
            var v1813 = symbol$$23.getType();
            var typeName$$11 = JAM.call(v1813.getScopedTypeName, v1813, [enclosingScope$$2]);
            JAM.call(result$$38.push, result$$38, [JAM.new(ScopeEntry, [name$$90, typeName$$11, symbol$$23])])
          }
        }else {
          var v12562 = name$$90 == "true";
          if(!v12562) {
            v12562 = name$$90 == "false"
          }
          if(v12562) {
            JAM.call(result$$38.push, result$$38, [JAM.new(ScopeEntry, [name$$90, "bool", this.compiler.typeChecker.booleanType.symbol])])
          }
        }
        i$$138 = i$$138 + 1;
        v1818 = i$$138 < allNames.length
      }
      return result$$38
    }
    function v1285(enclosingScopeContext$$4) {
      var scope$$35 = JAM.call(this.getScope, this, [enclosingScopeContext$$4]);
      if(scope$$35 == null) {
        return[]
      }
      var inScopeNames = new TypeScript$$32.StringHashTable;
      var allSymbolNames = JAM.call(scope$$35.getAllSymbolNames, scope$$35, [enclosingScopeContext$$4.isMemberCompletion]);
      var i$$137 = 0;
      var v1823 = i$$137 < allSymbolNames.length;
      for(;v1823;) {
        introspect(JAM.policy.p1) {
          var name$$89 = allSymbolNames[i$$137]
        }
        var v12566 = name$$89 == TypeScript$$32.globalId;
        if(!v12566) {
          var v18906 = name$$89 == "_Core";
          if(!v18906) {
            v18906 = name$$89 == "_element"
          }
          v12566 = v18906
        }
        if(v12566) {
          i$$137 = i$$137 + 1;
          v1823 = i$$137 < allSymbolNames.length;
          continue
        }
        JAM.call(inScopeNames.add, inScopeNames, [name$$89, ""]);
        i$$137 = i$$137 + 1;
        v1823 = i$$137 < allSymbolNames.length
      }
      var svModuleDecl = this.compiler.typeChecker.currentModDecl;
      this.compiler.typeChecker.currentModDecl = enclosingScopeContext$$4.deepestModuleDecl;
      var result$$37 = JAM.call(this.getTypeNamesForNames, this, [enclosingScopeContext$$4, inScopeNames.getAllKeys(), scope$$35]);
      this.compiler.typeChecker.currentModDecl = svModuleDecl;
      return result$$37
    }
    function v1284(enclosingScopeContext$$3) {
      var v12572 = enclosingScopeContext$$3.enclosingObjectLit;
      if(v12572) {
        v12572 = enclosingScopeContext$$3.isMemberCompletion
      }
      if(v12572) {
        return enclosingScopeContext$$3.getObjectLiteralScope()
      }else {
        if(enclosingScopeContext$$3.isMemberCompletion) {
          if(enclosingScopeContext$$3.useFullAst) {
            var v1828 = this.compiler.typeFlow;
            return JAM.call(v1828.findMemberScopeAtFullAst, v1828, [enclosingScopeContext$$3])
          }else {
            var v1829 = this.compiler.typeFlow;
            return JAM.call(v1829.findMemberScopeAt, v1829, [enclosingScopeContext$$3])
          }
        }else {
          return enclosingScopeContext$$3.getScope()
        }
      }
      return
    }
    function ScopeTraversal$$1(compiler$$2) {
      this.compiler = compiler$$2;
      return
    }
    ScopeTraversal$$1.prototype.getScope = v1284;
    ScopeTraversal$$1.prototype.getScopeEntries = v1285;
    ScopeTraversal$$1.prototype.getTypeNamesForNames = v1286;
    return ScopeTraversal$$1
  }
  function v1283() {
    function ScopeEntry$$1(name$$88, type$$60, sym$$49) {
      this.name = name$$88;
      this.type = type$$60;
      this.sym = sym$$49;
      return
    }
    return ScopeEntry$$1
  }
  function v1282() {
    function v1281(fileName$$8, useUTF8$$1) {
      try {
        var v1836 = this.emitSettings.ioHost;
        return JAM.call(v1836.createFile, v1836, [fileName$$8, useUTF8$$1])
      }catch(ex$$6) {
        var v1837 = this.errorReporter;
        JAM.call(v1837.emitterError, v1837, [null, ex$$6.message])
      }
      return
    }
    function v1280(scripts) {
      var i$$136 = 0;
      var len$$68 = scripts.length;
      var v1840 = i$$136 < len$$68;
      for(;v1840;) {
        introspect(JAM.policy.p1) {
          var script$$38 = scripts[i$$136]
        }
        if(JAM.call(this.outputScriptToUTF8, this, [script$$38])) {
          return true
        }
        i$$136 = i$$136 + 1;
        v1840 = i$$136 < len$$68
      }
      return false
    }
    function v1279(script$$37) {
      var v1841 = script$$37.containsUnicodeChar;
      if(!v1841) {
        var v12576 = this.emitSettings.emitComments;
        if(v12576) {
          v12576 = script$$37.containsUnicodeCharInComment
        }
        v1841 = v12576
      }
      return v1841
    }
    function v1278(ioHost$$4) {
      function v1277(fileName$$7, wholeFileNameReplaced$$3) {
        return JAM.call(TypeScriptCompiler$$1.mapToFileNameExtension, TypeScriptCompiler$$1, [".txt", fileName$$7, wholeFileNameReplaced$$3])
      }
      JAM.call(this.parseEmitOption, this, [ioHost$$4]);
      var outFile$$1 = null;
      var context$$65 = null;
      var i$$135 = 0;
      var len$$67 = this.scripts.members.length;
      var v1856 = i$$135 < len$$67;
      for(;v1856;) {
        var v1843 = this.scripts.members;
        introspect(JAM.policy.p1) {
          var script$$36 = v1843[i$$135]
        }
        var v12580 = this.emitSettings.outputMany;
        if(!v12580) {
          v12580 = context$$65 == null
        }
        if(v12580) {
          var v12581 = this.units;
          introspect(JAM.policy.p1) {
            var v1844 = v12581[i$$135]
          }
          var fname$$8 = v1844.filename;
          var mapToTxtFileName = v1277;
          var v1845 = this.emitSettings;
          var outFname$$2 = JAM.call(v1845.mapOutputFileName, v1845, [fname$$8, mapToTxtFileName]);
          outFile$$1 = JAM.call(this.createFile, this, [outFname$$2, JAM.call(this.useUTF8ForFile, this, [script$$36])]);
          context$$65 = JAM.new(TypeScript$$32.PrintContext, [outFile$$1, this.parser])
        }
        var v1850 = TypeScript$$32.getAstWalkerFactory();
        JAM.call(v1850.walk, v1850, [script$$36, TypeScript$$32.prePrintAST, TypeScript$$32.postPrintAST, null, context$$65]);
        if(this.emitSettings.outputMany) {
          try {
            outFile$$1.Close()
          }catch(e$$11) {
            var v1853 = this.errorReporter;
            JAM.call(v1853.emitterError, v1853, [null, e$$11.message])
          }
        }
        i$$135 = i$$135 + 1;
        v1856 = i$$135 < len$$67
      }
      if(!this.emitSettings.outputMany) {
        try {
          outFile$$1.Close()
        }catch(e$$12) {
          var v1857 = this.errorReporter;
          JAM.call(v1857.emitterError, v1857, [null, e$$12.message])
        }
      }
      return
    }
    function v1276(outputFile) {
      if(this.settings.mapSourceFiles) {
        throw Error("Cannot generate source map");
      }
      if(this.settings.generateDeclarationFiles) {
        throw Error("Cannot generate declaration files");
      }
      if(this.settings.outputOption != "") {
        throw Error("Cannot parse output option");
      }
      var emitter$$41 = emitter$$41 = JAM.new(TypeScript$$32.Emitter, [this.typeChecker, "stdout", outputFile, this.emitSettings, this.errorReporter]);
      var i$$134 = 0;
      var len$$66 = this.scripts.members.length;
      var v1871 = i$$134 < len$$66;
      for(;v1871;) {
        var v1868 = this.scripts.members;
        introspect(JAM.policy.p1) {
          var script$$35 = v1868[i$$134]
        }
        this.typeChecker.locationInfo = script$$35.locationInfo;
        JAM.call(emitter$$41.emitJavascript, emitter$$41, [script$$35, TypeScript$$32.TokenID.Comma, false]);
        i$$134 = i$$134 + 1;
        v1871 = i$$134 < len$$66
      }
      return
    }
    function v1275(ioHost$$3) {
      JAM.call(this.parseEmitOption, this, [ioHost$$3]);
      var emitter$$40 = null;
      var i$$133 = 0;
      var len$$65 = this.scripts.members.length;
      var v1876 = i$$133 < len$$65;
      for(;v1876;) {
        var v1873 = this.scripts.members;
        introspect(JAM.policy.p1) {
          var script$$34 = v1873[i$$133]
        }
        var v12592 = this.emitSettings.outputMany;
        if(!v12592) {
          v12592 = emitter$$40 == null
        }
        if(v12592) {
          emitter$$40 = JAM.call(this.emitUnit, this, [script$$34, !this.emitSettings.outputMany])
        }else {
          JAM.call(this.emitUnit, this, [script$$34, true, emitter$$40])
        }
        i$$133 = i$$133 + 1;
        v1876 = i$$133 < len$$65
      }
      if(emitter$$40) {
        emitter$$40.Close()
      }
      return
    }
    function v1274(script$$33, reuseEmitter$$1, emitter$$39) {
      if(!JAM.call(script$$33.emitRequired, script$$33, [this.emitSettings])) {
        return null
      }
      var fname$$7 = script$$33.locationInfo.filename;
      if(!emitter$$39) {
        var v1879 = this.emitSettings;
        var outFname$$1 = JAM.call(v1879.mapOutputFileName, v1879, [fname$$7, TypeScriptCompiler$$1.mapToJSFileName]);
        var outFile = JAM.call(this.createFile, this, [outFname$$1, JAM.call(this.useUTF8ForFile, this, [script$$33])]);
        emitter$$39 = JAM.new(TypeScript$$32.Emitter, [this.typeChecker, outFname$$1, outFile, this.emitSettings, this.errorReporter]);
        if(this.settings.mapSourceFiles) {
          JAM.call(emitter$$39.setSourceMappings, emitter$$39, [JAM.new(TypeScript$$32.SourceMapper, [fname$$7, outFname$$1, outFile, JAM.call(this.createFile, this, [outFname$$1 + TypeScript$$32.SourceMapper.MapFileExtension, false]), this.errorReporter])])
        }
      }else {
        if(this.settings.mapSourceFiles) {
          JAM.call(emitter$$39.setSourceMappings, emitter$$39, [JAM.new(TypeScript$$32.SourceMapper, [fname$$7, emitter$$39.emittingFileName, emitter$$39.outfile, emitter$$39.sourceMapper.sourceMapOut, this.errorReporter])])
        }
      }
      this.typeChecker.locationInfo = script$$33.locationInfo;
      JAM.call(emitter$$39.emitJavascript, emitter$$39, [script$$33, TypeScript$$32.TokenID.Comma, false]);
      if(!reuseEmitter$$1) {
        emitter$$39.Close();
        return null
      }else {
        return emitter$$39
      }
      return
    }
    function mapToJSFileName(fileName$$6, wholeFileNameReplaced$$2) {
      return JAM.call(TypeScriptCompiler$$1.mapToFileNameExtension, TypeScriptCompiler$$1, [".js", fileName$$6, wholeFileNameReplaced$$2])
    }
    function mapToFileNameExtension(extension, fileName$$5, wholeFileNameReplaced$$1) {
      if(wholeFileNameReplaced$$1) {
        return fileName$$5
      }else {
        var splitFname = fileName$$5.split(".");
        splitFname.pop();
        return splitFname.join(".") + extension
      }
      return
    }
    function v1273() {
      if(!this.canEmitDeclarations()) {
        return
      }
      if(this.errorReporter.hasErrors) {
        return
      }
      if(this.scripts.members.length == 0) {
        return
      }
      var declarationEmitter$$1 = null;
      var i$$132 = 0;
      var len$$64 = this.scripts.members.length;
      var v1902 = i$$132 < len$$64;
      for(;v1902;) {
        var v1899 = this.scripts.members;
        introspect(JAM.policy.p1) {
          var script$$32 = v1899[i$$132]
        }
        var v12611 = this.emitSettings.outputMany;
        if(!v12611) {
          v12611 = declarationEmitter$$1 == null
        }
        if(v12611) {
          declarationEmitter$$1 = JAM.call(this.emitDeclarationsUnit, this, [script$$32, !this.emitSettings.outputMany])
        }else {
          JAM.call(this.emitDeclarationsUnit, this, [script$$32, true, declarationEmitter$$1])
        }
        i$$132 = i$$132 + 1;
        v1902 = i$$132 < len$$64
      }
      if(declarationEmitter$$1) {
        declarationEmitter$$1.Close()
      }
      return
    }
    function v1272(script$$31, reuseEmitter, declarationEmitter) {
      if(!JAM.call(this.canEmitDeclarations, this, [script$$31])) {
        return null
      }
      if(!declarationEmitter) {
        var v1904 = this.emitSettings;
        var declareFileName$$2 = JAM.call(v1904.mapOutputFileName, v1904, [script$$31.locationInfo.filename, TypeScriptCompiler$$1.mapToDTSFileName]);
        var declareFile = JAM.call(this.createFile, this, [declareFileName$$2, JAM.call(this.useUTF8ForFile, this, [script$$31])]);
        declarationEmitter = JAM.new(TypeScript$$32.DeclarationEmitter, [this.typeChecker, this.emitSettings, this.errorReporter]);
        JAM.call(declarationEmitter.setDeclarationFile, declarationEmitter, [declareFile])
      }
      JAM.call(declarationEmitter.emitDeclarations, declarationEmitter, [script$$31]);
      if(!reuseEmitter) {
        declarationEmitter.Close();
        return null
      }else {
        return declarationEmitter
      }
      return
    }
    function v1271(script$$30) {
      if(!this.settings.generateDeclarationFiles) {
        return false
      }
      var v12616 = !!script$$30;
      if(v12616) {
        var v18925 = script$$30.isDeclareFile;
        if(!v18925) {
          var v22868 = script$$30.isResident;
          if(!v22868) {
            v22868 = script$$30.bod == null
          }
          v18925 = v22868
        }
        v12616 = v18925
      }
      if(v12616) {
        return false
      }
      return true
    }
    function mapToDTSFileName(fileName$$4, wholeFileNameReplaced) {
      return JAM.call(TypeScript$$32.getDeclareFilePath, TypeScript$$32, [fileName$$4])
    }
    function v1270(script$$29) {
      if(this.emitSettings.outputMany) {
        return JAM.call(this.outputScriptToUTF8, this, [script$$29])
      }else {
        return JAM.call(this.outputScriptsToUTF8, this, [this.scripts.members])
      }
      return
    }
    function v1269(ioHost$$2) {
      this.emitSettings.ioHost = ioHost$$2;
      if(this.emitSettings.outputOption == "") {
        this.emitSettings.outputMany = true;
        this.emitSettings.commonDirectoryPath = "";
        return
      }
      var v1922 = this.emitSettings;
      var v18927 = this.emitSettings.ioHost;
      var v26782 = JAM.call(TypeScript$$32.switchToForwardSlashes, TypeScript$$32, [JAM.call(v18927.resolvePath, v18927, [this.emitSettings.outputOption])]);
      v1922.outputOption = v26782;
      var v12621 = this.emitSettings.ioHost;
      if(JAM.call(v12621.directoryExists, v12621, [this.emitSettings.outputOption])) {
        this.emitSettings.outputMany = true
      }else {
        var v12623 = this.emitSettings.ioHost;
        if(JAM.call(v12623.fileExists, v12623, [this.emitSettings.outputOption])) {
          this.emitSettings.outputMany = false
        }else {
          this.emitSettings.outputMany = !JAM.call(TypeScript$$32.isJSFile, TypeScript$$32, [this.emitSettings.outputOption])
        }
      }
      var v12626 = this.isDynamicModuleCompilation();
      if(v12626) {
        v12626 = !this.emitSettings.outputMany
      }
      if(v12626) {
        var v1928 = this.errorReporter;
        JAM.call(v1928.emitterError, v1928, [null, "Cannot compile dynamic modules when emitting into single file"])
      }
      if(this.emitSettings.outputMany) {
        this.updateCommonDirectoryPath()
      }
      return
    }
    function v1268() {
      var commonComponents = [];
      var commonComponentsLength = -1;
      var i$$131 = 0;
      var len$$63 = this.scripts.members.length;
      var v1941 = i$$131 < len$$63;
      for(;v1941;) {
        var v1932 = this.scripts.members;
        introspect(JAM.policy.p1) {
          var script$$28 = v1932[i$$131]
        }
        if(JAM.call(script$$28.emitRequired, script$$28, [this.emitSettings])) {
          var fileName$$3 = script$$28.locationInfo.filename;
          var fileComponents = JAM.call(TypeScript$$32.filePathComponents, TypeScript$$32, [fileName$$3]);
          if(commonComponentsLength == -1) {
            commonComponents = fileComponents;
            commonComponentsLength = commonComponents.length
          }else {
            var updatedPath = false;
            var j$$20 = 0;
            var v12631 = j$$20 < commonComponentsLength;
            if(v12631) {
              v12631 = j$$20 < fileComponents.length
            }
            var v1937 = v12631;
            for(;v1937;) {
              introspect(JAM.policy.p1) {
                var v12632 = commonComponents[j$$20]
              }
              introspect(JAM.policy.p1) {
                var v12633 = fileComponents[j$$20]
              }
              if(v12632 != v12633) {
                commonComponentsLength = j$$20;
                updatedPath = true;
                if(j$$20 == 0) {
                  var v1934 = this.errorReporter;
                  JAM.call(v1934.emitterError, v1934, [null, "Cannot find the common subdirectory path for the input files"]);
                  return
                }
                break
              }
              j$$20 = j$$20 + 1;
              var v12634 = j$$20 < commonComponentsLength;
              if(v12634) {
                v12634 = j$$20 < fileComponents.length
              }
              v1937 = v12634
            }
            var v12635 = !updatedPath;
            if(v12635) {
              v12635 = fileComponents.length < commonComponentsLength
            }
            if(v12635) {
              commonComponentsLength = fileComponents.length
            }
          }
        }
        i$$131 = i$$131 + 1;
        v1941 = i$$131 < len$$63
      }
      this.emitSettings.commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";
      if(this.emitSettings.outputOption.charAt(this.emitSettings.outputOption.length - 1) != "/") {
        var v1943 = this.emitSettings;
        v1943.outputOption = v1943.outputOption + "/"
      }
      return
    }
    function v1267() {
      var i$$130 = 0;
      var len$$62 = this.scripts.members.length;
      var v1948 = i$$130 < len$$62;
      for(;v1948;) {
        var v1946 = this.scripts.members;
        introspect(JAM.policy.p1) {
          var script$$27 = v1946[i$$130]
        }
        var v12640 = !script$$27.isDeclareFile;
        if(v12640) {
          v12640 = script$$27.topLevelMod != null
        }
        if(v12640) {
          return true
        }
        i$$130 = i$$130 + 1;
        v1948 = i$$130 < len$$62
      }
      return false
    }
    function v1266() {
      function v1265() {
        TypeScript$$32.CompilerDiagnostics.analysisPass = TypeScript$$32.CompilerDiagnostics.analysisPass + 1;
        JAM.call(_this$$20.initTypeChecker, _this$$20, [_this$$20.errorOutput]);
        var v1950 = _this$$20.persistentTypeState;
        JAM.call(v1950.setCollectionMode, v1950, [TypeScript$$32.TypeCheckCollectionMode.Transient]);
        _this$$20.cleanTypesForReTypeCheck();
        return _this$$20.typeCheck()
      }
      var _this$$20 = this;
      return JAM.call(this.timeFunction, this, ["reTypeCheck()", v1265])
    }
    function v1264(updateResult$$4) {
      function v1263() {
        return false
      }
      return JAM.call(this.timeFunction, this, ["attemptIncrementalTypeCheck()", v1263])
    }
    function v1262() {
      function v1261() {
        var i$$129 = 0;
        var len$$61 = _this$$19.scripts.members.length;
        var v1956 = i$$129 < len$$61;
        for(;v1956;) {
          var v1953 = _this$$19.scripts.members;
          introspect(JAM.policy.p1) {
            var script$$26 = v1953[i$$129]
          }
          if(script$$26.isResident) {
            i$$129 = i$$129 + 1;
            v1956 = i$$129 < len$$61;
            continue
          }
          JAM.call(_this$$19.cleanASTTypesForReTypeCheck, _this$$19, [script$$26]);
          var v1955 = _this$$19.typeChecker;
          JAM.call(v1955.collectTypes, v1955, [script$$26]);
          i$$129 = i$$129 + 1;
          v1956 = i$$129 < len$$61
        }
        return null
      }
      var _this$$19 = this;
      return JAM.call(this.timeFunction, this, ["cleanTypesForReTypeCheck()", v1261])
    }
    function v1260(ast$$122) {
      function cleanASTType(ast$$123, parent$$72) {
        ast$$123.type = null;
        if(ast$$123.nodeType == TypeScript$$32.NodeType.VarDecl) {
          var vardecl = ast$$123;
          vardecl.sym = null
        }else {
          if(ast$$123.nodeType == TypeScript$$32.NodeType.ArgDecl) {
            var argdecl = ast$$123;
            argdecl.sym = null
          }else {
            if(ast$$123.nodeType == TypeScript$$32.NodeType.Name) {
              var name$$87 = ast$$123;
              name$$87.sym = null
            }else {
              if(ast$$123.nodeType == TypeScript$$32.NodeType.FuncDecl) {
                var funcdecl = ast$$123;
                funcdecl.signature = null;
                var v1957 = funcdecl;
                var v26783 = new Array;
                v1957.freeVariables = v26783;
                funcdecl.symbols = null;
                funcdecl.accessorSymbol = null;
                funcdecl.scopeType = null
              }else {
                if(ast$$123.nodeType == TypeScript$$32.NodeType.ModuleDeclaration) {
                  var modDecl$$3 = ast$$123;
                  modDecl$$3.mod = null
                }else {
                  if(ast$$123.nodeType == TypeScript$$32.NodeType.With) {
                    ast$$123.withSym = null
                  }else {
                    if(ast$$123.nodeType == TypeScript$$32.NodeType.Catch) {
                      ast$$123.containedScope = null
                    }
                  }
                }
              }
            }
          }
        }
        return ast$$123
      }
      var v1965 = TypeScript$$32.getAstWalkerFactory();
      JAM.call(v1965.walk, v1965, [ast$$122, cleanASTType]);
      return
    }
    function v1259() {
      function v1258() {
        var binder$$1 = JAM.new(TypeScript$$32.Binder, [_this$$18.typeChecker]);
        _this$$18.typeChecker.units = _this$$18.units;
        JAM.call(binder$$1.bind, binder$$1, [_this$$18.typeChecker.globalScope, _this$$18.typeChecker.globals]);
        JAM.call(binder$$1.bind, binder$$1, [_this$$18.typeChecker.globalScope, _this$$18.typeChecker.ambientGlobals]);
        JAM.call(binder$$1.bind, binder$$1, [_this$$18.typeChecker.globalScope, _this$$18.typeChecker.globalTypes]);
        JAM.call(binder$$1.bind, binder$$1, [_this$$18.typeChecker.globalScope, _this$$18.typeChecker.ambientGlobalTypes]);
        var v1977 = _this$$18;
        var v26784 = JAM.new(TypeScript$$32.TypeFlow, [_this$$18.logger, _this$$18.typeChecker.globalScope, _this$$18.parser, _this$$18.typeChecker]);
        v1977.typeFlow = v26784;
        var i$$128 = 0;
        var script$$25 = null;
        var len$$60 = _this$$18.scripts.members.length;
        var v1979 = _this$$18.persistentTypeState;
        JAM.call(v1979.setCollectionMode, v1979, [TypeScript$$32.TypeCheckCollectionMode.Resident]);
        i$$128 = 0;
        var v1985 = i$$128 < len$$60;
        for(;v1985;) {
          script$$25 = _this$$18.scripts.members[i$$128];
          var v12675 = !script$$25.isResident;
          if(!v12675) {
            v12675 = script$$25.hasBeenTypeChecked
          }
          if(v12675) {
            i$$128 = i$$128 + 1;
            v1985 = i$$128 < len$$60;
            continue
          }
          var v1983 = _this$$18.typeFlow;
          JAM.call(v1983.assignScopes, v1983, [script$$25]);
          _this$$18.typeFlow.initLibs();
          i$$128 = i$$128 + 1;
          v1985 = i$$128 < len$$60
        }
        i$$128 = 0;
        var v1989 = i$$128 < len$$60;
        for(;v1989;) {
          script$$25 = _this$$18.scripts.members[i$$128];
          var v12677 = !script$$25.isResident;
          if(!v12677) {
            v12677 = script$$25.hasBeenTypeChecked
          }
          if(v12677) {
            i$$128 = i$$128 + 1;
            v1989 = i$$128 < len$$60;
            continue
          }
          var v1988 = _this$$18.typeFlow;
          JAM.call(v1988.typeCheck, v1988, [script$$25]);
          script$$25.hasBeenTypeChecked = true;
          i$$128 = i$$128 + 1;
          v1989 = i$$128 < len$$60
        }
        var v1990 = _this$$18.persistentTypeState;
        JAM.call(v1990.setCollectionMode, v1990, [TypeScript$$32.TypeCheckCollectionMode.Transient]);
        len$$60 = _this$$18.scripts.members.length;
        i$$128 = 0;
        var v1997 = i$$128 < len$$60;
        for(;v1997;) {
          script$$25 = _this$$18.scripts.members[i$$128];
          if(script$$25.isResident) {
            i$$128 = i$$128 + 1;
            v1997 = i$$128 < len$$60;
            continue
          }
          var v1995 = _this$$18.typeFlow;
          JAM.call(v1995.assignScopes, v1995, [script$$25]);
          _this$$18.typeFlow.initLibs();
          i$$128 = i$$128 + 1;
          v1997 = i$$128 < len$$60
        }
        i$$128 = 0;
        var v2001 = i$$128 < len$$60;
        for(;v2001;) {
          script$$25 = _this$$18.scripts.members[i$$128];
          if(script$$25.isResident) {
            i$$128 = i$$128 + 1;
            v2001 = i$$128 < len$$60;
            continue
          }
          var v2000 = _this$$18.typeFlow;
          JAM.call(v2000.typeCheck, v2000, [script$$25]);
          i$$128 = i$$128 + 1;
          v2001 = i$$128 < len$$60
        }
        return null
      }
      var _this$$18 = this;
      return JAM.call(this.timeFunction, this, ["typeCheck()", v1258])
    }
    function v1257(sourceText$$9, filename$$9) {
      var v2002 = this.parser;
      JAM.call(v2002.setErrorRecovery, v2002, [this.errorOutput]);
      var v2004 = this.parser;
      var script$$24 = JAM.call(v2004.parse, v2004, [sourceText$$9, filename$$9, 0]);
      var index$$64 = this.units.length;
      JAM.set(this.units, index$$64, script$$24.locationInfo);
      var v2007 = this.typeChecker;
      JAM.call(v2007.collectTypes, v2007, [script$$24]);
      var v2008 = this.scripts;
      JAM.call(v2008.append, v2008, [script$$24]);
      return
    }
    function v1256(prog$$2, filename$$8) {
      return JAM.call(this.parseSourceUnit, this, [JAM.new(TypeScript$$32.StringSourceText, [prog$$2]), filename$$8])
    }
    function v1255(sourceText$$8, filename$$7, keepResident$$1, referencedFiles$$2) {
      function v1254() {
        var v2010 = _this$$17.parser;
        var script$$23 = JAM.call(v2010.parse, v2010, [sourceText$$8, filename$$7, _this$$17.units.length, TypeScript$$32.AllowedElements.Global]);
        script$$23.referencedFiles = referencedFiles$$2;
        script$$23.isResident = keepResident$$1;
        var v2013 = _this$$17.persistentTypeState;
        var v12685;
        if(keepResident$$1) {
          v12685 = TypeScript$$32.TypeCheckCollectionMode.Resident
        }else {
          v12685 = TypeScript$$32.TypeCheckCollectionMode.Transient
        }
        JAM.call(v2013.setCollectionMode, v2013, [v12685]);
        var index$$63 = _this$$17.units.length;
        JAM.set(_this$$17.units, index$$63, script$$23.locationInfo);
        var v2017 = _this$$17.typeChecker;
        JAM.call(v2017.collectTypes, v2017, [script$$23]);
        var v2018 = _this$$17.scripts;
        JAM.call(v2018.append, v2018, [script$$23]);
        return script$$23
      }
      if(typeof referencedFiles$$2 === "undefined") {
        referencedFiles$$2 = []
      }
      var _this$$17 = this;
      return JAM.call(this.timeFunction, this, ["addSourceUnit(" + filename$$7 + ", " + keepResident$$1 + ")", v1254])
    }
    function v1253(prog$$1, filename$$6, keepResident, referencedFiles$$1) {
      if(typeof keepResident === "undefined") {
        keepResident = false
      }
      if(typeof referencedFiles$$1 === "undefined") {
        referencedFiles$$1 = []
      }
      return JAM.call(this.addSourceUnit, this, [JAM.new(TypeScript$$32.StringSourceText, [prog$$1]), filename$$6, keepResident, referencedFiles$$1])
    }
    function v1252(sourceText$$7, filename$$5, setRecovery$$2) {
      function v1251() {
        function v1250(minChar$$36, charLen$$1, message$$22, unitIndex$$14) {
          JAM.call(parseErrors$$4.push, parseErrors$$4, [JAM.new(ErrorEntry, [unitIndex$$14, minChar$$36, minChar$$36 + charLen$$1, message$$22])]);
          return
        }
        var i$$127 = 0;
        var len$$59 = _this$$16.units.length;
        var v2034 = i$$127 < len$$59;
        for(;v2034;) {
          var v22878 = _this$$16.units;
          introspect(JAM.policy.p1) {
            var v18960 = v22878[i$$127]
          }
          if(v18960.filename == filename$$5) {
            var v18961 = _this$$16.scripts.members;
            introspect(JAM.policy.p1) {
              var v12693 = v18961[i$$127]
            }
            if(v12693.isResident) {
              return JAM.call(UpdateUnitResult.noEdits, UpdateUnitResult, [i$$127])
            }
            if(setRecovery$$2) {
              var v2027 = _this$$16.parser;
              JAM.call(v2027.setErrorRecovery, v2027, [null])
            }
            var updateResult$$3;
            var parseErrors$$4 = [];
            var errorCapture$$2 = v1250;
            var svErrorCallback = _this$$16.parser.errorCallback;
            if(svErrorCallback) {
              _this$$16.parser.errorCallback = errorCapture$$2
            }
            var v2030 = _this$$16.scripts.members;
            introspect(JAM.policy.p1) {
              var oldScript = v2030[i$$127]
            }
            var v2031 = _this$$16.parser;
            var newScript = JAM.call(v2031.parse, v2031, [sourceText$$7, filename$$5, i$$127]);
            if(svErrorCallback) {
              _this$$16.parser.errorCallback = svErrorCallback
            }
            updateResult$$3 = JAM.call(UpdateUnitResult.unknownEdits, UpdateUnitResult, [oldScript, newScript, parseErrors$$4]);
            return updateResult$$3
          }
          i$$127 = i$$127 + 1;
          v2034 = i$$127 < len$$59
        }
        throw new Error('Unknown file "' + filename$$5 + '"');
      }
      var _this$$16 = this;
      return JAM.call(this.timeFunction, this, ["partialUpdateUnit(" + filename$$5 + ")", v1251])
    }
    function v1249(updateResult$$2) {
      switch(updateResult$$2.kind) {
        case UpdateUnitKind.NoEdits:
          return false;
        case UpdateUnitKind.Unknown:
          JAM.set(this.scripts.members, updateResult$$2.unitIndex, updateResult$$2.script2);
          JAM.set(this.units, updateResult$$2.unitIndex, updateResult$$2.script2.locationInfo);
          var i$$126 = 0;
          var len$$58 = updateResult$$2.parseErrors.length;
          var v2049 = i$$126 < len$$58;
          for(;v2049;) {
            var v2042 = updateResult$$2.parseErrors;
            introspect(JAM.policy.p1) {
              var e$$10 = v2042[i$$126]
            }
            if(this.parser.errorCallback) {
              var v2043 = this.parser;
              JAM.call(v2043.errorCallback, v2043, [e$$10.minChar, e$$10.limChar - e$$10.minChar, e$$10.message, e$$10.unitIndex])
            }
            i$$126 = i$$126 + 1;
            v2049 = i$$126 < len$$58
          }
          return true;
        case UpdateUnitKind.EditsInsideSingleScope:
          var v2050 = JAM.new(TypeScript$$32.IncrementalParser, [this.logger]);
          JAM.call(v2050.mergeTrees, v2050, [updateResult$$2]);
          return true
      }
      return
    }
    function v1248(sourceText$$6, filename$$4, setRecovery$$1) {
      function v1247() {
        var updateResult$$1 = JAM.call(_this$$15.partialUpdateUnit, _this$$15, [sourceText$$6, filename$$4, setRecovery$$1]);
        return JAM.call(_this$$15.applyUpdateResult, _this$$15, [updateResult$$1])
      }
      var _this$$15 = this;
      return JAM.call(this.timeFunction, this, ["updateSourceUnit(" + filename$$4 + ")", v1247])
    }
    function v1246(prog, filename$$3, setRecovery) {
      return JAM.call(this.updateSourceUnit, this, [JAM.new(TypeScript$$32.StringSourceText, [prog]), filename$$3, setRecovery])
    }
    function v1245(fn$$10) {
      this.parser.errorCallback = fn$$10;
      return
    }
    function v1244() {
      var v26785 = JAM.new(TypeScript$$32.EmitOptions, [this.settings]);
      this.emitSettings = v26785;
      return
    }
    function v1243(outerr$$2) {
      this.errorOutput = outerr$$2;
      var v2057 = this.errorReporter;
      JAM.call(v2057.setErrOut, v2057, [outerr$$2]);
      this.parser.outfile = outerr$$2;
      return
    }
    function v1242(errorOutput$$1) {
      this.persistentTypeState.refreshPersistentState();
      var v26786 = JAM.new(TypeScript$$32.TypeChecker, [this.persistentTypeState]);
      this.typeChecker = v26786;
      this.typeChecker.errorReporter = this.errorReporter;
      this.typeChecker.checkControlFlow = this.settings.controlFlow;
      this.typeChecker.checkControlFlowUseDef = this.settings.controlFlowUseDef;
      this.typeChecker.printControlFlowGraph = this.settings.printControlFlow;
      this.typeChecker.errorsOnWith = this.settings.errorOnWith;
      this.typeChecker.styleSettings = this.settings.styleSettings;
      this.typeChecker.canCallDefinitionSignature = this.settings.canCallDefinitionSignature;
      this.errorReporter.checker = this.typeChecker;
      JAM.call(this.setErrorOutput, this, [this.errorOutput]);
      return
    }
    function v1241(funcDescription, func$$4) {
      return JAM.call(TypeScript$$32.timeFunction, TypeScript$$32, [this.logger, funcDescription, func$$4])
    }
    function TypeScriptCompiler$$1(errorOutput, logger$$6, settings$$4) {
      if(typeof logger$$6 === "undefined") {
        logger$$6 = new TypeScript$$32.NullLogger
      }
      if(typeof settings$$4 === "undefined") {
        settings$$4 = TypeScript$$32.defaultSettings
      }
      this.errorOutput = errorOutput;
      this.logger = logger$$6;
      this.settings = settings$$4;
      var v26787 = new TypeScript$$32.Parser;
      this.parser = v26787;
      this.typeFlow = null;
      var v26788 = new TypeScript$$32.ASTList;
      this.scripts = v26788;
      var v26789 = new Array;
      this.units = v26789;
      var v26790 = JAM.new(TypeScript$$32.ErrorReporter, [this.errorOutput]);
      this.errorReporter = v26790;
      var v26791 = JAM.new(TypeScript$$32.PersistentGlobalTypeState, [this.errorReporter]);
      this.persistentTypeState = v26791;
      this.errorReporter.parser = this.parser;
      JAM.call(this.initTypeChecker, this, [this.errorOutput]);
      this.parser.style_requireSemi = this.settings.styleSettings.requireSemi;
      this.parser.style_funcInLoop = this.settings.styleSettings.funcInLoop;
      this.parser.inferPropertiesFromThisAssignment = this.settings.inferPropertiesFromThisAssignment;
      var v26792 = JAM.new(TypeScript$$32.EmitOptions, [this.settings]);
      this.emitSettings = v26792;
      TypeScript$$32.codeGenTarget = settings$$4.codeGenTarget;
      return
    }
    TypeScriptCompiler$$1.prototype.timeFunction = v1241;
    TypeScriptCompiler$$1.prototype.initTypeChecker = v1242;
    TypeScriptCompiler$$1.prototype.setErrorOutput = v1243;
    TypeScriptCompiler$$1.prototype.emitCommentsToOutput = v1244;
    TypeScriptCompiler$$1.prototype.setErrorCallback = v1245;
    TypeScriptCompiler$$1.prototype.updateUnit = v1246;
    TypeScriptCompiler$$1.prototype.updateSourceUnit = v1248;
    TypeScriptCompiler$$1.prototype.applyUpdateResult = v1249;
    TypeScriptCompiler$$1.prototype.partialUpdateUnit = v1252;
    TypeScriptCompiler$$1.prototype.addUnit = v1253;
    TypeScriptCompiler$$1.prototype.addSourceUnit = v1255;
    TypeScriptCompiler$$1.prototype.parseUnit = v1256;
    TypeScriptCompiler$$1.prototype.parseSourceUnit = v1257;
    TypeScriptCompiler$$1.prototype.typeCheck = v1259;
    TypeScriptCompiler$$1.prototype.cleanASTTypesForReTypeCheck = v1260;
    TypeScriptCompiler$$1.prototype.cleanTypesForReTypeCheck = v1262;
    TypeScriptCompiler$$1.prototype.attemptIncrementalTypeCheck = v1264;
    TypeScriptCompiler$$1.prototype.reTypeCheck = v1266;
    TypeScriptCompiler$$1.prototype.isDynamicModuleCompilation = v1267;
    TypeScriptCompiler$$1.prototype.updateCommonDirectoryPath = v1268;
    TypeScriptCompiler$$1.prototype.parseEmitOption = v1269;
    TypeScriptCompiler$$1.prototype.useUTF8ForFile = v1270;
    TypeScriptCompiler$$1.mapToDTSFileName = mapToDTSFileName;
    TypeScriptCompiler$$1.prototype.canEmitDeclarations = v1271;
    TypeScriptCompiler$$1.prototype.emitDeclarationsUnit = v1272;
    TypeScriptCompiler$$1.prototype.emitDeclarations = v1273;
    TypeScriptCompiler$$1.mapToFileNameExtension = mapToFileNameExtension;
    TypeScriptCompiler$$1.mapToJSFileName = mapToJSFileName;
    TypeScriptCompiler$$1.prototype.emitUnit = v1274;
    TypeScriptCompiler$$1.prototype.emit = v1275;
    TypeScriptCompiler$$1.prototype.emitToOutfile = v1276;
    TypeScriptCompiler$$1.prototype.emitAST = v1278;
    TypeScriptCompiler$$1.prototype.outputScriptToUTF8 = v1279;
    TypeScriptCompiler$$1.prototype.outputScriptsToUTF8 = v1280;
    TypeScriptCompiler$$1.prototype.createFile = v1281;
    return TypeScriptCompiler$$1
  }
  function v1240() {
    function ErrorEntry$$1(unitIndex$$13, minChar$$35, limChar$$13, message$$21) {
      this.unitIndex = unitIndex$$13;
      this.minChar = minChar$$35;
      this.limChar = limChar$$13;
      this.message = message$$21;
      return
    }
    return ErrorEntry$$1
  }
  function v1239() {
    function singleScopeEdits(script1$$2, script2$$2, scope1$$2, scope2$$1, editRange$$4, parseErrors$$3) {
      var result$$36 = new UpdateUnitResult$$1(UpdateUnitKind.EditsInsideSingleScope, script1$$2.locationInfo.unitIndex, script1$$2, script2$$2);
      result$$36.scope1 = scope1$$2;
      result$$36.scope2 = scope2$$1;
      result$$36.editRange = editRange$$4;
      result$$36.parseErrors = parseErrors$$3;
      return result$$36
    }
    function unknownEdits(script1$$1, script2$$1, parseErrors$$2) {
      var result$$35 = new UpdateUnitResult$$1(UpdateUnitKind.Unknown, script1$$1.locationInfo.unitIndex, script1$$1, script2$$1);
      result$$35.parseErrors = parseErrors$$2;
      return result$$35
    }
    function noEdits(unitIndex$$12) {
      return new UpdateUnitResult$$1(UpdateUnitKind.NoEdits, unitIndex$$12, null, null)
    }
    function UpdateUnitResult$$1(kind, unitIndex$$11, script1, script2) {
      this.kind = kind;
      this.unitIndex = unitIndex$$11;
      this.script1 = script1;
      this.script2 = script2;
      this.scope1 = null;
      this.scope2 = null;
      this.editRange = null;
      this.parseErrors = [];
      return
    }
    UpdateUnitResult$$1.noEdits = noEdits;
    UpdateUnitResult$$1.unknownEdits = unknownEdits;
    UpdateUnitResult$$1.singleScopeEdits = singleScopeEdits;
    return UpdateUnitResult$$1
  }
  function v1238() {
    function v1237() {
      return"editRange(minChar=" + this.minChar + ", limChar=" + this.limChar + ", delta=" + this.delta + ")"
    }
    function v1236(pos$$8) {
      var v12721 = this.minChar <= pos$$8;
      if(v12721) {
        v12721 = pos$$8 < this.limChar
      }
      var v2126 = v12721;
      if(!v2126) {
        var v12722 = this.minChar <= pos$$8;
        if(v12722) {
          v12722 = pos$$8 < this.limChar + this.delta
        }
        v2126 = v12722
      }
      return v2126
    }
    function v1235() {
      var v2127 = this.minChar === -1;
      if(v2127) {
        var v12725 = this.limChar === -1;
        if(v12725) {
          v12725 = this.delta === -1
        }
        v2127 = v12725
      }
      return v2127
    }
    function unknown() {
      return new ScriptEditRange$$1(-1, -1, -1)
    }
    function ScriptEditRange$$1(minChar$$34, limChar$$12, delta$$2) {
      this.minChar = minChar$$34;
      this.limChar = limChar$$12;
      this.delta = delta$$2;
      return
    }
    ScriptEditRange$$1.unknown = unknown;
    ScriptEditRange$$1.prototype.isUnknown = v1235;
    ScriptEditRange$$1.prototype.containsPosition = v1236;
    ScriptEditRange$$1.prototype.toString = v1237;
    return ScriptEditRange$$1
  }
  function v1234(UpdateUnitKind$$1) {
    UpdateUnitKind$$1._map = [];
    UpdateUnitKind$$1._map[0] = "Unknown";
    UpdateUnitKind$$1.Unknown = 0;
    UpdateUnitKind$$1._map[1] = "NoEdits";
    UpdateUnitKind$$1.NoEdits = 1;
    UpdateUnitKind$$1._map[2] = "EditsInsideSingleScope";
    UpdateUnitKind$$1.EditsInsideSingleScope = 2;
    return
  }
  var v12726 = TypeScript$$32.UpdateUnitKind;
  if(!v12726) {
    v12726 = TypeScript$$32.UpdateUnitKind = {}
  }
  v1234(v12726);
  var UpdateUnitKind = TypeScript$$32.UpdateUnitKind;
  var ScriptEditRange = v1238();
  TypeScript$$32.ScriptEditRange = ScriptEditRange;
  var UpdateUnitResult = v1239();
  TypeScript$$32.UpdateUnitResult = UpdateUnitResult;
  var ErrorEntry = v1240();
  TypeScript$$32.ErrorEntry = ErrorEntry;
  var v2135 = TypeScript$$32;
  var v26793 = new TypeScript$$32.CompilationSettings;
  v2135.defaultSettings = v26793;
  var TypeScriptCompiler = v1282();
  TypeScript$$32.TypeScriptCompiler = TypeScriptCompiler;
  var ScopeEntry = v1283();
  TypeScript$$32.ScopeEntry = ScopeEntry;
  var ScopeTraversal = v1287();
  TypeScript$$32.ScopeTraversal = ScopeTraversal;
  return
}
function v1233(TypeScript$$31) {
  function v1232() {
    function v1231(pre$$21, ast$$121) {
      return!JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [ast$$121.flags, TypeScript$$31.ASTFlags.IsStatement])
    }
    function v1230(pre$$20, script$$22) {
      if(pre$$20) {
        if(this.emitOptions.outputMany) {
          var i$$125 = 0;
          var v2144 = i$$125 < script$$22.referencedFiles.length;
          for(;v2144;) {
            var v12732 = script$$22.referencedFiles;
            introspect(JAM.policy.p1) {
              var v2137 = v12732[i$$125]
            }
            var referencePath$$1 = v2137.path;
            var declareFileName$$1;
            if(JAM.call(TypeScript$$31.isRooted, TypeScript$$31, [referencePath$$1])) {
              var v2138 = this.emitOptions;
              declareFileName$$1 = JAM.call(v2138.mapOutputFileName, v2138, [referencePath$$1, TypeScript$$31.TypeScriptCompiler.mapToDTSFileName])
            }else {
              var v18974 = script$$22.referencedFiles;
              introspect(JAM.policy.p1) {
                var v12734 = v18974[i$$125]
              }
              declareFileName$$1 = JAM.call(TypeScript$$31.getDeclareFilePath, TypeScript$$31, [v12734.path])
            }
            var v2142 = this.declFile;
            JAM.call(v2142.WriteLine, v2142, ['/// <reference path="' + declareFileName$$1 + '" />']);
            i$$125 = i$$125 + 1;
            v2144 = i$$125 < script$$22.referencedFiles.length
          }
        }
        JAM.call(this.pushDeclarationContainer, this, [script$$22])
      }else {
        JAM.call(this.popDeclarationContainer, this, [script$$22])
      }
      return true
    }
    function v1229(pre$$19, moduleDecl$$9) {
      if(JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [moduleDecl$$9.modFlags, TypeScript$$31.ModuleFlags.IsWholeFile])) {
        if(JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [moduleDecl$$9.modFlags, TypeScript$$31.ModuleFlags.IsDynamic])) {
          if(pre$$19) {
            if(!this.emitOptions.outputMany) {
              this.singleDeclFile = this.declFile;
              var v2146 = TypeScript$$31.CompilerDiagnostics;
              JAM.call(v2146.assert, v2146, [this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file"]);
              var v2148 = this.emitOptions;
              var declareFileName = JAM.call(v2148.mapOutputFileName, v2148, [JAM.call(TypeScript$$31.stripQuotes, TypeScript$$31, [moduleDecl$$9.name.sym.name]), TypeScript$$31.TypeScriptCompiler.mapToDTSFileName]);
              var v2151 = moduleDecl$$9.containsUnicodeChar;
              if(!v2151) {
                var v12745 = this.emitOptions.emitComments;
                if(v12745) {
                  v12745 = moduleDecl$$9.containsUnicodeCharInComment
                }
                v2151 = v12745
              }
              var useUTF8InOutputfile$$1 = v2151;
              try {
                var v12747 = this.emitOptions.ioHost;
                var v26794 = JAM.new(DeclFileWriter, [JAM.call(v12747.createFile, v12747, [declareFileName, useUTF8InOutputfile$$1])]);
                this.declFile = v26794
              }catch(ex$$4) {
                var v2153 = this.errorReporter;
                JAM.call(v2153.emitterError, v2153, [null, ex$$4.message])
              }
            }
            JAM.call(this.pushDeclarationContainer, this, [moduleDecl$$9])
          }else {
            if(!this.emitOptions.outputMany) {
              var v2156 = TypeScript$$31.CompilerDiagnostics;
              JAM.call(v2156.assert, v2156, [this.singleDeclFile != this.declFile, "singleDeclFile cannot be null as we are going to revert back to it"]);
              var v2158 = TypeScript$$31.CompilerDiagnostics;
              JAM.call(v2158.assert, v2158, [this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file"]);
              try {
                this.declFile.Close()
              }catch(ex$$5) {
                var v2161 = this.errorReporter;
                JAM.call(v2161.emitterError, v2161, [null, ex$$5.message])
              }
              this.declFile = this.singleDeclFile
            }
            JAM.call(this.popDeclarationContainer, this, [moduleDecl$$9])
          }
        }
        return true
      }
      if(moduleDecl$$9.isEnum()) {
        if(pre$$19) {
          JAM.call(this.emitEnumSignature, this, [moduleDecl$$9])
        }
        return false
      }
      if(!JAM.call(this.canEmitPrePostAstSignature, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [moduleDecl$$9.modFlags]), moduleDecl$$9, pre$$19])) {
        return false
      }
      if(pre$$19) {
        if(this.emitDottedModuleName()) {
          this.dottedModuleEmit = this.dottedModuleEmit + "."
        }else {
          var v26795 = JAM.call(this.getDeclFlagsString, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [moduleDecl$$9.modFlags]), "module"]);
          this.dottedModuleEmit = v26795
        }
        this.dottedModuleEmit = this.dottedModuleEmit + moduleDecl$$9.name.text;
        var v2170 = moduleDecl$$9.members.members.length == 1;
        if(v2170) {
          var v12758 = moduleDecl$$9.members.members[0].nodeType == TypeScript$$31.NodeType.ModuleDeclaration;
          if(v12758) {
            var v18990 = !moduleDecl$$9.members.members[0].isEnum();
            if(v18990) {
              v18990 = JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [moduleDecl$$9.members.members[0].modFlags, TypeScript$$31.ModuleFlags.Exported])
            }
            v12758 = v18990
          }
          v2170 = v12758
        }
        var isCurrentModuleDotted = v2170;
        var moduleDeclComments = moduleDecl$$9.getDocComments();
        var v2171 = isCurrentModuleDotted;
        if(v2171) {
          var v12759 = moduleDeclComments == null;
          if(!v12759) {
            v12759 = moduleDeclComments.length == 0
          }
          v2171 = v12759
        }
        isCurrentModuleDotted = v2171;
        var v2172 = this.isDottedModuleName;
        JAM.call(v2172.push, v2172, [isCurrentModuleDotted]);
        JAM.call(this.pushDeclarationContainer, this, [moduleDecl$$9]);
        if(!isCurrentModuleDotted) {
          JAM.call(this.emitDeclarationComments, this, [moduleDecl$$9]);
          var v2173 = this.declFile;
          JAM.call(v2173.Write, v2173, [this.dottedModuleEmit]);
          var v2175 = this.declFile;
          JAM.call(v2175.WriteLine, v2175, [" {"]);
          this.indenter.increaseIndent()
        }
      }else {
        if(!this.emitDottedModuleName()) {
          this.indenter.decreaseIndent();
          this.emitIndent();
          var v2179 = this.declFile;
          JAM.call(v2179.WriteLine, v2179, ["}"])
        }
        JAM.call(this.popDeclarationContainer, this, [moduleDecl$$9]);
        this.isDottedModuleName.pop()
      }
      return true
    }
    function v1228(moduleDecl$$8) {
      if(!JAM.call(this.canEmitSignature, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [moduleDecl$$8.modFlags])])) {
        return false
      }
      JAM.call(this.emitDeclarationComments, this, [moduleDecl$$8]);
      JAM.call(this.emitDeclFlags, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [moduleDecl$$8.modFlags]), "enum"]);
      var v2184 = this.declFile;
      JAM.call(v2184.WriteLine, v2184, [moduleDecl$$8.name.text + " {"]);
      this.indenter.increaseIndent();
      var membersLen$$1 = moduleDecl$$8.members.members.length;
      var j$$19 = 1;
      var v2194 = j$$19 < membersLen$$1;
      for(;v2194;) {
        var v2188 = moduleDecl$$8.members.members;
        introspect(JAM.policy.p1) {
          var memberDecl$$1 = v2188[j$$19]
        }
        if(memberDecl$$1.nodeType == TypeScript$$31.NodeType.VarDecl) {
          JAM.call(this.emitDeclarationComments, this, [memberDecl$$1]);
          this.emitIndent();
          var v2189 = this.declFile;
          JAM.call(v2189.WriteLine, v2189, [memberDecl$$1.id.text + ","])
        }else {
          var v2191 = TypeScript$$31.CompilerDiagnostics;
          JAM.call(v2191.assert, v2191, [memberDecl$$1.nodeType != TypeScript$$31.NodeType.Asg, "We want to catch this"])
        }
        j$$19 = j$$19 + 1;
        v2194 = j$$19 < membersLen$$1
      }
      this.indenter.decreaseIndent();
      this.emitIndent();
      var v2196 = this.declFile;
      JAM.call(v2196.WriteLine, v2196, ["}"]);
      return false
    }
    function v1227(pre$$18, importDecl$$3) {
      if(pre$$18) {
        var v12771 = this.declarationContainerStack[0];
        if(JAM.call(v12771.isExternallyVisibleSymbol, v12771, [importDecl$$3.id.sym])) {
          JAM.call(this.emitDeclarationComments, this, [importDecl$$3]);
          this.emitIndent();
          var v2197 = this.declFile;
          JAM.call(v2197.Write, v2197, ["import "]);
          var v2198 = this.declFile;
          JAM.call(v2198.Write, v2198, [importDecl$$3.id.text + " = "]);
          if(importDecl$$3.isDynamicImport) {
            var v2200 = this.declFile;
            JAM.call(v2200.WriteLine, v2200, ["module (" + importDecl$$3.getAliasName() + ");"])
          }else {
            var v2202 = this.declFile;
            JAM.call(v2202.WriteLine, v2202, [importDecl$$3.getAliasName() + ";"])
          }
        }
      }
      return false
    }
    function v1226(pre$$17, interfaceDecl$$7) {
      if(!JAM.call(this.canEmitPrePostAstSignature, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [interfaceDecl$$7.varFlags]), interfaceDecl$$7, pre$$17])) {
        return false
      }
      if(pre$$17) {
        var interfaceName$$1 = interfaceDecl$$7.name.text;
        JAM.call(this.emitDeclarationComments, this, [interfaceDecl$$7]);
        JAM.call(this.emitDeclFlags, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [interfaceDecl$$7.varFlags]), "interface"]);
        var v2209 = this.declFile;
        JAM.call(v2209.Write, v2209, [interfaceName$$1]);
        JAM.call(this.emitBaseList, this, [interfaceDecl$$7.extendsList, "extends"]);
        var v2211 = this.declFile;
        JAM.call(v2211.WriteLine, v2211, [" {"]);
        this.indenter.increaseIndent();
        JAM.call(this.pushDeclarationContainer, this, [interfaceDecl$$7])
      }else {
        this.indenter.decreaseIndent();
        JAM.call(this.popDeclarationContainer, this, [interfaceDecl$$7]);
        this.emitIndent();
        var v2214 = this.declFile;
        JAM.call(v2214.WriteLine, v2214, ["}"])
      }
      return true
    }
    function v1225(pre$$16, classDecl$$10) {
      if(!JAM.call(this.canEmitPrePostAstSignature, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [classDecl$$10.varFlags]), classDecl$$10, pre$$16])) {
        return false
      }
      if(pre$$16) {
        var className$$5 = classDecl$$10.name.text;
        JAM.call(this.emitDeclarationComments, this, [classDecl$$10]);
        JAM.call(this.emitDeclFlags, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [classDecl$$10.varFlags]), "class"]);
        var v2218 = this.declFile;
        JAM.call(v2218.Write, v2218, [className$$5]);
        JAM.call(this.emitBaseList, this, [classDecl$$10.extendsList, "extends"]);
        JAM.call(this.emitBaseList, this, [classDecl$$10.implementsList, "implements"]);
        var v2221 = this.declFile;
        JAM.call(v2221.WriteLine, v2221, [" {"]);
        JAM.call(this.pushDeclarationContainer, this, [classDecl$$10]);
        this.indenter.increaseIndent();
        if(classDecl$$10.constructorDecl) {
          JAM.call(this.emitClassMembersFromConstructorDefinition, this, [classDecl$$10.constructorDecl])
        }
      }else {
        this.indenter.decreaseIndent();
        JAM.call(this.popDeclarationContainer, this, [classDecl$$10]);
        this.emitIndent();
        var v2226 = this.declFile;
        JAM.call(v2226.WriteLine, v2226, ["}"])
      }
      return true
    }
    function v1224(funcDecl$$37) {
      if(funcDecl$$37.arguments) {
        var argsLen$$3 = funcDecl$$37.arguments.members.length;
        if(funcDecl$$37.variableArgList) {
          argsLen$$3 = argsLen$$3 - 1
        }
        var i$$124 = 0;
        var v2238 = i$$124 < argsLen$$3;
        for(;v2238;) {
          var v2229 = funcDecl$$37.arguments.members;
          introspect(JAM.policy.p1) {
            var argDecl$$4 = v2229[i$$124]
          }
          if(JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [argDecl$$4.varFlags, TypeScript$$31.VarFlags.Property])) {
            JAM.call(this.emitDeclarationComments, this, [argDecl$$4]);
            JAM.call(this.emitDeclFlags, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [argDecl$$4.varFlags]), "var"]);
            var v2231 = this.declFile;
            JAM.call(v2231.Write, v2231, [argDecl$$4.id.text]);
            var v12786 = argDecl$$4.typeExpr;
            if(v12786) {
              v12786 = JAM.call(this.canEmitTypeAnnotationSignature, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [argDecl$$4.varFlags])])
            }
            if(v12786) {
              var v2233 = this.declFile;
              JAM.call(v2233.Write, v2233, [": "]);
              JAM.call(this.emitTypeSignature, this, [argDecl$$4.type])
            }
            var v2236 = this.declFile;
            JAM.call(v2236.WriteLine, v2236, [";"])
          }
          i$$124 = i$$124 + 1;
          v2238 = i$$124 < argsLen$$3
        }
      }
      return
    }
    function v1223(funcDecl$$36) {
      var accessorSymbol$$1 = funcDecl$$36.accessorSymbol;
      var v12787 = accessorSymbol$$1.getter;
      if(v12787) {
        v12787 = accessorSymbol$$1.getter.declAST != funcDecl$$36
      }
      if(v12787) {
        return false
      }
      JAM.call(this.emitDeclarationComments, this, [accessorSymbol$$1]);
      JAM.call(this.emitDeclFlags, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [accessorSymbol$$1.flags]), "var"]);
      var v2242 = this.declFile;
      JAM.call(v2242.Write, v2242, [funcDecl$$36.name.text]);
      var propertyType = accessorSymbol$$1.getType();
      if(JAM.call(this.canEmitTypeAnnotationSignature, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [accessorSymbol$$1.flags])])) {
        var v2244 = this.declFile;
        JAM.call(v2244.Write, v2244, [" : "]);
        JAM.call(this.emitTypeSignature, this, [propertyType])
      }
      var v2246 = this.declFile;
      JAM.call(v2246.WriteLine, v2246, [";"]);
      return false
    }
    function v1222(bases$$8, qual) {
      var v12791 = bases$$8;
      if(v12791) {
        v12791 = bases$$8.members.length > 0
      }
      if(v12791) {
        var v2247 = this.declFile;
        JAM.call(v2247.Write, v2247, [" " + qual + " "]);
        var basesLen$$3 = bases$$8.members.length;
        var i$$123 = 0;
        var v2254 = i$$123 < basesLen$$3;
        for(;v2254;) {
          var v2250 = bases$$8.members;
          introspect(JAM.policy.p1) {
            var baseExpr$$3 = v2250[i$$123]
          }
          var baseSymbol$$4 = baseExpr$$3.type.symbol;
          var baseType$$1 = baseExpr$$3.type;
          if(i$$123 > 0) {
            var v2252 = this.declFile;
            JAM.call(v2252.Write, v2252, [", "])
          }
          JAM.call(this.emitTypeSignature, this, [baseType$$1]);
          i$$123 = i$$123 + 1;
          v2254 = i$$123 < basesLen$$3
        }
      }
      return
    }
    function v1221(pre$$15, funcDecl$$35) {
      if(!pre$$15) {
        return false
      }
      if(funcDecl$$35.isAccessor()) {
        return JAM.call(this.emitPropertyAccessorSignature, this, [funcDecl$$35])
      }
      var isInterfaceMember = this.getAstDeclarationContainer().nodeType == TypeScript$$31.NodeType.InterfaceDeclaration;
      if(funcDecl$$35.bod) {
        if(funcDecl$$35.isConstructor) {
          var v12795 = funcDecl$$35.type.construct;
          if(v12795) {
            v12795 = funcDecl$$35.type.construct.signatures.length > 1
          }
          if(v12795) {
            return false
          }
        }else {
          var v12796 = funcDecl$$35.type.call;
          if(v12796) {
            v12796 = funcDecl$$35.type.call.signatures.length > 1
          }
          if(v12796) {
            return false
          }
        }
      }else {
        var v12797 = !isInterfaceMember;
        if(v12797) {
          var v19013 = JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [funcDecl$$35.fncFlags, TypeScript$$31.FncFlags.Private]);
          if(v19013) {
            var v22902 = funcDecl$$35.type.call;
            if(v22902) {
              v22902 = funcDecl$$35.type.call.signatures.length > 1
            }
            v19013 = v22902
          }
          v12797 = v19013
        }
        if(v12797) {
          var signatures$$4 = funcDecl$$35.type.call.signatures;
          var firstSignature = signatures$$4[0].declAST;
          if(firstSignature.bod) {
            firstSignature = signatures$$4[1].declAST
          }
          if(firstSignature != funcDecl$$35) {
            return false
          }
        }
      }
      if(!JAM.call(this.canEmitSignature, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [funcDecl$$35.fncFlags]), false])) {
        return false
      }
      JAM.call(this.emitDeclarationComments, this, [funcDecl$$35]);
      if(funcDecl$$35.isConstructor) {
        this.emitIndent();
        var v2271 = this.declFile;
        JAM.call(v2271.Write, v2271, ["constructor"])
      }else {
        var id$$24 = funcDecl$$35.getNameText();
        if(!isInterfaceMember) {
          JAM.call(this.emitDeclFlags, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [funcDecl$$35.fncFlags]), "function"]);
          var v2273 = this.declFile;
          JAM.call(v2273.Write, v2273, [id$$24])
        }else {
          this.emitIndent();
          if(funcDecl$$35.isConstructMember()) {
            var v2274 = this.declFile;
            JAM.call(v2274.Write, v2274, ["new"])
          }else {
            var v12801 = !funcDecl$$35.isCallMember();
            if(v12801) {
              v12801 = !funcDecl$$35.isIndexerMember()
            }
            if(v12801) {
              var v2275 = this.declFile;
              JAM.call(v2275.Write, v2275, [id$$24]);
              if(JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [funcDecl$$35.name.flags, TypeScript$$31.ASTFlags.OptionalName])) {
                var v2276 = this.declFile;
                JAM.call(v2276.Write, v2276, ["? "])
              }
            }
          }
        }
      }
      if(!funcDecl$$35.isIndexerMember()) {
        var v2282 = this.declFile;
        JAM.call(v2282.Write, v2282, ["("])
      }else {
        var v2283 = this.declFile;
        JAM.call(v2283.Write, v2283, ["["])
      }
      this.indenter.increaseIndent();
      if(funcDecl$$35.arguments) {
        var argsLen$$2 = funcDecl$$35.arguments.members.length;
        if(funcDecl$$35.variableArgList) {
          argsLen$$2 = argsLen$$2 - 1
        }
        var i$$122 = 0;
        var v2291 = i$$122 < argsLen$$2;
        for(;v2291;) {
          var v2288 = funcDecl$$35.arguments.members;
          introspect(JAM.policy.p1) {
            var argDecl$$3 = v2288[i$$122]
          }
          JAM.call(this.emitArgDecl, this, [argDecl$$3, funcDecl$$35]);
          if(i$$122 < argsLen$$2 - 1) {
            var v2289 = this.declFile;
            JAM.call(v2289.Write, v2289, [", "])
          }
          i$$122 = i$$122 + 1;
          v2291 = i$$122 < argsLen$$2
        }
      }
      if(funcDecl$$35.variableArgList) {
        var v2293 = funcDecl$$35.arguments.members;
        var v2294 = funcDecl$$35.arguments.members.length - 1;
        introspect(JAM.policy.p1) {
          var lastArg$$2 = v2293[v2294]
        }
        if(funcDecl$$35.arguments.members.length > 1) {
          var v2295 = this.declFile;
          JAM.call(v2295.Write, v2295, [", ..."])
        }else {
          var v2296 = this.declFile;
          JAM.call(v2296.Write, v2296, ["..."])
        }
        JAM.call(this.emitArgDecl, this, [lastArg$$2, funcDecl$$35])
      }
      this.indenter.decreaseIndent();
      if(!funcDecl$$35.isIndexerMember()) {
        var v2300 = this.declFile;
        JAM.call(v2300.Write, v2300, [")"])
      }else {
        var v2301 = this.declFile;
        JAM.call(v2301.Write, v2301, ["]"])
      }
      var v12812 = !funcDecl$$35.isConstructor;
      if(v12812) {
        var v22906 = funcDecl$$35.returnTypeAnnotation;
        if(!v22906) {
          v22906 = funcDecl$$35.signature.returnType.type != this.checker.anyType
        }
        var v19022 = v22906;
        if(v19022) {
          v19022 = JAM.call(this.canEmitTypeAnnotationSignature, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [funcDecl$$35.fncFlags])])
        }
        v12812 = v19022
      }
      if(v12812) {
        var v2303 = this.declFile;
        JAM.call(v2303.Write, v2303, [": "]);
        JAM.call(this.emitTypeSignature, this, [funcDecl$$35.signature.returnType.type])
      }
      var v2306 = this.declFile;
      JAM.call(v2306.WriteLine, v2306, [";"]);
      return false
    }
    function v1220(argDecl$$2, funcDecl$$34) {
      JAM.call(this.emitDeclarationComments, this, [argDecl$$2, false]);
      var v2307 = this.declFile;
      JAM.call(v2307.Write, v2307, [argDecl$$2.id.text]);
      if(argDecl$$2.isOptionalArg()) {
        var v2309 = this.declFile;
        JAM.call(v2309.Write, v2309, ["?"])
      }
      var v19024 = argDecl$$2.typeExpr;
      if(!v19024) {
        v19024 = argDecl$$2.type != this.checker.anyType
      }
      var v12815 = v19024;
      if(v12815) {
        v12815 = JAM.call(this.canEmitTypeAnnotationSignature, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [funcDecl$$34.fncFlags])])
      }
      if(v12815) {
        var v2311 = this.declFile;
        JAM.call(v2311.Write, v2311, [": "]);
        JAM.call(this.emitTypeSignature, this, [argDecl$$2.type])
      }
      return
    }
    function v1219(pre$$14, block$$2) {
      if(!block$$2.isStatementBlock) {
        if(pre$$14) {
          this.varListCount = block$$2.statements.members.length
        }else {
          this.varListCount = 0
        }
        return true
      }
      return false
    }
    function v1218(pre$$13, varDecl$$20) {
      var v12818 = pre$$13;
      if(v12818) {
        v12818 = JAM.call(this.canEmitSignature, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [varDecl$$20.varFlags]), false])
      }
      if(v12818) {
        var interfaceMember = this.getAstDeclarationContainer().nodeType == TypeScript$$31.NodeType.InterfaceDeclaration;
        JAM.call(this.emitDeclarationComments, this, [varDecl$$20]);
        if(!interfaceMember) {
          if(this.varListCount >= 0) {
            JAM.call(this.emitDeclFlags, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [varDecl$$20.varFlags]), "var"]);
            this.varListCount = -this.varListCount
          }
          var v2321 = this.declFile;
          JAM.call(v2321.Write, v2321, [varDecl$$20.id.text])
        }else {
          this.emitIndent();
          var v2323 = this.declFile;
          JAM.call(v2323.Write, v2323, [varDecl$$20.id.text]);
          if(JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [varDecl$$20.id.flags, TypeScript$$31.ASTFlags.OptionalName])) {
            var v2325 = this.declFile;
            JAM.call(v2325.Write, v2325, ["?"])
          }
        }
        var type$$59 = null;
        var v12827 = varDecl$$20.typeExpr;
        if(v12827) {
          v12827 = varDecl$$20.typeExpr.type
        }
        if(v12827) {
          type$$59 = varDecl$$20.typeExpr.type
        }else {
          if(varDecl$$20.sym) {
            type$$59 = varDecl$$20.sym.getType();
            if(type$$59 == this.checker.anyType) {
              type$$59 = null
            }
          }
        }
        var v12829 = type$$59;
        if(v12829) {
          v12829 = JAM.call(this.canEmitTypeAnnotationSignature, this, [JAM.call(TypeScript$$31.ToDeclFlags, TypeScript$$31, [varDecl$$20.varFlags])])
        }
        if(v12829) {
          var v2333 = this.declFile;
          JAM.call(v2333.Write, v2333, [": "]);
          JAM.call(this.emitTypeSignature, this, [type$$59])
        }
        if(this.varListCount > 0) {
          this.varListCount = this.varListCount - 1
        }else {
          if(this.varListCount < 0) {
            this.varListCount = this.varListCount + 1
          }
        }
        if(this.varListCount < 0) {
          var v2337 = this.declFile;
          JAM.call(v2337.Write, v2337, [", "])
        }else {
          var v2338 = this.declFile;
          JAM.call(v2338.WriteLine, v2338, [";"])
        }
      }
      return false
    }
    function v1217(astOrSymbol, endLine) {
      if(typeof endLine === "undefined") {
        endLine = true
      }
      if(!this.emitOptions.emitComments) {
        return
      }
      var declComments = astOrSymbol.getDocComments();
      if(declComments.length > 0) {
        var i$$121 = 0;
        var v2344 = i$$121 < declComments.length;
        for(;v2344;) {
          introspect(JAM.policy.p1) {
            var v2343 = declComments[i$$121]
          }
          JAM.call(this.emitComment, this, [v2343]);
          i$$121 = i$$121 + 1;
          v2344 = i$$121 < declComments.length
        }
        if(endLine) {
          if(!this.declFile.onNewLine) {
            var v2345 = this.declFile;
            JAM.call(v2345.WriteLine, v2345, [""])
          }
        }else {
          if(this.declFile.onNewLine) {
            this.emitIndent()
          }
        }
      }
      return
    }
    function v1216(comment$$10) {
      var text$$26 = comment$$10.getText();
      if(this.declFile.onNewLine) {
        this.emitIndent()
      }else {
        if(!comment$$10.isBlockComment) {
          var v2349 = this.declFile;
          JAM.call(v2349.WriteLine, v2349, [""]);
          this.emitIndent()
        }
      }
      var v2352 = this.declFile;
      JAM.call(v2352.Write, v2352, [text$$26[0]]);
      var i$$120 = 1;
      var v2357 = i$$120 < text$$26.length;
      for(;v2357;) {
        var v2354 = this.declFile;
        JAM.call(v2354.WriteLine, v2354, [""]);
        this.emitIndent();
        var v2355 = this.declFile;
        introspect(JAM.policy.p1) {
          var v2356 = text$$26[i$$120]
        }
        JAM.call(v2355.Write, v2355, [v2356]);
        i$$120 = i$$120 + 1;
        v2357 = i$$120 < text$$26.length
      }
      var v12846 = comment$$10.endsLine;
      if(!v12846) {
        v12846 = !comment$$10.isBlockComment
      }
      if(v12846) {
        var v2358 = this.declFile;
        JAM.call(v2358.WriteLine, v2358, [""])
      }else {
        var v2359 = this.declFile;
        JAM.call(v2359.Write, v2359, [" "])
      }
      return
    }
    function v1215(type$$58) {
      var containingScope = null;
      var declarationContainerAst = this.getAstDeclarationContainer();
      switch(declarationContainerAst.nodeType) {
        case TypeScript$$31.NodeType.ModuleDeclaration:
        ;
        case TypeScript$$31.NodeType.InterfaceDeclaration:
        ;
        case TypeScript$$31.NodeType.FuncDecl:
          if(declarationContainerAst.type) {
            containingScope = declarationContainerAst.type.containedScope
          }
          break;
        case TypeScript$$31.NodeType.Script:
          var script$$21 = declarationContainerAst;
          if(script$$21.bod) {
            containingScope = script$$21.bod.enclosingScope
          }
          break;
        case TypeScript$$31.NodeType.ClassDeclaration:
          if(declarationContainerAst.type) {
            containingScope = declarationContainerAst.type.instanceType.containedScope
          }
          break;
        default:
          var v2367 = TypeScript$$31.CompilerDiagnostics;
          JAM.call(v2367.debugPrint, v2367, ["Unknown containing scope"])
      }
      var typeNameMembers = JAM.call(type$$58.getScopedTypeNameEx, type$$58, [containingScope]);
      JAM.call(this.emitTypeNamesMember, this, [typeNameMembers]);
      return
    }
    function v1214(memberName$$5, emitIndent) {
      if(typeof emitIndent === "undefined") {
        emitIndent = false
      }
      if(memberName$$5.prefix == "{ ") {
        if(emitIndent) {
          this.emitIndent()
        }
        var v2370 = this.declFile;
        JAM.call(v2370.WriteLine, v2370, ["{"]);
        this.indenter.increaseIndent();
        emitIndent = true
      }else {
        if(memberName$$5.prefix != "") {
          if(emitIndent) {
            this.emitIndent()
          }
          var v2372 = this.declFile;
          JAM.call(v2372.Write, v2372, [memberName$$5.prefix]);
          emitIndent = false
        }
      }
      if(memberName$$5.isString()) {
        if(emitIndent) {
          this.emitIndent()
        }
        var v2376 = this.declFile;
        JAM.call(v2376.Write, v2376, [memberName$$5.text])
      }else {
        var ar$$1 = memberName$$5;
        var index$$62 = 0;
        var v2381 = index$$62 < ar$$1.entries.length;
        for(;v2381;) {
          var v12852 = ar$$1.entries;
          introspect(JAM.policy.p1) {
            var v2378 = v12852[index$$62]
          }
          JAM.call(this.emitTypeNamesMember, this, [v2378, emitIndent]);
          if(ar$$1.delim == "; ") {
            var v2379 = this.declFile;
            JAM.call(v2379.WriteLine, v2379, [";"])
          }
          index$$62 = index$$62 + 1;
          v2381 = index$$62 < ar$$1.entries.length
        }
      }
      if(memberName$$5.suffix == "}") {
        this.indenter.decreaseIndent();
        this.emitIndent();
        var v2384 = this.declFile;
        JAM.call(v2384.Write, v2384, [memberName$$5.suffix])
      }else {
        var v2386 = this.declFile;
        JAM.call(v2386.Write, v2386, [memberName$$5.suffix])
      }
      return
    }
    function v1213(ast$$120) {
      var v2389 = TypeScript$$31.CompilerDiagnostics;
      JAM.call(v2389.assert, v2389, [ast$$120 != this.getAstDeclarationContainer(), "Declaration container mismatch"]);
      this.declarationContainerStack.pop();
      return
    }
    function v1212(ast$$119) {
      var v2392 = this.declarationContainerStack;
      JAM.call(v2392.push, v2392, [ast$$119]);
      return
    }
    function v1211(declFlag) {
      if(typeof declFlag === "undefined") {
        declFlag = TypeScript$$31.DeclFlags.None
      }
      return!JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [declFlag, TypeScript$$31.DeclFlags.Private])
    }
    function v1210(declFlags$$3, typeString$$1) {
      var v2396 = this.declFile;
      JAM.call(v2396.Write, v2396, [JAM.call(this.getDeclFlagsString, this, [declFlags$$3, typeString$$1])]);
      return
    }
    function v1209(declFlags$$2, typeString) {
      var result$$34 = this.getIndentString();
      var accessorString = "";
      if(JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [declFlags$$2, TypeScript$$31.DeclFlags.GetAccessor])) {
        accessorString = "get "
      }else {
        if(JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [declFlags$$2, TypeScript$$31.DeclFlags.SetAccessor])) {
          accessorString = "set "
        }
      }
      var container$$23 = this.getAstDeclarationContainer();
      var v12862 = container$$23.nodeType == TypeScript$$31.NodeType.ModuleDeclaration;
      if(v12862) {
        var v19043 = JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [container$$23.modFlags, TypeScript$$31.ModuleFlags.IsWholeFile]);
        if(v19043) {
          v19043 = JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [declFlags$$2, TypeScript$$31.DeclFlags.Exported])
        }
        v12862 = v19043
      }
      if(v12862) {
        result$$34 = result$$34 + "export "
      }
      var v12863 = JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [declFlags$$2, TypeScript$$31.DeclFlags.LocalStatic]);
      if(!v12863) {
        v12863 = JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [declFlags$$2, TypeScript$$31.DeclFlags.Static])
      }
      if(v12863) {
        result$$34 = result$$34 + ("static " + accessorString)
      }else {
        if(JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [declFlags$$2, TypeScript$$31.DeclFlags.Private])) {
          result$$34 = result$$34 + ("private " + accessorString)
        }else {
          if(JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [declFlags$$2, TypeScript$$31.DeclFlags.Public])) {
            result$$34 = result$$34 + ("public " + accessorString)
          }else {
            if(accessorString == "") {
              result$$34 = result$$34 + (typeString + " ")
            }else {
              result$$34 = result$$34 + accessorString
            }
          }
        }
      }
      return result$$34
    }
    function v1208(declFlags$$1, astWithPrePostCallback, preCallback) {
      if(this.ignoreCallbackAst) {
        var v2405 = TypeScript$$31.CompilerDiagnostics;
        JAM.call(v2405.assert, v2405, [this.ignoreCallbackAst != astWithPrePostCallback, "Ignore Callback AST mismatch"]);
        this.ignoreCallbackAst = null;
        return false
      }else {
        var v12871 = preCallback;
        if(v12871) {
          v12871 = !JAM.call(this.canEmitSignature, this, [declFlags$$1, true, preCallback])
        }
        if(v12871) {
          this.ignoreCallbackAst = astWithPrePostCallback;
          return false
        }
      }
      return true
    }
    function v1207(declFlags, canEmitGlobalAmbientDecl, useDeclarationContainerTop) {
      if(typeof canEmitGlobalAmbientDecl === "undefined") {
        canEmitGlobalAmbientDecl = true
      }
      if(typeof useDeclarationContainerTop === "undefined") {
        useDeclarationContainerTop = true
      }
      var container$$22;
      if(useDeclarationContainerTop) {
        container$$22 = this.getAstDeclarationContainer()
      }else {
        container$$22 = this.declarationContainerStack[this.declarationContainerStack.length - 2]
      }
      var v12875 = container$$22.nodeType == TypeScript$$31.NodeType.ModuleDeclaration;
      if(v12875) {
        v12875 = !JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [declFlags, TypeScript$$31.DeclFlags.Exported])
      }
      if(v12875) {
        return false
      }
      var v12876 = !canEmitGlobalAmbientDecl;
      if(v12876) {
        var v19054 = container$$22.nodeType == TypeScript$$31.NodeType.Script;
        if(v19054) {
          v19054 = JAM.call(TypeScript$$31.hasFlag, TypeScript$$31, [declFlags, TypeScript$$31.DeclFlags.Ambient])
        }
        v12876 = v19054
      }
      if(v12876) {
        return false
      }
      return true
    }
    function v1206() {
      var v2415 = this.declFile;
      JAM.call(v2415.Write, v2415, [this.getIndentString()]);
      return
    }
    function v1205(declIndent) {
      if(typeof declIndent === "undefined") {
        declIndent = false
      }
      if(this.emitOptions.minWhitespace) {
        return""
      }else {
        return this.indenter.getIndent()
      }
      return
    }
    function v1204(script$$20) {
      var v2420 = TypeScript$$31.AstWalkerWithDetailCallback;
      JAM.call(v2420.walk, v2420, [script$$20, this]);
      return
    }
    function v1203() {
      try {
        this.declFile.Close()
      }catch(ex$$3) {
        var v2422 = this.errorReporter;
        JAM.call(v2422.emitterError, v2422, [null, ex$$3.message])
      }
      return
    }
    function v1202(file) {
      var v26796 = JAM.new(DeclFileWriter, [file]);
      this.declFile = v26796;
      return
    }
    function v1201() {
      var v2424;
      if(this.isDottedModuleName.length == 0) {
        v2424 = false
      }else {
        v2424 = this.isDottedModuleName[this.isDottedModuleName.length - 1]
      }
      return v2424
    }
    function v1200() {
      var v2425 = this.declarationContainerStack;
      var v2426 = this.declarationContainerStack.length - 1;
      introspect(JAM.policy.p1) {
        return v2425[v2426]
      }
    }
    function DeclarationEmitter$$1(checker$$23, emitOptions$$2, errorReporter$$5) {
      this.checker = checker$$23;
      this.emitOptions = emitOptions$$2;
      this.errorReporter = errorReporter$$5;
      this.declFile = null;
      var v26797 = new TypeScript$$31.Indenter;
      this.indenter = v26797;
      this.declarationContainerStack = [];
      this.isDottedModuleName = [];
      this.ignoreCallbackAst = null;
      this.singleDeclFile = null;
      this.varListCount = 0;
      return
    }
    DeclarationEmitter$$1.prototype.getAstDeclarationContainer = v1200;
    DeclarationEmitter$$1.prototype.emitDottedModuleName = v1201;
    DeclarationEmitter$$1.prototype.setDeclarationFile = v1202;
    DeclarationEmitter$$1.prototype.Close = v1203;
    DeclarationEmitter$$1.prototype.emitDeclarations = v1204;
    DeclarationEmitter$$1.prototype.getIndentString = v1205;
    DeclarationEmitter$$1.prototype.emitIndent = v1206;
    DeclarationEmitter$$1.prototype.canEmitSignature = v1207;
    DeclarationEmitter$$1.prototype.canEmitPrePostAstSignature = v1208;
    DeclarationEmitter$$1.prototype.getDeclFlagsString = v1209;
    DeclarationEmitter$$1.prototype.emitDeclFlags = v1210;
    DeclarationEmitter$$1.prototype.canEmitTypeAnnotationSignature = v1211;
    DeclarationEmitter$$1.prototype.pushDeclarationContainer = v1212;
    DeclarationEmitter$$1.prototype.popDeclarationContainer = v1213;
    DeclarationEmitter$$1.prototype.emitTypeNamesMember = v1214;
    DeclarationEmitter$$1.prototype.emitTypeSignature = v1215;
    DeclarationEmitter$$1.prototype.emitComment = v1216;
    DeclarationEmitter$$1.prototype.emitDeclarationComments = v1217;
    DeclarationEmitter$$1.prototype.VarDeclCallback = v1218;
    DeclarationEmitter$$1.prototype.BlockCallback = v1219;
    DeclarationEmitter$$1.prototype.emitArgDecl = v1220;
    DeclarationEmitter$$1.prototype.FuncDeclCallback = v1221;
    DeclarationEmitter$$1.prototype.emitBaseList = v1222;
    DeclarationEmitter$$1.prototype.emitPropertyAccessorSignature = v1223;
    DeclarationEmitter$$1.prototype.emitClassMembersFromConstructorDefinition = v1224;
    DeclarationEmitter$$1.prototype.ClassDeclarationCallback = v1225;
    DeclarationEmitter$$1.prototype.InterfaceDeclarationCallback = v1226;
    DeclarationEmitter$$1.prototype.ImportDeclarationCallback = v1227;
    DeclarationEmitter$$1.prototype.emitEnumSignature = v1228;
    DeclarationEmitter$$1.prototype.ModuleDeclarationCallback = v1229;
    DeclarationEmitter$$1.prototype.ScriptCallback = v1230;
    DeclarationEmitter$$1.prototype.DefaultCallback = v1231;
    return DeclarationEmitter$$1
  }
  function v1199() {
    function v1198() {
      this.declFile.Close();
      return
    }
    function v1197(s$$36) {
      var v2461 = this.declFile;
      JAM.call(v2461.WriteLine, v2461, [s$$36]);
      this.onNewLine = true;
      return
    }
    function v1196(s$$35) {
      var v2462 = this.declFile;
      JAM.call(v2462.Write, v2462, [s$$35]);
      this.onNewLine = false;
      return
    }
    function DeclFileWriter$$1(declFile) {
      this.declFile = declFile;
      this.onNewLine = true;
      return
    }
    DeclFileWriter$$1.prototype.Write = v1196;
    DeclFileWriter$$1.prototype.WriteLine = v1197;
    DeclFileWriter$$1.prototype.Close = v1198;
    return DeclFileWriter$$1
  }
  var DeclFileWriter = v1199();
  TypeScript$$31.DeclFileWriter = DeclFileWriter;
  var DeclarationEmitter = v1232();
  TypeScript$$31.DeclarationEmitter = DeclarationEmitter;
  return
}
function v1195(TypeScript$$30) {
  function v1194() {
    function v1193(ast$$117, start$$13, delta$$1) {
      function pre$$12(cur$$11, parent$$71, walker$$55) {
        var v12883 = cur$$11.limChar !== -1;
        if(v12883) {
          v12883 = cur$$11.limChar < start$$13
        }
        if(v12883) {
          walker$$55.options.goChildren = false
        }
        applyDelta(cur$$11);
        applyDeltaToComments(cur$$11.preComments);
        applyDeltaToComments(cur$$11.postComments);
        return cur$$11
      }
      function applyDeltaToComments(comments$$13) {
        var v12884 = comments$$13;
        if(v12884) {
          v12884 = comments$$13.length > 0
        }
        if(v12884) {
          var i$$119 = 0;
          var v2471 = i$$119 < comments$$13.length;
          for(;v2471;) {
            introspect(JAM.policy.p1) {
              var v2470 = comments$$13[i$$119]
            }
            applyDelta(v2470);
            i$$119 = i$$119 + 1;
            v2471 = i$$119 < comments$$13.length
          }
        }
        return
      }
      function applyDelta(ast$$118) {
        var v12887 = ast$$118.minChar !== -1;
        if(v12887) {
          v12887 = ast$$118.minChar >= start$$13
        }
        if(v12887) {
          ast$$118.minChar = ast$$118.minChar + delta$$1
        }
        var v12889 = ast$$118.limChar !== -1;
        if(v12889) {
          v12889 = ast$$118.limChar >= start$$13
        }
        if(v12889) {
          ast$$118.limChar = ast$$118.limChar + delta$$1
        }
        return
      }
      var v2475 = TypeScript$$30.getAstWalkerFactory();
      JAM.call(v2475.walk, v2475, [ast$$117, pre$$12]);
      return
    }
    function v1192(script$$19, partial$$1, editRange$$3) {
      var lineMap1 = script$$19.locationInfo.lineMap;
      var lineMap2 = partial$$1.locationInfo.lineMap;
      if(this.logger.information()) {
        var v2478 = this.logger;
        JAM.call(v2478.log, v2478, ["lineMap1 (before):"]);
        var v2479 = this.astLogger;
        JAM.call(v2479.logLinemap, v2479, [lineMap1]);
        var v2480 = this.logger;
        JAM.call(v2480.log, v2480, ["lineMap2 (quick parse):"]);
        var v2481 = this.astLogger;
        JAM.call(v2481.logLinemap, v2481, [lineMap2]);
        var v2482 = this.logger;
        JAM.call(v2482.log, v2482, ["EditRange=" + editRange$$3])
      }
      var i1 = 2;
      var i2 = 2;
      var len1 = lineMap1.length;
      var len2 = lineMap2.length;
      var v2489 = i1 < len1;
      for(;v2489;) {
        introspect(JAM.policy.p1) {
          var v12892 = lineMap1[i1]
        }
        if(v12892 <= editRange$$3.minChar) {
          i1 = i1 + 1
        }else {
          introspect(JAM.policy.p1) {
            var v12894 = lineMap1[i1]
          }
          if(v12894 >= editRange$$3.limChar) {
            introspect(JAM.policy.p1) {
              var v12896 = lineMap1[i1]
            }
            lineMap1[i1] = v12896 + editRange$$3.delta;
            i1 = i1 + 1
          }else {
            if(i2 < len2) {
              introspect(JAM.policy.p1) {
                var v12898 = lineMap2[i2]
              }
              lineMap1.splice(i1, 0, v12898 + editRange$$3.minChar);
              i1 = i1 + 1;
              len1 = len1 + 1;
              i2 = i2 + 1
            }else {
              lineMap1.splice(i1, 1);
              len1 = len1 - 1
            }
          }
        }
        v2489 = i1 < len1
      }
      if(i2 < len2) {
        var v19065 = len1 - 1;
        introspect(JAM.policy.p1) {
          var v12900 = lineMap1[v19065]
        }
        introspect(JAM.policy.p1) {
          var v19066 = lineMap2[i2]
        }
        if(v12900 >= v19066 + editRange$$3.minChar) {
          i1 = 2;
          var v12902 = i1 < len1;
          if(v12902) {
            v12902 = i2 < len2
          }
          var v2492 = v12902;
          for(;v2492;) {
            introspect(JAM.policy.p1) {
              var v12903 = lineMap1[i1]
            }
            introspect(JAM.policy.p1) {
              var v19068 = lineMap2[i2]
            }
            if(v12903 < v19068 + editRange$$3.minChar) {
              i1 = i1 + 1
            }else {
              introspect(JAM.policy.p1) {
                var v12905 = lineMap2[i2]
              }
              lineMap1.splice(i1, 0, v12905 + editRange$$3.minChar);
              i1 = i1 + 1;
              len1 = len1 + 1;
              i2 = i2 + 1
            }
            var v12907 = i1 < len1;
            if(v12907) {
              v12907 = i2 < len2
            }
            v2492 = v12907
          }
        }
        var v2495 = i2 < len2;
        for(;v2495;) {
          introspect(JAM.policy.p1) {
            var v12908 = lineMap2[i2]
          }
          JAM.call(lineMap1.push, lineMap1, [v12908 + editRange$$3.minChar]);
          i2 = i2 + 1;
          v2495 = i2 < len2
        }
      }
      if(this.logger.information()) {
        var v2497 = this.logger;
        JAM.call(v2497.log, v2497, ["lineMap1 (after merge):"]);
        var v2498 = this.astLogger;
        JAM.call(v2498.logLinemap, v2498, [lineMap1])
      }
      return
    }
    function v1191(script$$18, oldAst, newAst) {
      function pre$$11(cur$$10, parent$$70, walker$$54) {
        if(cur$$10 === oldAst) {
          newAst.preComments = cur$$10.preComments;
          newAst.postComments = cur$$10.postComments;
          var v2500 = _this$$14.logger;
          JAM.call(v2500.log, v2500, ["replaced old AST node with new one in script AST"]);
          walker$$54.options.stopWalk();
          return newAst
        }
        if(JAM.call(TypeScript$$30.isValidAstNode, TypeScript$$30, [cur$$10])) {
          var v12911 = cur$$10.limChar < oldAst.minChar;
          if(!v12911) {
            v12911 = cur$$10.minChar > oldAst.limChar
          }
          if(v12911) {
            walker$$54.options.goChildren = false
          }
        }
        return cur$$10
      }
      var _this$$14 = this;
      var v2506 = TypeScript$$30.getAstWalkerFactory();
      JAM.call(v2506.walk, v2506, [script$$18, pre$$11]);
      return
    }
    function v1190(updateResult) {
      function v1189() {
        var editRange$$2 = JAM.new(TypeScript$$30.ScriptEditRange, [updateResult.scope1.minChar, updateResult.scope1.limChar, updateResult.editRange.delta]);
        JAM.call(_this$$13.applyDeltaPosition, _this$$13, [updateResult.script1, editRange$$2.limChar, editRange$$2.delta]);
        JAM.call(_this$$13.applyDeltaPosition, _this$$13, [updateResult.script2, 0, editRange$$2.minChar]);
        JAM.call(_this$$13.mergeLocationInfo, _this$$13, [updateResult.script1, updateResult.script2, editRange$$2]);
        JAM.call(_this$$13.replaceAST, _this$$13, [updateResult.script1, updateResult.scope1, updateResult.scope2]);
        return
      }
      var _this$$13 = this;
      JAM.call(TypeScript$$30.timeFunction, TypeScript$$30, [this.logger, "mergeTrees()", v1189]);
      return
    }
    function v1188(previousScript$$1, scriptId$$1, newSourceText$$1, editRange$$1) {
      function errorCapture$$1(minChar$$33, charLen, message$$20, unitIndex$$10) {
        JAM.call(parseErrors$$1.push, parseErrors$$1, [JAM.new(TypeScript$$30.ErrorEntry, [unitIndex$$10, minChar$$33, minChar$$33 + charLen, message$$20])]);
        return
      }
      var v2523 = this.logger;
      JAM.call(v2523.log, v2523, ['attemptIncrementalUpdateUnit("' + scriptId$$1 + '")']);
      if(editRange$$1 === null) {
        throw new Error("editRange should be valid");
      }
      var scope1$$1 = JAM.call(this.getEnclosingScopeContextIfSingleScopeEdit, this, [previousScript$$1, scriptId$$1, newSourceText$$1, editRange$$1]);
      if(scope1$$1 === null) {
        return null
      }
      var newScopeLength$$1 = scope1$$1.scopeStartAST.limChar - scope1$$1.scopeStartAST.minChar + editRange$$1.delta;
      if(newScopeLength$$1 >= newSourceText$$1.getLength() / 2) {
        var v2529 = this.logger;
        JAM.call(v2529.log, v2529, ["  Bailing out because range of scope to reparse (" + newScopeLength$$1 + " characters) is greater than half the size of the source text"]);
        return null
      }
      var parseErrors$$1 = [];
      var quickParseResult = JAM.call(TypeScript$$30.quickParse, TypeScript$$30, [this.logger, scope1$$1.scopeStartAST, newSourceText$$1, scope1$$1.scopeStartAST.minChar, scope1$$1.scopeStartAST.minChar + newScopeLength$$1, errorCapture$$1]);
      if(quickParseResult.endLexState != TypeScript$$30.LexState.Start) {
        var v2536 = this.logger;
        JAM.call(v2536.log, v2536, ["  Bailing out because scope contains unterminated comment"]);
        return null
      }
      var scriptFragment$$1 = quickParseResult.Script;
      if(scriptFragment$$1.vars.members.length !== 0) {
        var v2538 = this.logger;
        JAM.call(v2538.log, v2538, ["  Bailing out because new source text defines variables"]);
        return null
      }
      if(scriptFragment$$1.bod.members.length !== 1) {
        var v2540 = this.logger;
        JAM.call(v2540.log, v2540, ["  Bailing out because new source text defines more than one scope (or none)"]);
        return null
      }
      var oldScope = scope1$$1.scopeStartAST;
      var newScope = scriptFragment$$1.bod.members[0];
      if(oldScope.nodeType != newScope.nodeType) {
        var v2543 = this.logger;
        JAM.call(v2543.log, v2543, ["  Bailing out because new source text does not define the same scope type as the existing scope"]);
        return null
      }
      var v12932 = !oldScope.leftCurlyCount;
      if(!v12932) {
        v12932 = !oldScope.rightCurlyCount
      }
      if(v12932) {
        var v2545 = this.logger;
        JAM.call(v2545.log, v2545, ["  Bailing out because sopce doesn't have left/right curly count"]);
        return null
      }
      if(oldScope.leftCurlyCount !== newScope.leftCurlyCount) {
        var v2547 = this.logger;
        JAM.call(v2547.log, v2547, ["  Bailing out because new source text contains more (or fewer) left curly braces"]);
        return null
      }
      if(oldScope.rightCurlyCount !== newScope.rightCurlyCount) {
        var v2549 = this.logger;
        JAM.call(v2549.log, v2549, ["  Bailing out because new source text contains more (or fewer) right curly braces"]);
        return null
      }
      if(newScope.minChar !== 0) {
        var v2551 = this.logger;
        JAM.call(v2551.log, v2551, ["  Bailing out because new function declaration does not start at position 0"]);
        return null
      }
      if(newScope.limChar !== newScopeLength$$1) {
        var v2553 = this.logger;
        JAM.call(v2553.log, v2553, ["  Bailing out because new function declaration does not end at the new end position"]);
        return null
      }
      var v2555 = TypeScript$$30.UpdateUnitResult;
      return JAM.call(v2555.singleScopeEdits, v2555, [previousScript$$1, scriptFragment$$1, oldScope, newScope, editRange$$1, parseErrors$$1])
    }
    function v1187(previousScript, scriptId, newSourceText, editRange) {
      var v2556 = this.logger;
      JAM.call(v2556.log, v2556, ['checkEditsInsideSingleScope("' + scriptId + '")']);
      if(editRange === null) {
        throw new Error("editRange should be valid");
      }
      if(editRange.isUnknown()) {
        var v2559 = this.logger;
        JAM.call(v2559.log, v2559, ["  Bailing out because edit range is unknown"]);
        return null
      }
      var scope1 = JAM.call(TypeScript$$30.findEnclosingScopeAt, TypeScript$$30, [this.logger, previousScript, newSourceText, editRange.minChar, false]);
      var scope2 = JAM.call(TypeScript$$30.findEnclosingScopeAt, TypeScript$$30, [this.logger, previousScript, newSourceText, editRange.limChar, false]);
      var v12940 = scope1 == null;
      if(!v12940) {
        v12940 = scope2 == null
      }
      if(v12940) {
        var v2565 = this.logger;
        JAM.call(v2565.log, v2565, ["  Bailing out because containing scopes cannot be determined"]);
        return null
      }
      if(scope1.scopeStartAST !== scope2.scopeStartAST) {
        var v2567 = this.logger;
        JAM.call(v2567.log, v2567, ["  Bailing out because edit overlaps 2 disctint scopes"]);
        return null
      }
      var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;
      if(newScopeLength <= 0) {
        var v2571 = this.logger;
        JAM.call(v2571.log, v2571, ["  Bailing out because scope has been entirely removed from new source text"]);
        return null
      }
      return scope1
    }
    function IncrementalParser$$1(logger$$5) {
      this.logger = logger$$5;
      var v26798 = JAM.new(TypeScript$$30.AstLogger, [this.logger]);
      this.astLogger = v26798;
      return
    }
    IncrementalParser$$1.prototype.getEnclosingScopeContextIfSingleScopeEdit = v1187;
    IncrementalParser$$1.prototype.attemptIncrementalUpdateUnit = v1188;
    IncrementalParser$$1.prototype.mergeTrees = v1190;
    IncrementalParser$$1.prototype.replaceAST = v1191;
    IncrementalParser$$1.prototype.mergeLocationInfo = v1192;
    IncrementalParser$$1.prototype.applyDeltaPosition = v1193;
    return IncrementalParser$$1
  }
  var IncrementalParser = v1194();
  TypeScript$$30.IncrementalParser = IncrementalParser;
  return
}
function v1186(TypeScript$$29) {
  function v1185() {
    function v1184(str$$12) {
      var v2581 = this.styleSettings;
      JAM.call(v2581.parseOptions, v2581, [str$$12]);
      return
    }
    function CompilationSettings$$1() {
      var v26799 = new StyleSettings;
      this.styleSettings = v26799;
      this.propagateConstants = false;
      this.minWhitespace = false;
      this.parseOnly = false;
      this.errorRecovery = false;
      this.emitComments = false;
      this.watch = false;
      this.exec = false;
      this.resolve = true;
      this.controlFlow = false;
      this.printControlFlow = false;
      this.controlFlowUseDef = false;
      this.errorOnWith = true;
      this.preprocess = true;
      this.canCallDefinitionSignature = false;
      this.inferPropertiesFromThisAssignment = false;
      this.useDefaultLib = true;
      this.codeGenTarget = TypeScript$$29.CodeGenTarget.ES3;
      this.moduleGenTarget = TypeScript$$29.ModuleGenTarget.Synchronous;
      this.outputOption = "";
      this.mapSourceFiles = false;
      this.generateDeclarationFiles = false;
      this.useCaseSensitiveFileResolution = false;
      return
    }
    CompilationSettings$$1.prototype.setStyleOptions = v1184;
    return CompilationSettings$$1
  }
  function v1183() {
    function v1182(str$$11) {
      var opts = str$$11.split(";");
      var i$$118 = 0;
      var len$$57 = opts.length;
      var v2589 = i$$118 < len$$57;
      for(;v2589;) {
        introspect(JAM.policy.p1) {
          var opt$$1 = opts[i$$118]
        }
        var val$$7 = true;
        var colonIndex = opt$$1.lastIndexOf(":");
        if(colonIndex >= 0) {
          var valStr = JAM.call(opt$$1.substring, opt$$1, [colonIndex + 1]);
          opt$$1 = JAM.call(opt$$1.substring, opt$$1, [0, colonIndex]);
          if(valStr == "off") {
            val$$7 = false
          }
        }
        if(!JAM.call(this.setOption, this, [opt$$1, val$$7])) {
          return false
        }
        i$$118 = i$$118 + 1;
        v2589 = i$$118 < len$$57
      }
      return true
    }
    function v1181(opt, val$$6) {
      introspect(JAM.policy.p1) {
        var optExists = this[opt]
      }
      if(optExists !== undefined) {
        JAM.set(this, opt, val$$6);
        return true
      }else {
        return false
      }
      return
    }
    function StyleSettings$$1() {
      this.bitwise = false;
      this.blockInCompoundStmt = false;
      this.eqeqeq = false;
      this.forin = false;
      this.emptyBlocks = true;
      this.newMustBeUsed = false;
      this.requireSemi = false;
      this.assignmentInCond = false;
      this.eqnull = false;
      this.evalOK = true;
      this.innerScopeDeclEscape = true;
      this.funcInLoop = true;
      this.reDeclareLocal = true;
      this.literalSubscript = true;
      this.implicitAny = false;
      return
    }
    StyleSettings$$1.prototype.setOption = v1181;
    StyleSettings$$1.prototype.parseOptions = v1182;
    return StyleSettings$$1
  }
  function getAdditionalDependencyPath(comment$$6) {
    var amdDependencyRegEx = /^(\/\/\/\s*<amd-dependency\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/igm;
    var match$$1 = JAM.call(amdDependencyRegEx.exec, amdDependencyRegEx, [comment$$6]);
    if(match$$1) {
      var path$$18 = match$$1[3];
      return path$$18
    }else {
      return null
    }
    return
  }
  function getImplicitImport(comment$$7) {
    var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/igm;
    var match$$2 = JAM.call(implicitImportRegEx.exec, implicitImportRegEx, [comment$$7]);
    if(match$$2) {
      return true
    }
    return false
  }
  function getStyleSettings(comment$$8, styleSettings) {
    var styleRegEx = /^(\/\/\/\s*<style\s+)(([a-zA-Z])+=('|").+('|"))\s*\/>/igm;
    var settings$$2 = JAM.call(styleRegEx.exec, styleRegEx, [comment$$8]);
    if(settings$$2) {
      var settingsRegEx = /^([a-zA-Z]+=['"]on['|"])/igm;
      settings$$2 = JAM.call(settingsRegEx.exec, settingsRegEx, [settings$$2[2]]);
      if(settings$$2) {
        var i$$117 = 0;
        var v2610 = i$$117 < settings$$2.length;
        for(;v2610;) {
          introspect(JAM.policy.p1) {
            var v2594 = settings$$2[i$$117]
          }
          var setting = v2594.split("=");
          var on = '"on"';
          switch(setting[0]) {
            case "blockInCompoundStmt":
              styleSettings.blockInCompoundStmt = setting[1] == on;
              break;
            case "eqeqeq":
              styleSettings.eqeqeq = setting[1] == on;
              break;
            case "forin":
              styleSettings.forin = setting[1] == on;
              break;
            case "emptyBlocks":
              styleSettings.emptyBlocks = setting[1] == on;
              break;
            case "newMustBeUsed":
              styleSettings.newMustBeUsed = setting[1] == on;
              break;
            case "requireSemi":
              styleSettings.requireSemi = setting[1] == on;
              break;
            case "assignmentInCond":
              styleSettings.assignmentInCond = setting[1] == on;
              break;
            case "eqnull":
              styleSettings.eqnull = setting[1] == on;
              break;
            case "evalOK":
              styleSettings.evalOK = setting[1] == on;
              break;
            case "innerScopeDeclEscape":
              styleSettings.innerScopeDeclEscape = setting[1] == on;
              break;
            case "funcInLoop":
              styleSettings.funcInLoop = setting[1] == on;
              break;
            case "reDeclareLocal":
              styleSettings.reDeclareLocal = setting[1] == on;
              break;
            case "literalSubscript":
              styleSettings.literalSubscript = setting[1] == on;
              break;
            case "implicitAny":
              styleSettings.implicitAny = setting[1] == on
          }
          i$$117 = i$$117 + 1;
          v2610 = i$$117 < settings$$2.length
        }
      }
    }
    return
  }
  function getReferencedFiles(sourceText$$4) {
    var preProcessInfo = preProcessFile(sourceText$$4, null, false);
    return preProcessInfo.referencedFiles
  }
  function preProcessFile(sourceText$$5, options$$7, readImportFiles) {
    if(typeof options$$7 === "undefined") {
      options$$7 = new CompilationSettings
    }
    if(typeof readImportFiles === "undefined") {
      readImportFiles = true
    }
    var scanner$$1 = new TypeScript$$29.Scanner;
    scanner$$1.resetComments();
    JAM.call(scanner$$1.setSourceText, scanner$$1, [sourceText$$5, TypeScript$$29.LexMode.File]);
    var tok$$5 = scanner$$1.scan();
    var comments$$12 = [];
    var comment$$9 = null;
    var leftCurlies = [];
    var settings$$3 = options$$7;
    var referencedFiles = [];
    var importedFiles = [];
    var isLibFile = false;
    var v2626 = tok$$5.tokenId != TypeScript$$29.TokenID.EndOfFile;
    for(;v2626;) {
      var v12953 = readImportFiles;
      if(v12953) {
        v12953 = tok$$5.tokenId == TypeScript$$29.TokenID.Import
      }
      if(v12953) {
        tok$$5 = scanner$$1.scan();
        var v12954 = tok$$5.tokenId == TypeScript$$29.TokenID.Identifier;
        if(!v12954) {
          v12954 = JAM.call(TypeScript$$29.convertTokToID, TypeScript$$29, [tok$$5, false])
        }
        if(v12954) {
          tok$$5 = scanner$$1.scan();
          if(tok$$5.tokenId == TypeScript$$29.TokenID.Equals) {
            tok$$5 = scanner$$1.scan();
            if(tok$$5.tokenId == TypeScript$$29.TokenID.Module) {
              tok$$5 = scanner$$1.scan();
              if(tok$$5.tokenId == TypeScript$$29.TokenID.OpenParen) {
                tok$$5 = scanner$$1.scan();
                if(tok$$5.tokenId == TypeScript$$29.TokenID.StringLiteral) {
                  var ref$$2 = {minChar:scanner$$1.startPos, limChar:scanner$$1.pos, path:JAM.call(TypeScript$$29.stripQuotes, TypeScript$$29, [JAM.call(TypeScript$$29.switchToForwardSlashes, TypeScript$$29, [tok$$5.getText()])]), isResident:false};
                  JAM.call(importedFiles.push, importedFiles, [ref$$2])
                }
              }
            }
          }
        }
      }
      if(tok$$5.tokenId == TypeScript$$29.TokenID.OpenBrace) {
        JAM.call(leftCurlies.push, leftCurlies, [tok$$5])
      }
      if(tok$$5.tokenId == TypeScript$$29.TokenID.CloseBrace) {
        leftCurlies.pop()
      }
      tok$$5 = scanner$$1.scan();
      v2626 = tok$$5.tokenId != TypeScript$$29.TokenID.EndOfFile
    }
    comments$$12 = scanner$$1.getComments();
    var iComment = 0;
    var v2639 = iComment < comments$$12.length;
    for(;v2639;) {
      comment$$9 = comments$$12[iComment];
      if(!comment$$9.isBlock) {
        var referencedCode;
        JSCompiler_inline_label_getFileReferenceFromReferencePath_29: {
          var comment$$inline_23 = comment$$9.getText();
          var referencesRegEx$$inline_24 = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/igm;
          var match$$inline_25 = JAM.call(referencesRegEx$$inline_24.exec, referencesRegEx$$inline_24, [comment$$inline_23]);
          if(match$$inline_25) {
            var path$$inline_26 = JAM.call(TypeScript$$29.normalizePath, TypeScript$$29, [match$$inline_25[3]]);
            var adjustedPath$$inline_27 = JAM.call(TypeScript$$29.normalizePath, TypeScript$$29, [path$$inline_26]);
            var v2628 = match$$inline_25.length >= 7;
            if(v2628) {
              v2628 = match$$inline_25[6] == "true"
            }
            var isResident$$inline_28 = v2628;
            if(isResident$$inline_28) {
              var v2629 = TypeScript$$29.CompilerDiagnostics;
              JAM.call(v2629.debugPrint, v2629, [path$$inline_26 + " is resident"])
            }
            referencedCode = {minChar:0, limChar:0, path:JAM.call(TypeScript$$29.switchToForwardSlashes, TypeScript$$29, [adjustedPath$$inline_27]), isResident:isResident$$inline_28}
          }else {
            referencedCode = null
          }
        }
        if(referencedCode) {
          referencedCode.minChar = comment$$9.startPos;
          referencedCode.limChar = referencedCode.minChar + comment$$9.value.length;
          JAM.call(referencedFiles.push, referencedFiles, [referencedCode])
        }
        if(settings$$3) {
          getStyleSettings(comment$$9.getText(), settings$$3.styleSettings);
          var isNoLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/igm;
          var isNoLibMatch = JAM.call(isNoLibRegex.exec, isNoLibRegex, [comment$$9.getText()]);
          if(isNoLibMatch) {
            isLibFile = isNoLibMatch[3] == "true"
          }
        }
      }
      iComment = iComment + 1;
      v2639 = iComment < comments$$12.length
    }
    return{settings:settings$$3, referencedFiles:referencedFiles, importedFiles:importedFiles, isLibFile:isLibFile}
  }
  var StyleSettings = v1183();
  TypeScript$$29.StyleSettings = StyleSettings;
  var CompilationSettings = v1185();
  TypeScript$$29.CompilationSettings = CompilationSettings;
  TypeScript$$29.getAdditionalDependencyPath = getAdditionalDependencyPath;
  TypeScript$$29.getImplicitImport = getImplicitImport;
  TypeScript$$29.getStyleSettings = getStyleSettings;
  TypeScript$$29.getReferencedFiles = getReferencedFiles;
  TypeScript$$29.preProcessFile = preProcessFile;
  return
}
function v1180(TypeScript$$28) {
  function v1179() {
    function v1178(referencePath, parentPath, performSearch, resolutionDispatcher) {
      var resolvedFile = {content:"", path:referencePath};
      var ioHost$$1 = this.environment.ioHost;
      var isRelativePath = JAM.call(TypeScript$$28.isRelative, TypeScript$$28, [referencePath]);
      var v2641;
      if(isRelativePath) {
        v2641 = false
      }else {
        v2641 = JAM.call(TypeScript$$28.isRooted, TypeScript$$28, [referencePath])
      }
      var isRootedPath = v2641;
      var v2642;
      if(isRelativePath) {
        v2642 = JAM.call(ioHost$$1.resolvePath, ioHost$$1, [parentPath + "/" + referencePath])
      }else {
        var v12977;
        var v22931 = isRootedPath;
        if(!v22931) {
          var v24818 = !parentPath;
          if(!v24818) {
            v24818 = performSearch
          }
          v22931 = v24818
        }
        if(v22931) {
          v12977 = referencePath
        }else {
          v12977 = parentPath + "/" + referencePath
        }
        v2642 = v12977
      }
      var normalizedPath = v2642;
      var v12978 = !JAM.call(TypeScript$$28.isSTRFile, TypeScript$$28, [normalizedPath]);
      if(v12978) {
        v12978 = !JAM.call(TypeScript$$28.isTSFile, TypeScript$$28, [normalizedPath])
      }
      if(v12978) {
        normalizedPath = normalizedPath + ".ts"
      }
      normalizedPath = JAM.call(TypeScript$$28.switchToForwardSlashes, TypeScript$$28, [JAM.call(TypeScript$$28.stripQuotes, TypeScript$$28, [normalizedPath])]);
      var v2645;
      if(this.environment.compilationSettings.useCaseSensitiveFileResolution) {
        v2645 = normalizedPath
      }else {
        v2645 = normalizedPath.toLocaleUpperCase()
      }
      var absoluteModuleID = v2645;
      var v19108 = this.visited;
      introspect(JAM.policy.p1) {
        var v12980 = v19108[absoluteModuleID]
      }
      if(!v12980) {
        var v12981 = isRelativePath;
        if(!v12981) {
          var v19109 = isRootedPath;
          if(!v19109) {
            v19109 = !performSearch
          }
          v12981 = v19109
        }
        if(v12981) {
          try {
            var v2646 = TypeScript$$28.CompilerDiagnostics;
            JAM.call(v2646.debugPrint, v2646, ["   Reading code from " + normalizedPath]);
            try {
              var v2648 = resolvedFile;
              var v26800 = JAM.call(ioHost$$1.readFile, ioHost$$1, [normalizedPath]);
              v2648.content = v26800
            }catch(err) {
              try {
                if(JAM.call(TypeScript$$28.isSTRFile, TypeScript$$28, [normalizedPath])) {
                  normalizedPath = JAM.call(TypeScript$$28.changePathToTS, TypeScript$$28, [normalizedPath])
                }else {
                  if(JAM.call(TypeScript$$28.isTSFile, TypeScript$$28, [normalizedPath])) {
                    normalizedPath = JAM.call(TypeScript$$28.changePathToSTR, TypeScript$$28, [normalizedPath])
                  }
                }
                var v2651 = TypeScript$$28.CompilerDiagnostics;
                JAM.call(v2651.debugPrint, v2651, ["   Reading code from " + normalizedPath]);
                var v2653 = resolvedFile;
                var v26801 = JAM.call(ioHost$$1.readFile, ioHost$$1, [normalizedPath]);
                v2653.content = v26801
              }catch(err$$1) {
                normalizedPath = JAM.call(TypeScript$$28.changePathToDSTR, TypeScript$$28, [normalizedPath]);
                var v2654 = TypeScript$$28.CompilerDiagnostics;
                JAM.call(v2654.debugPrint, v2654, ["   Reading code from " + normalizedPath]);
                try {
                  var v2656 = resolvedFile;
                  var v26802 = JAM.call(ioHost$$1.readFile, ioHost$$1, [normalizedPath]);
                  v2656.content = v26802
                }catch(err$$2) {
                  normalizedPath = JAM.call(TypeScript$$28.changePathToDTS, TypeScript$$28, [normalizedPath]);
                  var v2657 = TypeScript$$28.CompilerDiagnostics;
                  JAM.call(v2657.debugPrint, v2657, ["   Reading code from " + normalizedPath]);
                  var v2659 = resolvedFile;
                  var v26803 = JAM.call(ioHost$$1.readFile, ioHost$$1, [normalizedPath]);
                  v2659.content = v26803
                }
              }
            }
            var v2660 = TypeScript$$28.CompilerDiagnostics;
            JAM.call(v2660.debugPrint, v2660, ["   Found code at " + normalizedPath]);
            resolvedFile.path = normalizedPath;
            JAM.set(this.visited, absoluteModuleID, true)
          }catch(err$$3) {
            var v2663 = TypeScript$$28.CompilerDiagnostics;
            JAM.call(v2663.debugPrint, v2663, ["   Did not find code for " + referencePath])
          }
        }else {
          resolvedFile = JAM.call(ioHost$$1.findFile, ioHost$$1, [parentPath, normalizedPath]);
          if(!resolvedFile) {
            if(JAM.call(TypeScript$$28.isSTRFile, TypeScript$$28, [normalizedPath])) {
              normalizedPath = JAM.call(TypeScript$$28.changePathToTS, TypeScript$$28, [normalizedPath])
            }else {
              if(JAM.call(TypeScript$$28.isTSFile, TypeScript$$28, [normalizedPath])) {
                normalizedPath = JAM.call(TypeScript$$28.changePathToSTR, TypeScript$$28, [normalizedPath])
              }
            }
            resolvedFile = JAM.call(ioHost$$1.findFile, ioHost$$1, [parentPath, normalizedPath])
          }
          if(!resolvedFile) {
            normalizedPath = JAM.call(TypeScript$$28.changePathToDTS, TypeScript$$28, [normalizedPath]);
            resolvedFile = JAM.call(ioHost$$1.findFile, ioHost$$1, [parentPath, normalizedPath]);
            if(!resolvedFile) {
              normalizedPath = JAM.call(TypeScript$$28.changePathToDSTR, TypeScript$$28, [normalizedPath]);
              resolvedFile = JAM.call(ioHost$$1.findFile, ioHost$$1, [parentPath, normalizedPath])
            }
          }
          if(resolvedFile) {
            var v2670 = resolvedFile;
            var v26804 = JAM.call(TypeScript$$28.switchToForwardSlashes, TypeScript$$28, [JAM.call(TypeScript$$28.stripQuotes, TypeScript$$28, [resolvedFile.path])]);
            v2670.path = v26804;
            var v2671 = TypeScript$$28.CompilerDiagnostics;
            JAM.call(v2671.debugPrint, v2671, [referencePath + " resolved to: " + resolvedFile.path]);
            resolvedFile.content = resolvedFile.content;
            JAM.set(this.visited, absoluteModuleID, true)
          }else {
            var v2674 = TypeScript$$28.CompilerDiagnostics;
            JAM.call(v2674.debugPrint, v2674, ["Could not find " + referencePath])
          }
        }
        var v12985 = resolvedFile;
        if(v12985) {
          v12985 = resolvedFile.content
        }
        if(v12985) {
          var rootDir = JAM.call(ioHost$$1.dirName, ioHost$$1, [resolvedFile.path]);
          var sourceUnit = JAM.new(SourceUnit, [resolvedFile.path, resolvedFile.content]);
          var preProcessedFileInfo = JAM.call(TypeScript$$28.preProcessFile, TypeScript$$28, [sourceUnit, this.environment.compilationSettings]);
          sourceUnit.referencedFiles = preProcessedFileInfo.referencedFiles;
          var i$$116 = 0;
          var v2685 = i$$116 < preProcessedFileInfo.referencedFiles.length;
          for(;v2685;) {
            var v2681 = preProcessedFileInfo.referencedFiles;
            introspect(JAM.policy.p1) {
              var referencedFile = v2681[i$$116]
            }
            var v2682;
            if(JAM.call(TypeScript$$28.isRooted, TypeScript$$28, [referencedFile.path])) {
              v2682 = referencedFile.path
            }else {
              v2682 = rootDir + "/" + referencedFile.path
            }
            normalizedPath = v2682;
            normalizedPath = JAM.call(ioHost$$1.resolvePath, ioHost$$1, [normalizedPath]);
            if(referencePath == normalizedPath) {
              JAM.call(resolutionDispatcher.postResolutionError, resolutionDispatcher, [normalizedPath, "File contains reference to itself", null]);
              i$$116 = i$$116 + 1;
              v2685 = i$$116 < preProcessedFileInfo.referencedFiles.length;
              continue
            }
            JAM.call(this.resolveCode, this, [referencedFile.path, rootDir, false, resolutionDispatcher]);
            i$$116 = i$$116 + 1;
            v2685 = i$$116 < preProcessedFileInfo.referencedFiles.length
          }
          i$$116 = 0;
          var v2687 = i$$116 < preProcessedFileInfo.importedFiles.length;
          for(;v2687;) {
            var v19117 = preProcessedFileInfo.importedFiles;
            introspect(JAM.policy.p1) {
              var v12994 = v19117[i$$116]
            }
            JAM.call(this.resolveCode, this, [v12994.path, rootDir, true, resolutionDispatcher]);
            i$$116 = i$$116 + 1;
            v2687 = i$$116 < preProcessedFileInfo.importedFiles.length
          }
          JAM.call(resolutionDispatcher.postResolution, resolutionDispatcher, [sourceUnit.path, sourceUnit])
        }
      }
      return
    }
    function CodeResolver$$1(environment) {
      this.environment = environment;
      this.visited = {};
      return
    }
    CodeResolver$$1.prototype.resolveCode = v1178;
    return CodeResolver$$1
  }
  function v1177() {
    function CompilationEnvironment$$1(compilationSettings, ioHost) {
      this.compilationSettings = compilationSettings;
      this.ioHost = ioHost;
      this.residentCode = [];
      this.code = [];
      return
    }
    return CompilationEnvironment$$1
  }
  function v1176() {
    function v1175() {
      return this.content.length
    }
    function v1174(start$$12, end$$6) {
      var v2693 = this.content;
      return JAM.call(v2693.substring, v2693, [start$$12, end$$6])
    }
    function SourceUnit$$1(path$$16, content$$5) {
      this.path = path$$16;
      this.content = content$$5;
      this.referencedFiles = null;
      return
    }
    SourceUnit$$1.prototype.getText = v1174;
    SourceUnit$$1.prototype.getLength = v1175;
    return SourceUnit$$1
  }
  var SourceUnit = v1176();
  TypeScript$$28.SourceUnit = SourceUnit;
  var CompilationEnvironment = v1177();
  TypeScript$$28.CompilationEnvironment = CompilationEnvironment;
  var CodeResolver = v1179();
  TypeScript$$28.CodeResolver = CodeResolver;
  return
}
function v1173(TypeScript$$27) {
  function stripQuotes(str$$7) {
    return str$$7.replace('"', "").replace("'", "").replace("'", "").replace('"', "")
  }
  function isQuoted(str$$8) {
    var v2697 = str$$8.indexOf('"') != -1;
    if(!v2697) {
      var v12998 = str$$8.indexOf("'") != -1;
      if(!v12998) {
        var v19121 = str$$8.indexOf("'") != -1;
        if(!v19121) {
          v19121 = str$$8.indexOf('"') != -1
        }
        v12998 = v19121
      }
      v2697 = v12998
    }
    return v2697
  }
  function quoteStr(str$$9) {
    return'"' + str$$9 + '"'
  }
  function swapQuotes(str$$10) {
    if(str$$10.indexOf('"') != -1) {
      str$$10 = str$$10.replace('"', "'");
      str$$10 = str$$10.replace('"', "'")
    }else {
      str$$10 = str$$10.replace("'", '"');
      str$$10 = str$$10.replace("'", '"')
    }
    return str$$10
  }
  function switchToForwardSlashes(path$$8) {
    return path$$8.replace(/\\/g, "/")
  }
  function trimModName(modName$$4) {
    var v13001 = modName$$4.length > 6;
    if(v13001) {
      v13001 = JAM.call(modName$$4.substring, modName$$4, [modName$$4.length - 6, modName$$4.length]) == ".d.str"
    }
    if(v13001) {
      return JAM.call(modName$$4.substring, modName$$4, [0, modName$$4.length - 6])
    }
    var v13003 = modName$$4.length > 4;
    if(v13003) {
      v13003 = JAM.call(modName$$4.substring, modName$$4, [modName$$4.length - 4, modName$$4.length]) == ".str"
    }
    if(v13003) {
      return JAM.call(modName$$4.substring, modName$$4, [0, modName$$4.length - 4])
    }
    var v13005 = modName$$4.length > 5;
    if(v13005) {
      v13005 = JAM.call(modName$$4.substring, modName$$4, [modName$$4.length - 5, modName$$4.length]) == ".d.ts"
    }
    if(v13005) {
      return JAM.call(modName$$4.substring, modName$$4, [0, modName$$4.length - 5])
    }
    var v13007 = modName$$4.length > 3;
    if(v13007) {
      v13007 = JAM.call(modName$$4.substring, modName$$4, [modName$$4.length - 3, modName$$4.length]) == ".ts"
    }
    if(v13007) {
      return JAM.call(modName$$4.substring, modName$$4, [0, modName$$4.length - 3])
    }
    var v13009 = modName$$4.length > 3;
    if(v13009) {
      v13009 = JAM.call(modName$$4.substring, modName$$4, [modName$$4.length - 3, modName$$4.length]) == ".js"
    }
    if(v13009) {
      return JAM.call(modName$$4.substring, modName$$4, [0, modName$$4.length - 3])
    }
    return modName$$4
  }
  function getDeclareFilePath(fname) {
    var v2710;
    if(isSTRFile(fname)) {
      v2710 = changePathToDSTR(fname)
    }else {
      var v13011;
      if(isTSFile(fname)) {
        v13011 = changePathToDTS(fname)
      }else {
        v13011 = changePathToDTS(fname)
      }
      v2710 = v13011
    }
    return v2710
  }
  function isFileOfExtension(fname$$1, ext) {
    var invariantFname = fname$$1.toLocaleUpperCase();
    var invariantExt = ext.toLocaleUpperCase();
    var extLength = invariantExt.length;
    var v2711 = invariantFname.length > extLength;
    if(v2711) {
      v2711 = JAM.call(invariantFname.substring, invariantFname, [invariantFname.length - extLength, invariantFname.length]) == invariantExt
    }
    return v2711
  }
  function isJSFile(fname$$2) {
    return isFileOfExtension(fname$$2, ".js")
  }
  function isSTRFile(fname$$3) {
    return isFileOfExtension(fname$$3, ".str")
  }
  function isTSFile(fname$$4) {
    return isFileOfExtension(fname$$4, ".ts")
  }
  function isDSTRFile(fname$$5) {
    return isFileOfExtension(fname$$5, ".d.str")
  }
  function isDTSFile(fname$$6) {
    return isFileOfExtension(fname$$6, ".d.ts")
  }
  function getPrettyName(modPath$$3, quote$$1, treatAsFileName) {
    if(typeof quote$$1 === "undefined") {
      quote$$1 = true
    }
    if(typeof treatAsFileName === "undefined") {
      treatAsFileName = false
    }
    var v2714;
    if(treatAsFileName) {
      v2714 = switchToForwardSlashes(modPath$$3)
    }else {
      v2714 = trimModName(stripQuotes(modPath$$3))
    }
    var modName$$5 = v2714;
    var components = JAM.call(this.getPathComponents, this, [modName$$5]);
    var v2715;
    if(components.length) {
      var v13018;
      if(quote$$1) {
        var v22948 = components.length - 1;
        introspect(JAM.policy.p1) {
          var v19136 = components[v22948]
        }
        v13018 = quoteStr(v19136)
      }else {
        v13018 = components[components.length - 1]
      }
      v2715 = v13018
    }else {
      v2715 = modPath$$3
    }
    return v2715
  }
  function getPathComponents(path$$9) {
    return path$$9.split("/")
  }
  function getRelativePathToFixedPath(fixedModFilePath, absoluteModPath) {
    absoluteModPath = switchToForwardSlashes(absoluteModPath);
    var modComponents = JAM.call(this.getPathComponents, this, [absoluteModPath]);
    var fixedModComponents = JAM.call(this.getPathComponents, this, [fixedModFilePath]);
    var joinStartIndex = 0;
    var v13020 = joinStartIndex < modComponents.length;
    if(v13020) {
      v13020 = joinStartIndex < fixedModComponents.length
    }
    var v2717 = v13020;
    for(;v2717;) {
      introspect(JAM.policy.p1) {
        var v13021 = fixedModComponents[joinStartIndex]
      }
      introspect(JAM.policy.p1) {
        var v13022 = modComponents[joinStartIndex]
      }
      if(v13021 != v13022) {
        break
      }
      joinStartIndex = joinStartIndex + 1;
      var v13023 = joinStartIndex < modComponents.length;
      if(v13023) {
        v13023 = joinStartIndex < fixedModComponents.length
      }
      v2717 = v13023
    }
    if(joinStartIndex != 0) {
      var relativePath = "";
      var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);
      var v2720 = joinStartIndex < fixedModComponents.length;
      for(;v2720;) {
        introspect(JAM.policy.p1) {
          var v13025 = fixedModComponents[joinStartIndex]
        }
        if(v13025 != "") {
          relativePath = relativePath + "../"
        }
        joinStartIndex = joinStartIndex + 1;
        v2720 = joinStartIndex < fixedModComponents.length
      }
      return relativePath + relativePathComponents.join("/")
    }
    return absoluteModPath
  }
  function quoteBaseName(modPath$$4) {
    var modName$$6 = trimModName(stripQuotes(modPath$$4));
    var path$$10 = getRootFilePath(modName$$6);
    if(path$$10 == "") {
      return modPath$$4
    }else {
      var components$$1 = modName$$6.split(path$$10);
      var v2725;
      if(components$$1.length > 1) {
        v2725 = 1
      }else {
        v2725 = 0
      }
      var fileIndex = v2725;
      introspect(JAM.policy.p1) {
        var v2726 = components$$1[fileIndex]
      }
      return quoteStr(v2726)
    }
    return
  }
  function changePathToSTR(modPath$$5) {
    return trimModName(stripQuotes(modPath$$5)) + ".str"
  }
  function changePathToDSTR(modPath$$6) {
    return trimModName(stripQuotes(modPath$$6)) + ".d.str"
  }
  function changePathToTS(modPath$$7) {
    return trimModName(stripQuotes(modPath$$7)) + ".ts"
  }
  function changePathToDTS(modPath$$8) {
    return trimModName(stripQuotes(modPath$$8)) + ".d.ts"
  }
  function isRelative(path$$11) {
    return path$$11.charAt(0) == "."
  }
  function isRooted(path$$12) {
    var v2733 = path$$12.charAt(0) == "\\";
    if(!v2733) {
      var v13033 = path$$12.charAt(0) == "/";
      if(!v13033) {
        var v19144 = path$$12.indexOf(":\\") != -1;
        if(!v19144) {
          v19144 = path$$12.indexOf(":/") != -1
        }
        v13033 = v19144
      }
      v2733 = v13033
    }
    return v2733
  }
  function getRootFilePath(outFname) {
    if(outFname == "") {
      return outFname
    }else {
      var isPath = outFname.indexOf("/") != -1;
      var v2735;
      if(isPath) {
        v2735 = filePath(outFname)
      }else {
        v2735 = ""
      }
      return v2735
    }
    return
  }
  function filePathComponents(fullPath) {
    fullPath = switchToForwardSlashes(fullPath);
    var components$$2 = getPathComponents(fullPath);
    return components$$2.slice(0, components$$2.length - 1)
  }
  function filePath(fullPath$$1) {
    var path$$13 = filePathComponents(fullPath$$1);
    return path$$13.join("/") + "/"
  }
  function normalizeURL(url$$3) {
    var hostDomainAndPortRegex = /^(https?:\/\/[\-\w\.]+(:\d+)?\/)(.*)$/i;
    var matches = JAM.call(hostDomainAndPortRegex.exec, hostDomainAndPortRegex, [url$$3]);
    if(matches) {
      var hostDomainAndPort = matches[1];
      var actualPath = matches[3];
      return hostDomainAndPort + normalizePath(actualPath)
    }
    return normalizePath(url$$3)
  }
  function normalizePath(path$$14) {
    path$$14 = switchToForwardSlashes(path$$14);
    var startedWithSep = path$$14.charAt(0) === "/";
    var parts = JAM.call(this.getPathComponents, this, [path$$14]);
    var i$$115 = 0;
    var v2745 = i$$115 < parts.length;
    for(;v2745;) {
      introspect(JAM.policy.p1) {
        var v19146 = parts[i$$115]
      }
      var v13037 = v19146 === ".";
      if(!v13037) {
        introspect(JAM.policy.p1) {
          var v19147 = parts[i$$115]
        }
        v13037 = v19147 === ""
      }
      if(v13037) {
        parts.splice(i$$115, 1);
        i$$115 = i$$115 - 1
      }
      var v13038 = i$$115 > 0;
      if(v13038) {
        introspect(JAM.policy.p1) {
          var v22953 = parts[i$$115]
        }
        var v19149 = v22953 === "..";
        if(v19149) {
          var v24826 = i$$115 - 1;
          introspect(JAM.policy.p1) {
            var v22954 = parts[v24826]
          }
          v19149 = v22954 !== ".."
        }
        v13038 = v19149
      }
      if(v13038) {
        parts.splice(i$$115 - 1, 2);
        i$$115 = i$$115 - 2
      }
      i$$115 = i$$115 + 1;
      v2745 = i$$115 < parts.length
    }
    var v13040;
    if(startedWithSep) {
      v13040 = "/"
    }else {
      v13040 = ""
    }
    return v13040 + parts.join("/")
  }
  function normalizeImportPath(path$$15) {
    return normalizePath(path$$15)
  }
  TypeScript$$27.stripQuotes = stripQuotes;
  TypeScript$$27.isQuoted = isQuoted;
  TypeScript$$27.quoteStr = quoteStr;
  TypeScript$$27.swapQuotes = swapQuotes;
  TypeScript$$27.switchToForwardSlashes = switchToForwardSlashes;
  TypeScript$$27.trimModName = trimModName;
  TypeScript$$27.getDeclareFilePath = getDeclareFilePath;
  TypeScript$$27.isJSFile = isJSFile;
  TypeScript$$27.isSTRFile = isSTRFile;
  TypeScript$$27.isTSFile = isTSFile;
  TypeScript$$27.isDSTRFile = isDSTRFile;
  TypeScript$$27.isDTSFile = isDTSFile;
  TypeScript$$27.getPrettyName = getPrettyName;
  TypeScript$$27.getPathComponents = getPathComponents;
  TypeScript$$27.getRelativePathToFixedPath = getRelativePathToFixedPath;
  TypeScript$$27.quoteBaseName = quoteBaseName;
  TypeScript$$27.changePathToSTR = changePathToSTR;
  TypeScript$$27.changePathToDSTR = changePathToDSTR;
  TypeScript$$27.changePathToTS = changePathToTS;
  TypeScript$$27.changePathToDTS = changePathToDTS;
  TypeScript$$27.isRelative = isRelative;
  TypeScript$$27.isRooted = isRooted;
  TypeScript$$27.getRootFilePath = getRootFilePath;
  TypeScript$$27.filePathComponents = filePathComponents;
  TypeScript$$27.filePath = filePath;
  TypeScript$$27.normalizeURL = normalizeURL;
  TypeScript$$27.pathNormalizeRegExp = /\//g;
  TypeScript$$27.normalizePath = normalizePath;
  TypeScript$$27.normalizeImportPath = normalizeImportPath;
  return
}
function v1172(TypeScript$$26) {
  function v1171() {
    function TypeLink$$1() {
      this.type = null;
      this.ast = null;
      return
    }
    return TypeLink$$1
  }
  function v1170(_super$$67) {
    function v1169(moduleType$$2) {
      var moduleName$$2 = null;
      moduleName$$2 = JAM.call(ModuleType$$1.findDynamicModuleNameInHashTable, ModuleType$$1, [moduleType$$2, this.members.allMembers]);
      if(moduleName$$2 == null) {
        moduleName$$2 = JAM.call(ModuleType$$1.findDynamicModuleNameInHashTable, ModuleType$$1, [moduleType$$2, this.ambientMembers.allMembers])
      }
      return moduleName$$2
    }
    function findDynamicModuleNameInHashTable(moduleType$$1, members$$27) {
      function v1168(key$$51, s$$34, c$$13) {
        var v13043 = moduleName$$1 == null;
        if(v13043) {
          v13043 = !JAM.call(TypeScript$$26.isQuoted, TypeScript$$26, [key$$51])
        }
        if(v13043) {
          var symbol$$22 = s$$34;
          var type$$57 = symbol$$22.getType();
          if(type$$57 == moduleType$$1) {
            moduleName$$1 = {name:key$$51, symbol:symbol$$22}
          }
        }
        return
      }
      var moduleName$$1 = null;
      JAM.call(members$$27.map, members$$27, [v1168, null]);
      return moduleName$$1
    }
    function v1167() {
      return null
    }
    function v1166() {
      return null
    }
    function v1165() {
      return this.ambientEnclosedTypes
    }
    function v1164() {
      return this.enclosedTypes
    }
    function v1163() {
      var v2753 = this.members != null;
      if(!v2753) {
        v2753 = this.enclosedTypes != null
      }
      return v2753
    }
    function v1162() {
      return true
    }
    function ModuleType$$1(enclosedTypes$$4, ambientEnclosedTypes$$4) {
      JAM.call(_super$$67.call, _super$$67, [this]);
      this.enclosedTypes = enclosedTypes$$4;
      this.ambientEnclosedTypes = ambientEnclosedTypes$$4;
      this.importedModules = [];
      return
    }
    JAM.call(__extends, null, [ModuleType$$1, _super$$67]);
    ModuleType$$1.prototype.isModuleType = v1162;
    ModuleType$$1.prototype.hasMembers = v1163;
    ModuleType$$1.prototype.getAllEnclosedTypes = v1164;
    ModuleType$$1.prototype.getAllAmbientEnclosedTypes = v1165;
    ModuleType$$1.prototype.getPublicEnclosedTypes = v1166;
    ModuleType$$1.prototype.getpublicAmbientEnclosedTypes = v1167;
    ModuleType$$1.findDynamicModuleNameInHashTable = findDynamicModuleNameInHashTable;
    ModuleType$$1.prototype.findDynamicModuleName = v1169;
    return ModuleType$$1
  }
  function v1161() {
    function v1160() {
      var v13047 = this.elementType;
      if(!v13047) {
        v13047 = !this.symbol
      }
      if(v13047) {
        return[]
      }
      var v13048 = this.isClassInstance();
      if(!v13048) {
        v13048 = this.isClass()
      }
      if(v13048) {
        if(this.symbol.declAST.nodeType == TypeScript$$26.NodeType.FuncDecl) {
          return this.symbol.declAST.classDecl.getDocComments()
        }else {
          return this.symbol.getDocComments()
        }
      }
      var v13052 = this.symbol.name;
      if(v13052) {
        var v19158 = this.symbol.name != "_anonymous";
        if(v19158) {
          var v24828 = this.call == null;
          if(v24828) {
            var v25757 = this.construct == null;
            if(v25757) {
              v25757 = this.index == null
            }
            v24828 = v25757
          }
          var v22957 = v24828;
          if(!v22957) {
            v22957 = this.members
          }
          v19158 = v22957
        }
        v13052 = v19158
      }
      if(v13052) {
        return this.symbol.getDocComments()
      }
      return[]
    }
    function v1159() {
      return null
    }
    function v1158() {
      return null
    }
    function v1157() {
      return null
    }
    function v1156() {
      return null
    }
    function v1155() {
      return this.members != null
    }
    function v1154() {
      return false
    }
    function v1153(b$$14, checker$$22, acceptVoid$$1, comparisonInfo$$17) {
      var v13053 = this == checker$$22.anyType;
      if(!v13053) {
        v13053 = b$$14 == checker$$22.anyType
      }
      if(v13053) {
        return checker$$22.anyType
      }else {
        if(this == b$$14) {
          return this
        }else {
          var v13054 = b$$14 == checker$$22.nullType;
          if(v13054) {
            v13054 = this != checker$$22.nullType
          }
          if(v13054) {
            return this
          }else {
            var v13055 = this == checker$$22.nullType;
            if(v13055) {
              v13055 = b$$14 != checker$$22.nullType
            }
            if(v13055) {
              return b$$14
            }else {
              var v13056 = acceptVoid$$1;
              if(v13056) {
                var v19166 = b$$14 == checker$$22.voidType;
                if(v19166) {
                  v19166 = this != checker$$22.voidType
                }
                v13056 = v19166
              }
              if(v13056) {
                return this
              }else {
                var v13057 = acceptVoid$$1;
                if(v13057) {
                  var v19167 = this == checker$$22.voidType;
                  if(v19167) {
                    v19167 = b$$14 != checker$$22.voidType
                  }
                  v13057 = v19167
                }
                if(v13057) {
                  return b$$14
                }else {
                  var v13058 = b$$14 == checker$$22.undefinedType;
                  if(v13058) {
                    v13058 = this != checker$$22.undefinedType
                  }
                  if(v13058) {
                    return this
                  }else {
                    var v13059 = this == checker$$22.undefinedType;
                    if(v13059) {
                      v13059 = b$$14 != checker$$22.undefinedType
                    }
                    if(v13059) {
                      return b$$14
                    }else {
                      var v13060 = this.elementType;
                      if(v13060) {
                        v13060 = b$$14.elementType
                      }
                      if(v13060) {
                        if(this.elementType == b$$14.elementType) {
                          return this
                        }else {
                          var v2769 = this.elementType;
                          var mergedET = JAM.call(v2769.mergeOrdered, v2769, [b$$14.elementType, checker$$22, acceptVoid$$1, comparisonInfo$$17]);
                          if(mergedET == null) {
                            return JAM.call(checker$$22.makeArrayType, checker$$22, [checker$$22.anyType])
                          }else {
                            return JAM.call(checker$$22.makeArrayType, checker$$22, [mergedET])
                          }
                        }
                      }else {
                        if(JAM.call(checker$$22.sourceIsSubtypeOfTarget, checker$$22, [this, b$$14, comparisonInfo$$17])) {
                          return b$$14
                        }else {
                          if(JAM.call(checker$$22.sourceIsSubtypeOfTarget, checker$$22, [b$$14, this, comparisonInfo$$17])) {
                            return this
                          }else {
                            return null
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return
    }
    function v1152(baseType) {
      if(baseType == this) {
        return true
      }else {
        if(this.extendsList) {
          var i$$114 = 0;
          var len$$56 = this.extendsList.length;
          var v2787 = i$$114 < len$$56;
          for(;v2787;) {
            var v19172 = this.extendsList;
            introspect(JAM.policy.p1) {
              var v13063 = v19172[i$$114]
            }
            if(JAM.call(v13063.hasBase, v13063, [baseType])) {
              return true
            }
            i$$114 = i$$114 + 1;
            v2787 = i$$114 < len$$56
          }
        }
      }
      return false
    }
    function v1151(pattern$$8, replacement$$6, checker$$21, membersOnly) {
      function v1150(key$$50, s$$33, unused$$5) {
        var sym$$48 = s$$33;
        var bSym$$4 = JAM.call(sym$$48.specializeType, sym$$48, [pattern$$8, replacement$$6, checker$$21]);
        var v2790 = result$$33.ambientMembers;
        JAM.call(v2790.addPrivateMember, v2790, [bSym$$4.name, bSym$$4]);
        return
      }
      function v1149(key$$49, s$$32, unused$$4) {
        var sym$$47 = s$$32;
        var bSym$$3 = JAM.call(sym$$47.specializeType, sym$$47, [pattern$$8, replacement$$6, checker$$21]);
        var v2792 = result$$33.ambientMembers;
        JAM.call(v2792.addPublicMember, v2792, [bSym$$3.name, bSym$$3]);
        return
      }
      function v1148(key$$48, s$$31, unused$$3) {
        var sym$$46 = s$$31;
        var bSym$$2 = JAM.call(sym$$46.specializeType, sym$$46, [pattern$$8, replacement$$6, checker$$21]);
        var v2794 = result$$33.members;
        JAM.call(v2794.addPrivateMember, v2794, [bSym$$2.name, bSym$$2]);
        return
      }
      function v1147(key$$47, s$$30, unused$$2) {
        var sym$$45 = s$$30;
        var bSym$$1 = JAM.call(sym$$45.specializeType, sym$$45, [pattern$$8, replacement$$6, checker$$21]);
        var v2796 = result$$33.members;
        JAM.call(v2796.addPublicMember, v2796, [bSym$$1.name, bSym$$1]);
        return
      }
      if(pattern$$8 == this) {
        return replacement$$6
      }
      var result$$33 = this;
      if(membersOnly) {
        if(this.isReferenceType()) {
          result$$33 = new Type$$1;
          if(this.members) {
            var v2799 = result$$33;
            var v26805 = JAM.new(TypeScript$$26.ScopedMembers, [JAM.new(TypeScript$$26.DualStringHashTable, [new TypeScript$$26.StringHashTable, new TypeScript$$26.StringHashTable])]);
            v2799.members = v26805;
            var v2800 = this.members.publicMembers;
            JAM.call(v2800.map, v2800, [v1147, null]);
            var v2801 = this.members.privateMembers;
            JAM.call(v2801.map, v2801, [v1148, null])
          }
          if(this.ambientMembers) {
            var v2803 = result$$33;
            var v26806 = JAM.new(TypeScript$$26.ScopedMembers, [JAM.new(TypeScript$$26.DualStringHashTable, [new TypeScript$$26.StringHashTable, new TypeScript$$26.StringHashTable])]);
            v2803.ambientMembers = v26806;
            var v2804 = this.ambientMembers.publicMembers;
            JAM.call(v2804.map, v2804, [v1149, null]);
            var v2805 = this.ambientMembers.privateMembers;
            JAM.call(v2805.map, v2805, [v1150, null])
          }
          var v2807 = result$$33;
          var v26807 = JAM.call(checker$$21.scopeOf, checker$$21, [result$$33]);
          v2807.containedScope = v26807;
          result$$33.memberScope = result$$33.containedScope
        }
      }else {
        if(this.elementType) {
          if(this.elementType == pattern$$8) {
            result$$33 = JAM.call(checker$$21.makeArrayType, checker$$21, [replacement$$6])
          }else {
            if(this.elementType.elementType == pattern$$8) {
              result$$33 = JAM.call(checker$$21.makeArrayType, checker$$21, [JAM.call(checker$$21.makeArrayType, checker$$21, [replacement$$6])])
            }
          }
        }else {
          if(this.call) {
            result$$33 = new Type$$1;
            var v2812 = result$$33;
            var v13074 = this.call;
            var v26808 = JAM.call(v13074.specializeType, v13074, [pattern$$8, replacement$$6, checker$$21]);
            v2812.call = v26808
          }
        }
      }
      return result$$33
    }
    function v1146() {
      var v2815 = this.members;
      if(!v2815) {
        var v13075 = this.extendsList;
        if(!v13075) {
          var v19180 = this.construct;
          if(!v19180) {
            var v22966 = this.call;
            if(!v22966) {
              var v24830 = this.index;
              if(!v24830) {
                v24830 = this.elementType
              }
              v22966 = v24830
            }
            v19180 = v22966
          }
          v13075 = v19180
        }
        v2815 = v13075
      }
      return v2815
    }
    function v1145(flow$$1) {
      if(this == flow$$1.anyType) {
        return null
      }else {
        if(this.isDouble()) {
          if(flow$$1.numberInterfaceType) {
            return flow$$1.numberInterfaceType.memberScope
          }else {
            return null
          }
        }else {
          if(this.isBoolean()) {
            if(flow$$1.booleanInterfaceType) {
              return flow$$1.booleanInterfaceType.memberScope
            }else {
              return null
            }
          }else {
            if(this == flow$$1.stringType) {
              if(flow$$1.stringInterfaceType) {
                return flow$$1.stringInterfaceType.memberScope
              }else {
                return null
              }
            }else {
              if(this.elementType) {
                if(flow$$1.arrayInterfaceType) {
                  var v2822 = this.elementType;
                  var arrInstType$$3 = JAM.call(v2822.getArrayBase, v2822, [flow$$1.arrayInterfaceType, flow$$1.checker]);
                  return arrInstType$$3.memberScope
                }else {
                  return null
                }
              }else {
                return this.memberScope
              }
            }
          }
        }
      }
      return
    }
    function v1144(checker$$20) {
      var v13079 = this.isClassInstance();
      if(!v13079) {
        v13079 = this.isClass()
      }
      if(v13079) {
        if(this.symbol.declAST) {
          var v2831 = checker$$20.typeFlow;
          JAM.call(v2831.inScopeTypeCheckDecl, v2831, [this.symbol.declAST])
        }
      }
      return
    }
    function v1143(prefix$$5, topLevel$$1, isElementType$$1, scope$$34) {
      function v1142(key$$46, s$$29, unused$$1) {
        var sym$$44 = s$$29;
        if(!JAM.call(TypeScript$$26.hasFlag, TypeScript$$26, [sym$$44.flags, TypeScript$$26.SymbolFlags.BuiltIn])) {
          var typeNameMember = JAM.call(sym$$44.getTypeNameEx, sym$$44, [scope$$34]);
          var v13083 = typeNameMember.isArray();
          if(v13083) {
            v13083 = typeNameMember.delim == delim
          }
          if(v13083) {
            JAM.call(allMemberNames.addAll, allMemberNames, [typeNameMember.entries])
          }else {
            JAM.call(allMemberNames.add, allMemberNames, [typeNameMember])
          }
          memCount = memCount + 1;
          curlies$$1 = true
        }
        return
      }
      if(this.elementType) {
        var v13084 = this.elementType;
        return JAM.call(MemberName.create, MemberName, [JAM.call(v13084.getMemberTypeNameEx, v13084, [prefix$$5, false, true, scope$$34]), "", "[]"])
      }else {
        var v13085 = this.symbol;
        if(v13085) {
          var v19186 = this.symbol.name;
          if(v19186) {
            var v22970 = this.symbol.name != "_anonymous";
            if(v22970) {
              var v25760 = this.call == null;
              if(v25760) {
                var v26264 = this.construct == null;
                if(v26264) {
                  v26264 = this.index == null
                }
                v25760 = v26264
              }
              var v24833 = v25760;
              if(!v24833) {
                var v25761 = JAM.call(TypeScript$$26.hasFlag, TypeScript$$26, [this.typeFlags, TypeScript$$26.TypeFlags.BuildingName]);
                if(!v25761) {
                  var v26267 = this.members;
                  if(v26267) {
                    v26267 = !this.isClass()
                  }
                  v25761 = v26267
                }
                v24833 = v25761
              }
              v22970 = v24833
            }
            v19186 = v22970
          }
          v13085 = v19186
        }
        if(v13085) {
          var v2839 = this.symbol;
          var tn = JAM.call(v2839.scopeRelativeName, v2839, [scope$$34]);
          var v13086;
          if(tn == "null") {
            v13086 = "any"
          }else {
            v13086 = tn
          }
          return JAM.call(MemberName.create, MemberName, [v13086])
        }else {
          var v13087 = this.members;
          if(!v13087) {
            var v19188 = this.call;
            if(!v19188) {
              v19188 = this.construct
            }
            v13087 = v19188
          }
          if(v13087) {
            if(JAM.call(TypeScript$$26.hasFlag, TypeScript$$26, [this.typeFlags, TypeScript$$26.TypeFlags.BuildingName])) {
              return JAM.call(MemberName.create, MemberName, ["this"])
            }
            this.typeFlags = this.typeFlags | TypeScript$$26.TypeFlags.BuildingName;
            var builder$$5 = "";
            var allMemberNames = new MemberNameArray;
            var v2842 = isElementType$$1;
            if(!v2842) {
              v2842 = this.index != null
            }
            var curlies$$1 = v2842;
            var memCount = 0;
            var delim = "; ";
            if(this.members) {
              var v2843 = this.members.allMembers;
              JAM.call(v2843.map, v2843, [v1142, null])
            }
            var signatureCount = this.callCount();
            var j$$18;
            var len$$55 = 0;
            var v2845 = !curlies$$1;
            if(v2845) {
              var v13095 = signatureCount == 1;
              if(v13095) {
                v13095 = topLevel$$1
              }
              v2845 = v13095
            }
            var shortform$$3 = v2845;
            if(this.call) {
              var v13096 = this.call;
              JAM.call(allMemberNames.addAll, allMemberNames, [JAM.call(v13096.toStrings, v13096, [prefix$$5, shortform$$3, scope$$34])])
            }
            if(this.construct) {
              var v13097 = this.construct;
              JAM.call(allMemberNames.addAll, allMemberNames, [JAM.call(v13097.toStrings, v13097, ["new", shortform$$3, scope$$34])])
            }
            if(this.index) {
              var v13098 = this.index;
              JAM.call(allMemberNames.addAll, allMemberNames, [JAM.call(v13098.toStrings, v13098, ["", shortform$$3, scope$$34])])
            }
            var v13099 = curlies$$1;
            if(!v13099) {
              var v19192 = signatureCount > 1;
              if(v19192) {
                v19192 = topLevel$$1
              }
              v13099 = v19192
            }
            if(v13099) {
              allMemberNames.prefix = "{ ";
              allMemberNames.suffix = "}";
              allMemberNames.delim = delim
            }else {
              if(allMemberNames.entries.length > 1) {
                allMemberNames.delim = delim
              }
            }
            this.typeFlags = this.typeFlags & ~TypeScript$$26.TypeFlags.BuildingName;
            var v13103 = signatureCount == 0;
            if(v13103) {
              v13103 = memCount == 0
            }
            if(v13103) {
              return JAM.call(MemberName.create, MemberName, ["{}"])
            }else {
              return allMemberNames
            }
          }else {
            return JAM.call(MemberName.create, MemberName, ["{}"])
          }
        }
      }
      return
    }
    function v1141(prefix$$4, topLevel, isElementType, scope$$33) {
      var memberName$$4 = JAM.call(this.getMemberTypeNameEx, this, [prefix$$4, topLevel, isElementType, scope$$33]);
      return memberName$$4.toString()
    }
    function v1140() {
      var total = 0;
      if(this.call) {
        total = total + this.call.signatures.length
      }
      if(this.construct) {
        total = total + this.construct.signatures.length
      }
      if(this.index) {
        total = total + this.index.signatures.length
      }
      return total
    }
    function v1139(scope$$32) {
      return JAM.call(this.getMemberTypeNameEx, this, ["", true, false, scope$$32])
    }
    function v1138(scope$$31) {
      return JAM.call(this.getMemberTypeName, this, ["", true, false, scope$$31])
    }
    function v1137() {
      return JAM.call(this.getMemberTypeName, this, ["", true, false, null])
    }
    function v1136() {
      return JAM.call(TypeScript$$26.hasFlag, TypeScript$$26, [this.primitiveTypeClass, Primitive.Null])
    }
    function v1135() {
      return JAM.call(TypeScript$$26.hasFlag, TypeScript$$26, [this.primitiveTypeClass, Primitive.Boolean])
    }
    function v1134() {
      return JAM.call(TypeScript$$26.hasFlag, TypeScript$$26, [this.primitiveTypeClass, Primitive.String])
    }
    function v1133() {
      return JAM.call(TypeScript$$26.hasFlag, TypeScript$$26, [this.primitiveTypeClass, Primitive.Double])
    }
    function v1132() {
      this.typeFlags = this.typeFlags | TypeScript$$26.TypeFlags.HasImplementation;
      return
    }
    function v1131() {
      return JAM.call(TypeScript$$26.hasFlag, TypeScript$$26, [this.typeFlags, TypeScript$$26.TypeFlags.HasImplementation])
    }
    function v1130() {
      if(this.isClass()) {
        return this.instanceType
      }else {
        return this
      }
      return
    }
    function v1129() {
      var v2872 = this.symbol;
      if(v2872) {
        var v13110 = !this.elementType;
        if(v13110) {
          v13110 = this.symbol.type.isClass()
        }
        v2872 = v13110
      }
      return v2872
    }
    function v1128() {
      return this.elementType != null
    }
    function v1127() {
      return this.instanceType != null
    }
    function v1126(arrInstType$$2, checker$$19) {
      var v2875 = this.arrayCache;
      return JAM.call(v2875.specialize, v2875, [arrInstType$$2, checker$$19])
    }
    function v1125() {
      var v13111 = this.extendsList;
      if(v13111) {
        v13111 = this.extendsList.length > 0
      }
      if(v13111) {
        return this.extendsList[0]
      }else {
        return null
      }
      return
    }
    function Type$$1() {
      this.typeID = currentTypeID;
      currentTypeID = currentTypeID + 1;
      this.construct = null;
      this.call = null;
      this.index = null;
      this.passTypeCreated = TypeScript$$26.CompilerDiagnostics.analysisPass;
      this.primitiveTypeClass = Primitive.None;
      this.typeFlags = TypeScript$$26.TypeFlags.None;
      return
    }
    Type$$1.prototype.baseClass = v1125;
    Type$$1.prototype.getArrayBase = v1126;
    Type$$1.prototype.isClass = v1127;
    Type$$1.prototype.isArray = v1128;
    Type$$1.prototype.isClassInstance = v1129;
    Type$$1.prototype.getInstanceType = v1130;
    Type$$1.prototype.hasImplementation = v1131;
    Type$$1.prototype.setHasImplementation = v1132;
    Type$$1.prototype.isDouble = v1133;
    Type$$1.prototype.isString = v1134;
    Type$$1.prototype.isBoolean = v1135;
    Type$$1.prototype.isNull = v1136;
    Type$$1.prototype.getTypeName = v1137;
    Type$$1.prototype.getScopedTypeName = v1138;
    Type$$1.prototype.getScopedTypeNameEx = v1139;
    Type$$1.prototype.callCount = v1140;
    Type$$1.prototype.getMemberTypeName = v1141;
    Type$$1.prototype.getMemberTypeNameEx = v1143;
    Type$$1.prototype.checkDecl = v1144;
    Type$$1.prototype.getMemberScope = v1145;
    Type$$1.prototype.isReferenceType = v1146;
    Type$$1.prototype.specializeType = v1151;
    Type$$1.prototype.hasBase = v1152;
    Type$$1.prototype.mergeOrdered = v1153;
    Type$$1.prototype.isModuleType = v1154;
    Type$$1.prototype.hasMembers = v1155;
    Type$$1.prototype.getAllEnclosedTypes = v1156;
    Type$$1.prototype.getAllAmbientEnclosedTypes = v1157;
    Type$$1.prototype.getPublicEnclosedTypes = v1158;
    Type$$1.prototype.getpublicAmbientEnclosedTypes = v1159;
    Type$$1.prototype.getDocComments = v1160;
    return Type$$1
  }
  function v1124(_super$$66) {
    function v1123(entries) {
      var i$$113 = 0;
      var v2913 = i$$113 < entries.length;
      for(;v2913;) {
        var v2911 = this.entries;
        introspect(JAM.policy.p1) {
          var v2912 = entries[i$$113]
        }
        JAM.call(v2911.push, v2911, [v2912]);
        i$$113 = i$$113 + 1;
        v2913 = i$$113 < entries.length
      }
      return
    }
    function v1122(entry$$2) {
      var v2914 = this.entries;
      JAM.call(v2914.push, v2914, [entry$$2]);
      return
    }
    function v1121() {
      return true
    }
    function MemberNameArray$$1() {
      JAM.call(_super$$66.apply, _super$$66, [this, arguments]);
      this.delim = "";
      this.entries = [];
      return
    }
    JAM.call(__extends, null, [MemberNameArray$$1, _super$$66]);
    MemberNameArray$$1.prototype.isArray = v1121;
    MemberNameArray$$1.prototype.add = v1122;
    MemberNameArray$$1.prototype.addAll = v1123;
    return MemberNameArray$$1
  }
  function v1120(_super$$65) {
    function v1119() {
      return true
    }
    function MemberNameString$$1(text$$25) {
      JAM.call(_super$$65.call, _super$$65, [this]);
      this.text = text$$25;
      return
    }
    JAM.call(__extends, null, [MemberNameString$$1, _super$$65]);
    MemberNameString$$1.prototype.isString = v1119;
    return MemberNameString$$1
  }
  function v1118() {
    function create(arg1, arg2, arg3) {
      if(typeof arg1 == "string") {
        return JAM.new(MemberNameString, [arg1])
      }else {
        var result$$32 = new MemberNameArray;
        if(arg2) {
          result$$32.prefix = arg2
        }
        if(arg3) {
          result$$32.suffix = arg3
        }
        var v2919 = result$$32.entries;
        JAM.call(v2919.push, v2919, [arg1]);
        return result$$32
      }
      return
    }
    function memberNameToString(memberName$$3) {
      var result$$31 = memberName$$3.prefix;
      if(memberName$$3.isString()) {
        result$$31 = result$$31 + memberName$$3.text
      }else {
        var ar = memberName$$3;
        var index$$61 = 0;
        var v2921 = index$$61 < ar.entries.length;
        for(;v2921;) {
          var v13117 = result$$31;
          var v22978 = ar.entries;
          introspect(JAM.policy.p1) {
            var v19204 = v22978[index$$61]
          }
          result$$31 = v13117 + JAM.call(MemberName$$1.memberNameToString, MemberName$$1, [v19204]);
          result$$31 = result$$31 + ar.delim;
          index$$61 = index$$61 + 1;
          v2921 = index$$61 < ar.entries.length
        }
      }
      result$$31 = result$$31 + memberName$$3.suffix;
      return result$$31
    }
    function v1117() {
      return JAM.call(MemberName$$1.memberNameToString, MemberName$$1, [this])
    }
    function v1116() {
      return false
    }
    function v1115() {
      return false
    }
    function MemberName$$1() {
      this.prefix = "";
      this.suffix = "";
      return
    }
    MemberName$$1.prototype.isString = v1115;
    MemberName$$1.prototype.isArray = v1116;
    MemberName$$1.prototype.toString = v1117;
    MemberName$$1.memberNameToString = memberNameToString;
    MemberName$$1.create = create;
    return MemberName$$1
  }
  function v1114(Primitive$$1) {
    Primitive$$1._map = [];
    Primitive$$1.None = 0;
    Primitive$$1.Void = 1;
    Primitive$$1.Double = 2;
    Primitive$$1.String = 4;
    Primitive$$1.Boolean = 8;
    Primitive$$1.Any = 16;
    Primitive$$1.Null = 32;
    Primitive$$1.Undefined = 64;
    return
  }
  function getTypeLink(ast$$116, checker$$18, autoVar) {
    var result$$30 = new TypeLink;
    result$$30.ast = ast$$116;
    var v13122 = ast$$116 == null;
    if(v13122) {
      v13122 = autoVar
    }
    if(v13122) {
      result$$30.type = checker$$18.anyType
    }else {
      result$$30.type = null
    }
    return result$$30
  }
  var v13123 = TypeScript$$26.Primitive;
  if(!v13123) {
    v13123 = TypeScript$$26.Primitive = {}
  }
  v1114(v13123);
  var Primitive = TypeScript$$26.Primitive;
  var MemberName = v1118();
  TypeScript$$26.MemberName = MemberName;
  var MemberNameString = v1120(MemberName);
  TypeScript$$26.MemberNameString = MemberNameString;
  var MemberNameArray = v1124(MemberName);
  TypeScript$$26.MemberNameArray = MemberNameArray;
  var currentTypeID = -1;
  var Type = v1161();
  TypeScript$$26.Type = Type;
  var ModuleType = v1170(Type);
  TypeScript$$26.ModuleType = ModuleType;
  var TypeLink = v1171();
  TypeScript$$26.TypeLink = TypeLink;
  TypeScript$$26.getTypeLink = getTypeLink;
  return
}
function v1113(TypeScript$$25) {
  function v1112() {
    function v1111(enclosingScopeContext$$2) {
      function preFindMemberScopeFullAstFuzy(ast$$115, parent$$69, walker$$53) {
        if(JAM.call(TypeScript$$25.isValidAstNode, TypeScript$$25, [ast$$115])) {
          var v13124 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [ast$$115.flags, matchFlag$$2]);
          if(v13124) {
            var v19208 = ast$$115.minChar < pos$$7;
            if(v19208) {
              v19208 = pos$$7 <= ast$$115.limChar
            }
            v13124 = v19208
          }
          if(v13124) {
            astResult = ast$$115
          }
          var v2929 = walker$$53.options;
          var v13125 = ast$$115.minChar <= pos$$7;
          if(v13125) {
            v13125 = pos$$7 <= ast$$115.limChar
          }
          v2929.goChildren = v13125
        }
        return ast$$115
      }
      function preFindMemberScopeFullAst(ast$$114, parent$$68, walker$$52) {
        if(JAM.call(TypeScript$$25.isValidAstNode, TypeScript$$25, [ast$$114])) {
          var v13126 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [ast$$114.flags, matchFlag$$2]);
          if(v13126) {
            var v19212 = pos$$7 == ast$$114.limChar;
            if(!v19212) {
              v19212 = pos$$7 - 1 == ast$$114.limChar
            }
            v13126 = v19212
          }
          if(v13126) {
            astResult = ast$$114;
            walker$$52.options.stopWalk()
          }
          var v2933 = walker$$52.options;
          var v13127 = ast$$114.minChar <= pos$$7;
          if(v13127) {
            v13127 = pos$$7 <= ast$$114.limChar
          }
          v2933.goChildren = v13127
        }
        return ast$$114
      }
      var matchFlag$$2 = TypeScript$$25.ASTFlags.DotLHS;
      var pos$$7 = enclosingScopeContext$$2.pos;
      var astResult = null;
      var v2936 = TypeScript$$25.getAstWalkerFactory();
      JAM.call(v2936.walk, v2936, [enclosingScopeContext$$2.script, preFindMemberScopeFullAst]);
      if(astResult == null) {
        var v2938 = TypeScript$$25.getAstWalkerFactory();
        JAM.call(v2938.walk, v2938, [enclosingScopeContext$$2.script, preFindMemberScopeFullAstFuzy])
      }
      var v13128 = astResult;
      if(v13128) {
        var v19215 = enclosingScopeContext$$2.enclosingClassDecl;
        if(v19215) {
          v19215 = astResult.type == enclosingScopeContext$$2.enclosingClassDecl.type.instanceType
        }
        v13128 = v19215
      }
      if(v13128) {
        enclosingScopeContext$$2.publicsOnly = false
      }
      var v13129 = astResult;
      if(v13129) {
        v13129 = astResult.type
      }
      if(v13129) {
        var v2942 = astResult.type;
        return JAM.call(v2942.getMemberScope, v2942, [this])
      }else {
        return null
      }
      return
    }
    function v1110(enclosingScopeContext$$1) {
      return JAM.call(this.findMemberScope, this, [enclosingScopeContext$$1, TypeScript$$25.ASTFlags.DotLHS])
    }
    function v1109(enclosingScopeContext, matchFlag$$1) {
      var enclosingScope$$1 = enclosingScopeContext.getScope();
      var pos$$6 = enclosingScopeContext.pos - enclosingScopeContext.scopeStartAST.minChar;
      var scriptFragment = enclosingScopeContext.getScriptFragment();
      var memContext = JAM.new(TypeScript$$25.MemberScopeContext, [this, pos$$6, matchFlag$$1]);
      memContext.scope = enclosingScope$$1;
      if(scriptFragment.nodeType == TypeScript$$25.NodeType.Name) {
        var v2948 = scriptFragment.type;
        return JAM.call(v2948.getMemberScope, v2948, [this])
      }else {
        var v2949 = TypeScript$$25.getAstWalkerFactory();
        JAM.call(v2949.walk, v2949, [scriptFragment, TypeScript$$25.preFindMemberScope, null, null, memContext]);
        var v13134 = memContext.ast;
        if(v13134) {
          var v19217 = enclosingScopeContext.enclosingClassDecl;
          if(v19217) {
            v19217 = memContext.ast.type == enclosingScopeContext.enclosingClassDecl.type.instanceType
          }
          v13134 = v19217
        }
        if(v13134) {
          enclosingScopeContext.publicsOnly = false
        }
        if(memContext.type) {
          var v2952 = memContext.type;
          return JAM.call(v2952.getMemberScope, v2952, [this])
        }else {
          return null
        }
      }
      return
    }
    function v1108(ast$$113) {
      var script$$17 = ast$$113;
      this.checker.locationInfo = script$$17.locationInfo;
      var globalChain$$1 = JAM.new(ScopeChain, [this.checker.gloMod, null, this.globalScope]);
      var context$$64 = JAM.new(TypeScript$$25.AssignScopeContext, [globalChain$$1, this, [this.checker.currentModDecl]]);
      var v2960 = TypeScript$$25.getAstWalkerFactory();
      JAM.call(v2960.walk, v2960, [ast$$113, TypeScript$$25.preAssignScopes, TypeScript$$25.postAssignScopes, null, context$$64]);
      return
    }
    function v1107(ast$$112) {
      var callEx$$5 = ast$$112;
      var v13137 = this.checker.styleSettings.newMustBeUsed;
      if(v13137) {
        v13137 = ast$$112.nodeType == TypeScript$$25.NodeType.New
      }
      if(v13137) {
        if(JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [ast$$112.flags, TypeScript$$25.ASTFlags.IsStatement])) {
          var v2963 = this.checker.errorReporter;
          JAM.call(v2963.styleError, v2963, [ast$$112, "use of new expression as a statement"])
        }
      }else {
        var v13141 = !this.checker.styleSettings.evalOK;
        if(v13141) {
          v13141 = ast$$112.nodeType == TypeScript$$25.NodeType.Call
        }
        if(v13141) {
          var v13142 = callEx$$5.target.nodeType == TypeScript$$25.NodeType.Name;
          if(v13142) {
            v13142 = callEx$$5.target.text == "eval"
          }
          if(v13142) {
            var v2965 = this.checker.errorReporter;
            JAM.call(v2965.styleError, v2965, [callEx$$5, "eval not permitted"])
          }
        }
      }
      if(callEx$$5.target.nodeType == TypeScript$$25.NodeType.FuncDecl) {
        callEx$$5.target.isInlineCallLiteral = true
      }
      var prevInSuperCall = this.inSuperCall;
      if(callEx$$5.target.nodeType == TypeScript$$25.NodeType.Super) {
        this.inSuperCall = true
      }
      var v2972 = callEx$$5;
      var v26809 = JAM.call(this.typeCheck, this, [callEx$$5.target]);
      v2972.target = v26809;
      JAM.call(this.preTypeCheckCallArgs, this, [callEx$$5.arguments]);
      var target$$48 = callEx$$5.target;
      var v13149 = target$$48.type == null;
      if(!v13149) {
        var v19234 = target$$48.type == this.anyType;
        if(!v19234) {
          var v22998 = this.functionInterfaceType;
          if(v22998) {
            v22998 = target$$48.type == this.functionInterfaceType
          }
          v19234 = v22998
        }
        v13149 = v19234
      }
      if(v13149) {
        callEx$$5.type = this.anyType
      }else {
        var fnType$$1 = target$$48.type;
        if(fnType$$1.call) {
          var signature$$14 = JAM.call(this.resolveOverload, this, [callEx$$5, fnType$$1.call]);
          if(signature$$14 == null) {
            callEx$$5.type = this.anyType
          }else {
            callEx$$5.type = signature$$14.returnType.type;
            callEx$$5.signature = signature$$14
          }
        }else {
          var v13150 = callEx$$5.target.nodeType == TypeScript$$25.NodeType.Super;
          if(v13150) {
            var v19238 = this.thisFnc;
            if(v19238) {
              var v23002 = this.thisFnc.isConstructor;
              if(v23002) {
                v23002 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [this.thisFnc.fncFlags, TypeScript$$25.FncFlags.ClassMethod])
              }
              v19238 = v23002
            }
            v13150 = v19238
          }
          if(v13150) {
            var v2977;
            if(fnType$$1.symbol.type.construct) {
              v2977 = JAM.call(this.resolveOverload, this, [callEx$$5, fnType$$1.symbol.type.construct])
            }else {
              v2977 = null
            }
            signature$$14 = v2977;
            if(signature$$14 == null) {
              callEx$$5.type = this.anyType
            }else {
              callEx$$5.flags = callEx$$5.flags | TypeScript$$25.ASTFlags.ClassBaseConstructorCall;
              callEx$$5.type = signature$$14.returnType.type;
              callEx$$5.signature = signature$$14
            }
          }else {
            callEx$$5.type = this.anyType;
            var v2980 = this.checker.errorReporter;
            JAM.call(v2980.invalidCall, v2980, [callEx$$5, callEx$$5.nodeType, this.scope])
          }
        }
      }
      JAM.call(this.postTypeCheckCallArgs, this, [callEx$$5]);
      this.inSuperCall = prevInSuperCall;
      return callEx$$5
    }
    function v1106(callEx$$4) {
      var acceptedTargetType = false;
      var i$$112 = 0;
      var v13156 = callEx$$4.target;
      if(v13156) {
        var v19242 = callEx$$4.target.type;
        if(v19242) {
          var v23006 = callEx$$4.signature;
          if(v23006) {
            v23006 = callEx$$4.arguments
          }
          v19242 = v23006
        }
        v13156 = v19242
      }
      if(v13156) {
        var sig$$4 = callEx$$4.signature;
        var v13157 = sig$$4;
        if(v13157) {
          v13157 = callEx$$4.arguments.members.length >= sig$$4.nonOptionalParameterCount
        }
        if(v13157) {
          acceptedTargetType = true;
          var targetType$$8 = null;
          var v2986;
          if(sig$$4.hasVariableArgList) {
            v2986 = sig$$4.parameters.length - 1
          }else {
            v2986 = sig$$4.parameters.length
          }
          var nonVarArgFormalParamLength = v2986;
          var v2987;
          if(callEx$$4.arguments.members.length < nonVarArgFormalParamLength) {
            v2987 = callEx$$4.arguments.members.length
          }else {
            v2987 = nonVarArgFormalParamLength
          }
          var nonVarArgActualParamLength = v2987;
          i$$112 = 0;
          var v2994 = i$$112 < nonVarArgActualParamLength;
          for(;v2994;) {
            var v13163 = sig$$4.parameters;
            introspect(JAM.policy.p1) {
              var v2988 = v13163[i$$112]
            }
            targetType$$8 = v2988.getType();
            var v19248 = callEx$$4.arguments.members;
            introspect(JAM.policy.p1) {
              var v13164 = v19248[i$$112]
            }
            switch(v13164.nodeType) {
              case TypeScript$$25.NodeType.FuncDecl:
              ;
              case TypeScript$$25.NodeType.ObjectLit:
              ;
              case TypeScript$$25.NodeType.ArrayLit:
                var v2989 = this.checker;
                var v2990 = this.checker.inProvisionalTypecheckMode();
                var v24845 = sig$$4.parameters;
                introspect(JAM.policy.p1) {
                  var v23010 = v24845[i$$112]
                }
                var v2991 = !v23010.declAST.isParenthesized;
                var v13167 = callEx$$4.arguments.members;
                introspect(JAM.policy.p1) {
                  var v2992 = v13167[i$$112]
                }
                JAM.call(v2989.typeCheckWithContextualType, v2989, [targetType$$8, v2990, v2991, v2992])
            }
            i$$112 = i$$112 + 1;
            v2994 = i$$112 < nonVarArgActualParamLength
          }
          if(sig$$4.hasVariableArgList) {
            var varArgParamIndex = sig$$4.nonOptionalParameterCount - 1;
            var v13168 = sig$$4.parameters;
            introspect(JAM.policy.p1) {
              var v2996 = v13168[varArgParamIndex]
            }
            targetType$$8 = v2996.getType();
            if(targetType$$8) {
              targetType$$8 = targetType$$8.elementType
            }
            var v23011 = sig$$4.parameters;
            introspect(JAM.policy.p1) {
              var v19251 = v23011[varArgParamIndex]
            }
            var isParenthesized = !v19251.declAST.isParenthesized;
            i$$112 = nonVarArgActualParamLength;
            var v3002 = i$$112 < callEx$$4.arguments.members.length;
            for(;v3002;) {
              var v19253 = callEx$$4.arguments.members;
              introspect(JAM.policy.p1) {
                var v13171 = v19253[i$$112]
              }
              switch(v13171.nodeType) {
                case TypeScript$$25.NodeType.FuncDecl:
                ;
                case TypeScript$$25.NodeType.ObjectLit:
                ;
                case TypeScript$$25.NodeType.ArrayLit:
                  var v2998 = this.checker;
                  var v2999 = this.checker.inProvisionalTypecheckMode();
                  var v13173 = callEx$$4.arguments.members;
                  introspect(JAM.policy.p1) {
                    var v3000 = v13173[i$$112]
                  }
                  JAM.call(v2998.typeCheckWithContextualType, v2998, [targetType$$8, v2999, isParenthesized, v3000])
              }
              i$$112 = i$$112 + 1;
              v3002 = i$$112 < callEx$$4.arguments.members.length
            }
          }
        }
      }
      var v13175 = !acceptedTargetType;
      if(v13175) {
        v13175 = callEx$$4.arguments
      }
      if(v13175) {
        this.checker.killCurrentContextualType();
        i$$112 = 0;
        var v3009 = i$$112 < callEx$$4.arguments.members.length;
        for(;v3009;) {
          var v19257 = callEx$$4.arguments.members;
          introspect(JAM.policy.p1) {
            var v13177 = v19257[i$$112]
          }
          switch(v13177.nodeType) {
            case TypeScript$$25.NodeType.FuncDecl:
            ;
            case TypeScript$$25.NodeType.ObjectLit:
            ;
            case TypeScript$$25.NodeType.ArrayLit:
              var v13178 = callEx$$4.arguments.members;
              introspect(JAM.policy.p1) {
                var v3007 = v13178[i$$112]
              }
              JAM.call(this.typeCheck, this, [v3007]);
            default:
          }
          i$$112 = i$$112 + 1;
          v3009 = i$$112 < callEx$$4.arguments.members.length
        }
      }
      return
    }
    function v1105(args$$16) {
      if(!args$$16) {
        return
      }
      var i$$111 = 0;
      var v3014 = i$$111 < args$$16.members.length;
      for(;v3014;) {
        var v19261 = args$$16.members;
        introspect(JAM.policy.p1) {
          var v13181 = v19261[i$$111]
        }
        switch(v13181.nodeType) {
          case TypeScript$$25.NodeType.FuncDecl:
          ;
          case TypeScript$$25.NodeType.ObjectLit:
          ;
          case TypeScript$$25.NodeType.ArrayLit:
            i$$111 = i$$111 + 1;
            v3014 = i$$111 < args$$16.members.length;
            continue;
          default:
            var v13183 = args$$16.members;
            introspect(JAM.policy.p1) {
              var v3012 = v13183[i$$111]
            }
            JAM.call(this.typeCheck, this, [v3012])
        }
        i$$111 = i$$111 + 1;
        v3014 = i$$111 < args$$16.members.length
      }
      return
    }
    function v1104(ast$$111) {
      var callEx$$3 = ast$$111;
      var v3015 = callEx$$3;
      var v26810 = JAM.call(this.typeCheck, this, [callEx$$3.target]);
      v3015.target = v26810;
      var target$$47 = callEx$$3.target;
      var v13186 = target$$47.type.construct;
      if(!v13186) {
        v13186 = target$$47.type.call
      }
      if(v13186) {
        JAM.call(this.preTypeCheckCallArgs, this, [callEx$$3.arguments])
      }else {
        var v3017 = callEx$$3;
        var v26811 = JAM.call(this.typeCheck, this, [callEx$$3.arguments]);
        v3017.arguments = v26811
      }
      if(target$$47.type == this.anyType) {
        callEx$$3.type = this.anyType;
        var v3019 = callEx$$3;
        var v26812 = JAM.call(this.typeCheck, this, [callEx$$3.arguments]);
        v3019.arguments = v26812
      }else {
        if(target$$47.type.construct) {
          var signature$$13 = JAM.call(this.resolveOverload, this, [callEx$$3, target$$47.type.construct]);
          if(signature$$13 == null) {
            callEx$$3.type = this.anyType
          }else {
            if(signature$$13.returnType.type == this.voidType) {
              callEx$$3.type = this.anyType;
              callEx$$3.signature = signature$$13
            }else {
              callEx$$3.type = signature$$13.returnType.type;
              callEx$$3.signature = signature$$13
            }
          }
        }else {
          if(target$$47.type.call) {
            signature$$13 = JAM.call(this.resolveOverload, this, [callEx$$3, target$$47.type.call]);
            if(signature$$13 == null) {
              callEx$$3.type = this.anyType
            }else {
              var v13197 = signature$$13.returnType.type == this.voidType;
              if(!v13197) {
                v13197 = signature$$13.returnType.type == this.anyType
              }
              if(v13197) {
                callEx$$3.type = this.anyType;
                callEx$$3.signature = signature$$13
              }else {
                var v3025 = this.checker.errorReporter;
                JAM.call(v3025.simpleError, v3025, [callEx$$3.target, "new expression only valid on constructors"])
              }
            }
          }else {
            if(target$$47.type.elementType) {
              callEx$$3.type = target$$47.type
            }else {
              var v3029 = this.checker.errorReporter;
              JAM.call(v3029.invalidCall, v3029, [callEx$$3, callEx$$3.nodeType, this.scope]);
              callEx$$3.type = this.anyType
            }
          }
        }
      }
      JAM.call(this.postTypeCheckCallArgs, this, [callEx$$3]);
      return callEx$$3
    }
    function v1103(application, group$$1) {
      var rd$$2 = this.resolutionDataCache.getResolutionData();
      var actuals$$1 = rd$$2.actuals;
      var exactCandidates$$1 = rd$$2.exactCandidates;
      var conversionCandidates$$1 = rd$$2.conversionCandidates;
      var candidate = null;
      var hasOverloads = group$$1.signatures.length > 1;
      var comparisonInfo$$16 = new TypeScript$$25.TypeComparisonInfo;
      var args$$15 = null;
      var target$$46 = null;
      var v13202 = application.nodeType == TypeScript$$25.NodeType.Call;
      if(!v13202) {
        v13202 = application.nodeType == TypeScript$$25.NodeType.New
      }
      if(v13202) {
        var callEx$$2 = application;
        args$$15 = callEx$$2.arguments;
        target$$46 = callEx$$2.target;
        if(callEx$$2.arguments) {
          var len$$54 = callEx$$2.arguments.members.length;
          var i$$110 = 0;
          var v3041 = i$$110 < len$$54;
          for(;v3041;) {
            var v13204 = callEx$$2.arguments.members;
            introspect(JAM.policy.p1) {
              var v3040 = v13204[i$$110]
            }
            actuals$$1[i$$110] = v3040.type;
            i$$110 = i$$110 + 1;
            v3041 = i$$110 < len$$54
          }
        }
      }else {
        if(application.nodeType == TypeScript$$25.NodeType.Index) {
          var binExp = application;
          target$$46 = binExp.operand1;
          args$$15 = new TypeScript$$25.ASTList;
          args$$15.members[0] = binExp.operand2;
          actuals$$1[0] = binExp.operand2.type
        }
      }
      var j$$17 = 0;
      var groupLen = group$$1.signatures.length;
      var v3053 = j$$17 < groupLen;
      for(;v3053;) {
        var v3049 = group$$1.signatures;
        introspect(JAM.policy.p1) {
          var signature$$12 = v3049[j$$17]
        }
        var v13207 = hasOverloads;
        if(v13207) {
          var v19280 = signature$$12 == group$$1.definitionSignature;
          if(v19280) {
            v19280 = !this.checker.canCallDefinitionSignature
          }
          v13207 = v19280
        }
        if(v13207) {
          j$$17 = j$$17 + 1;
          v3053 = j$$17 < groupLen;
          continue
        }
        var v13208 = !signature$$12.returnType.type;
        if(v13208) {
          var v19282 = signature$$12.declAST;
          if(v19282) {
            v19282 = signature$$12.typeCheckStatus != TypeScript$$25.TypeCheckStatus.Finished
          }
          v13208 = v19282
        }
        if(v13208) {
          JAM.call(this.typeCheckFunction, this, [signature$$12.declAST])
        }
        JAM.call(this.tryAddCandidates, this, [signature$$12, actuals$$1, exactCandidates$$1, conversionCandidates$$1, comparisonInfo$$16]);
        j$$17 = j$$17 + 1;
        v3053 = j$$17 < groupLen
      }
      if(exactCandidates$$1.length == 0) {
        var v3054 = this.checker;
        var applicableCandidates = JAM.call(v3054.getApplicableSignatures, v3054, [conversionCandidates$$1, args$$15, comparisonInfo$$16]);
        if(applicableCandidates.length > 0) {
          var v3055 = this.checker;
          var candidateInfo = JAM.call(v3055.findMostApplicableSignature, v3055, [applicableCandidates, args$$15]);
          if(candidateInfo.ambiguous) {
            var v3056 = this.checker.errorReporter;
            JAM.call(v3056.simpleError, v3056, [target$$46, "Ambiguous call expression - could not choose overload"])
          }
          candidate = candidateInfo.sig
        }else {
          var emsg$$3 = "Supplied parameters do not match any signature of call target";
          if(comparisonInfo$$16.message) {
            var v3058 = this.checker.errorReporter;
            JAM.call(v3058.simpleError, v3058, [target$$46, emsg$$3 + ":\n\t" + comparisonInfo$$16.message])
          }else {
            var v3060 = this.checker.errorReporter;
            JAM.call(v3060.simpleError, v3060, [target$$46, emsg$$3])
          }
        }
      }else {
        if(exactCandidates$$1.length > 1) {
          var applicableSigs$$1 = [];
          i$$110 = 0;
          var v3064 = i$$110 < exactCandidates$$1.length;
          for(;v3064;) {
            introspect(JAM.policy.p1) {
              var v3063 = exactCandidates$$1[i$$110]
            }
            applicableSigs$$1[i$$110] = {signature:v3063, hadProvisionalErrors:false};
            i$$110 = i$$110 + 1;
            v3064 = i$$110 < exactCandidates$$1.length
          }
          var v3065 = this.checker;
          candidateInfo = JAM.call(v3065.findMostApplicableSignature, v3065, [applicableSigs$$1, args$$15]);
          if(candidateInfo.ambiguous) {
            var v3066 = this.checker.errorReporter;
            JAM.call(v3066.simpleError, v3066, [target$$46, "Ambiguous call expression - could not choose overload"])
          }
          candidate = candidateInfo.sig
        }else {
          candidate = exactCandidates$$1[0]
        }
      }
      var v3070 = this.resolutionDataCache;
      JAM.call(v3070.returnResolutionData, v3070, [rd$$2]);
      return candidate
    }
    function v1102(signature$$11, actuals, exactCandidates, conversionCandidates, comparisonInfo$$15) {
      var lowerBound = signature$$11.nonOptionalParameterCount;
      var upperBound = signature$$11.parameters.length;
      var formalLen = lowerBound;
      var acceptable = false;
      var v13220 = actuals.length >= lowerBound;
      if(v13220) {
        var v19284 = signature$$11.hasVariableArgList;
        if(!v19284) {
          v19284 = actuals.length <= upperBound
        }
        v13220 = v19284
      }
      if(v13220) {
        var v3072;
        if(signature$$11.hasVariableArgList) {
          v3072 = signature$$11.parameters.length
        }else {
          v3072 = actuals.length
        }
        formalLen = v3072;
        acceptable = true
      }
      var repeatType = null;
      var v13223 = acceptable;
      if(!v13223) {
        v13223 = signature$$11.hasVariableArgList
      }
      if(v13223) {
        if(signature$$11.hasVariableArgList) {
          formalLen = formalLen - 1;
          var v23029 = signature$$11.parameters;
          introspect(JAM.policy.p1) {
            var v19286 = v23029[formalLen]
          }
          repeatType = v19286.parameter.typeLink.type;
          repeatType = repeatType.elementType;
          acceptable = actuals.length >= formalLen
        }
        var len$$53 = actuals.length;
        var exact = acceptable;
        var convert = acceptable;
        var i$$109 = 0;
        var v3082 = i$$109 < len$$53;
        for(;v3082;) {
          var typeA;
          if(i$$109 < formalLen) {
            var v23030 = signature$$11.parameters;
            introspect(JAM.policy.p1) {
              var v19287 = v23030[i$$109]
            }
            typeA = v19287.parameter.typeLink.type
          }else {
            typeA = repeatType
          }
          introspect(JAM.policy.p1) {
            var typeB = actuals[i$$109]
          }
          var v13226 = !typeA;
          if(!v13226) {
            var v19288 = !typeB;
            if(!v19288) {
              var v24848 = this.checker;
              v19288 = !JAM.call(v24848.typesAreIdentical, v24848, [typeA, typeB])
            }
            v13226 = v19288
          }
          if(v13226) {
            exact = false
          }
          var v19290 = this.checker;
          if(!JAM.call(v19290.sourceIsAssignableToTarget, v19290, [typeB, typeA, comparisonInfo$$15])) {
            convert = false
          }
          if(!(exact || convert)) {
            break
          }
          i$$109 = i$$109 + 1;
          v3082 = i$$109 < len$$53
        }
        if(exact) {
          JAM.set(exactCandidates, exactCandidates.length, signature$$11)
        }else {
          var v13229 = convert;
          if(v13229) {
            v13229 = exactCandidates.length == 0
          }
          if(v13229) {
            JAM.set(conversionCandidates, conversionCandidates.length, signature$$11)
          }
        }
      }
      return
    }
    function v1101(binex$$13) {
      var v3087 = binex$$13;
      var v26813 = JAM.call(this.typeCheck, this, [binex$$13.operand1]);
      v3087.operand1 = v26813;
      var v3088 = binex$$13;
      var v26814 = JAM.call(this.typeCheck, this, [binex$$13.operand2]);
      v3088.operand2 = v26814;
      binex$$13.type = binex$$13.operand2.type;
      return binex$$13
    }
    function v1100(binex$$12) {
      var v3090 = binex$$12;
      var v26815 = JAM.call(this.typeCheck, this, [binex$$12.operand1]);
      v3090.operand1 = v26815;
      var v3091 = binex$$12;
      var v26816 = JAM.call(this.typeCheck, this, [binex$$12.operand2]);
      v3091.operand2 = v26816;
      var leftType$$6 = binex$$12.operand1.type;
      var rightType$$5 = binex$$12.operand2.type;
      var v13234 = leftType$$6 == this.checker.anyType;
      if(!v13234) {
        v13234 = rightType$$5 == this.checker.anyType
      }
      if(v13234) {
        binex$$12.type = this.checker.anyType
      }else {
        if(leftType$$6 == this.checker.booleanType) {
          if(rightType$$5 == this.checker.booleanType) {
            binex$$12.type = this.checker.booleanType
          }else {
            binex$$12.type = this.checker.anyType
          }
        }else {
          if(leftType$$6 == this.checker.numberType) {
            if(rightType$$5 == this.checker.numberType) {
              binex$$12.type = this.checker.numberType
            }else {
              binex$$12.type = this.checker.anyType
            }
          }else {
            if(leftType$$6 == this.checker.stringType) {
              if(rightType$$5 == this.checker.stringType) {
                binex$$12.type = this.checker.stringType
              }else {
                binex$$12.type = this.checker.anyType
              }
            }else {
              var v13241 = this.checker;
              if(JAM.call(v13241.sourceIsSubtypeOfTarget, v13241, [leftType$$6, rightType$$5])) {
                binex$$12.type = rightType$$5
              }else {
                var v13242 = this.checker;
                if(JAM.call(v13242.sourceIsSubtypeOfTarget, v13242, [rightType$$5, leftType$$6])) {
                  binex$$12.type = leftType$$6
                }else {
                  binex$$12.type = this.checker.anyType
                }
              }
            }
          }
        }
      }
      return binex$$12
    }
    function v1099(ast$$110) {
      var binex$$11 = ast$$110;
      var v3111 = binex$$11;
      var v26817 = JAM.call(this.typeCheck, this, [binex$$11.operand1]);
      v3111.operand1 = v26817;
      var v3112 = binex$$11;
      var v26818 = JAM.call(this.typeCheck, this, [binex$$11.operand2]);
      v3112.operand2 = v26818;
      binex$$11.type = binex$$11.operand2.type;
      return binex$$11
    }
    function v1098(ast$$109) {
      var binex$$10 = ast$$109;
      var v3114 = binex$$10;
      var v26819 = JAM.call(this.typeCheck, this, [binex$$10.operand1]);
      v3114.operand1 = v26819;
      var v3115 = binex$$10;
      var v26820 = JAM.call(this.typeCheck, this, [binex$$10.operand2]);
      v3115.operand2 = v26820;
      var v23035 = binex$$10.operand1.type == this.checker.anyType;
      if(!v23035) {
        var v24851 = this.checker;
        v23035 = JAM.call(v24851.sourceIsSubtypeOfTarget, v24851, [binex$$10.operand1.type, this.objectInterfaceType])
      }
      var v19301 = v23035;
      if(v19301) {
        var v23036 = binex$$10.operand2.type == this.anyType;
        if(!v23036) {
          var v24857 = this.checker;
          v23036 = JAM.call(v24857.sourceIsSubtypeOfTarget, v24857, [binex$$10.operand2.type, this.functionInterfaceType])
        }
        v19301 = v23036
      }
      if(!v19301) {
        var v3116 = this.checker.errorReporter;
        JAM.call(v3116.simpleError, v3116, [ast$$109, "The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type"])
      }
      binex$$10.type = this.booleanType;
      return binex$$10
    }
    function v1097(returnStmt$$1) {
      if(this.thisFnc) {
        var targetType$$7 = null;
        if(this.checker.hasTargetType()) {
          var tcContext = this.checker.currentContextualTypeContext;
          var accessorType$$1 = tcContext.targetAccessorType;
          if(accessorType$$1) {
            targetType$$7 = accessorType$$1
          }else {
            var targetSig$$1 = this.checker.currentContextualTypeContext.targetSig;
            var v13251 = targetSig$$1;
            if(v13251) {
              v13251 = targetSig$$1.returnType.type != this.voidType
            }
            if(v13251) {
              targetType$$7 = targetSig$$1.returnType.type
            }
          }
        }
        if(returnStmt$$1.returnExpression) {
          var v3123 = this.thisFnc;
          v3123.fncFlags = v3123.fncFlags | TypeScript$$25.FncFlags.HasReturnExpression;
          var v13252 = targetType$$7 == null;
          if(v13252) {
            var v19306 = this.thisFnc.returnTypeAnnotation;
            if(v19306) {
              var v23040 = this.thisFnc.returnTypeAnnotation.type;
              if(v23040) {
                v23040 = this.thisFnc.returnTypeAnnotation.type != this.voidType
              }
              v19306 = v23040
            }
            v13252 = v19306
          }
          if(v13252) {
            targetType$$7 = this.thisFnc.returnTypeAnnotation.type
          }
          var v3126 = this.checker;
          JAM.call(v3126.typeCheckWithContextualType, v3126, [targetType$$7, this.checker.inProvisionalTypecheckMode(), targetType$$7 != null, returnStmt$$1.returnExpression]);
          var v3130;
          var v19307 = this.thisFnc.returnTypeAnnotation;
          if(v19307) {
            v19307 = this.thisFnc.returnTypeAnnotation.type
          }
          if(v19307) {
            v3130 = this.thisFnc.returnTypeAnnotation.type
          }else {
            v3130 = targetType$$7
          }
          var expectedReturnType = v3130;
          if(expectedReturnType) {
            var v13257 = expectedReturnType == this.voidType;
            if(v13257) {
              v13257 = returnStmt$$1.returnExpression.type != this.voidType
            }
            if(v13257) {
              var v3131 = this.checker.errorReporter;
              JAM.call(v3131.simpleError, v3131, [returnStmt$$1, "Return with value expression in void function"]);
              returnStmt$$1.type = returnStmt$$1.returnExpression.type
            }else {
              var v3133 = returnStmt$$1;
              var v26821 = JAM.call(this.cast, this, [returnStmt$$1.returnExpression, expectedReturnType]);
              v3133.returnExpression = v26821;
              returnStmt$$1.type = expectedReturnType
            }
          }else {
            if(targetType$$7) {
              if(returnStmt$$1.returnExpression.type != this.voidType) {
                var v3135 = returnStmt$$1;
                var v26822 = JAM.call(this.cast, this, [returnStmt$$1.returnExpression, targetType$$7]);
                v3135.returnExpression = v26822
              }else {
                returnStmt$$1.returnExpression.type = targetType$$7
              }
            }
            returnStmt$$1.type = returnStmt$$1.returnExpression.type
          }
          JAM.set(this.thisFnc.returnStatementsWithExpressions, this.thisFnc.returnStatementsWithExpressions.length, returnStmt$$1)
        }else {
          var v3141;
          if(targetType$$7 == null) {
            v3141 = this.checker.voidType
          }else {
            v3141 = targetType$$7
          }
          returnStmt$$1.type = v3141
        }
      }
      return returnStmt$$1
    }
    function v1096(type$$56, ast$$108) {
      var v13267 = type$$56;
      if(v13267) {
        var v19314 = type$$56.construct;
        if(v19314) {
          v19314 = type$$56.construct.signatures.length > 0
        }
        v13267 = v19314
      }
      if(v13267) {
        var i$$108 = 0;
        var v3146 = i$$108 < type$$56.construct.signatures.length;
        for(;v3146;) {
          var v24866 = type$$56.construct.signatures;
          introspect(JAM.policy.p1) {
            var v23046 = v24866[i$$108]
          }
          if(v23046.returnType.type == this.checker.voidType) {
            var v3144 = this.checker.errorReporter;
            JAM.call(v3144.simpleError, v3144, [ast$$108, "Constructors may not have a return type of 'void'"]);
            break
          }
          i$$108 = i$$108 + 1;
          v3146 = i$$108 < type$$56.construct.signatures.length
        }
      }
      return
    }
    function v1095(arrayLit) {
      function v1094(index$$60) {
        var v13273 = elements$$2.members;
        introspect(JAM.policy.p1) {
          var v3148 = v13273[index$$60]
        }
        return v3148.type
      }
      function v1093(index$$59, type$$55) {
        var v13274 = elements$$2.members;
        introspect(JAM.policy.p1) {
          var v3149 = v13274[index$$59]
        }
        v3149.type = type$$55;
        return
      }
      function v1092() {
        return elements$$2.members.length
      }
      var elements$$2 = arrayLit.operand;
      var elementType = this.anyType;
      var targetElementType = null;
      var comparisonInfo$$14 = new TypeScript$$25.TypeComparisonInfo;
      comparisonInfo$$14.onlyCaptureFirstError = true;
      if(this.checker.hasTargetType()) {
        var targetType$$6 = this.checker.currentContextualTypeContext.contextualType;
        if(targetType$$6.elementType) {
          targetElementType = targetType$$6.elementType
        }
      }
      if(elements$$2) {
        var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck;
        this.inArrayElementTypeCheck = true;
        var v3155 = this.checker;
        JAM.call(v3155.typeCheckWithContextualType, v3155, [targetElementType, this.checker.inProvisionalTypecheckMode(), targetElementType != null, elements$$2]);
        this.inArrayElementTypeCheck = prevInArrayElemTypeCheck;
        elementType = elements$$2.members[0].type;
        var collection$$3 = {getLength:v1092, setTypeAtIndex:v1093, getTypeAtIndex:v1094};
        var v3159 = this.checker;
        elementType = JAM.call(v3159.findBestCommonType, v3159, [elementType, targetElementType, collection$$3, false, comparisonInfo$$14]);
        var v13279 = elementType == this.checker.undefinedType;
        if(!v13279) {
          var v19320 = !prevInArrayElemTypeCheck;
          if(v19320) {
            v19320 = elementType == this.nullType
          }
          v13279 = v19320
        }
        if(v13279) {
          elementType = this.anyType
        }
      }
      if(!elementType) {
        var emsg$$2 = "Incompatible types in array literal expression";
        if(!comparisonInfo$$14.message) {
          var v3161 = this.checker.errorReporter;
          JAM.call(v3161.simpleError, v3161, [arrayLit, emsg$$2])
        }else {
          var v3162 = this.checker.errorReporter;
          JAM.call(v3162.simpleError, v3162, [arrayLit, emsg$$2 + ": " + comparisonInfo$$14.message])
        }
        elementType = this.anyType
      }else {
        if(targetElementType) {
          var v13285 = this.checker;
          if(JAM.call(v13285.sourceIsAssignableToTarget, v13285, [elementType, targetElementType])) {
            elementType = targetElementType
          }
        }
      }
      var v3167 = arrayLit;
      var v13286 = this.checker;
      var v26823 = JAM.call(v13286.makeArrayType, v13286, [elementType]);
      v3167.type = v26823;
      return
    }
    function v1091(objectLit$$2) {
      var resultType$$2 = new TypeScript$$25.Type;
      var v3169 = resultType$$2;
      var v26824 = JAM.new(TypeScript$$25.TypeSymbol, [this.checker.anon, objectLit$$2.minChar, objectLit$$2.limChar - objectLit$$2.minChar, this.checker.locationInfo.unitIndex, resultType$$2]);
      v3169.symbol = v26824;
      var v3170 = resultType$$2;
      var v26825 = JAM.new(TypeScript$$25.ScopedMembers, [JAM.new(TypeScript$$25.DualStringHashTable, [new TypeScript$$25.StringHashTable, new TypeScript$$25.StringHashTable])]);
      v3170.members = v26825;
      var v3171 = resultType$$2;
      var v26826 = JAM.new(TypeScript$$25.SymbolTableScope, [resultType$$2.members, null, null, null, null]);
      v3171.memberScope = v26826;
      var aggScope$$3 = JAM.new(TypeScript$$25.SymbolAggregateScope, [resultType$$2.symbol]);
      JAM.call(aggScope$$3.addParentScope, aggScope$$3, [resultType$$2.memberScope]);
      JAM.call(aggScope$$3.addParentScope, aggScope$$3, [this.scope]);
      resultType$$2.containedScope = aggScope$$3;
      var memberDecls$$1 = objectLit$$2.operand;
      var prevThisType$$3 = this.thisType;
      var acceptTargetType = false;
      var targetType$$5 = null;
      if(this.checker.hasTargetType()) {
        targetType$$5 = this.checker.currentContextualTypeContext.contextualType;
        var v13298 = targetType$$5;
        if(v13298) {
          var v19329 = targetType$$5.symbol;
          if(v19329) {
            var v24867 = this.checker;
            v19329 = !JAM.call(v24867.typeStatusIsFinished, v24867, [targetType$$5.symbol.typeCheckStatus])
          }
          v13298 = v19329
        }
        if(v13298) {
          if(targetType$$5.symbol.declAST) {
            JAM.call(this.typeCheck, this, [targetType$$5.symbol.declAST])
          }
        }
        acceptTargetType = true
      }
      if(memberDecls$$1) {
        var i$$107 = 0;
        var len$$52 = memberDecls$$1.members.length;
        var v3211 = i$$107 < len$$52;
        for(;v3211;) {
          var v3182 = memberDecls$$1.members;
          introspect(JAM.policy.p1) {
            var binex$$9 = v3182[i$$107]
          }
          var id$$23 = binex$$9.operand1;
          var text$$24;
          var targetMember$$1 = null;
          var fieldSymbol$$4 = null;
          if(id$$23.nodeType == TypeScript$$25.NodeType.Name) {
            text$$24 = id$$23.text
          }else {
            if(id$$23.nodeType == TypeScript$$25.NodeType.QString) {
              var idText$$5 = id$$23.text;
              text$$24 = JAM.call(idText$$5.substring, idText$$5, [1, idText$$5.length - 1])
            }else {
              var v3184 = this.checker.errorReporter;
              JAM.call(v3184.simpleError, v3184, [objectLit$$2, "malformed object literal"]);
              resultType$$2 = this.anyType;
              break
            }
          }
          var v13307 = acceptTargetType;
          if(v13307) {
            v13307 = targetType$$5.memberScope
          }
          if(v13307) {
            var v3187 = targetType$$5.memberScope;
            targetMember$$1 = JAM.call(v3187.find, v3187, [text$$24, false, false])
          }
          var v13308 = binex$$9.operand2.nodeType == TypeScript$$25.NodeType.FuncDecl;
          if(v13308) {
            v13308 = binex$$9.operand2.isAccessor()
          }
          if(v13308) {
            var funcDecl$$33 = binex$$9.operand2;
            var v3189 = resultType$$2.members.publicMembers;
            var accessorSym$$1 = JAM.call(v3189.lookup, v3189, [text$$24]);
            var v3190 = this.checker;
            accessorSym$$1 = JAM.call(v3190.createAccessorSymbol, v3190, [funcDecl$$33, accessorSym$$1, resultType$$2, true, false, resultType$$2.memberScope, null]);
            funcDecl$$33.accessorSymbol = accessorSym$$1;
            fieldSymbol$$4 = accessorSym$$1;
            if(id$$23.nodeType == TypeScript$$25.NodeType.Name) {
              id$$23.sym = accessorSym$$1
            }
          }
          var v3194 = this.checker;
          var v13312;
          if(acceptTargetType && targetMember$$1) {
            v13312 = targetMember$$1.getType()
          }else {
            v13312 = null
          }
          JAM.call(v3194.typeCheckWithContextualType, v3194, [v13312, false, acceptTargetType, binex$$9.operand2]);
          if(acceptTargetType && targetMember$$1) {
            var v19337 = binex$$9.operand2.type == this.anyType;
            if(!v19337) {
              var v23058 = this.checker;
              v19337 = JAM.call(v23058.sourceIsAssignableToTarget, v23058, [binex$$9.operand2.type, targetMember$$1.getType()])
            }
            var v13313 = v19337;
            if(!v13313) {
              var v19338 = binex$$9.operand2.nodeType == TypeScript$$25.NodeType.FuncDecl;
              if(v19338) {
                var v23064 = binex$$9.operand2.isAccessor();
                if(v23064) {
                  v23064 = JAM.call(this.typeFromAccessorFuncDecl, this, [binex$$9.operand2]) == targetMember$$1.getType()
                }
                v19338 = v23064
              }
              v13313 = v19338
            }
            if(v13313) {
              var v3197 = binex$$9.operand1;
              var v26827 = targetMember$$1.getType();
              v3197.type = v26827
            }
          }else {
            var v3199 = binex$$9.operand2;
            var v13314;
            if(binex$$9.operand2.type == this.checker.undefinedType) {
              v13314 = this.anyType
            }else {
              v13314 = binex$$9.operand2.type
            }
            v3199.type = v13314
          }
          if(fieldSymbol$$4 == null) {
            var memberType$$1 = binex$$9.operand2.type;
            var field$$6 = new TypeScript$$25.ValueLocation;
            fieldSymbol$$4 = JAM.new(TypeScript$$25.FieldSymbol, [text$$24, id$$23.minChar, this.checker.locationInfo.unitIndex, true, field$$6]);
            fieldSymbol$$4.flags = fieldSymbol$$4.flags | TypeScript$$25.SymbolFlags.Property;
            field$$6.symbol = fieldSymbol$$4;
            var v3206 = fieldSymbol$$4;
            var v26828 = this.checker.getTypeCheckFinishedStatus();
            v3206.typeCheckStatus = v26828;
            var v3207 = field$$6;
            var v26829 = new TypeScript$$25.TypeLink;
            v3207.typeLink = v26829;
            field$$6.typeLink.type = memberType$$1;
            var v3209 = resultType$$2.members.publicMembers;
            JAM.call(v3209.add, v3209, [text$$24, fieldSymbol$$4])
          }
          fieldSymbol$$4.isObjectLitField = true;
          i$$107 = i$$107 + 1;
          v3211 = i$$107 < len$$52
        }
      }
      this.thisType = prevThisType$$3;
      objectLit$$2.type = resultType$$2;
      if(targetType$$5) {
        objectLit$$2.targetType = targetType$$5
      }
      return
    }
    function v1090(funcDecl$$32) {
      if(!funcDecl$$32.isAccessor()) {
        return null
      }
      if(JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$32.fncFlags, TypeScript$$25.FncFlags.GetAccessor])) {
        return funcDecl$$32.type.call.signatures[0].returnType.type
      }else {
        return funcDecl$$32.type.call.signatures[0].parameters[0].getType()
      }
      return
    }
    function v1089(ifStmt$$1) {
      var v3216 = ifStmt$$1;
      var v26830 = JAM.call(this.typeCheck, this, [ifStmt$$1.cond]);
      v3216.cond = v26830;
      JAM.call(this.typeCheckCondExpr, this, [ifStmt$$1.cond]);
      var v3218 = ifStmt$$1;
      var v26831 = JAM.call(this.typeCheck, this, [ifStmt$$1.thenBod]);
      v3218.thenBod = v26831;
      var v3219 = ifStmt$$1;
      var v26832 = JAM.call(this.typeCheck, this, [ifStmt$$1.elseBod]);
      v3219.elseBod = v26832;
      JAM.call(this.typeCheckCompoundStmtBlock, this, [ifStmt$$1.thenBod, "if statement"]);
      JAM.call(this.typeCheckCompoundStmtBlock, this, [ifStmt$$1.elseBod, "if statement"]);
      ifStmt$$1.type = this.voidType;
      return ifStmt$$1
    }
    function v1088(stmts$$3, stmtType) {
      var v13329 = this.checker.styleSettings.blockInCompoundStmt;
      if(v13329) {
        v13329 = stmts$$3
      }
      if(v13329) {
        if(stmts$$3.nodeType != TypeScript$$25.NodeType.Block) {
          var v3222 = this.checker.errorReporter;
          JAM.call(v3222.styleError, v3222, [stmts$$3, stmtType + " requires a block"])
        }
      }
      return
    }
    function v1087(cond$$3) {
      if(this.checker.styleSettings.assignmentInCond) {
        var v13334 = cond$$3 !== null;
        if(v13334) {
          var v19350 = cond$$3.nodeType >= TypeScript$$25.NodeType.Asg;
          if(v19350) {
            v19350 = cond$$3.nodeType <= TypeScript$$25.NodeType.LastAsg
          }
          v13334 = v19350
        }
        if(v13334) {
          var v3226 = this.checker.errorReporter;
          JAM.call(v3226.simpleError, v3226, [cond$$3, "top-level assignment statement in conditional expression"])
        }
      }
      return
    }
    function v1086(doWhileStmt) {
      var v3229 = doWhileStmt;
      var v26833 = JAM.call(this.typeCheck, this, [doWhileStmt.cond]);
      v3229.cond = v26833;
      JAM.call(this.typeCheckCondExpr, this, [doWhileStmt.cond]);
      var v3231 = doWhileStmt;
      var v26834 = JAM.call(this.typeCheck, this, [doWhileStmt.body]);
      v3231.body = v26834;
      JAM.call(this.typeCheckCompoundStmtBlock, this, [doWhileStmt.body, "do while statement"]);
      doWhileStmt.type = this.voidType;
      return doWhileStmt
    }
    function v1085(whileStmt$$1) {
      var v3233 = whileStmt$$1;
      var v26835 = JAM.call(this.typeCheck, this, [whileStmt$$1.cond]);
      v3233.cond = v26835;
      JAM.call(this.typeCheckCondExpr, this, [whileStmt$$1.cond]);
      var v3235 = whileStmt$$1;
      var v26836 = JAM.call(this.typeCheck, this, [whileStmt$$1.body]);
      v3235.body = v26836;
      JAM.call(this.typeCheckCompoundStmtBlock, this, [whileStmt$$1.body, "while statement"]);
      whileStmt$$1.type = this.voidType;
      return whileStmt$$1
    }
    function v1084(forInStmt$$1) {
      var v3237 = forInStmt$$1;
      var v26837 = JAM.call(this.typeCheck, this, [forInStmt$$1.obj]);
      v3237.obj = v26837;
      var v3238 = forInStmt$$1;
      var v26838 = JAM.call(this.cast, this, [JAM.call(this.typeCheck, this, [forInStmt$$1.lval]), this.checker.stringType]);
      v3238.lval = v26838;
      if(forInStmt$$1.lval.nodeType == TypeScript$$25.NodeType.VarDecl) {
        var varDecl$$19 = forInStmt$$1.lval;
        if(varDecl$$19.typeExpr) {
          var v3239 = this.checker.errorReporter;
          JAM.call(v3239.simpleError, v3239, [varDecl$$19, "Variable declarations for for/in expressions may not contain a type annotation"])
        }
        if(varDecl$$19.sym) {
          var v3241 = varDecl$$19.sym;
          JAM.call(v3241.setType, v3241, [this.checker.stringType])
        }
      }
      var v3245 = forInStmt$$1;
      var v26839 = JAM.call(this.typeCheck, this, [forInStmt$$1.body]);
      v3245.body = v26839;
      JAM.call(this.typeCheckCompoundStmtBlock, this, [forInStmt$$1.body, "for in statement"]);
      return forInStmt$$1
    }
    function v1083(withStmt$$2) {
      if(this.checker.errorsOnWith) {
        var v3247 = this.checker.errorReporter;
        JAM.call(v3247.simpleError, v3247, [withStmt$$2.expr, "All symbols within a 'with' block will be typed as 'any'"])
      }
      var v3250 = withStmt$$2;
      var v26840 = JAM.call(this.typeCheck, this, [withStmt$$2.expr]);
      v3250.expr = v26840;
      this.checker.inWith = true;
      var v3252 = withStmt$$2;
      var v26841 = JAM.call(this.typeCheck, this, [withStmt$$2.body]);
      v3252.body = v26841;
      JAM.call(this.typeCheckCompoundStmtBlock, this, [withStmt$$2.body, "with statement"]);
      this.checker.inWith = false;
      return withStmt$$2
    }
    function v1082(forStmt$$1) {
      var v3255 = forStmt$$1;
      var v26842 = JAM.call(this.typeCheck, this, [forStmt$$1.init]);
      v3255.init = v26842;
      this.nestingLevel = this.nestingLevel + 1;
      var v3256 = forStmt$$1;
      var v26843 = JAM.call(this.typeCheck, this, [forStmt$$1.cond]);
      v3256.cond = v26843;
      JAM.call(this.typeCheckCondExpr, this, [forStmt$$1.cond]);
      var v3258 = forStmt$$1;
      var v26844 = JAM.call(this.typeCheck, this, [forStmt$$1.incr]);
      v3258.incr = v26844;
      this.nestingLevel = this.nestingLevel - 1;
      var v3259 = forStmt$$1;
      var v26845 = JAM.call(this.typeCheck, this, [forStmt$$1.body]);
      v3259.body = v26845;
      JAM.call(this.typeCheckCompoundStmtBlock, this, [forStmt$$1.body, "for statement"]);
      forStmt$$1.type = this.voidType;
      return forStmt$$1
    }
    function v1081(moduleDecl$$7) {
      if(!moduleDecl$$7.mod) {
        return moduleDecl$$7
      }
      if(this.currentScript) {
        this.currentScript.requiresGlobal = true
      }
      var mod$$3 = moduleDecl$$7.mod;
      var sym$$43 = null;
      var prevScope$$6 = this.scope;
      var prevThisType$$2 = this.thisType;
      var prevCurrentModDecl$$1 = this.checker.currentModDecl;
      this.checker.currentModDecl = moduleDecl$$7;
      this.thisType = null;
      this.scope = mod$$3.containedScope;
      JAM.call(this.typeCheck, this, [moduleDecl$$7.members]);
      sym$$43 = mod$$3.symbol;
      this.checker.currentModDecl = prevCurrentModDecl$$1;
      this.thisType = prevThisType$$2;
      this.scope = prevScope$$6;
      moduleDecl$$7.type = mod$$3;
      if(sym$$43) {
        sym$$43.typeCheckStatus = TypeScript$$25.TypeCheckStatus.Finished
      }
      return moduleDecl$$7
    }
    function v1080(importDecl$$2) {
      var mod$$2 = importDecl$$2.alias.type;
      var sym$$42 = null;
      var prevInImportTC = this.inImportTypeCheck;
      this.inImportTypeCheck = true;
      JAM.call(this.typeCheck, this, [importDecl$$2.alias]);
      mod$$2 = importDecl$$2.alias.type;
      if(mod$$2 == null) {
        var v3272 = this.checker.errorReporter;
        JAM.call(v3272.simpleError, v3272, [importDecl$$2.alias, "Could not resolve module alias '" + importDecl$$2.id.actualText + "'"]);
        mod$$2 = this.checker.anyType;
        importDecl$$2.id.sym.type = mod$$2
      }
      importDecl$$2.id.type = mod$$2;
      sym$$42 = mod$$2.symbol;
      if(!mod$$2.isModuleType()) {
        var v3279 = this.checker.errorReporter;
        JAM.call(v3279.simpleError, v3279, [importDecl$$2.alias, "A module cannot be aliased to a non-module type"])
      }else {
        sym$$42.type = mod$$2;
        var v13364 = this.checker.typeFlow.currentScript;
        if(v13364) {
          var v19357 = this.checker.typeFlow.currentScript.topLevelMod;
          if(v19357) {
            v19357 = this.checker.typeFlow.currentScript.topLevelMod.mod
          }
          v13364 = v19357
        }
        if(v13364) {
          var v3281 = this.checker.typeFlow.currentScript.topLevelMod.mod.importedModules;
          JAM.call(v3281.push, v3281, [importDecl$$2])
        }
        importDecl$$2.id.sym.type = mod$$2;
        var v13367 = mod$$2.symbol;
        if(v13367) {
          v13367 = mod$$2.symbol.declAST
        }
        if(v13367) {
          var v3284 = mod$$2.symbol.declAST;
          v3284.modFlags = v3284.modFlags & ~TypeScript$$25.ModuleFlags.ShouldEmitModuleDecl
        }
      }
      this.inImportTypeCheck = prevInImportTC;
      return importDecl$$2
    }
    function v1079(interfaceDecl$$6) {
      JAM.call(this.typeCheckBases, this, [interfaceDecl$$6.type]);
      JAM.call(this.typeCheckBaseListPrivacy, this, [interfaceDecl$$6.extendsList, interfaceDecl$$6.type.symbol, true]);
      JAM.call(this.typeCheck, this, [interfaceDecl$$6.members]);
      JAM.call(this.checkBaseTypeMemberInheritance, this, [interfaceDecl$$6.type, interfaceDecl$$6]);
      if(interfaceDecl$$6.extendsList) {
        var i$$106 = 0;
        var v3304 = i$$106 < interfaceDecl$$6.extendsList.members.length;
        for(;v3304;) {
          var v23081 = interfaceDecl$$6.extendsList.members;
          introspect(JAM.policy.p1) {
            var v19363 = v23081[i$$106]
          }
          if(v19363.type.call) {
            if(interfaceDecl$$6.type.call) {
              var v3292 = interfaceDecl$$6.type.call;
              var v13374 = interfaceDecl$$6.type.call.signatures;
              var v25782 = interfaceDecl$$6.extendsList.members;
              introspect(JAM.policy.p1) {
                var v24887 = v25782[i$$106]
              }
              var v26846 = v13374.concat(v24887.type.call.signatures);
              v3292.signatures = v26846
            }else {
              var v3293 = interfaceDecl$$6.type;
              var v23084 = interfaceDecl$$6.extendsList.members;
              introspect(JAM.policy.p1) {
                var v19366 = v23084[i$$106]
              }
              v3293.call = v19366.type.call
            }
          }
          var v23085 = interfaceDecl$$6.extendsList.members;
          introspect(JAM.policy.p1) {
            var v19367 = v23085[i$$106]
          }
          if(v19367.type.construct) {
            if(interfaceDecl$$6.type.construct) {
              var v3296 = interfaceDecl$$6.type.construct;
              var v13380 = interfaceDecl$$6.type.construct.signatures;
              var v25783 = interfaceDecl$$6.extendsList.members;
              introspect(JAM.policy.p1) {
                var v24890 = v25783[i$$106]
              }
              var v26847 = v13380.concat(v24890.type.construct.signatures);
              v3296.signatures = v26847
            }else {
              var v3297 = interfaceDecl$$6.type;
              var v23088 = interfaceDecl$$6.extendsList.members;
              introspect(JAM.policy.p1) {
                var v19370 = v23088[i$$106]
              }
              v3297.construct = v19370.type.construct
            }
          }
          var v23089 = interfaceDecl$$6.extendsList.members;
          introspect(JAM.policy.p1) {
            var v19371 = v23089[i$$106]
          }
          if(v19371.type.index) {
            if(interfaceDecl$$6.type.index) {
              var v3300 = interfaceDecl$$6.type.index;
              var v13386 = interfaceDecl$$6.type.index.signatures;
              var v25784 = interfaceDecl$$6.extendsList.members;
              introspect(JAM.policy.p1) {
                var v24893 = v25784[i$$106]
              }
              var v26848 = v13386.concat(v24893.type.index.signatures);
              v3300.signatures = v26848
            }else {
              var v3301 = interfaceDecl$$6.type;
              var v23092 = interfaceDecl$$6.extendsList.members;
              introspect(JAM.policy.p1) {
                var v19374 = v23092[i$$106]
              }
              v3301.index = v19374.type.index
            }
          }
          i$$106 = i$$106 + 1;
          v3304 = i$$106 < interfaceDecl$$6.extendsList.members.length
        }
      }
      return interfaceDecl$$6
    }
    function v1078(type$$54, ast$$107) {
      if(type$$54.call) {
        var v3306 = type$$54.call;
        JAM.call(v3306.typeCheck, v3306, [this.checker, ast$$107, type$$54.construct != null])
      }
      if(type$$54.construct) {
        var v3310 = type$$54.construct;
        JAM.call(v3310.typeCheck, v3310, [this.checker, ast$$107, false])
      }
      if(type$$54.index) {
        var v3313 = type$$54.index;
        JAM.call(v3313.typeCheck, v3313, [this.checker, ast$$107, false])
      }
      return
    }
    function v1077(classDecl$$9) {
      var typeSymbol$$6 = classDecl$$9.type.symbol;
      if(typeSymbol$$6.typeCheckStatus == TypeScript$$25.TypeCheckStatus.Finished) {
        return classDecl$$9
      }else {
        if(typeSymbol$$6.typeCheckStatus == TypeScript$$25.TypeCheckStatus.Started) {
          return classDecl$$9
        }else {
          typeSymbol$$6.typeCheckStatus = TypeScript$$25.TypeCheckStatus.Started;
          var v3318 = this.checker;
          JAM.call(v3318.addStartedPTO, v3318, [typeSymbol$$6])
        }
      }
      var prevScope$$5 = this.scope;
      var svClassNode$$1 = this.thisClassNode;
      this.thisClassNode = classDecl$$9;
      var classType$$6 = classDecl$$9.type;
      JAM.call(this.typeCheckBases, this, [classType$$6.instanceType]);
      JAM.call(this.typeCheckBaseListPrivacy, this, [classDecl$$9.extendsList, typeSymbol$$6, true]);
      JAM.call(this.typeCheckBaseListPrivacy, this, [classDecl$$9.implementsList, typeSymbol$$6, false]);
      var prevThisType$$1 = this.thisType;
      this.thisType = classType$$6.instanceType;
      this.scope = classType$$6.instanceType.containedScope;
      if(classDecl$$9.constructorDecl) {
        this.scope = classType$$6.instanceType.constructorScope;
        var ssb$$1 = this.scope;
        var funcTable$$2 = ssb$$1.valueMembers.allMembers;
        JAM.call(this.addConstructorLocalArgs, this, [classDecl$$9.constructorDecl.type.symbol, classDecl$$9.constructorDecl.arguments, funcTable$$2, true])
      }
      JAM.call(this.typeCheck, this, [classDecl$$9.members]);
      typeSymbol$$6.typeCheckStatus = TypeScript$$25.TypeCheckStatus.Finished;
      JAM.call(this.checkBaseTypeMemberInheritance, this, [classType$$6, classDecl$$9]);
      JAM.call(this.checkMembersImplementInterfaces, this, [classType$$6]);
      JAM.call(this.typeCheckOverloadSignatures, this, [classType$$6, classDecl$$9]);
      JAM.call(this.typeCheckOverloadSignatures, this, [classType$$6.instanceType, classDecl$$9]);
      if(!classDecl$$9.constructorDecl) {
        var v13398 = classDecl$$9.extendsList;
        if(v13398) {
          var v19379 = classDecl$$9.extendsList.members.length;
          if(v19379) {
            var v23095 = classDecl$$9.extendsList.members[0].type;
            if(v23095) {
              v23095 = classDecl$$9.extendsList.members[0].type.symbol.type.isClass()
            }
            v19379 = v23095
          }
          v13398 = v19379
        }
        if(v13398) {
          JAM.call(TypeScript$$25.cloneParentConstructGroupForChildType, TypeScript$$25, [classDecl$$9.type, classDecl$$9.extendsList.members[0].type.symbol.type])
        }
      }
      this.thisType = prevThisType$$1;
      this.thisClassNode = svClassNode$$1;
      this.scope = prevScope$$5;
      return classDecl$$9
    }
    function v1076(derivedType, derivedTypeDecl) {
      function v1075(key$$45, s$$28, c$$12) {
        var sym$$41 = s$$28;
        var j$$16 = 0;
        var v3349 = j$$16 < len$$51;
        for(;v3349;) {
          var v3337 = instanceType$$6.extendsList;
          introspect(JAM.policy.p1) {
            var base$$3 = v3337[j$$16]
          }
          if(base$$3.memberScope == null) {
            var v3338 = _this$$12.checker.errorReporter;
            JAM.call(v3338.simpleError, v3338, [derivedTypeDecl, "Base type '" + base$$3.symbol.name + "' lacks an implementation."])
          }else {
            var v3340 = base$$3.memberScope;
            var bSym = JAM.call(v3340.find, v3340, [sym$$41.name, false, false]);
            if(bSym) {
              var aType = sym$$41.getType();
              var bType = bSym.getType();
              var v19382 = _this$$12.checker;
              if(!JAM.call(v19382.sourceIsSubtypeOfTarget, v19382, [aType, bType])) {
                var v3342 = _this$$12.checker.errorReporter;
                JAM.call(v3342.simpleErrorFromSym, v3342, [sym$$41, "Type of overridden member '" + sym$$41.name + "' is not subtype of original member defined by type '" + bSym.container.name + "'"])
              }else {
                var v13406 = sym$$41.kind() == TypeScript$$25.SymbolKind.Type;
                if(v13406) {
                  v13406 = bSym.kind() == TypeScript$$25.SymbolKind.Field
                }
                if(v13406) {
                  var v3344 = _this$$12.checker.errorReporter;
                  JAM.call(v3344.simpleErrorFromSym, v3344, [sym$$41, "Cannot override field '" + sym$$41.name + "' with method"])
                }
              }
            }
          }
          j$$16 = j$$16 + 1;
          v3349 = j$$16 < len$$51
        }
        return
      }
      var _this$$12 = this;
      var instanceType$$6 = derivedType.getInstanceType();
      if(instanceType$$6.extendsList == null) {
        return
      }
      var len$$51 = instanceType$$6.extendsList.length;
      if(len$$51 > 0) {
        var names$$1 = new TypeScript$$25.StringHashTable;
        if(instanceType$$6.isClassInstance()) {
          var i$$105 = 0;
          var v3355 = i$$105 < len$$51;
          for(;v3355;) {
            var v13410 = instanceType$$6.extendsList;
            introspect(JAM.policy.p1) {
              var v3353 = v13410[i$$105]
            }
            JAM.call(this.assertUniqueNamesInBaseTypes, this, [names$$1, v3353, derivedTypeDecl, i$$105 > 0]);
            i$$105 = i$$105 + 1;
            v3355 = i$$105 < len$$51
          }
        }
        if(instanceType$$6.members) {
          var v3357 = instanceType$$6.members.publicMembers;
          JAM.call(v3357.map, v3357, [v1075, null])
        }
      }
      return
    }
    function v1074(names, type$$53, classDecl$$8, checkUnique) {
      function v1073(key$$44, s$$27, c$$11) {
        var sym$$40 = s$$27;
        var dup = JAM.call(names.lookup, names, [sym$$40.name]);
        if(dup) {
          if(checkUnique) {
            var v3361 = _this$$11.checker.errorReporter;
            JAM.call(v3361.simpleError, v3361, [classDecl$$8, "duplicate member name in bases for " + classDecl$$8.name.actualText + ": " + type$$53.symbol.name + " and " + dup.container.name + " both contain member with name " + sym$$40.name])
          }
        }else {
          JAM.call(names.add, names, [sym$$40.name, sym$$40])
        }
        return
      }
      var _this$$11 = this;
      if(type$$53) {
        if(type$$53.members) {
          var v3364 = type$$53.members.publicMembers;
          JAM.call(v3364.map, v3364, [v1073, null])
        }
        if(type$$53.extendsList) {
          var len$$50 = type$$53.extendsList.length;
          var i$$104 = 0;
          var v3369 = i$$104 < len$$50;
          for(;v3369;) {
            var v25790 = type$$53.extendsList;
            introspect(JAM.policy.p1) {
              var v24902 = v25790[i$$104]
            }
            if(!(v24902.symbol.flags & TypeScript$$25.SymbolFlags.RecursivelyReferenced)) {
              var v13417 = type$$53.extendsList;
              introspect(JAM.policy.p1) {
                var v3367 = v13417[i$$104]
              }
              JAM.call(this.assertUniqueNamesInBaseTypes, this, [names, v3367, classDecl$$8, checkUnique])
            }
            i$$104 = i$$104 + 1;
            v3369 = i$$104 < len$$50
          }
        }
      }
      return
    }
    function v1072(bases$$7) {
      if(bases$$7 == null) {
        return
      }
      var basesLen$$2 = bases$$7.members.length;
      var i$$103 = 0;
      var v3375 = i$$103 < basesLen$$2;
      for(;v3375;) {
        var v3373 = bases$$7.members;
        introspect(JAM.policy.p1) {
          var baseExpr$$2 = v3373[i$$103]
        }
        var baseSymbol$$3 = null;
        if(baseExpr$$2.nodeType == TypeScript$$25.NodeType.Call) {
          JAM.call(this.typeCheckNew, this, [baseExpr$$2])
        }
        i$$103 = i$$103 + 1;
        v3375 = i$$103 < basesLen$$2
      }
      return
    }
    function v1071(implementingType) {
      var instanceType$$5 = implementingType.getInstanceType();
      if(instanceType$$5.implementsList) {
        var len$$49 = instanceType$$5.implementsList.length;
        var i$$102 = 0;
        var v3387 = i$$102 < len$$49;
        for(;v3387;) {
          var v3377 = instanceType$$5.implementsList;
          introspect(JAM.policy.p1) {
            var interfaceType$$3 = v3377[i$$102]
          }
          var comparisonInfo$$13 = new TypeScript$$25.TypeComparisonInfo;
          var v19394 = this.checker;
          if(!JAM.call(v19394.sourceIsSubtypeOfTarget, v19394, [instanceType$$5, interfaceType$$3, comparisonInfo$$13])) {
            var emsg$$1 = "Class '" + instanceType$$5.getTypeName() + "' declares interface '" + interfaceType$$3.getTypeName() + "' but does not implement it";
            if(!comparisonInfo$$13.message) {
              var v3380 = this.checker.errorReporter;
              JAM.call(v3380.simpleErrorFromSym, v3380, [instanceType$$5.symbol, emsg$$1])
            }else {
              var v3382 = this.checker.errorReporter;
              JAM.call(v3382.simpleErrorFromSym, v3382, [instanceType$$5.symbol, emsg$$1 + ": " + comparisonInfo$$13.message])
            }
          }
          i$$102 = i$$102 + 1;
          v3387 = i$$102 < len$$49
        }
      }
      return
    }
    function v1070(type$$52) {
      var seenInterface = false;
      var bases$$6 = type$$52.extendsList;
      var baseLinks = type$$52.extendsTypeLinks;
      if(bases$$6) {
        var len$$48 = bases$$6.length;
        if(len$$48 > 0) {
          type$$52.typeFlags = type$$52.typeFlags | TypeScript$$25.TypeFlags.HasBaseType
        }
        var i$$101 = 0;
        var v3413 = i$$101 < len$$48;
        for(;v3413;) {
          introspect(JAM.policy.p1) {
            var v13430 = bases$$6[i$$101]
          }
          if(v13430 == this.checker.anyType) {
            introspect(JAM.policy.p1) {
              var v3390 = baseLinks[i$$101]
            }
            v3390.type = null;
            var oldErrors = this.checker.errorReporter.errorSink;
            var v3392 = TypeScript$$25.CompilerDiagnostics;
            JAM.call(v3392.assert, v3392, [oldErrors.length == 0, "There shouldnt be any contextual errors when typechecking base type names"]);
            this.checker.errorReporter.pushToErrorSink = true;
            var v3395 = bases$$6;
            var v3396 = i$$101;
            var v13435 = this.checker;
            introspect(JAM.policy.p1) {
              var v13436 = baseLinks[i$$101]
            }
            var v26849 = JAM.call(v13435.resolveBaseTypeLink, v13435, [v13436, type$$52.containedScope]);
            v3395[v3396] = v26849;
            this.checker.errorReporter.pushToErrorSink = false;
            this.checker.errorReporter.freeCapturedErrors()
          }
          introspect(JAM.policy.p1) {
            var base$$2 = bases$$6[i$$101]
          }
          introspect(JAM.policy.p1) {
            var v3400 = baseLinks[i$$101]
          }
          var baseRef$$1 = v3400.ast;
          var v3401 = base$$2.symbol;
          if(v3401) {
            var v13440 = base$$2.symbol.name == "Object";
            if(v13440) {
              v13440 = base$$2.symbol.container == this.checker.gloMod
            }
            v3401 = v13440
          }
          var baseTypeOfObject = v3401;
          if(baseTypeOfObject) {
            type$$52.typeFlags = type$$52.typeFlags | TypeScript$$25.TypeFlags.HasBaseTypeOfObject
          }
          if(base$$2.isClassInstance()) {
            if(!type$$52.isClassInstance()) {
              var v3402 = this.checker.errorReporter;
              JAM.call(v3402.simpleError, v3402, [baseRef$$1, "Interface base type must be interface"])
            }else {
              if(seenInterface) {
                var v3403 = this.checker.errorReporter;
                JAM.call(v3403.simpleError, v3403, [baseRef$$1, "Class may not follow interface as base type"])
              }
            }
          }else {
            if(base$$2.isModuleType()) {
              var v3405 = this.checker.errorReporter;
              JAM.call(v3405.simpleError, v3405, [baseRef$$1, "Types may not be derived from module types"])
            }else {
              if(base$$2.members) {
                if(!seenInterface) {
                  seenInterface = true
                }
              }else {
                if(!type$$52.isClassInstance()) {
                  var v3407 = this.checker.errorReporter;
                  JAM.call(v3407.simpleError, v3407, [baseRef$$1, "Interface base type must be interface"])
                }else {
                  var v3408 = this.checker.errorReporter;
                  JAM.call(v3408.simpleError, v3408, [baseRef$$1, "Base type must be interface or class"])
                }
                break
              }
            }
          }
          i$$101 = i$$101 + 1;
          v3413 = i$$101 < len$$48
        }
      }
      return
    }
    function v1069(funcDecl$$31) {
      function v1068(typeName$$10, isModuleName$$9) {
        return JAM.call(_this$$10.functionReturnTypePrivacyErrorReporter, _this$$10, [funcDecl$$31, signature$$10, typeName$$10, isModuleName$$9])
      }
      function v1067(index$$58) {
        var v13450 = funcDecl$$31.returnStatementsWithExpressions;
        introspect(JAM.policy.p1) {
          var v3414 = v13450[index$$58]
        }
        return v3414.type
      }
      function v1066(index$$57, type$$51) {
        var v13451 = funcDecl$$31.returnStatementsWithExpressions;
        introspect(JAM.policy.p1) {
          var v3415 = v13451[index$$57]
        }
        v3415.type = type$$51;
        return
      }
      function v1065() {
        return funcDecl$$31.returnStatementsWithExpressions.length
      }
      function v1064(sym$$39) {
        return sym$$39.kind() == TypeScript$$25.SymbolKind.Parameter
      }
      function v1063(typeName$$9, isModuleName$$8) {
        var v13453 = signature$$10.parameters;
        introspect(JAM.policy.p1) {
          var v3419 = v13453[p$$1]
        }
        return JAM.call(_this$$10.functionArgumentPrivacyErrorReporter, _this$$10, [funcDecl$$31, p$$1, v3419, typeName$$9, isModuleName$$8])
      }
      function v1062(typeName$$8, isModuleName$$7) {
        return JAM.call(_this$$10.functionArgumentPrivacyErrorReporter, _this$$10, [funcDecl$$31, p$$1, symbol$$21, typeName$$8, isModuleName$$7])
      }
      var _this$$10 = this;
      this.nestingLevel = 0;
      var fnType = funcDecl$$31.type;
      var fgSym$$4 = fnType.symbol;
      var signature$$10 = funcDecl$$31.signature;
      var v13454 = this.checker;
      if(JAM.call(v13454.typeStatusIsFinished, v13454, [signature$$10.typeCheckStatus])) {
        return funcDecl$$31
      }else {
        if(signature$$10.typeCheckStatus == TypeScript$$25.TypeCheckStatus.Started) {
          var v13458 = !funcDecl$$31.returnTypeAnnotation;
          if(v13458) {
            var v19404 = funcDecl$$31.bod;
            if(v19404) {
              var v23110 = !funcDecl$$31.isSignature();
              if(v23110) {
                var v24904 = !funcDecl$$31.isConstructor;
                if(v24904) {
                  v24904 = JAM.call(this.allReturnsAreVoid, this, [funcDecl$$31])
                }
                v23110 = v24904
              }
              v19404 = v23110
            }
            v13458 = v19404
          }
          if(v13458) {
            signature$$10.returnType.type = this.voidType;
            return funcDecl$$31
          }else {
            if(funcDecl$$31.returnTypeAnnotation == null) {
              if(this.checker.styleSettings.implicitAny) {
                var v3421 = this.checker.errorReporter;
                JAM.call(v3421.styleError, v3421, [funcDecl$$31, "type implicitly set to 'any'"])
              }
              signature$$10.returnType.type = this.anyType;
              fgSym$$4.flags = fgSym$$4.flags | TypeScript$$25.SymbolFlags.RecursivelyReferenced
            }
            return funcDecl$$31
          }
        }
      }
      signature$$10.typeCheckStatus = TypeScript$$25.TypeCheckStatus.Started;
      var v3429 = this.checker;
      JAM.call(v3429.addStartedPTO, v3429, [signature$$10]);
      var prevScope$$4 = this.scope;
      var prevFnc = this.thisFnc;
      var prevMethodStatus$$2 = this.enclosingFncIsMethod;
      var prevClassNode = this.thisClassNode;
      var v3430 = funcDecl$$31.isMethod();
      if(!v3430) {
        v3430 = funcDecl$$31.isConstructor
      }
      this.enclosingFncIsMethod = v3430;
      this.thisFnc = funcDecl$$31;
      var container$$21 = funcDecl$$31.type.symbol;
      var prevThisType = this.thisType;
      var prevLocationInfo$$2 = this.checker.locationInfo;
      var funcTable$$1 = null;
      var acceptedContextualType = false;
      var targetParams = null;
      var targetReturnType$$1 = null;
      var v3433 = funcDecl$$31.isAccessor();
      if(v3433) {
        v3433 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.fncFlags, TypeScript$$25.FncFlags.GetAccessor])
      }
      var isGetter$$4 = v3433;
      var v3434 = funcDecl$$31.isAccessor();
      if(v3434) {
        v3434 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.fncFlags, TypeScript$$25.FncFlags.SetAccessor])
      }
      var isSetter$$4 = v3434;
      var v3435;
      var v19409 = isGetter$$4 || isSetter$$4;
      if(v19409) {
        v19409 = funcDecl$$31.accessorSymbol
      }
      if(v19409) {
        v3435 = funcDecl$$31.accessorSymbol.getType()
      }else {
        v3435 = null
      }
      var accessorType = v3435;
      var prevModDecl$$1 = this.checker.currentModDecl;
      var v13471 = funcDecl$$31.isConstructor;
      if(v13471) {
        v13471 = !funcDecl$$31.isOverload
      }
      if(v13471) {
        if(fnType.instanceType == null) {
          var v3437 = this.checker.errorReporter;
          JAM.call(v3437.simpleError, v3437, [funcDecl$$31, "Malformed function body (is this a class named the same as an existing interface?)"]);
          return funcDecl$$31
        }
        this.scope = fnType.instanceType.constructorScope;
        var ssb = this.scope;
        funcTable$$1 = ssb.valueMembers.allMembers
      }else {
        var v19411 = funcDecl$$31.isSpecialFn();
        if(v19411) {
          v19411 = !(funcDecl$$31.fncFlags & TypeScript$$25.FncFlags.Signature)
        }
        var v13474 = v19411;
        if(!v13474) {
          v13474 = funcDecl$$31.isOverload
        }
        if(v13474) {
          funcTable$$1 = funcDecl$$31.symbols;
          var v13475 = !JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.fncFlags, TypeScript$$25.FncFlags.Static]);
          if(v13475) {
            v13475 = fnType.containedScope
          }
          if(v13475) {
            this.scope = fnType.containedScope
          }
        }else {
          if(funcDecl$$31.bod) {
            this.scope = fnType.containedScope
          }
          ssb = this.scope;
          var v13476 = ssb;
          if(v13476) {
            v13476 = ssb.valueMembers
          }
          if(v13476) {
            funcTable$$1 = ssb.valueMembers.allMembers
          }
        }
      }
      var v13477 = funcDecl$$31.isConstructor;
      if(v13477) {
        var v19414 = funcDecl$$31.bod;
        if(v19414) {
          v19414 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.fncFlags, TypeScript$$25.FncFlags.ClassMethod])
        }
        v13477 = v19414
      }
      if(v13477) {
        var hasBaseType = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.classDecl.type.instanceType.typeFlags, TypeScript$$25.TypeFlags.HasBaseType]);
        var v3449 = !hasBaseType;
        if(!v3449) {
          v3449 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.classDecl.type.instanceType.typeFlags, TypeScript$$25.TypeFlags.HasBaseTypeOfObject])
        }
        var noSuperCallAllowed = v3449;
        var superCallMustBeFirst = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.classDecl.varFlags, TypeScript$$25.VarFlags.ClassSuperMustBeFirstCallInConstructor]);
        var v13485 = noSuperCallAllowed;
        if(v13485) {
          v13485 = JAM.call(this.classConstructorHasSuperCall, this, [funcDecl$$31])
        }
        if(v13485) {
          var v3452 = this.checker.errorReporter;
          JAM.call(v3452.simpleError, v3452, [funcDecl$$31, "Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class"])
        }else {
          if(hasBaseType) {
            if(superCallMustBeFirst) {
              var v13487 = !funcDecl$$31.bod;
              if(!v13487) {
                var v19419 = !funcDecl$$31.bod.members.length;
                if(!v19419) {
                  var v25794 = funcDecl$$31.bod.members[0].nodeType == TypeScript$$25.NodeType.Call;
                  if(v25794) {
                    v25794 = funcDecl$$31.bod.members[0].target.nodeType == TypeScript$$25.NodeType.Super
                  }
                  var v24911 = v25794;
                  if(!v24911) {
                    var v25795 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.bod.flags, TypeScript$$25.ASTFlags.StrictMode]);
                    if(v25795) {
                      var v26284 = funcDecl$$31.bod.members.length > 1;
                      if(v26284) {
                        var v26524 = funcDecl$$31.bod.members[1].nodeType == TypeScript$$25.NodeType.Call;
                        if(v26524) {
                          v26524 = funcDecl$$31.bod.members[1].target.nodeType == TypeScript$$25.NodeType.Super
                        }
                        v26284 = v26524
                      }
                      v25795 = v26284
                    }
                    v24911 = v25795
                  }
                  v19419 = !v24911
                }
                v13487 = v19419
              }
              if(v13487) {
                var v3453 = this.checker.errorReporter;
                JAM.call(v3453.simpleError, v3453, [funcDecl$$31, "If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor"])
              }
            }else {
              if(!JAM.call(this.classConstructorHasSuperCall, this, [funcDecl$$31])) {
                var v3455 = this.checker.errorReporter;
                JAM.call(v3455.simpleError, v3455, [funcDecl$$31, "Constructors for derived classes must contain a call to the class's 'super' constructor"])
              }
            }
          }
        }
      }
      var v13491 = funcDecl$$31.isMethod();
      if(v13491) {
        v13491 = funcDecl$$31.type.enclosingType
      }
      if(v13491) {
        var enclosingClassNode = null;
        if(funcDecl$$31.type.enclosingType.symbol.declAST.nodeType == TypeScript$$25.NodeType.FuncDecl) {
          enclosingClassNode = funcDecl$$31.type.enclosingType.symbol.declAST.classDecl
        }else {
          if(funcDecl$$31.type.enclosingType.symbol.declAST.nodeType == TypeScript$$25.NodeType.ClassDeclaration) {
            enclosingClassNode = funcDecl$$31.type.enclosingType.symbol.declAST
          }
        }
        if(enclosingClassNode) {
          this.thisClassNode = enclosingClassNode
        }
      }
      if(fnType.enclosingType) {
        var enclosingSym = fnType.symbol.container;
        var v13498 = enclosingSym;
        if(v13498) {
          var v19428 = enclosingSym.isType();
          if(v19428) {
            v19428 = enclosingSym.getType().isClass()
          }
          v13498 = v19428
        }
        if(v13498) {
          enclosingSym = enclosingSym.container
        }
        var v13499 = enclosingSym;
        if(v13499) {
          var v19429 = enclosingSym.declAST;
          if(v19429) {
            v19429 = enclosingSym.declAST.nodeType == TypeScript$$25.NodeType.ModuleDeclaration
          }
          v13499 = v19429
        }
        if(v13499) {
          this.checker.currentModDecl = enclosingSym.declAST
        }
      }
      if(funcDecl$$31.unitIndex > 0) {
        var v13501 = this.checker.units;
        if(v13501) {
          v13501 = funcDecl$$31.unitIndex < this.checker.units.length
        }
        if(v13501) {
          var v3469 = this.checker;
          var v13502 = this.checker.units;
          var v13503 = funcDecl$$31.unitIndex;
          introspect(JAM.policy.p1) {
            v3469.locationInfo = v13502[v13503]
          }
        }else {
          this.checker.locationInfo = TypeScript$$25.unknownLocationInfo
        }
      }
      if(fnType.enclosingType) {
        this.thisType = fnType.enclosingType
      }else {
        this.thisType = prevThisType
      }
      var paramLen$$4 = signature$$10.parameters.length;
      var v13504 = !funcDecl$$31.isConstructor;
      if(v13504) {
        var v19435 = funcDecl$$31.bod;
        if(v19435) {
          v19435 = !funcDecl$$31.isSignature()
        }
        v13504 = v19435
      }
      if(v13504) {
        var tmpParamScope = this.scope;
        ssb = this.scope;
        var v13505 = !funcDecl$$31.isMethod();
        if(v13505) {
          v13505 = funcDecl$$31.returnTypeAnnotation == null
        }
        if(v13505) {
          var v13506 = prevScope$$4;
          if(v13506) {
            var v19438 = funcDecl$$31.name;
            if(v19438) {
              v19438 = !funcDecl$$31.name.isMissing()
            }
            v13506 = v19438
          }
          if(v13506) {
            var considerSym = JAM.call(prevScope$$4.findAmbient, prevScope$$4, [funcDecl$$31.name.text, false, false]);
            var v13508 = considerSym;
            if(v13508) {
              var v19439 = considerSym.declAST;
              if(v19439) {
                v19439 = considerSym.declAST.type
              }
              v13508 = v19439
            }
            if(v13508) {
              var v3476 = this.checker;
              JAM.call(v3476.setContextualType, v3476, [considerSym.declAST.type, false])
            }
          }
          if(this.checker.hasTargetType()) {
            var candidateTypeContext = this.checker.currentContextualTypeContext;
            var candidateType$$1 = candidateTypeContext.contextualType;
            var v13511 = this.checker;
            if(JAM.call(v13511.canContextuallyTypeFunction, v13511, [candidateType$$1, funcDecl$$31, true])) {
              var v3481;
              if(candidateType$$1.construct) {
                v3481 = candidateType$$1.construct
              }else {
                v3481 = candidateType$$1.call
              }
              var candidateSigs$$1 = v3481;
              candidateTypeContext.targetSig = candidateSigs$$1.signatures[0];
              var candidateParams = candidateTypeContext.targetSig.parameters;
              targetParams = candidateParams;
              targetReturnType$$1 = candidateTypeContext.targetSig.returnType.type;
              if(candidateTypeContext.targetSig.declAST) {
                if(candidateTypeContext.targetSig.declAST.isConstructor) {
                  funcDecl$$31.isTargetTypedAsMethod = true
                }else {
                  if(candidateTypeContext.targetSig.declAST.isMethod()) {
                    funcDecl$$31.isTargetTypedAsMethod = true
                  }
                }
              }
              fgSym$$4.type = candidateTypeContext.contextualType;
              acceptedContextualType = true
            }else {
              var v13517 = candidateType$$1;
              if(v13517) {
                v13517 = funcDecl$$31.isAccessor()
              }
              if(v13517) {
                accessorType = candidateType$$1;
                candidateTypeContext.targetAccessorType = accessorType
              }else {
                this.checker.killCurrentContextualType()
              }
            }
          }
        }
        var paramTable = ssb.valueMembers;
        var v26850 = JAM.new(TypeScript$$25.SymbolScopeBuilder, [paramTable, null, null, null, prevScope$$4, container$$21]);
        this.scope = v26850;
        var p$$1 = 0;
        var v3506 = p$$1 < paramLen$$4;
        for(;v3506;) {
          var v3494 = signature$$10.parameters;
          introspect(JAM.policy.p1) {
            var symbol$$21 = v3494[p$$1]
          }
          var ast$$106 = symbol$$21.declAST;
          var v13518 = this.checker.hasTargetType();
          if(v13518) {
            var v19443 = targetParams;
            if(v19443) {
              var v23131 = this.checker.currentContextualTypeContext.targetSig.hasVariableArgList;
              if(!v23131) {
                v23131 = p$$1 < targetParams.length
              }
              v19443 = v23131
            }
            v13518 = v19443
          }
          if(v13518) {
            candidateTypeContext = this.checker.currentContextualTypeContext;
            var hasVarArgList = candidateTypeContext.targetSig.hasVariableArgList;
            var v3497 = ast$$106;
            var v13519;
            var v23132 = hasVarArgList;
            if(v23132) {
              v23132 = p$$1 >= targetParams.length - 1
            }
            if(v23132) {
              var v24922 = targetParams.length - 1;
              introspect(JAM.policy.p1) {
                var v23133 = targetParams[v24922]
              }
              v13519 = v23133.getType().elementType
            }else {
              introspect(JAM.policy.p1) {
                var v19445 = targetParams[p$$1]
              }
              v13519 = v19445.getType()
            }
            v3497.type = v13519;
            var v3498 = ast$$106.sym;
            JAM.call(v3498.setType, v3498, [ast$$106.type]);
            var v3500 = ast$$106.sym;
            var v26851 = this.checker.getTypeCheckFinishedStatus();
            v3500.typeCheckStatus = v26851
          }else {
            JAM.call(this.typeCheck, this, [ast$$106])
          }
          if(isSetter$$4 && accessorType) {
            ast$$106 = JAM.call(this.cast, this, [ast$$106, accessorType])
          }
          symbol$$21.container = container$$21;
          JAM.call(this.checkTypePrivacy, this, [symbol$$21.getType(), container$$21, v1062]);
          var v3504 = paramTable.publicMembers;
          JAM.call(v3504.add, v3504, [symbol$$21.name, symbol$$21]);
          p$$1 = p$$1 + 1;
          v3506 = p$$1 < paramLen$$4
        }
        this.scope = tmpParamScope
      }else {
        JAM.call(this.typeCheck, this, [funcDecl$$31.arguments]);
        p$$1 = 0;
        var v3513 = p$$1 < paramLen$$4;
        for(;v3513;) {
          var v23134 = signature$$10.parameters;
          introspect(JAM.policy.p1) {
            var v19447 = v23134[p$$1]
          }
          var v3508 = v19447.parameter.typeLink;
          var v19448 = funcDecl$$31.arguments.members;
          introspect(JAM.policy.p1) {
            var v13522 = v19448[p$$1]
          }
          v3508.type = v13522.type;
          var v19449 = signature$$10.parameters;
          introspect(JAM.policy.p1) {
            var v13523 = v19449[p$$1]
          }
          JAM.call(this.checkTypePrivacy, this, [v13523.getType(), container$$21, v1063]);
          var v19450 = funcDecl$$31.arguments.members;
          introspect(JAM.policy.p1) {
            var v13524 = v19450[p$$1]
          }
          if(v13524.parameterPropertySym) {
            var v19451 = funcDecl$$31.arguments.members;
            introspect(JAM.policy.p1) {
              var v13525 = v19451[p$$1]
            }
            var v3510 = v13525.parameterPropertySym;
            var v19452 = funcDecl$$31.arguments.members;
            introspect(JAM.policy.p1) {
              var v13526 = v19452[p$$1]
            }
            JAM.call(v3510.setType, v3510, [v13526.type])
          }
          p$$1 = p$$1 + 1;
          v3513 = p$$1 < paramLen$$4
        }
        if(funcDecl$$31.fncFlags & TypeScript$$25.FncFlags.IndexerMember) {
          var v13529 = !paramLen$$4;
          if(!v13529) {
            v13529 = paramLen$$4 > 1
          }
          if(v13529) {
            var v3514 = this.checker.errorReporter;
            JAM.call(v3514.simpleError, v3514, [funcDecl$$31, "Index signatures may take one and only one parameter"])
          }else {
            if(funcDecl$$31.arguments.members[0].type == this.checker.numberType) {
              var v3515 = fnType.index;
              v3515.flags = v3515.flags | TypeScript$$25.SignatureFlags.IsNumberIndexer
            }else {
              if(funcDecl$$31.arguments.members[0].type == this.checker.stringType) {
                var v3516 = fnType.index;
                v3516.flags = v3516.flags | TypeScript$$25.SignatureFlags.IsStringIndexer
              }else {
                var v3517 = this.checker.errorReporter;
                JAM.call(v3517.simpleError, v3517, [funcDecl$$31.arguments.members[0], "Index signatures may only take 'string' or 'number' as their parameter"])
              }
            }
          }
        }
      }
      var v13537 = funcDecl$$31.bod;
      if(v13537) {
        v13537 = !funcDecl$$31.isSignature()
      }
      if(v13537) {
        if(!funcDecl$$31.isConstructor) {
          JAM.call(this.addFormals, this, [container$$21, signature$$10, funcTable$$1])
        }else {
          JAM.call(this.addConstructorLocalArgs, this, [funcDecl$$31.type.symbol, funcDecl$$31.arguments, funcTable$$1, JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.fncFlags, TypeScript$$25.FncFlags.ClassMethod])]);
          var v13542 = this.thisClassNode;
          if(v13542) {
            v13542 = this.thisClassNode.extendsList
          }
          if(v13542) {
            var tmpScope = this.scope;
            var funcMembers$$1 = JAM.new(TypeScript$$25.ScopedMembers, [funcTable$$1]);
            var v26852 = JAM.new(TypeScript$$25.FilteredSymbolScopeBuilder, [funcMembers$$1, prevScope$$4, funcDecl$$31.type.symbol, v1064]);
            this.scope = v26852;
            JAM.call(this.typeCheckBaseCalls, this, [this.thisClassNode.extendsList]);
            this.scope = tmpScope
          }
        }
        var prevMod = this.checker.currentModDecl;
        var v13545 = funcDecl$$31.type;
        if(v13545) {
          var v19467 = funcDecl$$31.type.symbol;
          if(v19467) {
            var v23144 = !funcDecl$$31.isMethod();
            if(v23144) {
              v23144 = funcDecl$$31.type.symbol.declModule
            }
            v19467 = v23144
          }
          v13545 = v19467
        }
        if(v13545) {
          this.checker.currentModDecl = funcDecl$$31.type.symbol.declModule
        }
        if(acceptedContextualType) {
          var v3536 = this.checker;
          JAM.call(v3536.setContextualType, v3536, [null, this.checker.inProvisionalTypecheckMode()])
        }
        JAM.call(this.typeCheck, this, [funcDecl$$31.bod]);
        if(acceptedContextualType) {
          this.checker.unsetContextualType()
        }
        this.checker.currentModDecl = prevMod;
        if(this.checker.checkControlFlow) {
          var cfg = funcDecl$$31.buildControlFlow();
          if(this.checker.printControlFlowGraph) {
            JAM.call(cfg.print, cfg, [this.checker.errorReporter.outfile])
          }
          JAM.call(cfg.reportUnreachable, cfg, [this.checker.errorReporter]);
          if(this.checker.checkControlFlowUseDef) {
            JAM.call(cfg.useDef, cfg, [this.checker.errorReporter, funcDecl$$31.type.symbol])
          }
        }
        if(funcDecl$$31.isConstructor) {
          var fns$$1 = funcDecl$$31.scopes;
          var fnsLen$$1 = fns$$1.members.length;
          var freeVars$$2;
          var sym$$38;
          var j$$15 = 0;
          var v3553 = j$$15 < fnsLen$$1;
          for(;v3553;) {
            var v3549 = fns$$1.members;
            introspect(JAM.policy.p1) {
              var fn$$9 = v3549[j$$15]
            }
            if(!fn$$9.isSignature()) {
              var v13556 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [fn$$9.fncFlags, TypeScript$$25.FncFlags.Method]);
              if(v13556) {
                v13556 = !JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [fn$$9.fncFlags, TypeScript$$25.FncFlags.Static])
              }
              if(v13556) {
                JAM.call(this.checkPromoteFreeVars, this, [fn$$9, funcDecl$$31.type.symbol])
              }
            }
            j$$15 = j$$15 + 1;
            v3553 = j$$15 < fnsLen$$1
          }
        }
      }
      this.scope = prevScope$$4;
      this.thisFnc = prevFnc;
      this.thisClassNode = prevClassNode;
      this.enclosingFncIsMethod = prevMethodStatus$$2;
      this.thisType = prevThisType;
      this.checker.locationInfo = prevLocationInfo$$2;
      this.checker.currentModDecl = prevModDecl$$1;
      var v3558 = signature$$10;
      var v26853 = this.checker.getTypeCheckFinishedStatus();
      v3558.typeCheckStatus = v26853;
      if(funcDecl$$31.returnTypeAnnotation) {
        JAM.call(this.checkForVoidConstructor, this, [funcDecl$$31.returnTypeAnnotation.type, funcDecl$$31.returnTypeAnnotation]);
        if(signature$$10.returnType.type == null) {
          var v3561 = this.checker;
          JAM.call(v3561.resolveTypeLink, v3561, [this.scope, signature$$10.returnType, false])
        }
      }else {
        if(targetReturnType$$1) {
          signature$$10.returnType.type = targetReturnType$$1
        }
      }
      var v13561 = !(fgSym$$4.flags & TypeScript$$25.SymbolFlags.RecursivelyReferenced);
      if(v13561) {
        v13561 = funcDecl$$31.returnStatementsWithExpressions.length > 0
      }
      if(v13561) {
        var collection$$2 = {getLength:v1065, setTypeAtIndex:v1066, getTypeAtIndex:v1067};
        var bestCommonReturnType = funcDecl$$31.returnStatementsWithExpressions[0].type;
        var v3568 = this.checker;
        bestCommonReturnType = JAM.call(v3568.findBestCommonType, v3568, [bestCommonReturnType, null, collection$$2, true]);
        if(bestCommonReturnType) {
          var v3569 = signature$$10.returnType;
          var v13563 = this.checker;
          var v26854 = JAM.call(v13563.widenType, v13563, [bestCommonReturnType]);
          v3569.type = v26854
        }else {
          var i$$100 = 0;
          var v3572 = i$$100 < funcDecl$$31.returnStatementsWithExpressions.length;
          for(;v3572;) {
            var v3570 = this.checker.errorReporter;
            var v13566 = funcDecl$$31.returnStatementsWithExpressions;
            introspect(JAM.policy.p1) {
              var v3571 = v13566[i$$100]
            }
            JAM.call(v3570.simpleError, v3570, [v3571, "Incompatible return type"]);
            i$$100 = i$$100 + 1;
            v3572 = i$$100 < funcDecl$$31.returnStatementsWithExpressions.length
          }
          signature$$10.returnType.type = this.anyType
        }
      }
      var onlyHasThrow = false;
      if(signature$$10.returnType.type == null) {
        if(JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.fncFlags, TypeScript$$25.FncFlags.HasReturnExpression])) {
          if(this.checker.styleSettings.implicitAny) {
            var v3575 = this.checker.errorReporter;
            JAM.call(v3575.styleError, v3575, [funcDecl$$31, "type implicitly set to 'any'"])
          }
          signature$$10.returnType.type = this.anyType
        }else {
          signature$$10.returnType.type = this.voidType
        }
      }else {
        var v13573 = signature$$10.returnType.type == this.nullType;
        if(!v13573) {
          v13573 = signature$$10.returnType.type == this.checker.undefinedType
        }
        if(v13573) {
          signature$$10.returnType.type = this.anyType
        }else {
          var v13574 = signature$$10.returnType.type != this.voidType;
          if(v13574) {
            var v19488 = signature$$10.returnType.type != this.checker.undefinedType;
            if(v19488) {
              v19488 = signature$$10.returnType.type != this.anyType
            }
            v13574 = v19488
          }
          if(v13574) {
            var v13575 = !funcDecl$$31.isSignature();
            if(v13575) {
              var v19490 = !funcDecl$$31.isConstructor;
              if(v19490) {
                var v23160 = !JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.fncFlags, TypeScript$$25.FncFlags.HasReturnExpression]);
                if(v23160) {
                  v23160 = !JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.fncFlags, TypeScript$$25.FncFlags.IsFatArrowFunction])
                }
                v19490 = v23160
              }
              v13575 = v19490
            }
            if(v13575) {
              var v3581 = funcDecl$$31.bod.members.length > 0;
              if(v3581) {
                v3581 = funcDecl$$31.bod.members[0].nodeType == TypeScript$$25.NodeType.Throw
              }
              onlyHasThrow = v3581;
              if(!onlyHasThrow) {
                var v3582 = this.checker.errorReporter;
                var v13580 = funcDecl$$31.returnTypeAnnotation;
                if(!v13580) {
                  v13580 = funcDecl$$31
                }
                JAM.call(v3582.simpleError, v3582, [v13580, "Function declared a non-void return type, but has no return expression"])
              }
            }
            JAM.call(this.checkTypePrivacy, this, [signature$$10.returnType.type, container$$21, v1068])
          }
        }
      }
      if(funcDecl$$31.accessorSymbol) {
        accessorType = funcDecl$$31.accessorSymbol.getType();
        var v13582 = !onlyHasThrow;
        if(v13582) {
          var v19495 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.fncFlags, TypeScript$$25.FncFlags.GetAccessor]);
          if(v19495) {
            v19495 = !JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.fncFlags, TypeScript$$25.FncFlags.HasReturnExpression])
          }
          v13582 = v19495
        }
        if(v13582) {
          var v3591 = this.checker.errorReporter;
          JAM.call(v3591.simpleError, v3591, [funcDecl$$31, "Getters must return a value"])
        }
        if(accessorType) {
          var v19496 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.fncFlags, TypeScript$$25.FncFlags.GetAccessor]);
          if(v19496) {
            v19496 = accessorType != signature$$10.returnType.type
          }
          var v13584 = v19496;
          if(!v13584) {
            var v19497 = funcDecl$$31.arguments.members.length > 0;
            if(v19497) {
              v19497 = accessorType != funcDecl$$31.arguments.members[0].type
            }
            v13584 = v19497
          }
          if(v13584) {
            var v3593 = this.checker.errorReporter;
            JAM.call(v3593.simpleError, v3593, [funcDecl$$31, "Getter and setter types do not agree"])
          }
        }else {
          if(JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$31.fncFlags, TypeScript$$25.FncFlags.GetAccessor])) {
            var v3595 = funcDecl$$31.accessorSymbol;
            JAM.call(v3595.setType, v3595, [signature$$10.returnType.type])
          }else {
            if(funcDecl$$31.arguments.members.length != 1) {
              var v3597 = this.checker.errorReporter;
              JAM.call(v3597.simpleError, v3597, [funcDecl$$31, "Setters may have one and only one argument"])
            }else {
              var v3598 = funcDecl$$31.accessorSymbol;
              JAM.call(v3598.setType, v3598, [funcDecl$$31.arguments.members[0].type])
            }
          }
        }
      }
      JAM.call(this.typeCheckOverloadSignatures, this, [fnType, funcDecl$$31]);
      return funcDecl$$31
    }
    function v1061(funcDecl$$30, signature$$9, typeName$$7, isModuleName$$6) {
      var reportOnFuncDecl = false;
      var v13592 = funcDecl$$30.returnTypeAnnotation != null;
      if(v13592) {
        v13592 = funcDecl$$30.returnTypeAnnotation.type == signature$$9.returnType.type
      }
      if(v13592) {
        JAM.call(this.returnTypePrivacyError, this, [funcDecl$$30.returnTypeAnnotation, funcDecl$$30, typeName$$7, isModuleName$$6])
      }
      var i$$99 = 0;
      var v3607 = i$$99 < funcDecl$$30.returnStatementsWithExpressions.length;
      for(;v3607;) {
        var v23175 = funcDecl$$30.returnStatementsWithExpressions;
        introspect(JAM.policy.p1) {
          var v19506 = v23175[i$$99]
        }
        if(v19506.type == signature$$9.returnType.type) {
          var v13596 = funcDecl$$30.returnStatementsWithExpressions;
          introspect(JAM.policy.p1) {
            var v3605 = v13596[i$$99]
          }
          JAM.call(this.returnTypePrivacyError, this, [v3605, funcDecl$$30, typeName$$7, isModuleName$$6])
        }else {
          reportOnFuncDecl = true
        }
        i$$99 = i$$99 + 1;
        v3607 = i$$99 < funcDecl$$30.returnStatementsWithExpressions.length
      }
      if(reportOnFuncDecl) {
        JAM.call(this.returnTypePrivacyError, this, [funcDecl$$30, funcDecl$$30, typeName$$7, isModuleName$$6])
      }
      return
    }
    function v1060(astError, funcDecl$$29, typeName$$6, isModuleName$$5) {
      var v3608 = funcDecl$$29.isAccessor();
      if(v3608) {
        v3608 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$29.fncFlags, TypeScript$$25.FncFlags.GetAccessor])
      }
      var isGetter$$3 = v3608;
      var v3609 = funcDecl$$29.isAccessor();
      if(v3609) {
        v3609 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$29.fncFlags, TypeScript$$25.FncFlags.SetAccessor])
      }
      var isSetter$$3 = v3609;
      var isPublicFunc$$1 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$29.fncFlags, TypeScript$$25.FncFlags.Public]);
      var v13603 = funcDecl$$29.type.symbol;
      var isContainerInterface$$1 = JAM.call(v13603.getInterfaceDeclFromSymbol, v13603, [this.checker]) != null;
      var typestring$$3 = "";
      if(isModuleName$$5) {
        var quotestring$$3 = "";
        if(!JAM.call(TypeScript$$25.isQuoted, TypeScript$$25, [typeName$$6])) {
          quotestring$$3 = "'"
        }
        typestring$$3 = " is using inaccessible module " + quotestring$$3 + typeName$$6 + quotestring$$3
      }else {
        typestring$$3 = " has or is using private type '" + typeName$$6 + "'"
      }
      if(!isContainerInterface$$1) {
        if(isGetter$$3) {
          var v3616 = this.checker.errorReporter;
          var v23176;
          if(isPublicFunc$$1) {
            v23176 = "public"
          }else {
            v23176 = "exported"
          }
          JAM.call(v3616.simpleError, v3616, [astError, v23176 + " getter return type" + typestring$$3])
        }else {
          if(!isSetter$$3) {
            var v3618 = this.checker.errorReporter;
            var v23177;
            if(isPublicFunc$$1) {
              v23177 = "public"
            }else {
              v23177 = "exported"
            }
            JAM.call(v3618.simpleError, v3618, [astError, v23177 + " function return type" + typestring$$3])
          }
        }
      }else {
        if(funcDecl$$29.isConstructMember()) {
          var v3621 = this.checker.errorReporter;
          JAM.call(v3621.simpleError, v3621, [astError, "exported interface's constructor return type" + typestring$$3])
        }else {
          if(funcDecl$$29.isCallMember()) {
            var v3623 = this.checker.errorReporter;
            JAM.call(v3623.simpleError, v3623, [astError, "exported interface's call return type" + typestring$$3])
          }else {
            if(funcDecl$$29.isIndexerMember()) {
              var v3625 = this.checker.errorReporter;
              JAM.call(v3625.simpleError, v3625, [astError, "exported interface's indexer return type" + typestring$$3])
            }else {
              var v3627 = this.checker.errorReporter;
              JAM.call(v3627.simpleError, v3627, [astError, "exported interface's function return type" + typestring$$3])
            }
          }
        }
      }
      return
    }
    function v1059(funcDecl$$28, p, paramSymbol, typeName$$5, isModuleName$$4) {
      var v3633 = funcDecl$$28.isAccessor();
      if(v3633) {
        v3633 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$28.fncFlags, TypeScript$$25.FncFlags.GetAccessor])
      }
      var isGetter$$2 = v3633;
      var v3634 = funcDecl$$28.isAccessor();
      if(v3634) {
        v3634 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$28.fncFlags, TypeScript$$25.FncFlags.SetAccessor])
      }
      var isSetter$$2 = v3634;
      var isPublicFunc = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [funcDecl$$28.fncFlags, TypeScript$$25.FncFlags.Public]);
      var v13620 = funcDecl$$28.type.symbol;
      var isContainerInterface = JAM.call(v13620.getInterfaceDeclFromSymbol, v13620, [this.checker]) != null;
      var typestring$$2 = "";
      if(isModuleName$$4) {
        var quotestring$$2 = "";
        if(!JAM.call(TypeScript$$25.isQuoted, TypeScript$$25, [typeName$$5])) {
          quotestring$$2 = "'"
        }
        typestring$$2 = " is using inaccessible module " + quotestring$$2 + typeName$$5 + quotestring$$2
      }else {
        typestring$$2 = " has or is using private type '" + typeName$$5 + "'"
      }
      if(!isContainerInterface) {
        if(funcDecl$$28.isConstructor) {
          var v3641 = this.checker.errorReporter;
          var v13625 = funcDecl$$28.arguments.members;
          introspect(JAM.policy.p1) {
            var v3642 = v13625[p]
          }
          JAM.call(v3641.simpleError, v3641, [v3642, "exported class's constructor parameter '" + paramSymbol.name + "'" + typestring$$2])
        }else {
          if(isSetter$$2) {
            var v3644 = this.checker.errorReporter;
            var v13628 = funcDecl$$28.arguments.members;
            introspect(JAM.policy.p1) {
              var v3645 = v13628[p]
            }
            var v25810;
            if(isPublicFunc) {
              v25810 = "public"
            }else {
              v25810 = "exported"
            }
            JAM.call(v3644.simpleError, v3644, [v3645, v25810 + " setter parameter '" + paramSymbol.name + "'" + typestring$$2])
          }else {
            if(!isGetter$$2) {
              var v3647 = this.checker.errorReporter;
              var v13631 = funcDecl$$28.arguments.members;
              introspect(JAM.policy.p1) {
                var v3648 = v13631[p]
              }
              var v25811;
              if(isPublicFunc) {
                v25811 = "public"
              }else {
                v25811 = "exported"
              }
              JAM.call(v3647.simpleError, v3647, [v3648, v25811 + " function parameter '" + paramSymbol.name + "'" + typestring$$2])
            }
          }
        }
      }else {
        if(funcDecl$$28.isConstructMember()) {
          var v3652 = this.checker.errorReporter;
          var v13634 = funcDecl$$28.arguments.members;
          introspect(JAM.policy.p1) {
            var v3653 = v13634[p]
          }
          JAM.call(v3652.simpleError, v3652, [v3653, "exported interface's constructor parameter '" + paramSymbol.name + "'" + typestring$$2])
        }else {
          if(funcDecl$$28.isCallMember()) {
            var v3655 = this.checker.errorReporter;
            var v13637 = funcDecl$$28.arguments.members;
            introspect(JAM.policy.p1) {
              var v3656 = v13637[p]
            }
            JAM.call(v3655.simpleError, v3655, [v3656, "exported interface's call parameter '" + paramSymbol.name + "'" + typestring$$2])
          }else {
            if(!funcDecl$$28.isIndexerMember()) {
              var v3658 = this.checker.errorReporter;
              var v13641 = funcDecl$$28.arguments.members;
              introspect(JAM.policy.p1) {
                var v3659 = v13641[p]
              }
              JAM.call(v3658.simpleError, v3658, [v3659, "exported interface's function parameter '" + paramSymbol.name + "'" + typestring$$2])
            }
          }
        }
      }
      return
    }
    function v1058(sgroup, declSymbol$$4, errorCallback$$6) {
      if(sgroup) {
        var len$$47 = sgroup.signatures.length;
        var i$$98 = 0;
        var v3674 = i$$98 < sgroup.signatures.length;
        for(;v3674;) {
          var v3666 = sgroup.signatures;
          introspect(JAM.policy.p1) {
            var signature$$8 = v3666[i$$98]
          }
          var v13644 = len$$47 > 1;
          if(v13644) {
            v13644 = signature$$8 == sgroup.definitionSignature
          }
          if(v13644) {
            i$$98 = i$$98 + 1;
            v3674 = i$$98 < sgroup.signatures.length;
            continue
          }
          if(signature$$8.returnType) {
            JAM.call(this.checkTypePrivacy, this, [signature$$8.returnType.type, declSymbol$$4, errorCallback$$6])
          }
          var paramLen$$3 = signature$$8.parameters.length;
          var j$$14 = 0;
          var v3673 = j$$14 < paramLen$$3;
          for(;v3673;) {
            var v3671 = signature$$8.parameters;
            introspect(JAM.policy.p1) {
              var param$$7 = v3671[j$$14]
            }
            JAM.call(this.checkTypePrivacy, this, [param$$7.getType(), declSymbol$$4, errorCallback$$6]);
            j$$14 = j$$14 + 1;
            v3673 = j$$14 < paramLen$$3
          }
          i$$98 = i$$98 + 1;
          v3674 = i$$98 < sgroup.signatures.length
        }
      }
      return
    }
    function v1057(type$$50, declSymbol$$3, errorCallback$$5) {
      function v1056(key$$43, s$$26, unused) {
        var sym$$37 = s$$26;
        if(!JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [sym$$37.flags, TypeScript$$25.SymbolFlags.BuiltIn])) {
          JAM.call(_this$$9.checkTypePrivacy, _this$$9, [sym$$37.getType(), declSymbol$$3, errorCallback$$5])
        }
        return
      }
      var _this$$9 = this;
      var v19535 = type$$50;
      if(v19535) {
        v19535 = type$$50.primitiveTypeClass == TypeScript$$25.Primitive.None
      }
      if(!v19535) {
        return
      }
      if(type$$50.isArray()) {
        return JAM.call(this.checkTypePrivacy, this, [type$$50.elementType, declSymbol$$3, errorCallback$$5])
      }
      var v13650 = type$$50.symbol;
      if(v13650) {
        var v19536 = type$$50.symbol.name;
        if(v19536) {
          var v23190 = type$$50.symbol.name != "_anonymous";
          if(v23190) {
            var v25813 = type$$50.call == null;
            if(v25813) {
              var v26290 = type$$50.construct == null;
              if(v26290) {
                v26290 = type$$50.index == null
              }
              v25813 = v26290
            }
            var v24946 = v25813;
            if(!v24946) {
              var v25814 = type$$50.members;
              if(v25814) {
                v25814 = !type$$50.isClass()
              }
              v24946 = v25814
            }
            v23190 = v24946
          }
          v19536 = v23190
        }
        v13650 = v19536
      }
      if(v13650) {
        return JAM.call(this.checkSymbolPrivacy, this, [type$$50.symbol, declSymbol$$3, errorCallback$$5])
      }
      if(type$$50.members) {
        var v3682 = type$$50.members.allMembers;
        JAM.call(v3682.map, v3682, [v1056, null])
      }
      JAM.call(this.checkSignatureGroupPrivacy, this, [type$$50.call, declSymbol$$3, errorCallback$$5]);
      JAM.call(this.checkSignatureGroupPrivacy, this, [type$$50.construct, declSymbol$$3, errorCallback$$5]);
      JAM.call(this.checkSignatureGroupPrivacy, this, [type$$50.index, declSymbol$$3, errorCallback$$5]);
      return
    }
    function v1055(typeSymbol$$5, declSymbol$$2, errorCallback$$4) {
      var externalModuleSymbol = null;
      var declSymbolPath = null;
      if(JAM.call(typeSymbol$$5.isExternallyVisible, typeSymbol$$5, [this.checker])) {
        var typeSymbolPath = typeSymbol$$5.pathToRoot();
        declSymbolPath = declSymbol$$2.pathToRoot();
        var typeSymbolLength = typeSymbolPath.length;
        var declSymbolPathLength = declSymbolPath.length;
        if(typeSymbolLength > 0) {
          var v24947 = typeSymbolLength - 1;
          introspect(JAM.policy.p1) {
            var v23191 = typeSymbolPath[v24947]
          }
          var v13653 = v23191.getType().isModuleType();
          if(v13653) {
            var v24948 = typeSymbolLength - 1;
            introspect(JAM.policy.p1) {
              var v23192 = typeSymbolPath[v24948]
            }
            var v19538 = v23192.isDynamic;
            if(v19538) {
              var v24949 = typeSymbolLength - 1;
              introspect(JAM.policy.p1) {
                var v23193 = typeSymbolPath[v24949]
              }
              var v24950 = declSymbolPathLength - 1;
              introspect(JAM.policy.p1) {
                var v23194 = declSymbolPath[v24950]
              }
              v19538 = v23193 != v23194
            }
            v13653 = v19538
          }
          if(v13653) {
            externalModuleSymbol = typeSymbolPath[typeSymbolLength - 1]
          }else {
            if(typeSymbolLength > 1) {
              var v24951 = typeSymbolLength - 2;
              introspect(JAM.policy.p1) {
                var v23195 = typeSymbolPath[v24951]
              }
              var v13654 = v23195.getType().isModuleType();
              if(v13654) {
                var v24952 = typeSymbolLength - 2;
                introspect(JAM.policy.p1) {
                  var v23196 = typeSymbolPath[v24952]
                }
                var v19540 = v23196.isDynamic;
                if(v19540) {
                  var v23197 = declSymbolPathLength == 1;
                  if(!v23197) {
                    var v25816 = typeSymbolLength - 2;
                    introspect(JAM.policy.p1) {
                      var v24953 = typeSymbolPath[v25816]
                    }
                    var v25817 = declSymbolPathLength - 2;
                    introspect(JAM.policy.p1) {
                      var v24954 = declSymbolPath[v25817]
                    }
                    v23197 = v24953 != v24954
                  }
                  v19540 = v23197
                }
                v13654 = v19540
              }
              if(v13654) {
                externalModuleSymbol = typeSymbolPath[typeSymbolLength - 2]
              }
            }
          }
        }
        if(externalModuleSymbol == null) {
          return
        }
      }
      var interfaceDecl$$5 = JAM.call(declSymbol$$2.getInterfaceDeclFromSymbol, declSymbol$$2, [this.checker]);
      var v13655 = interfaceDecl$$5;
      if(v13655) {
        v13655 = !JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [interfaceDecl$$5.varFlags, TypeScript$$25.VarFlags.Exported])
      }
      if(v13655) {
        return
      }
      var checkVisibilitySymbol = declSymbol$$2;
      var varDecl$$18 = declSymbol$$2.getVarDeclFromSymbol();
      if(varDecl$$18) {
        if(JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [varDecl$$18.varFlags, TypeScript$$25.VarFlags.Private])) {
          return
        }else {
          if(JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [varDecl$$18.varFlags, TypeScript$$25.VarFlags.Public])) {
            checkVisibilitySymbol = declSymbol$$2.container
          }
        }
      }
      if(JAM.call(checkVisibilitySymbol.isExternallyVisible, checkVisibilitySymbol, [this.checker])) {
        var privateSymbolName = typeSymbol$$5.name;
        if(externalModuleSymbol != null) {
          var prettyName$$2 = JAM.call(externalModuleSymbol.getPrettyNameOfDynamicModule, externalModuleSymbol, [declSymbolPath]);
          if(prettyName$$2 != null) {
            var v3699 = this.currentScript;
            JAM.call(v3699.AddExternallyVisibleImportedSymbol, v3699, [prettyName$$2.symbol, this.checker]);
            return
          }else {
            privateSymbolName = externalModuleSymbol.prettyName
          }
        }
        JAM.call(errorCallback$$4, null, [privateSymbolName, typeSymbol$$5.name != privateSymbolName])
      }
      return
    }
    function v1054(bases$$5, declSymbol$$1, extendsList$$8) {
      function v1053(typeName$$4, isModuleName$$3) {
        return JAM.call(_this$$8.baseListPrivacyErrorReporter, _this$$8, [bases$$5, i$$97, declSymbol$$1, extendsList$$8, typeName$$4, isModuleName$$3])
      }
      var _this$$8 = this;
      if(bases$$5) {
        var basesLen$$1 = bases$$5.members.length;
        var i$$97 = 0;
        var v3709 = i$$97 < basesLen$$1;
        for(;v3709;) {
          var v24957 = bases$$5.members;
          introspect(JAM.policy.p1) {
            var v23200 = v24957[i$$97]
          }
          var v13662 = !v23200.type;
          if(!v13662) {
            var v24958 = bases$$5.members;
            introspect(JAM.policy.p1) {
              var v23201 = v24958[i$$97]
            }
            v13662 = v23201.type == this.checker.anyType
          }
          if(v13662) {
            i$$97 = i$$97 + 1;
            v3709 = i$$97 < basesLen$$1;
            continue
          }
          var v23203 = bases$$5.members;
          introspect(JAM.policy.p1) {
            var v19548 = v23203[i$$97]
          }
          JAM.call(this.checkSymbolPrivacy, this, [v19548.type.symbol, declSymbol$$1, v1053]);
          i$$97 = i$$97 + 1;
          v3709 = i$$97 < basesLen$$1
        }
      }
      return
    }
    function v1052(bases$$4, i$$96, declSymbol, extendsList$$7, typeName$$3, isModuleName$$2) {
      var v19549 = bases$$4.members;
      introspect(JAM.policy.p1) {
        var v13664 = v19549[i$$96]
      }
      var baseSymbol$$2 = v13664.type.symbol;
      var v3711;
      if(declSymbol.declAST.nodeType == TypeScript$$25.NodeType.InterfaceDeclaration) {
        v3711 = "interface"
      }else {
        v3711 = "class"
      }
      var declTypeString = v3711;
      var v3712;
      if(extendsList$$7) {
        v3712 = "extends"
      }else {
        v3712 = "implements"
      }
      var baseListTypeString = v3712;
      var v3713;
      if(baseSymbol$$2.declAST.nodeType == TypeScript$$25.NodeType.InterfaceDeclaration) {
        v3713 = "interface"
      }else {
        v3713 = "class"
      }
      var baseTypeString = v3713;
      var typestring$$1 = "";
      if(isModuleName$$2) {
        var quotestring$$1 = "";
        if(!JAM.call(TypeScript$$25.isQuoted, TypeScript$$25, [typeName$$3])) {
          quotestring$$1 = "'"
        }
        typestring$$1 = " is using inaccessible module ";
        baseTypeString = " " + baseTypeString + " from private module " + quotestring$$1 + typeName$$3 + quotestring$$1
      }else {
        baseTypeString = " private " + baseTypeString + " '" + typeName$$3 + "'"
      }
      var v3717 = this.checker.errorReporter;
      var v13671 = bases$$4.members;
      introspect(JAM.policy.p1) {
        var v3718 = v13671[i$$96]
      }
      JAM.call(v3717.simpleError, v3717, [v3718, "exported " + declTypeString + " '" + declSymbol.name + "' " + baseListTypeString + baseTypeString]);
      return
    }
    function v1051(funcDecl$$27) {
      function preFindSuperCall(ast$$105, parent$$67, walker$$51) {
        var go$$5 = true;
        switch(ast$$105.nodeType) {
          case TypeScript$$25.NodeType.FuncDecl:
            go$$5 = false;
            break;
          case TypeScript$$25.NodeType.Call:
            var call = ast$$105;
            if(call.target.nodeType == TypeScript$$25.NodeType.Super) {
              go$$5 = false;
              foundSuper = true
            }
          ;
          default:
        }
        walker$$51.options.goChildren = go$$5;
        return ast$$105
      }
      var foundSuper = false;
      var v3723 = TypeScript$$25.getAstWalkerFactory();
      JAM.call(v3723.walk, v3723, [funcDecl$$27.bod, preFindSuperCall]);
      return foundSuper
    }
    function v1050(funcDecl$$26) {
      function v1049(ast$$104, parent$$66, walker$$50) {
        var go$$4 = true;
        switch(ast$$104.nodeType) {
          case TypeScript$$25.NodeType.FuncDecl:
            go$$4 = false;
            break;
          case TypeScript$$25.NodeType.Return:
            var returnStmt = ast$$104;
            if(returnStmt.returnExpression) {
              allReturnsAreVoid = false;
              go$$4 = false
            }
          ;
          default:
        }
        walker$$50.options.goChildren = go$$4;
        walker$$50.options.goNextSibling = go$$4;
        return ast$$104
      }
      var allReturnsAreVoid = true;
      if(funcDecl$$26.signature.returnType.type == null) {
        var preFindReturnExpressionTypes = v1049;
        var v3729 = TypeScript$$25.getAstWalkerFactory();
        JAM.call(v3729.walk, v3729, [funcDecl$$26.bod, preFindReturnExpressionTypes])
      }
      return allReturnsAreVoid
    }
    function v1048(funcDecl$$25, constructorSym) {
      var freeVars$$1 = funcDecl$$25.freeVariables;
      var k$$14 = 0;
      var len$$46 = freeVars$$1.length;
      var v3739 = k$$14 < len$$46;
      for(;v3739;) {
        introspect(JAM.policy.p1) {
          var sym$$36 = freeVars$$1[k$$14]
        }
        var v13676 = !sym$$36.isInstanceProperty();
        if(v13676) {
          v13676 = sym$$36.container == constructorSym
        }
        if(v13676) {
          TypeScript$$25.instanceFilter.reset();
          var v13677 = this.scope;
          if(JAM.call(v13677.search, v13677, [TypeScript$$25.instanceFilter, sym$$36.name, false, false])) {
            var v3733 = this.checker.errorReporter;
            JAM.call(v3733.simpleError, v3733, [funcDecl$$25, "Constructor-local variable shadows class property '" + sym$$36.name + "'. To access the class property, use 'self." + sym$$36.name + "'"])
          }
          var v3736 = this.checker.errorReporter;
          JAM.call(v3736.simpleError, v3736, [funcDecl$$25, "Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable '" + sym$$36.name + "' to a class property"])
        }
        k$$14 = k$$14 + 1;
        v3739 = k$$14 < len$$46
      }
      return
    }
    function v1047(funcDecl$$24) {
      if(!funcDecl$$24.isMethod()) {
        var freeVars = funcDecl$$24.freeVariables;
        var k$$13 = 0;
        var len$$45 = freeVars.length;
        var v3741 = k$$13 < len$$45;
        for(;v3741;) {
          introspect(JAM.policy.p1) {
            var sym$$35 = freeVars[k$$13]
          }
          if(sym$$35.isInstanceProperty()) {
            return true
          }
          k$$13 = k$$13 + 1;
          v3741 = k$$13 < len$$45
        }
      }
      var fns = funcDecl$$24.scopes;
      var fnsLen = fns.members.length;
      var j$$13 = 0;
      var v3746 = j$$13 < fnsLen;
      for(;v3746;) {
        var v3744 = fns.members;
        introspect(JAM.policy.p1) {
          var fn$$8 = v3744[j$$13]
        }
        if(JAM.call(this.checkInitSelf, this, [fn$$8])) {
          return true
        }
        j$$13 = j$$13 + 1;
        v3746 = j$$13 < fnsLen
      }
      return false
    }
    function v1046(container$$20, args$$14, table$$9, isClass$$1) {
      if(args$$14) {
        var len$$44 = args$$14.members.length;
        var i$$95 = 0;
        var v3761 = i$$95 < len$$44;
        for(;v3761;) {
          var v3748 = args$$14.members;
          introspect(JAM.policy.p1) {
            var local$$1 = v3748[i$$95]
          }
          var v13685 = local$$1.sym == null;
          if(!v13685) {
            var v19566 = isClass$$1;
            if(!v19566) {
              v19566 = local$$1.sym.kind() != TypeScript$$25.SymbolKind.Field
            }
            v13685 = v19566
          }
          if(v13685) {
            var result$$29 = null;
            if((result$$29 = JAM.call(table$$9.lookup, table$$9, [local$$1.id.text])) == null) {
              JAM.call(this.resolveBoundDecl, this, [local$$1]);
              var localVar$$1 = new TypeScript$$25.ValueLocation;
              var v3750 = localVar$$1;
              var v26855 = new TypeScript$$25.TypeLink;
              v3750.typeLink = v26855;
              var varSym$$2 = JAM.new(TypeScript$$25.ParameterSymbol, [local$$1.id.text, local$$1.minChar, this.checker.locationInfo.unitIndex, localVar$$1]);
              varSym$$2.declAST = local$$1;
              localVar$$1.symbol = varSym$$2;
              localVar$$1.typeLink.type = local$$1.type;
              localVar$$1.symbol.container = container$$20;
              local$$1.sym = localVar$$1.symbol;
              JAM.call(table$$9.add, table$$9, [local$$1.id.text, varSym$$2])
            }else {
              var v3758 = local$$1;
              var v26856 = result$$29.getType();
              v3758.type = v26856;
              local$$1.sym = result$$29
            }
          }
          i$$95 = i$$95 + 1;
          v3761 = i$$95 < len$$44
        }
      }
      return
    }
    function v1045(scope$$30, container$$19, vars$$3, table$$8, isModContainer) {
      var len$$43 = vars$$3.members.length;
      var hasArgsDef = false;
      var i$$94 = 0;
      var v3787 = i$$94 < len$$43;
      for(;v3787;) {
        var v3763 = vars$$3.members;
        introspect(JAM.policy.p1) {
          var local = v3763[i$$94]
        }
        var v13691 = local.sym == null;
        if(!v13691) {
          v13691 = local.sym.kind() != TypeScript$$25.SymbolKind.Field
        }
        if(v13691) {
          var result$$28 = null;
          if((result$$28 = JAM.call(table$$8.lookup, table$$8, [local.id.text])) == null) {
            var localVar = new TypeScript$$25.ValueLocation;
            var v3765 = localVar;
            var v26857 = new TypeScript$$25.TypeLink;
            v3765.typeLink = v26857;
            var varSym$$1 = null;
            if(JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [local.varFlags, TypeScript$$25.VarFlags.Static])) {
              local.varFlags = local.varFlags | TypeScript$$25.VarFlags.LocalStatic;
              varSym$$1 = JAM.new(TypeScript$$25.FieldSymbol, [local.id.text, local.minChar, this.checker.locationInfo.unitIndex, true, localVar])
            }else {
              varSym$$1 = JAM.new(TypeScript$$25.VariableSymbol, [local.id.text, local.minChar, this.checker.locationInfo.unitIndex, localVar])
            }
            JAM.call(varSym$$1.transferVarFlags, varSym$$1, [local.varFlags]);
            localVar.symbol = varSym$$1;
            varSym$$1.declAST = local;
            localVar.typeLink.ast = local.typeExpr;
            var v3777 = this.checker;
            JAM.call(v3777.resolveTypeLink, v3777, [scope$$30, localVar.typeLink, false]);
            var v13702 = local.type == null;
            if(v13702) {
              v13702 = local.init == null
            }
            if(v13702) {
              local.type = this.anyType
            }
            localVar.typeLink.type = local.type;
            localVar.symbol.container = container$$19;
            local.sym = localVar.symbol;
            JAM.call(table$$8.add, table$$8, [local.id.text, varSym$$1]);
            if(local.id.text == "arguments") {
              hasArgsDef = true
            }
          }else {
            var v3784 = local;
            var v26858 = result$$28.getType();
            v3784.type = v26858;
            local.sym = result$$28
          }
        }
        i$$94 = i$$94 + 1;
        v3787 = i$$94 < len$$43
      }
      if(!isModContainer) {
        if(!hasArgsDef) {
          var argLoc = new TypeScript$$25.ValueLocation;
          var v3789 = argLoc;
          var v26859 = new TypeScript$$25.TypeLink;
          v3789.typeLink = v26859;
          var theArgSym = JAM.new(TypeScript$$25.VariableSymbol, ["arguments", vars$$3.minChar, this.checker.locationInfo.unitIndex, argLoc]);
          if(!this.iargumentsInterfaceType) {
            var argumentsSym = JAM.call(scope$$30.find, scope$$30, ["IArguments", false, true]);
            if(argumentsSym) {
              argumentsSym.flags = argumentsSym.flags | TypeScript$$25.SymbolFlags.CompilerGenerated;
              var v26860 = argumentsSym.getType();
              this.iargumentsInterfaceType = v26860
            }else {
              this.iargumentsInterfaceType = this.anyType
            }
          }
          argLoc.typeLink.type = this.iargumentsInterfaceType;
          JAM.call(table$$8.add, table$$8, ["arguments", theArgSym])
        }
      }
      return
    }
    function v1044(container$$18, signature$$7, table$$7) {
      var len$$42 = signature$$7.parameters.length;
      var i$$93 = 0;
      var v3800 = i$$93 < len$$42;
      for(;v3800;) {
        var v3798 = signature$$7.parameters;
        introspect(JAM.policy.p1) {
          var symbol$$20 = v3798[i$$93]
        }
        symbol$$20.container = container$$18;
        JAM.call(table$$7.add, table$$7, [symbol$$20.name, symbol$$20]);
        i$$93 = i$$93 + 1;
        v3800 = i$$93 < len$$42
      }
      return
    }
    function v1043(trinex) {
      var v3801 = trinex;
      var v26861 = JAM.call(this.typeCheck, this, [trinex.operand1]);
      v3801.operand1 = v26861;
      var v3802 = trinex;
      var v26862 = JAM.call(this.typeCheck, this, [trinex.operand2]);
      v3802.operand2 = v26862;
      var v3803 = trinex;
      var v26863 = JAM.call(this.typeCheck, this, [trinex.operand3]);
      v3803.operand3 = v26863;
      var leftType$$5 = trinex.operand2.type;
      var rightType$$4 = trinex.operand3.type;
      if(leftType$$5 == rightType$$4) {
        trinex.type = leftType$$5
      }else {
        var v13713 = this.checker;
        if(JAM.call(v13713.sourceIsSubtypeOfTarget, v13713, [leftType$$5, rightType$$4])) {
          trinex.type = rightType$$4
        }else {
          var v13714 = this.checker;
          if(JAM.call(v13714.sourceIsSubtypeOfTarget, v13714, [rightType$$4, leftType$$5])) {
            trinex.type = leftType$$5
          }else {
            trinex.type = this.anyType;
            var v3806 = this.checker.errorReporter;
            JAM.call(v3806.incompatibleTypes, v3806, [trinex, leftType$$5, rightType$$4, trinex.printLabel(), this.scope])
          }
        }
      }
      return trinex
    }
    function v1042(binex$$8, assignment$$2) {
      var v3812 = binex$$8;
      var v26864 = JAM.call(this.cast, this, [JAM.call(this.typeCheck, this, [binex$$8.operand1]), this.doubleType]);
      v3812.operand1 = v26864;
      var v3813 = binex$$8;
      var v26865 = JAM.call(this.cast, this, [JAM.call(this.typeCheck, this, [binex$$8.operand2]), this.doubleType]);
      v3813.operand2 = v26865;
      var v13720 = assignment$$2;
      if(v13720) {
        v13720 = !JAM.call(this.astIsWriteable, this, [binex$$8.operand1])
      }
      if(v13720) {
        var v3814 = this.checker.errorReporter;
        JAM.call(v3814.valueCannotBeModified, v3814, [binex$$8])
      }
      binex$$8.type = this.doubleType;
      return binex$$8
    }
    function v1041(binex$$7) {
      var v3816 = binex$$7;
      var v26866 = JAM.call(this.cast, this, [JAM.call(this.typeCheck, this, [binex$$7.operand1]), this.stringType]);
      v3816.operand1 = v26866;
      var v3817 = binex$$7;
      var v26867 = JAM.call(this.typeCheck, this, [binex$$7.operand2]);
      v3817.operand2 = v26867;
      var v23220 = binex$$7.operand1.type == this.checker.anyType;
      if(!v23220) {
        v23220 = binex$$7.operand1.type == this.checker.stringType
      }
      var v19588 = v23220;
      if(v19588) {
        var v23221 = binex$$7.operand2.type == this.anyType;
        if(!v23221) {
          var v24971 = this.checker;
          v23221 = JAM.call(v24971.sourceIsSubtypeOfTarget, v24971, [binex$$7.operand2.type, this.objectInterfaceType])
        }
        v19588 = v23221
      }
      if(!v19588) {
        var v3818 = this.checker.errorReporter;
        JAM.call(v3818.simpleError, v3818, [binex$$7, "The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type"])
      }
      binex$$7.type = this.booleanType;
      return binex$$7
    }
    function v1040(ast$$103) {
      var binex$$6 = ast$$103;
      var v3820 = binex$$6;
      var v26868 = JAM.call(this.typeCheck, this, [binex$$6.operand1]);
      v3820.operand1 = v26868;
      var v3821 = binex$$6;
      var v26869 = JAM.call(this.typeCheck, this, [binex$$6.operand2]);
      v3821.operand2 = v26869;
      if(!this.checker.styleSettings.literalSubscript) {
        if(binex$$6.operand2.nodeType == TypeScript$$25.NodeType.QString) {
          var v3822 = this.checker.errorReporter;
          JAM.call(v3822.styleError, v3822, [ast$$103, "use literal subscript ('.') notation instead)"])
        }
      }
      var objExprType = binex$$6.operand1.type;
      var indexExprType = binex$$6.operand2.type;
      if(objExprType.elementType) {
        var v13733 = indexExprType == this.checker.anyType;
        if(!v13733) {
          var v19593 = indexExprType == this.checker.numberType;
          if(!v19593) {
            v19593 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [indexExprType.typeFlags, TypeScript$$25.TypeFlags.IsEnum])
          }
          v13733 = v19593
        }
        if(v13733) {
          binex$$6.type = objExprType.elementType
        }else {
          if(indexExprType == this.checker.stringType) {
            binex$$6.type = this.checker.anyType
          }else {
            var v3828 = this.checker.errorReporter;
            JAM.call(v3828.simpleError, v3828, [binex$$6, "Illegal property access"]);
            binex$$6.type = this.checker.anyType
          }
        }
      }else {
        if(objExprType.index) {
          var v13736 = indexExprType == this.checker.anyType;
          if(!v13736) {
            var v24977 = objExprType.index.flags & TypeScript$$25.SignatureFlags.IsStringIndexer;
            if(!v24977) {
              v24977 = objExprType.index.flags & TypeScript$$25.SignatureFlags.IsNumberIndexer
            }
            var v19597 = !v24977;
            if(!v19597) {
              var v24978 = objExprType.index.flags & TypeScript$$25.SignatureFlags.IsStringIndexer;
              if(v24978) {
                v24978 = indexExprType == this.checker.stringType
              }
              var v23230 = v24978;
              if(!v23230) {
                var v24979 = objExprType.index.flags & TypeScript$$25.SignatureFlags.IsNumberIndexer;
                if(v24979) {
                  var v25835 = indexExprType == this.checker.numberType;
                  if(!v25835) {
                    v25835 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [indexExprType.typeFlags, TypeScript$$25.TypeFlags.IsEnum])
                  }
                  v24979 = v25835
                }
                v23230 = v24979
              }
              v19597 = v23230
            }
            v13736 = v19597
          }
          if(v13736) {
            var sig$$3 = JAM.call(this.resolveOverload, this, [ast$$103, objExprType.index]);
            if(sig$$3) {
              binex$$6.type = sig$$3.returnType.type
            }else {
              binex$$6.type = this.checker.anyType
            }
          }else {
            if(indexExprType == this.checker.stringType) {
              binex$$6.type = this.checker.anyType
            }else {
              var v3836 = this.checker.errorReporter;
              JAM.call(v3836.simpleError, v3836, [binex$$6, "Illegal property access"]);
              binex$$6.type = this.checker.anyType
            }
          }
        }else {
          var v19600 = objExprType == this.checker.anyType;
          if(!v19600) {
            var v23233 = objExprType == this.checker.stringType;
            if(!v23233) {
              var v24983 = objExprType == this.checker.numberType;
              if(!v24983) {
                var v25838 = objExprType == this.checker.booleanType;
                if(!v25838) {
                  v25838 = objExprType.isReferenceType()
                }
                v24983 = v25838
              }
              v23233 = v24983
            }
            v19600 = v23233
          }
          var v13739 = v19600;
          if(v13739) {
            var v19601 = indexExprType == this.checker.anyType;
            if(!v19601) {
              var v23236 = indexExprType == this.checker.stringType;
              if(!v23236) {
                var v24987 = indexExprType == this.checker.numberType;
                if(!v24987) {
                  v24987 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [indexExprType.typeFlags, TypeScript$$25.TypeFlags.IsEnum])
                }
                v23236 = v24987
              }
              v19601 = v23236
            }
            v13739 = v19601
          }
          if(v13739) {
            binex$$6.type = this.checker.anyType
          }else {
            var v3841 = this.checker.errorReporter;
            JAM.call(v3841.simpleError, v3841, [binex$$6, "Illegal property access"]);
            binex$$6.type = this.checker.anyType
          }
        }
      }
      return binex$$6
    }
    function v1039(ast$$102) {
      var binex$$5 = ast$$102;
      var applyTargetType$$2 = !binex$$5.operand2.isParenthesized;
      var v3847 = binex$$5;
      var v26870 = JAM.call(this.typeCheck, this, [binex$$5.operand1]);
      v3847.operand1 = v26870;
      var v3848 = this.checker;
      JAM.call(v3848.typeCheckWithContextualType, v3848, [binex$$5.operand1.type, this.checker.inProvisionalTypecheckMode(), applyTargetType$$2, binex$$5.operand2]);
      var leftType$$4 = binex$$5.operand1.type;
      var rightType$$3 = binex$$5.operand2.type;
      if(!JAM.call(this.astIsWriteable, this, [binex$$5.operand1])) {
        var v3854 = this.checker.errorReporter;
        JAM.call(v3854.valueCannotBeModified, v3854, [binex$$5])
      }
      if(binex$$5.operand1.nodeType == TypeScript$$25.NodeType.Call) {
        var callEx$$1 = binex$$5.operand1
      }
      var preserveScope$$1 = false;
      var preservedContainedScope$$1 = null;
      if(binex$$5.operand2.type) {
        preservedContainedScope$$1 = binex$$5.operand2.type.containedScope;
        preserveScope$$1 = true
      }
      var v3859 = binex$$5;
      var v13751 = binex$$5.operand2;
      var v19605 = applyTargetType$$2;
      if(v19605) {
        v19605 = !this.checker.inProvisionalTypecheckMode()
      }
      var v26871 = JAM.call(this.castWithCoercion, this, [v13751, leftType$$4, v19605, false]);
      v3859.operand2 = v26871;
      var v13753 = preserveScope$$1;
      if(v13753) {
        v13753 = binex$$5.operand2.type.containedScope == null
      }
      if(v13753) {
        binex$$5.operand2.type.containedScope = preservedContainedScope$$1
      }
      binex$$5.type = rightType$$3;
      return binex$$5
    }
    function v1038(ast$$101) {
      var binex$$4 = ast$$101;
      var v3862 = binex$$4;
      var v26872 = JAM.call(this.typeCheck, this, [binex$$4.operand1]);
      v3862.operand1 = v26872;
      var v3863 = binex$$4;
      var v26873 = JAM.call(this.typeCheck, this, [binex$$4.operand2]);
      v3863.operand2 = v26873;
      var leftType$$3 = binex$$4.operand1.type;
      var rightType$$2 = binex$$4.operand2.type;
      var v23240 = this.checker;
      var v13757 = !JAM.call(v23240.sourceIsAssignableToTarget, v23240, [leftType$$3, rightType$$2]);
      if(v13757) {
        var v23241 = this.checker;
        v13757 = !JAM.call(v23241.sourceIsAssignableToTarget, v23241, [rightType$$2, leftType$$3])
      }
      if(v13757) {
        var v3866 = this.checker.errorReporter;
        JAM.call(v3866.incompatibleTypes, v3866, [binex$$4, leftType$$3, rightType$$2, binex$$4.printLabel(), this.scope])
      }
      binex$$4.type = this.booleanType;
      return binex$$4
    }
    function v1037(ast$$100) {
      var binex$$3 = ast$$100;
      var leftIsFnc = false;
      var v3870 = binex$$3;
      var v26874 = JAM.call(this.typeCheck, this, [binex$$3.operand1]);
      v3870.operand1 = v26874;
      var leftType$$2 = binex$$3.operand1.type;
      var leftScope = null;
      if(leftType$$2) {
        if(leftType$$2 == this.anyType) {
          binex$$3.type = this.anyType;
          return binex$$3
        }else {
          if(leftType$$2 == this.stringType) {
            if(this.stringInterfaceType) {
              leftScope = this.stringInterfaceType.memberScope
            }else {
              binex$$3.type = this.anyType;
              return binex$$3
            }
          }else {
            if(leftType$$2 == this.doubleType) {
              if(this.numberInterfaceType) {
                leftScope = this.numberInterfaceType.memberScope
              }else {
                binex$$3.type = this.anyType;
                return binex$$3
              }
            }else {
              if(leftType$$2 == this.booleanType) {
                if(this.booleanInterfaceType) {
                  leftScope = this.booleanInterfaceType.memberScope
                }else {
                  binex$$3.type = this.anyType;
                  return binex$$3
                }
              }else {
                var v19609 = leftType$$2.call;
                if(!v19609) {
                  v19609 = leftType$$2.construct
                }
                var v13764 = v19609;
                if(v13764) {
                  v13764 = leftType$$2.members == null
                }
                if(v13764) {
                  if(this.functionInterfaceType) {
                    leftScope = this.functionInterfaceType.memberScope
                  }else {
                    binex$$3.type = this.anyType;
                    return binex$$3
                  }
                }else {
                  if(leftType$$2.elementType) {
                    if(this.arrayInterfaceType) {
                      var v3880 = leftType$$2.elementType;
                      var arrInstType$$1 = JAM.call(v3880.getArrayBase, v3880, [this.arrayInterfaceType, this.checker]);
                      leftScope = arrInstType$$1.memberScope
                    }else {
                      binex$$3.type = this.anyType;
                      return binex$$3
                    }
                  }else {
                    leftScope = leftType$$2.memberScope
                  }
                }
              }
            }
          }
        }
      }
      if(leftScope == null) {
        var v3890 = this.checker.errorReporter;
        JAM.call(v3890.expectedClassOrInterface, v3890, [binex$$3]);
        binex$$3.type = this.anyType
      }else {
        var propertyName$$8 = binex$$3.operand2;
        var v13766 = this.thisClassNode;
        if(v13766) {
          v13766 = binex$$3.operand1.type == this.thisClassNode.type.instanceType
        }
        var v3891 = v13766;
        if(!v3891) {
          v3891 = this.inTypeRefTypeCheck
        }
        var lhsIsEnclosingType = v3891;
        var symbol$$19 = JAM.call(leftScope.find, leftScope, [propertyName$$8.text, !lhsIsEnclosingType, this.inTypeRefTypeCheck]);
        if(!symbol$$19) {
          var v13768 = this.objectInterfaceType;
          if(v13768) {
            v13768 = leftType$$2
          }
          if(v13768) {
            if(leftType$$2.isReferenceType()) {
              var v3895 = this.objectInterfaceType.memberScope;
              symbol$$19 = JAM.call(v3895.find, v3895, [propertyName$$8.text, false, this.inTypeRefTypeCheck])
            }
            if(!symbol$$19) {
              var v13770 = this.functionInterfaceType;
              if(v13770) {
                var v19613 = leftType$$2.call;
                if(!v19613) {
                  v19613 = leftType$$2.construct
                }
                v13770 = v19613
              }
              if(v13770) {
                var v3899 = this.functionInterfaceType.memberScope;
                symbol$$19 = JAM.call(v3899.find, v3899, [propertyName$$8.text, false, this.inTypeRefTypeCheck])
              }
            }
          }
        }
        var v13772 = !symbol$$19;
        if(!v13772) {
          v13772 = !JAM.call(symbol$$19.visible, symbol$$19, [leftScope, this.checker])
        }
        if(v13772) {
          binex$$3.type = this.anyType;
          if(symbol$$19 == null) {
            var v3906 = this.checker.errorReporter;
            JAM.call(v3906.simpleError, v3906, [propertyName$$8, "The property '" + propertyName$$8.actualText + "' does not exist on value of type '" + JAM.call(leftType$$2.getScopedTypeName, leftType$$2, [this.scope]) + "'"])
          }else {
            if(!this.inTypeRefTypeCheck) {
              var v3908 = this.checker.errorReporter;
              JAM.call(v3908.simpleError, v3908, [binex$$3, "The property '" + propertyName$$8.actualText + " on type '" + JAM.call(leftType$$2.getScopedTypeName, leftType$$2, [this.scope]) + "' is not visible"])
            }
          }
        }else {
          if(symbol$$19.isVariable()) {
            if(symbol$$19.isInferenceSymbol()) {
              var infSym$$2 = symbol$$19;
              var v13778 = infSym$$2.declAST;
              if(v13778) {
                var v23251 = this.checker;
                v13778 = !JAM.call(v23251.typeStatusIsFinished, v23251, [infSym$$2.typeCheckStatus])
              }
              if(v13778) {
                JAM.call(this.inScopeTypeCheckDecl, this, [infSym$$2.declAST])
              }
            }
          }
          propertyName$$8.sym = symbol$$19;
          var v3916 = binex$$3;
          var v26875 = symbol$$19.getType();
          v3916.type = v26875
        }
      }
      if(binex$$3.type == null) {
        binex$$3.type = this.anyType
      }
      return binex$$3
    }
    function v1036(ast$$99, assignment$$1) {
      var binex$$2 = ast$$99;
      var v3920 = binex$$2;
      var v26876 = JAM.call(this.typeCheck, this, [binex$$2.operand1]);
      v3920.operand1 = v26876;
      var v3921 = binex$$2;
      var v26877 = JAM.call(this.typeCheck, this, [binex$$2.operand2]);
      v3921.operand2 = v26877;
      var leftType$$1 = binex$$2.operand1.type;
      var rightType$$1 = binex$$2.operand2.type;
      var v13782 = assignment$$1;
      if(v13782) {
        v13782 = !JAM.call(this.astIsWriteable, this, [binex$$2.operand1])
      }
      if(v13782) {
        var v3924 = this.checker.errorReporter;
        JAM.call(v3924.valueCannotBeModified, v3924, [binex$$2])
      }
      var v13784 = this.checker.styleSettings.bitwise;
      if(v13784) {
        var v19623 = binex$$2.nodeType == TypeScript$$25.NodeType.And;
        if(!v19623) {
          var v23257 = binex$$2.nodeType == TypeScript$$25.NodeType.Or;
          if(!v23257) {
            var v24997 = binex$$2.nodeType == TypeScript$$25.NodeType.AsgAnd;
            if(!v24997) {
              v24997 = binex$$2.nodeType == TypeScript$$25.NodeType.AsgOr
            }
            v23257 = v24997
          }
          v19623 = v23257
        }
        v13784 = v19623
      }
      if(v13784) {
        var v3926 = this.checker.errorReporter;
        var v19624 = TypeScript$$25.nodeTypeTable;
        var v19625 = binex$$2.nodeType;
        introspect(JAM.policy.p1) {
          var v13786 = v19624[v19625]
        }
        JAM.call(v3926.styleError, v3926, [ast$$99, "use of " + v13786])
      }
      var v13787 = leftType$$1 == null;
      if(!v13787) {
        v13787 = rightType$$1 == null
      }
      if(v13787) {
        var v3929 = this.checker.errorReporter;
        JAM.call(v3929.simpleError, v3929, [binex$$2, "Could not typecheck arithmetic operation.  Possible recursive typecheck error?"]);
        binex$$2.type = this.anyType;
        return binex$$2
      }
      var nodeType$$14 = binex$$2.nodeType;
      var v13789 = this.checker;
      if(JAM.call(v13789.isNullOrUndefinedType, v13789, [leftType$$1])) {
        leftType$$1 = rightType$$1
      }
      var v13790 = this.checker;
      if(JAM.call(v13790.isNullOrUndefinedType, v13790, [rightType$$1])) {
        rightType$$1 = leftType$$1
      }
      var v3933 = this.checker;
      leftType$$1 = JAM.call(v3933.widenType, v3933, [leftType$$1]);
      var v3934 = this.checker;
      rightType$$1 = JAM.call(v3934.widenType, v3934, [rightType$$1]);
      var v13791 = nodeType$$14 == TypeScript$$25.NodeType.Add;
      if(!v13791) {
        v13791 = nodeType$$14 == TypeScript$$25.NodeType.AsgAdd
      }
      if(v13791) {
        var v13792 = leftType$$1 == this.checker.stringType;
        if(!v13792) {
          v13792 = rightType$$1 == this.checker.stringType
        }
        if(v13792) {
          binex$$2.type = this.checker.stringType
        }else {
          var v13793 = leftType$$1 == this.checker.numberType;
          if(v13793) {
            v13793 = rightType$$1 == this.checker.numberType
          }
          if(v13793) {
            binex$$2.type = this.checker.numberType
          }else {
            var v19635 = this.checker;
            var v13794 = JAM.call(v19635.sourceIsSubtypeOfTarget, v19635, [leftType$$1, this.checker.numberType]);
            if(v13794) {
              var v19637 = this.checker;
              v13794 = JAM.call(v19637.sourceIsSubtypeOfTarget, v19637, [rightType$$1, this.checker.numberType])
            }
            if(v13794) {
              binex$$2.type = this.checker.numberType
            }else {
              var v13795 = leftType$$1 == this.checker.anyType;
              if(!v13795) {
                v13795 = rightType$$1 == this.checker.anyType
              }
              if(v13795) {
                binex$$2.type = this.checker.anyType
              }else {
                binex$$2.type = this.anyType;
                var v3939 = this.checker.errorReporter;
                JAM.call(v3939.incompatibleTypes, v3939, [binex$$2, leftType$$1, rightType$$1, binex$$2.printLabel(), this.scope])
              }
            }
          }
        }
      }else {
        var v13797 = leftType$$1 == this.checker.numberType;
        if(v13797) {
          v13797 = rightType$$1 == this.checker.numberType
        }
        if(v13797) {
          binex$$2.type = this.checker.numberType
        }else {
          var v19644 = this.checker;
          var v13798 = JAM.call(v19644.sourceIsSubtypeOfTarget, v19644, [leftType$$1, this.checker.numberType]);
          if(v13798) {
            var v19646 = this.checker;
            v13798 = JAM.call(v19646.sourceIsSubtypeOfTarget, v19646, [rightType$$1, this.checker.numberType])
          }
          if(v13798) {
            binex$$2.type = this.checker.numberType
          }else {
            var v13799 = leftType$$1 == this.checker.anyType;
            if(!v13799) {
              v13799 = rightType$$1 == this.checker.anyType
            }
            if(v13799) {
              binex$$2.type = this.checker.numberType
            }else {
              binex$$2.type = this.anyType;
              var v3949 = this.checker.errorReporter;
              JAM.call(v3949.incompatibleTypes, v3949, [binex$$2, leftType$$1, rightType$$1, binex$$2.printLabel(), this.scope])
            }
          }
        }
      }
      return binex$$2
    }
    function v1035(ast$$98, assignment) {
      var binex$$1 = ast$$98;
      var resultType$$1 = null;
      var v3956 = binex$$1;
      var v26878 = JAM.call(this.typeCheck, this, [binex$$1.operand1]);
      v3956.operand1 = v26878;
      var v3957 = binex$$1;
      var v26879 = JAM.call(this.typeCheck, this, [binex$$1.operand2]);
      v3957.operand2 = v26879;
      var leftType = binex$$1.operand1.type;
      var rightType = binex$$1.operand2.type;
      var v13803 = assignment;
      if(v13803) {
        v13803 = !JAM.call(this.astIsWriteable, this, [binex$$1])
      }
      if(v13803) {
        var v3960 = this.checker.errorReporter;
        JAM.call(v3960.valueCannotBeModified, v3960, [binex$$1])
      }
      if(this.checker.styleSettings.bitwise) {
        var v3962 = this.checker.errorReporter;
        var v19653 = TypeScript$$25.nodeTypeTable;
        var v19654 = binex$$1.nodeType;
        introspect(JAM.policy.p1) {
          var v13807 = v19653[v19654]
        }
        JAM.call(v3962.styleError, v3962, [ast$$98, "use of " + v13807])
      }
      var v19655 = this.checker;
      var v13808 = JAM.call(v19655.sourceIsSubtypeOfTarget, v19655, [leftType, this.doubleType]);
      if(v13808) {
        var v19657 = this.checker;
        v13808 = JAM.call(v19657.sourceIsSubtypeOfTarget, v19657, [rightType, this.doubleType])
      }
      if(v13808) {
        resultType$$1 = this.doubleType
      }else {
        var v13809 = leftType == this.booleanType;
        if(v13809) {
          v13809 = rightType == this.booleanType
        }
        if(v13809) {
          resultType$$1 = this.booleanType
        }else {
          if(leftType == this.anyType) {
            var v13811 = rightType == this.anyType;
            if(!v13811) {
              var v19662 = rightType == this.doubleType;
              if(!v19662) {
                v19662 = rightType == this.booleanType
              }
              v13811 = v19662
            }
            if(v13811) {
              resultType$$1 = this.anyType
            }
          }else {
            if(rightType == this.anyType) {
              var v13813 = leftType == this.anyType;
              if(!v13813) {
                var v19665 = leftType == this.doubleType;
                if(!v19665) {
                  v19665 = leftType == this.booleanType
                }
                v13813 = v19665
              }
              if(v13813) {
                resultType$$1 = this.anyType
              }
            }
          }
        }
      }
      if(resultType$$1 == null) {
        resultType$$1 = this.anyType;
        var v3971 = this.checker.errorReporter;
        JAM.call(v3971.incompatibleTypes, v3971, [binex$$1, leftType, rightType, binex$$1.printLabel(), this.scope])
      }
      binex$$1.type = resultType$$1;
      return binex$$1
    }
    function v1034(ast$$97) {
      var unex$$3 = ast$$97;
      var lval$$1 = unex$$3.operand;
      if(!JAM.call(this.astIsWriteable, this, [unex$$3])) {
        var v3975 = this.checker.errorReporter;
        JAM.call(v3975.valueCannotBeModified, v3975, [unex$$3]);
        unex$$3.type = this.doubleType
      }else {
        unex$$3 = JAM.call(this.typeCheckUnaryNumberOperator, this, [ast$$97]);
        var v13817 = unex$$3.operand.type != this.checker.numberType;
        if(v13817) {
          var v19669 = unex$$3.operand.type != this.checker.anyType;
          if(v19669) {
            v19669 = !(unex$$3.operand.type.typeFlags & TypeScript$$25.TypeFlags.IsEnum)
          }
          v13817 = v19669
        }
        if(v13817) {
          var v3976 = this.checker.errorReporter;
          JAM.call(v3976.simpleError, v3976, [ast$$97, "'++' and '--' may only be applied to operands of type 'number' or 'any'"])
        }
      }
      return unex$$3
    }
    function v1033(ast$$96) {
      return JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [ast$$96.flags, TypeScript$$25.ASTFlags.Writeable])
    }
    function v1032(ast$$95) {
      var unex$$2 = ast$$95;
      var v3981 = unex$$2;
      var v26880 = JAM.call(this.typeCheck, this, [unex$$2.operand]);
      v3981.operand = v26880;
      unex$$2.type = this.booleanType;
      return unex$$2
    }
    function v1031(ast$$94) {
      var unex$$1 = ast$$94;
      var v3982 = unex$$1;
      var v26881 = JAM.call(this.typeCheck, this, [unex$$1.operand]);
      v3982.operand = v26881;
      unex$$1.type = this.doubleType;
      return ast$$94
    }
    function v1030(ast$$93) {
      var unex = ast$$93;
      var v3983 = unex;
      var v26882 = JAM.call(this.typeCheck, this, [unex.operand]);
      v3983.operand = v26882;
      unex.type = this.doubleType;
      return unex
    }
    function v1029(script$$16) {
      this.checker.locationInfo = script$$16.locationInfo;
      this.scope = this.checker.globalScope;
      if(!script$$16.topLevelMod) {
        JAM.call(this.addLocalsFromScope, this, [this.scope, this.checker.gloMod, script$$16.vars, this.checker.globals, true])
      }
      this.currentScript = script$$16;
      var v3991 = script$$16;
      var v26883 = JAM.call(this.typeCheck, this, [script$$16.bod]);
      v3991.bod = v26883;
      this.currentScript = null;
      return script$$16
    }
    function v1028(ast$$92) {
      function v1027(id$$22) {
        var v3992 = _this$$7.scope;
        return JAM.call(v3992.find, v3992, [id$$22, false, typespace$$24])
      }
      var _this$$7 = this;
      var identifier$$3 = ast$$92;
      if(this.checker.inWith) {
        identifier$$3.type = this.anyType
      }else {
        var typespace$$24 = this.inTypeRefTypeCheck;
        var idText$$4 = identifier$$3.text;
        var originalIdText$$1 = idText$$4;
        var isDynamicModuleName = JAM.call(TypeScript$$25.isQuoted, TypeScript$$25, [identifier$$3.text]);
        var v3994 = this.scope;
        var symbol$$18 = JAM.call(v3994.find, v3994, [idText$$4, false, typespace$$24]);
        var v13828 = symbol$$18 == null;
        if(v13828) {
          v13828 = isDynamicModuleName
        }
        if(v13828) {
          var v3995 = this.checker;
          symbol$$18 = JAM.call(v3995.findSymbolForDynamicModule, v3995, [idText$$4, this.currentScript.locationInfo.filename, v1027])
        }
        if(!symbol$$18) {
          if(!identifier$$3.isMissing()) {
            var v3998 = this.checker.errorReporter;
            JAM.call(v3998.unresolvedSymbol, v3998, [identifier$$3, identifier$$3.text])
          }
          identifier$$3.type = this.anyType
        }else {
          var v13832 = TypeScript$$25.optimizeModuleCodeGen;
          if(v13832) {
            var v19671 = symbol$$18;
            if(v19671) {
              v19671 = symbol$$18.isType()
            }
            v13832 = v19671
          }
          if(v13832) {
            var symType$$2 = symbol$$18.getType();
            var v13833 = symType$$2;
            if(v13833) {
              var v19672 = symbol$$18.aliasLink;
              if(v19672) {
                v19672 = symbol$$18.onlyReferencedAsTypeRef
              }
              v13833 = v19672
            }
            if(v13833) {
              var modDecl$$2 = symType$$2.symbol.declAST;
              var v13834 = modDecl$$2;
              if(v13834) {
                v13834 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [modDecl$$2.modFlags, TypeScript$$25.ModuleFlags.IsDynamic])
              }
              if(v13834) {
                symbol$$18.onlyReferencedAsTypeRef = this.inTypeRefTypeCheck
              }
            }
          }
          var v13835 = symbol$$18.declAST;
          if(v13835) {
            var v19675 = symbol$$18.declAST.nodeType == TypeScript$$25.NodeType.FuncDecl;
            if(v19675) {
              var v23289 = !symbol$$18.declAST.returnTypeAnnotation;
              if(v23289) {
                v23289 = symbol$$18.declAST.signature.typeCheckStatus == TypeScript$$25.TypeCheckStatus.Started
              }
              v19675 = v23289
            }
            v13835 = v19675
          }
          if(v13835) {
            var v4005 = symbol$$18.declAST.type.symbol;
            v4005.flags = v4005.flags | TypeScript$$25.SymbolFlags.RecursivelyReferenced;
            symbol$$18.declAST.signature.returnType.type = this.anyType
          }
          JAM.call(this.setTypeFromSymbol, this, [ast$$92, symbol$$18]);
          identifier$$3.sym = symbol$$18;
          if(this.thisFnc) {
            var v13838 = this.thisFnc.type;
            if(v13838) {
              v13838 = symbol$$18.container != this.thisFnc.type.symbol
            }
            if(v13838) {
              JAM.set(this.thisFnc.freeVariables, this.thisFnc.freeVariables.length, symbol$$18)
            }
          }
        }
      }
      return ast$$92
    }
    function v1026(ast$$91, symbol$$17) {
      if(symbol$$17.isVariable()) {
        if(symbol$$17.isInferenceSymbol()) {
          var infSym$$1 = symbol$$17;
          var v13841 = infSym$$1.declAST;
          if(v13841) {
            var v23292 = this.checker;
            v13841 = !JAM.call(v23292.typeStatusIsFinished, v23292, [infSym$$1.typeCheckStatus])
          }
          if(v13841) {
            JAM.call(this.inScopeTypeCheckDecl, this, [infSym$$1.declAST])
          }
          if(!this.checker.styleSettings.innerScopeDeclEscape) {
            var v13843 = infSym$$1.declAST;
            if(v13843) {
              v13843 = infSym$$1.declAST.nodeType == TypeScript$$25.NodeType.VarDecl
            }
            if(v13843) {
              if(this.nestingLevel < infSym$$1.declAST.nestingLevel) {
                var v4016 = this.checker.errorReporter;
                JAM.call(v4016.styleError, v4016, [ast$$91, "Illegal reference to a variable defined in more nested scope"])
              }
            }
          }
        }
        var v4021 = ast$$91;
        var v26884 = symbol$$17.getType();
        v4021.type = v26884;
        if(!symbol$$17.writeable()) {
          ast$$91.flags = ast$$91.flags & ~TypeScript$$25.ASTFlags.Writeable
        }
      }else {
        if(symbol$$17.isType()) {
          var v4025 = ast$$91;
          var v26885 = symbol$$17.getType();
          v4025.type = v26885;
          ast$$91.flags = ast$$91.flags & ~TypeScript$$25.ASTFlags.Writeable
        }else {
          ast$$91.type = this.anyType;
          var v4028 = this.checker.errorReporter;
          JAM.call(v4028.symbolDoesNotReferToAValue, v4028, [ast$$91, symbol$$17.name])
        }
      }
      return
    }
    function v1025(ast$$90) {
      ast$$90.type = this.anyType;
      var illegalThisRef = false;
      if(this.thisFnc == null) {
        if(this.thisType) {
          var v13852 = this.thisClassNode;
          if(v13852) {
            v13852 = this.thisClassNode.nodeType == TypeScript$$25.NodeType.ClassDeclaration
          }
          if(v13852) {
            illegalThisRef = true
          }else {
            ast$$90.type = this.thisType
          }
        }else {
          if(this.checker.currentModDecl) {
            var v4033 = this.checker.errorReporter;
            JAM.call(v4033.simpleError, v4033, [ast$$90, "'this' may not be referenced within module bodies"])
          }
        }
      }else {
        var v13855 = this.thisClassNode;
        if(v13855) {
          var v19693 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [this.thisFnc.fncFlags, TypeScript$$25.FncFlags.IsPropertyBound]);
          if(!v19693) {
            var v23301 = this.inSuperCall;
            if(v23301) {
              v23301 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [this.thisClassNode.varFlags, TypeScript$$25.VarFlags.ClassSuperMustBeFirstCallInConstructor])
            }
            v19693 = v23301
          }
          v13855 = v19693
        }
        if(v13855) {
          illegalThisRef = true
        }
        var v13856 = this.thisFnc.isMethod();
        if(!v13856) {
          var v19695 = this.thisFnc.isConstructor;
          if(!v19695) {
            v19695 = this.thisFnc.isTargetTypedAsMethod
          }
          v13856 = v19695
        }
        if(v13856) {
          var v13857 = this.thisType;
          if(v13857) {
            v13857 = !(this.thisFnc.fncFlags & TypeScript$$25.FncFlags.Static)
          }
          if(v13857) {
            ast$$90.type = this.thisType
          }
        }
      }
      var v13858 = !this.enclosingFncIsMethod;
      if(v13858) {
        var v19699 = this.thisFnc;
        if(v19699) {
          v19699 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [this.thisFnc.fncFlags, TypeScript$$25.FncFlags.IsFatArrowFunction])
        }
        v13858 = v19699
      }
      if(v13858) {
        if(this.thisFnc.boundToProperty) {
          var container$$17 = this.thisFnc.boundToProperty.sym.container;
          if(container$$17.declAST.nodeType == TypeScript$$25.NodeType.FuncDecl) {
            container$$17.declAST.setHasSelfReference()
          }
        }else {
          var encFnc = this.thisFnc.enclosingFnc;
          var firstEncFnc = encFnc;
          for(;encFnc;) {
            var v13863 = this.thisClassNode;
            if(v13863) {
              v13863 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [encFnc.fncFlags, TypeScript$$25.FncFlags.IsPropertyBound])
            }
            if(v13863) {
              illegalThisRef = true
            }
            var v13864 = !JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [encFnc.fncFlags, TypeScript$$25.FncFlags.IsFatArrowFunction]);
            if(!v13864) {
              v13864 = encFnc.hasSelfReference()
            }
            if(v13864) {
              encFnc.setHasSelfReference();
              break
            }
            encFnc = encFnc.enclosingFnc
          }
          var v13865 = !encFnc;
          if(v13865) {
            v13865 = firstEncFnc
          }
          if(v13865) {
            encFnc = firstEncFnc;
            encFnc.setHasSelfReference()
          }else {
            if(!encFnc) {
              if(this.thisClassNode) {
                var v4046 = this.thisClassNode;
                v4046.varFlags = v4046.varFlags | TypeScript$$25.VarFlags.MustCaptureThis
              }else {
                if(this.checker.currentModDecl) {
                  var v4047 = this.checker.currentModDecl;
                  v4047.modFlags = v4047.modFlags | TypeScript$$25.ModuleFlags.MustCaptureThis
                }else {
                  this.checker.mustCaptureGlobalThis = true
                }
              }
            }
          }
          var v13868 = encFnc;
          if(v13868) {
            var v23315 = encFnc.isMethod();
            if(!v23315) {
              v23315 = encFnc.isConstructor
            }
            var v19711 = v23315;
            if(v19711) {
              var v23316 = this.thisType;
              if(v23316) {
                v23316 = !JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [encFnc.fncFlags, TypeScript$$25.FncFlags.Static])
              }
              v19711 = v23316
            }
            v13868 = v19711
          }
          if(v13868) {
            ast$$90.type = this.thisType
          }
        }
      }
      if(illegalThisRef) {
        var v4056 = this.checker.errorReporter;
        JAM.call(v4056.simpleError, v4056, [ast$$90, "Keyword 'this' cannot be referenced in initializers in a class body, or in super constructor calls"])
      }
      return ast$$90
    }
    function v1024(ast$$89) {
      var v13870 = this.thisType;
      if(v13870) {
        var v23317 = this.enclosingFncIsMethod;
        if(v23317) {
          v23317 = !this.thisFnc.isStatic()
        }
        var v19712 = v23317;
        if(v19712) {
          v19712 = this.thisType.baseClass()
        }
        v13870 = v19712
      }
      if(v13870) {
        var v4057 = ast$$89;
        var v26886 = this.thisType.baseClass();
        v4057.type = v26886
      }else {
        var v13872 = !this.enclosingFncIsMethod;
        if(v13872) {
          var v19714 = this.thisType;
          if(v19714) {
            var v23319 = this.thisType.baseClass();
            if(v23319) {
              var v25022 = this.thisFnc;
              if(v25022) {
                v25022 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [this.thisFnc.fncFlags, TypeScript$$25.FncFlags.IsFatArrowFunction])
              }
              v23319 = v25022
            }
            v19714 = v23319
          }
          v13872 = v19714
        }
        if(v13872) {
          var enclosingFnc = this.thisFnc.enclosingFnc;
          var v4059 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [enclosingFnc.fncFlags, TypeScript$$25.FncFlags.IsFatArrowFunction]);
          for(;v4059;) {
            enclosingFnc = enclosingFnc.enclosingFnc;
            v4059 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [enclosingFnc.fncFlags, TypeScript$$25.FncFlags.IsFatArrowFunction])
          }
          var v13877 = enclosingFnc;
          if(v13877) {
            var v23320 = enclosingFnc.isMethod();
            if(!v23320) {
              v23320 = enclosingFnc.isConstructor
            }
            var v19717 = v23320;
            if(v19717) {
              v19717 = !enclosingFnc.isStatic()
            }
            v13877 = v19717
          }
          if(v13877) {
            var v4060 = ast$$89;
            var v26887 = this.thisType.baseClass();
            v4060.type = v26887;
            enclosingFnc.setHasSuperReferenceInFatArrowFunction();
            return ast$$89
          }
        }
        ast$$89.type = this.anyType;
        var v4063 = this.checker.errorReporter;
        JAM.call(v4063.invalidSuperReference, v4063, [ast$$89])
      }
      return ast$$89
    }
    function v1023(varDecl$$17, typeName$$2, isModuleName$$1) {
      var typestring = "";
      if(isModuleName$$1) {
        var quotestring = "";
        if(!JAM.call(TypeScript$$25.isQuoted, TypeScript$$25, [typeName$$2])) {
          quotestring = "'"
        }
        typestring = " is using inaccessible module " + quotestring + typeName$$2 + quotestring
      }else {
        typestring = " has or is using private type '" + typeName$$2 + "'"
      }
      if(JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [varDecl$$17.varFlags, TypeScript$$25.VarFlags.Public])) {
        if(varDecl$$17.sym.container.declAST.nodeType == TypeScript$$25.NodeType.InterfaceDeclaration) {
          var v4068 = this.checker.errorReporter;
          JAM.call(v4068.simpleError, v4068, [varDecl$$17, "property '" + varDecl$$17.sym.name + "' of exported interface" + typestring])
        }else {
          var v4070 = this.checker.errorReporter;
          JAM.call(v4070.simpleError, v4070, [varDecl$$17, "public member '" + varDecl$$17.sym.name + "' of exported class" + typestring])
        }
      }else {
        var v4073 = this.checker.errorReporter;
        JAM.call(v4073.simpleError, v4073, [varDecl$$17, "exported variable '" + varDecl$$17.sym.name + "'" + typestring])
      }
      return
    }
    function v1022(varDecl$$16) {
      function v1021(typeName$$1, isModuleName) {
        return JAM.call(_this$$6.varPrivacyErrorReporter, _this$$6, [varDecl$$16, typeName$$1, isModuleName])
      }
      function v1020(ast$$88, parent$$65, walker$$49) {
        var v13892 = ast$$88;
        if(v13892) {
          v13892 = ast$$88.nodeType == TypeScript$$25.NodeType.FuncDecl
        }
        if(v13892) {
          if(JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [ast$$88.fncFlags, TypeScript$$25.FncFlags.IsFatArrowFunction])) {
            ast$$88.fncFlags = ast$$88.fncFlags | TypeScript$$25.FncFlags.IsPropertyBound
          }
          walker$$49.options.goChildren = false
        }
        return ast$$88
      }
      var _this$$6 = this;
      var infSym = varDecl$$16.sym;
      if(infSym == null) {
        if(varDecl$$16.init) {
          var v4079 = varDecl$$16;
          var v26888 = JAM.call(this.typeCheck, this, [varDecl$$16.init]);
          v4079.init = v26888;
          var v4080 = varDecl$$16;
          var v13898 = this.checker;
          var v26889 = JAM.call(v13898.widenType, v13898, [varDecl$$16.init.type]);
          v4080.type = v26889
        }else {
          if(this.checker.styleSettings.implicitAny) {
            var v4081 = this.checker.errorReporter;
            JAM.call(v4081.styleError, v4081, [varDecl$$16, "type implicitly set to 'any'"])
          }
          varDecl$$16.type = this.anyType
        }
      }else {
        if(infSym.typeCheckStatus == TypeScript$$25.TypeCheckStatus.Started) {
          if(this.checker.styleSettings.implicitAny) {
            var v4084 = this.checker.errorReporter;
            JAM.call(v4084.styleError, v4084, [varDecl$$16, "type implicitly set to 'any'"])
          }
          varDecl$$16.type = this.anyType;
          JAM.call(infSym.setType, infSym, [this.anyType])
        }else {
          if(infSym.typeCheckStatus == TypeScript$$25.TypeCheckStatus.NotStarted) {
            infSym.typeCheckStatus = TypeScript$$25.TypeCheckStatus.Started;
            var v4088 = this.checker;
            JAM.call(v4088.addStartedPTO, v4088, [infSym]);
            var resolved$$1 = false;
            if(varDecl$$16.type == null) {
              if(varDecl$$16.typeExpr) {
                JAM.call(this.resolveBoundDecl, this, [varDecl$$16]);
                resolved$$1 = true;
                varDecl$$16.type = varDecl$$16.typeExpr.type;
                var v4090 = infSym;
                var v26890 = this.checker.getTypeCheckFinishedStatus();
                v4090.typeCheckStatus = v26890
              }
            }
            if(varDecl$$16.init) {
              var isLocalStatic = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [varDecl$$16.varFlags, TypeScript$$25.VarFlags.LocalStatic]);
              var prevScope$$3 = this.scope;
              var applyTargetType$$1 = !varDecl$$16.init.isParenthesized;
              if(isLocalStatic) {
                this.scope = varDecl$$16.sym.container.getType().memberScope
              }
              var v13913 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [varDecl$$16.varFlags, TypeScript$$25.VarFlags.Property]);
              if(v13913) {
                v13913 = this.thisClassNode
              }
              if(v13913) {
                var v4097 = TypeScript$$25.getAstWalkerFactory();
                JAM.call(v4097.walk, v4097, [varDecl$$16.init, v1020])
              }
              var v4100 = this.checker;
              JAM.call(v4100.typeCheckWithContextualType, v4100, [varDecl$$16.type, this.checker.inProvisionalTypecheckMode(), applyTargetType$$1, varDecl$$16.init]);
              this.scope = prevScope$$3;
              if(varDecl$$16.type) {
                var preserveScope = false;
                var preservedContainedScope = null;
                if(varDecl$$16.init.type) {
                  preservedContainedScope = varDecl$$16.init.type.containedScope;
                  preserveScope = true;
                  if(varDecl$$16.init.type == this.voidType) {
                    var v4105 = this.checker.errorReporter;
                    JAM.call(v4105.simpleError, v4105, [varDecl$$16, "Cannot assign type 'void' to variable '" + varDecl$$16.id.actualText + "'"])
                  }
                }
                var v4109 = varDecl$$16;
                var v13921 = varDecl$$16.init;
                var v13922 = varDecl$$16.type;
                var v19738 = applyTargetType$$1;
                if(v19738) {
                  v19738 = !this.checker.inProvisionalTypecheckMode()
                }
                var v26891 = JAM.call(this.castWithCoercion, this, [v13921, v13922, v19738, false]);
                v4109.init = v26891;
                var v13924 = preserveScope;
                if(v13924) {
                  v13924 = varDecl$$16.init.type.containedScope == null
                }
                if(v13924) {
                  varDecl$$16.init.type.containedScope = preservedContainedScope
                }
              }else {
                var v4112 = varDecl$$16;
                var v13926 = this.checker;
                var v26892 = JAM.call(v13926.widenType, v13926, [varDecl$$16.init.type]);
                v4112.type = v26892;
                if(varDecl$$16.type == this.voidType) {
                  var v4113 = this.checker.errorReporter;
                  JAM.call(v4113.simpleError, v4113, [varDecl$$16, "Cannot assign type 'void' to variable '" + varDecl$$16.id.actualText + "'"]);
                  varDecl$$16.type = this.anyType
                }
              }
              JAM.call(infSym.setType, infSym, [varDecl$$16.type])
            }else {
              if(!resolved$$1) {
                JAM.call(this.resolveBoundDecl, this, [varDecl$$16])
              }
            }
            var v4120 = infSym;
            var v26893 = this.checker.getTypeCheckFinishedStatus();
            v4120.typeCheckStatus = v26893
          }else {
            var v19742 = this.checker;
            var v13933 = JAM.call(v19742.typeStatusIsFinished, v19742, [infSym.typeCheckStatus]);
            if(v13933) {
              v13933 = infSym.declAST != varDecl$$16
            }
            if(v13933) {
              if(varDecl$$16.init) {
                var v4121 = varDecl$$16;
                var v26894 = JAM.call(this.typeCheck, this, [varDecl$$16.init]);
                v4121.init = v26894;
                var v4122 = varDecl$$16;
                var v26895 = infSym.getType();
                v4122.type = v26895;
                var v4123 = varDecl$$16;
                var v26896 = JAM.call(this.cast, this, [varDecl$$16.init, varDecl$$16.type]);
                v4123.init = v26896
              }
            }
          }
        }
      }
      var v13937 = varDecl$$16.id;
      if(v13937) {
        v13937 = varDecl$$16.sym
      }
      if(v13937) {
        varDecl$$16.id.sym = varDecl$$16.sym
      }
      var v13938 = varDecl$$16.sym;
      if(v13938) {
        v13938 = varDecl$$16.sym.container
      }
      if(v13938) {
        JAM.call(this.checkTypePrivacy, this, [varDecl$$16.sym.getType(), varDecl$$16.sym, v1021])
      }
      return varDecl$$16
    }
    function v1019(varDecl$$15) {
      if(varDecl$$15.typeExpr) {
        var v13940 = varDecl$$15.typeExpr.type == null;
        if(!v13940) {
          var v23333 = varDecl$$15.typeExpr.type;
          if(v23333) {
            var v25031 = varDecl$$15.typeExpr.type == this.anyType;
            if(v25031) {
              v25031 = this.scope
            }
            v23333 = v25031
          }
          var v19747 = v23333;
          if(!v19747) {
            var v23334 = varDecl$$15.typeExpr.type.symbol == null;
            if(!v23334) {
              var v25866 = this.checker;
              v23334 = !JAM.call(v25866.typeStatusIsFinished, v25866, [varDecl$$15.typeExpr.type.symbol.typeCheckStatus])
            }
            v19747 = v23334
          }
          v13940 = v19747
        }
        if(v13940) {
          JAM.call(this.typeCheck, this, [varDecl$$15.typeExpr])
        }
        varDecl$$15.type = varDecl$$15.typeExpr.type;
        if(varDecl$$15.sym) {
          var v4137 = varDecl$$15.sym;
          JAM.call(v4137.setType, v4137, [varDecl$$15.type])
        }
      }else {
        if(varDecl$$15.init == null) {
          if(this.checker.styleSettings.implicitAny) {
            var v4140 = this.checker.errorReporter;
            JAM.call(v4140.styleError, v4140, [varDecl$$15, "type implicitly set to 'any'"])
          }
          varDecl$$15.type = this.anyType;
          if(varDecl$$15.sym) {
            if(varDecl$$15.sym.isType()) {
              var tsym$$1 = varDecl$$15.sym;
              if(tsym$$1.isMethod) {
                var v4142 = this.checker.errorReporter;
                JAM.call(v4142.simpleError, v4142, [varDecl$$15, "Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)"]);
                return
              }else {
                var v4143 = this.checker.errorReporter;
                JAM.call(v4143.simpleError, v4143, [varDecl$$15, "Cannot bind type to variable"]);
                return
              }
            }
            var v4146 = varDecl$$15.sym;
            JAM.call(v4146.setType, v4146, [varDecl$$15.type])
          }
        }
      }
      return
    }
    function v1018(varDecl$$14) {
      var sym$$34 = varDecl$$14.sym;
      var svThisFnc$$1 = this.thisFnc;
      var svThisType$$1 = this.thisType;
      var prevMethodStatus$$1 = this.enclosingFncIsMethod;
      var prevLocationInfo$$1 = this.checker.locationInfo;
      var v13947 = sym$$34;
      if(v13947) {
        v13947 = sym$$34.container
      }
      if(v13947) {
        var v4152;
        if(JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [varDecl$$14.varFlags, TypeScript$$25.VarFlags.ClassConstructorProperty])) {
          v4152 = sym$$34.container.getType().constructorScope
        }else {
          v4152 = sym$$34.container.instanceScope()
        }
        var instanceScope = v4152;
        var v13951 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [varDecl$$14.varFlags, TypeScript$$25.VarFlags.Property]);
        if(v13951) {
          v13951 = sym$$34.container.declAST.nodeType == TypeScript$$25.NodeType.FuncDecl
        }
        if(v13951) {
          this.thisFnc = sym$$34.container.declAST
        }
        if(instanceScope) {
          var prevScope$$2 = this.scope;
          this.scope = instanceScope;
          var container$$16 = sym$$34.container;
          var v13952 = this.checker.units;
          if(v13952) {
            var v19758 = sym$$34.unitIndex >= 0;
            if(v19758) {
              v19758 = sym$$34.unitIndex < this.checker.units.length
            }
            v13952 = v19758
          }
          if(v13952) {
            var v4155 = this.checker;
            var v13953 = this.checker.units;
            var v13954 = sym$$34.unitIndex;
            introspect(JAM.policy.p1) {
              v4155.locationInfo = v13953[v13954]
            }
          }else {
            this.checker.locationInfo = TypeScript$$25.unknownLocationInfo
          }
          for(;container$$16;) {
            if(container$$16.kind() == TypeScript$$25.SymbolKind.Type) {
              var typeSym$$3 = container$$16;
              var type$$49 = typeSym$$3.type;
              if(type$$49.call) {
                this.enclosingFncIsMethod = typeSym$$3.isMethod
              }
              if(type$$49.isClass()) {
                this.thisType = type$$49.instanceType;
                break
              }
            }
            container$$16 = container$$16.container
          }
          JAM.call(this.typeCheckBoundDecl, this, [varDecl$$14]);
          this.scope = prevScope$$2
        }
      }
      this.thisFnc = svThisFnc$$1;
      this.thisType = svThisType$$1;
      this.checker.locationInfo = prevLocationInfo$$1;
      this.enclosingFncIsMethod = prevMethodStatus$$1;
      return
    }
    function v1017(ast$$87) {
      var v13957 = ast$$87.nodeType == TypeScript$$25.NodeType.VarDecl;
      if(!v13957) {
        v13957 = ast$$87.nodeType == TypeScript$$25.NodeType.ArgDecl
      }
      if(v13957) {
        JAM.call(this.inScopeTypeCheckBoundDecl, this, [ast$$87])
      }else {
        if(ast$$87.nodeType == TypeScript$$25.NodeType.FuncDecl) {
          var funcDecl$$23 = ast$$87;
          if(funcDecl$$23.isAccessor()) {
            JAM.call(this.typeCheckFunction, this, [funcDecl$$23])
          }
        }
      }
      return
    }
    function v1016(ast$$86) {
      if(ast$$86) {
        return JAM.call(ast$$86.typeCheck, ast$$86, [this])
      }else {
        return null
      }
      return
    }
    function v1015(ast$$85, enclosingScope) {
      var prevScope$$1 = this.scope;
      this.scope = enclosingScope;
      var svThisFnc = this.thisFnc;
      var svThisType = this.thisType;
      var svThisClassNode = this.thisClassNode;
      var svCurrentModDecl = this.checker.currentModDecl;
      var prevMethodStatus = this.enclosingFncIsMethod;
      var container$$15 = this.scope.container;
      var fnc$$1 = null;
      for(;container$$15;) {
        if(container$$15.kind() == TypeScript$$25.SymbolKind.Type) {
          var typeSym$$2 = container$$15;
          var type$$48 = typeSym$$2.type;
          if(type$$48.call) {
            if(fnc$$1 == null) {
              this.enclosingFncIsMethod = typeSym$$2.isMethod;
              fnc$$1 = container$$15.declAST
            }
          }
          if(type$$48.isClass()) {
            this.thisType = type$$48.instanceType;
            var v13962 = typeSym$$2.declAST;
            if(v13962) {
              v13962 = typeSym$$2.declAST.nodeType == TypeScript$$25.NodeType.ClassDeclaration
            }
            if(v13962) {
              this.thisClassNode = typeSym$$2.declAST
            }
            break
          }
          if(type$$48.isModuleType()) {
            this.checker.currentModDecl = typeSym$$2.declAST;
            break
          }
        }
        container$$15 = container$$15.container
      }
      this.thisFnc = fnc$$1;
      var updated = JAM.call(this.typeCheck, this, [ast$$85]);
      this.thisFnc = svThisFnc;
      this.thisType = svThisType;
      this.thisClassNode = svThisClassNode;
      this.checker.currentModDecl = svCurrentModDecl;
      this.enclosingFncIsMethod = prevMethodStatus;
      this.scope = prevScope$$1;
      return updated
    }
    function v1014(ast$$84, type$$47, applyCoercion, typeAssertion) {
      var comparisonInfo$$12 = new TypeScript$$25.TypeComparisonInfo;
      var v19770 = this.checker;
      var v13963 = JAM.call(v19770.sourceIsAssignableToTarget, v19770, [ast$$84.type, type$$47, comparisonInfo$$12]);
      if(!v13963) {
        var v19772 = typeAssertion;
        if(v19772) {
          var v23347 = this.checker;
          v19772 = JAM.call(v23347.sourceIsAssignableToTarget, v23347, [type$$47, ast$$84.type, comparisonInfo$$12])
        }
        v13963 = v19772
      }
      if(v13963) {
        if(applyCoercion) {
          if(type$$47 == null) {
            ast$$84.type = this.anyType
          }else {
            if(type$$47.isClass()) {
              ast$$84.type = type$$47.instanceType
            }else {
              ast$$84.type = type$$47
            }
          }
        }
        return ast$$84
      }else {
        var v4179 = this.checker.errorReporter;
        JAM.call(v4179.incompatibleTypes, v4179, [ast$$84, ast$$84.type, type$$47, null, this.scope, comparisonInfo$$12]);
        return ast$$84
      }
      return
    }
    function v1013(ast$$83, type$$46) {
      return JAM.call(this.castWithCoercion, this, [ast$$83, type$$46, true, false])
    }
    function v1012() {
      var v4183 = this.globalScope;
      var arraySym = JAM.call(v4183.find, v4183, ["Array", false, true]);
      var v13965 = arraySym;
      if(v13965) {
        v13965 = arraySym.kind() == TypeScript$$25.SymbolKind.Type
      }
      if(v13965) {
        this.arrayInterfaceType = arraySym.type
      }
      var v4185 = this.globalScope;
      var stringSym = JAM.call(v4185.find, v4185, ["String", false, true]);
      var v13966 = stringSym;
      if(v13966) {
        v13966 = stringSym.kind() == TypeScript$$25.SymbolKind.Type
      }
      if(v13966) {
        this.stringInterfaceType = stringSym.type
      }
      var v4187 = this.globalScope;
      var objectSym = JAM.call(v4187.find, v4187, ["Object", false, true]);
      var v13967 = objectSym;
      if(v13967) {
        v13967 = objectSym.kind() == TypeScript$$25.SymbolKind.Type
      }
      if(v13967) {
        this.objectInterfaceType = objectSym.type
      }
      var v4189 = this.globalScope;
      var fnSym = JAM.call(v4189.find, v4189, ["Function", false, true]);
      var v13968 = fnSym;
      if(v13968) {
        v13968 = fnSym.kind() == TypeScript$$25.SymbolKind.Type
      }
      if(v13968) {
        this.functionInterfaceType = fnSym.type
      }
      var v4191 = this.globalScope;
      var numberSym = JAM.call(v4191.find, v4191, ["Number", false, true]);
      var v13969 = numberSym;
      if(v13969) {
        v13969 = numberSym.kind() == TypeScript$$25.SymbolKind.Type
      }
      if(v13969) {
        this.numberInterfaceType = numberSym.type
      }
      var v4193 = this.globalScope;
      var booleanSym = JAM.call(v4193.find, v4193, ["Boolean", false, true]);
      var v13970 = booleanSym;
      if(v13970) {
        v13970 = booleanSym.kind() == TypeScript$$25.SymbolKind.Type
      }
      if(v13970) {
        this.booleanInterfaceType = booleanSym.type
      }
      var v4195 = this.globalScope;
      var regexSym = JAM.call(v4195.find, v4195, ["RegExp", false, true]);
      var v13971 = regexSym;
      if(v13971) {
        v13971 = regexSym.kind() == TypeScript$$25.SymbolKind.Type
      }
      if(v13971) {
        this.regexType = regexSym.type
      }
      return
    }
    function TypeFlow$$1(logger$$4, initScope, parser$$2, checker$$17) {
      this.logger = logger$$4;
      this.initScope = initScope;
      this.parser = parser$$2;
      this.checker = checker$$17;
      this.thisFnc = null;
      this.thisClassNode = null;
      this.enclosingFncIsMethod = false;
      this.arrayInterfaceType = null;
      this.stringInterfaceType = null;
      this.objectInterfaceType = null;
      this.functionInterfaceType = null;
      this.numberInterfaceType = null;
      this.booleanInterfaceType = null;
      this.iargumentsInterfaceType = null;
      this.currentScript = null;
      this.inImportTypeCheck = false;
      this.inTypeRefTypeCheck = false;
      this.inArrayElementTypeCheck = false;
      var v26897 = new ResolutionDataCache;
      this.resolutionDataCache = v26897;
      this.nestingLevel = 0;
      this.inSuperCall = false;
      this.checker.typeFlow = this;
      this.scope = this.initScope;
      this.globalScope = this.initScope;
      this.doubleType = this.checker.numberType;
      this.booleanType = this.checker.booleanType;
      this.stringType = this.checker.stringType;
      this.anyType = this.checker.anyType;
      this.regexType = this.anyType;
      this.nullType = this.checker.nullType;
      this.voidType = this.checker.voidType;
      var v4204 = this.checker;
      var v26898 = JAM.call(v4204.makeArrayType, v4204, [this.anyType]);
      this.arrayAnyType = v26898;
      return
    }
    TypeFlow$$1.prototype.initLibs = v1012;
    TypeFlow$$1.prototype.cast = v1013;
    TypeFlow$$1.prototype.castWithCoercion = v1014;
    TypeFlow$$1.prototype.inScopeTypeCheck = v1015;
    TypeFlow$$1.prototype.typeCheck = v1016;
    TypeFlow$$1.prototype.inScopeTypeCheckDecl = v1017;
    TypeFlow$$1.prototype.inScopeTypeCheckBoundDecl = v1018;
    TypeFlow$$1.prototype.resolveBoundDecl = v1019;
    TypeFlow$$1.prototype.typeCheckBoundDecl = v1022;
    TypeFlow$$1.prototype.varPrivacyErrorReporter = v1023;
    TypeFlow$$1.prototype.typeCheckSuper = v1024;
    TypeFlow$$1.prototype.typeCheckThis = v1025;
    TypeFlow$$1.prototype.setTypeFromSymbol = v1026;
    TypeFlow$$1.prototype.typeCheckName = v1028;
    TypeFlow$$1.prototype.typeCheckScript = v1029;
    TypeFlow$$1.prototype.typeCheckBitNot = v1030;
    TypeFlow$$1.prototype.typeCheckUnaryNumberOperator = v1031;
    TypeFlow$$1.prototype.typeCheckLogNot = v1032;
    TypeFlow$$1.prototype.astIsWriteable = v1033;
    TypeFlow$$1.prototype.typeCheckIncOrDec = v1034;
    TypeFlow$$1.prototype.typeCheckBitwiseOperator = v1035;
    TypeFlow$$1.prototype.typeCheckArithmeticOperator = v1036;
    TypeFlow$$1.prototype.typeCheckDotOperator = v1037;
    TypeFlow$$1.prototype.typeCheckBooleanOperator = v1038;
    TypeFlow$$1.prototype.typeCheckAsgOperator = v1039;
    TypeFlow$$1.prototype.typeCheckIndex = v1040;
    TypeFlow$$1.prototype.typeCheckInOperator = v1041;
    TypeFlow$$1.prototype.typeCheckShift = v1042;
    TypeFlow$$1.prototype.typeCheckQMark = v1043;
    TypeFlow$$1.prototype.addFormals = v1044;
    TypeFlow$$1.prototype.addLocalsFromScope = v1045;
    TypeFlow$$1.prototype.addConstructorLocalArgs = v1046;
    TypeFlow$$1.prototype.checkInitSelf = v1047;
    TypeFlow$$1.prototype.checkPromoteFreeVars = v1048;
    TypeFlow$$1.prototype.allReturnsAreVoid = v1050;
    TypeFlow$$1.prototype.classConstructorHasSuperCall = v1051;
    TypeFlow$$1.prototype.baseListPrivacyErrorReporter = v1052;
    TypeFlow$$1.prototype.typeCheckBaseListPrivacy = v1054;
    TypeFlow$$1.prototype.checkSymbolPrivacy = v1055;
    TypeFlow$$1.prototype.checkTypePrivacy = v1057;
    TypeFlow$$1.prototype.checkSignatureGroupPrivacy = v1058;
    TypeFlow$$1.prototype.functionArgumentPrivacyErrorReporter = v1059;
    TypeFlow$$1.prototype.returnTypePrivacyError = v1060;
    TypeFlow$$1.prototype.functionReturnTypePrivacyErrorReporter = v1061;
    TypeFlow$$1.prototype.typeCheckFunction = v1069;
    TypeFlow$$1.prototype.typeCheckBases = v1070;
    TypeFlow$$1.prototype.checkMembersImplementInterfaces = v1071;
    TypeFlow$$1.prototype.typeCheckBaseCalls = v1072;
    TypeFlow$$1.prototype.assertUniqueNamesInBaseTypes = v1074;
    TypeFlow$$1.prototype.checkBaseTypeMemberInheritance = v1076;
    TypeFlow$$1.prototype.typeCheckClass = v1077;
    TypeFlow$$1.prototype.typeCheckOverloadSignatures = v1078;
    TypeFlow$$1.prototype.typeCheckInterface = v1079;
    TypeFlow$$1.prototype.typeCheckImportDecl = v1080;
    TypeFlow$$1.prototype.typeCheckModule = v1081;
    TypeFlow$$1.prototype.typeCheckFor = v1082;
    TypeFlow$$1.prototype.typeCheckWith = v1083;
    TypeFlow$$1.prototype.typeCheckForIn = v1084;
    TypeFlow$$1.prototype.typeCheckWhile = v1085;
    TypeFlow$$1.prototype.typeCheckDoWhile = v1086;
    TypeFlow$$1.prototype.typeCheckCondExpr = v1087;
    TypeFlow$$1.prototype.typeCheckCompoundStmtBlock = v1088;
    TypeFlow$$1.prototype.typeCheckIf = v1089;
    TypeFlow$$1.prototype.typeFromAccessorFuncDecl = v1090;
    TypeFlow$$1.prototype.typeCheckObjectLit = v1091;
    TypeFlow$$1.prototype.typeCheckArrayLit = v1095;
    TypeFlow$$1.prototype.checkForVoidConstructor = v1096;
    TypeFlow$$1.prototype.typeCheckReturn = v1097;
    TypeFlow$$1.prototype.typeCheckInstOf = v1098;
    TypeFlow$$1.prototype.typeCheckCommaOperator = v1099;
    TypeFlow$$1.prototype.typeCheckLogOr = v1100;
    TypeFlow$$1.prototype.typeCheckLogAnd = v1101;
    TypeFlow$$1.prototype.tryAddCandidates = v1102;
    TypeFlow$$1.prototype.resolveOverload = v1103;
    TypeFlow$$1.prototype.typeCheckNew = v1104;
    TypeFlow$$1.prototype.preTypeCheckCallArgs = v1105;
    TypeFlow$$1.prototype.postTypeCheckCallArgs = v1106;
    TypeFlow$$1.prototype.typeCheckCall = v1107;
    TypeFlow$$1.prototype.assignScopes = v1108;
    TypeFlow$$1.prototype.findMemberScope = v1109;
    TypeFlow$$1.prototype.findMemberScopeAt = v1110;
    TypeFlow$$1.prototype.findMemberScopeAtFullAst = v1111;
    return TypeFlow$$1
  }
  function v1011() {
    function v1010(rd$$1) {
      rd$$1.actuals.length = 0;
      rd$$1.exactCandidates.length = 0;
      rd$$1.conversionCandidates.length = 0;
      this.nextUp = rd$$1.id;
      return
    }
    function v1009() {
      var rd = null;
      if(this.nextUp < this.cacheSize) {
        var v4291 = this.rdCache;
        var v4292 = this.nextUp;
        introspect(JAM.policy.p1) {
          rd = v4291[v4292]
        }
      }
      if(rd == null) {
        this.cacheSize = this.cacheSize + 1;
        rd = {actuals:new Array, exactCandidates:new Array, conversionCandidates:new Array, id:this.cacheSize};
        JAM.set(this.rdCache, this.cacheSize, rd)
      }
      this.nextUp = this.nextUp + 1;
      return rd
    }
    function ResolutionDataCache$$1() {
      this.cacheSize = 16;
      this.rdCache = [];
      this.nextUp = 0;
      var i$$92 = 0;
      var v4303 = i$$92 < this.cacheSize;
      for(;v4303;) {
        this.rdCache[i$$92] = {actuals:new Array, exactCandidates:new Array, conversionCandidates:new Array, id:i$$92};
        i$$92 = i$$92 + 1;
        v4303 = i$$92 < this.cacheSize
      }
      return
    }
    ResolutionDataCache$$1.prototype.getResolutionData = v1009;
    ResolutionDataCache$$1.prototype.returnResolutionData = v1010;
    return ResolutionDataCache$$1
  }
  function v1008() {
    function v1007(ast$$82) {
      if(this.current) {
        var v4306 = this.current.content;
        JAM.call(v4306.append, v4306, [ast$$82])
      }
      return
    }
    function v1006(target$$45, isContinue) {
      var targetBB = null;
      var i$$91 = 0;
      var len$$41 = this.statementStack.length;
      var v4311 = i$$91 < len$$41;
      for(;v4311;) {
        var v4309 = this.statementStack;
        introspect(JAM.policy.p1) {
          var targetInfo$$5 = v4309[i$$91]
        }
        if(targetInfo$$5.stmt == target$$45) {
          if(isContinue) {
            targetBB = targetInfo$$5.continueBB
          }else {
            targetBB = targetInfo$$5.breakBB
          }
          break
        }
        i$$91 = i$$91 + 1;
        v4311 = i$$91 < len$$41
      }
      if(targetBB) {
        var v4312 = this.current;
        JAM.call(v4312.addSuccessor, v4312, [targetBB])
      }
      this.setUnreachable();
      return
    }
    function v1005(ast$$81) {
      if(this.unreachable === null) {
        var v26899 = new Array;
        this.unreachable = v26899
      }
      JAM.set(this.unreachable, this.unreachable.length, ast$$81);
      return
    }
    function v1004() {
      this.current = null;
      this.noContinuation = true;
      return
    }
    function v1003() {
      var v4316 = this.current;
      JAM.call(v4316.addSuccessor, v4316, [this.exit]);
      this.setUnreachable();
      return
    }
    function v1002() {
      return this.statementStack.pop()
    }
    function v1001(stmt$$5, continueBB, breakBB) {
      var v4319 = this.statementStack;
      JAM.call(v4319.push, v4319, [{stmt:stmt$$5, continueBB:continueBB, breakBB:breakBB}]);
      return
    }
    function v1000(outfile$$14) {
      function node$$3(bb$$6) {
        if(bb$$6.index < 0) {
          bb$$6.index = index$$56;
          index$$56 = index$$56 + 1
        }
        if(bb$$6 == _this$$5.exit) {
          JAM.call(outfile$$14.WriteLine, outfile$$14, ["Exit block with index " + bb$$6.index])
        }else {
          JAM.call(outfile$$14.WriteLine, outfile$$14, ["Basic block with index " + bb$$6.index]);
          JAM.call(_this$$5.printBlockContent, _this$$5, [bb$$6, outfile$$14])
        }
        return
      }
      function preEdges$$1() {
        JAM.call(outfile$$14.Write, outfile$$14, ["  Branches to "]);
        return
      }
      function postEdges$$1() {
        JAM.call(outfile$$14.WriteLine, outfile$$14, [""]);
        return
      }
      function edge(node1, node2) {
        if(node2.index < 0) {
          node2.index = index$$56;
          index$$56 = index$$56 + 1
        }
        JAM.call(outfile$$14.Write, outfile$$14, [node2.index + " "]);
        return
      }
      var _this$$5 = this;
      var index$$56 = 0;
      JAM.call(this.bfs, this, [node$$3, edge, preEdges$$1, postEdges$$1]);
      if(this.unreachable != null) {
        var i$$90 = 0;
        var len$$40 = this.unreachable.length;
        var v4329 = i$$90 < len$$40;
        for(;v4329;) {
          JAM.call(outfile$$14.WriteLine, outfile$$14, ["Unreachable basic block ..."]);
          var v13992 = this.unreachable;
          introspect(JAM.policy.p1) {
            var v4328 = v13992[i$$90]
          }
          JAM.call(this.printAST, this, [v4328, outfile$$14]);
          i$$90 = i$$90 + 1;
          v4329 = i$$90 < len$$40
        }
      }
      return
    }
    function v999(er$$1, funcSym) {
      function v998(index$$55) {
        var v4331 = useDefContext$$3.uses;
        introspect(JAM.policy.p1) {
          var ast$$80 = v4331[index$$55]
        }
        JAM.call(er$$1.simpleError, er$$1, [ast$$80, "use of variable '" + ast$$80.actualText + "' that is not definitely assigned"]);
        return
      }
      function useDefInit(bb$$5) {
        var v4333 = bb$$5;
        var v26900 = JAM.new(BBUseDefInfo, [bb$$5]);
        v4333.useDef = v26900;
        var v4334 = bb$$5.useDef;
        JAM.call(v4334.initialize, v4334, [useDefContext$$3]);
        JAM.set(_this$$4.linearBBs, _this$$4.linearBBs.length, bb$$5);
        return
      }
      var _this$$4 = this;
      var useDefContext$$3 = new UseDefContext;
      useDefContext$$3.func = funcSym;
      JAM.call(this.bfs, this, [useDefInit, null, null, null]);
      var i$$89;
      var bbLen;
      i$$89 = 0;
      bbLen = this.linearBBs.length;
      var v4339 = i$$89 < bbLen;
      for(;v4339;) {
        var v19789 = this.linearBBs;
        introspect(JAM.policy.p1) {
          var v13996 = v19789[i$$89]
        }
        var v4337 = v13996.useDef;
        JAM.call(v4337.initializeGen, v4337, [useDefContext$$3]);
        var v19790 = this.linearBBs;
        introspect(JAM.policy.p1) {
          var v13997 = v19790[i$$89]
        }
        var v4338 = v13997.useDef;
        JAM.call(v4338.initializeKill, v4338, [useDefContext$$3]);
        i$$89 = i$$89 + 1;
        v4339 = i$$89 < bbLen
      }
      var changed$$1 = true;
      for(;changed$$1;) {
        changed$$1 = false;
        i$$89 = 0;
        var v4341 = i$$89 < bbLen;
        for(;v4341;) {
          var v23356 = this.linearBBs;
          introspect(JAM.policy.p1) {
            var v19791 = v23356[i$$89]
          }
          var v4340 = v19791.useDef.updateTop();
          if(!v4340) {
            v4340 = changed$$1
          }
          changed$$1 = v4340;
          i$$89 = i$$89 + 1;
          v4341 = i$$89 < bbLen
        }
      }
      var top$$2 = this.entry.useDef.top;
      JAM.call(top$$2.map, top$$2, [v998]);
      return
    }
    function v997(nodeFunc, edgeFunc, preEdges, postEdges) {
      var markValue = this.markBase;
      this.markBase = this.markBase + 1;
      var q = new Array;
      q[q.length] = this.entry;
      var v4351 = q.length > 0;
      for(;v4351;) {
        var bb$$4 = q.pop();
        if(!JAM.call(bb$$4.marked, bb$$4, [markValue])) {
          bb$$4.mark();
          if(nodeFunc) {
            JAM.call(nodeFunc, null, [bb$$4])
          }
          var succLen$$1 = bb$$4.successors.length;
          if(succLen$$1 > 0) {
            if(preEdges) {
              preEdges()
            }
            var j$$12 = succLen$$1 - 1;
            var v4348 = j$$12 >= 0;
            for(;v4348;) {
              var v4345 = bb$$4.successors;
              introspect(JAM.policy.p1) {
                var successor$$1 = v4345[j$$12]
              }
              if(!JAM.call(successor$$1.marked, successor$$1, [this.markBase])) {
                if(edgeFunc) {
                  JAM.call(edgeFunc, null, [bb$$4, successor$$1])
                }
                q[q.length] = successor$$1
              }
              j$$12 = j$$12 - 1;
              v4348 = j$$12 >= 0
            }
            if(postEdges) {
              postEdges()
            }
          }
        }
        v4351 = q.length > 0
      }
      return
    }
    function v996(bb$$3, outfile$$13) {
      var content$$4 = bb$$3.content;
      var i$$88 = 0;
      var len$$39 = content$$4.members.length;
      var v4354 = i$$88 < len$$39;
      for(;v4354;) {
        var v4353 = content$$4.members;
        introspect(JAM.policy.p1) {
          var ast$$79 = v4353[i$$88]
        }
        JAM.call(this.printAST, this, [ast$$79, outfile$$13]);
        i$$88 = i$$88 + 1;
        v4354 = i$$88 < len$$39
      }
      return
    }
    function v995(ast$$78, outfile$$12) {
      var printContext = JAM.new(TypeScript$$25.PrintContext, [outfile$$12, null]);
      printContext.increaseIndent();
      var v4356 = TypeScript$$25.getAstWalkerFactory();
      JAM.call(v4356.walk, v4356, [ast$$78, TypeScript$$25.prePrintAST, TypeScript$$25.postPrintAST, null, printContext]);
      printContext.decreaseIndent();
      return
    }
    function v994(er) {
      var v14006 = this.unreachable;
      if(v14006) {
        v14006 = this.unreachable.length > 0
      }
      if(v14006) {
        var len$$38 = this.unreachable.length;
        var i$$87 = 0;
        var v4362 = i$$87 < len$$38;
        for(;v4362;) {
          var v4360 = this.unreachable;
          introspect(JAM.policy.p1) {
            var unreachableAST = v4360[i$$87]
          }
          if(unreachableAST.nodeType != TypeScript$$25.NodeType.EndCode) {
            JAM.call(er.simpleError, er, [unreachableAST, "unreachable code"])
          }
          i$$87 = i$$87 + 1;
          v4362 = i$$87 < len$$38
        }
      }
      return
    }
    function v993() {
      return this.currentSwitch.pop()
    }
    function v992(bb$$2) {
      var v4365 = this.currentSwitch;
      JAM.call(v4365.push, v4365, [bb$$2]);
      return
    }
    function v991(ast$$77, parent$$64) {
      var v4366 = this.walker;
      return JAM.call(v4366.walk, v4366, [ast$$77, parent$$64])
    }
    function ControlFlowContext$$1(current$$3, exit$$1) {
      this.current = current$$3;
      this.exit = exit$$1;
      this.entry = null;
      this.unreachable = null;
      this.noContinuation = false;
      var v26901 = new Array;
      this.statementStack = v26901;
      var v26902 = new Array;
      this.currentSwitch = v26902;
      this.markBase = 0;
      var v26903 = new Array;
      this.linearBBs = v26903;
      this.entry = this.current;
      return
    }
    ControlFlowContext$$1.prototype.walk = v991;
    ControlFlowContext$$1.prototype.pushSwitch = v992;
    ControlFlowContext$$1.prototype.popSwitch = v993;
    ControlFlowContext$$1.prototype.reportUnreachable = v994;
    ControlFlowContext$$1.prototype.printAST = v995;
    ControlFlowContext$$1.prototype.printBlockContent = v996;
    ControlFlowContext$$1.prototype.bfs = v997;
    ControlFlowContext$$1.prototype.useDef = v999;
    ControlFlowContext$$1.prototype.print = v1000;
    ControlFlowContext$$1.prototype.pushStatement = v1001;
    ControlFlowContext$$1.prototype.popStatement = v1002;
    ControlFlowContext$$1.prototype.returnStmt = v1003;
    ControlFlowContext$$1.prototype.setUnreachable = v1004;
    ControlFlowContext$$1.prototype.addUnreachable = v1005;
    ControlFlowContext$$1.prototype.unconditionalBranch = v1006;
    ControlFlowContext$$1.prototype.addContent = v1007;
    return ControlFlowContext$$1
  }
  function v990() {
    function v989(successor) {
      JAM.set(this.successors, this.successors.length, successor);
      JAM.set(successor.predecessors, successor.predecessors.length, this);
      return
    }
    function v988() {
      this.markValue = this.markValue + 1;
      return
    }
    function v987(markBase) {
      return this.markValue > markBase
    }
    function BasicBlock$$1() {
      var v26904 = new Array;
      this.predecessors = v26904;
      this.index = -1;
      this.markValue = 0;
      var v26905 = new Array;
      this.successors = v26905;
      this.useDef = null;
      var v26906 = new TypeScript$$25.ASTList;
      this.content = v26906;
      return
    }
    BasicBlock$$1.prototype.marked = v987;
    BasicBlock$$1.prototype.mark = v988;
    BasicBlock$$1.prototype.addSuccessor = v989;
    return BasicBlock$$1
  }
  function v986() {
    function v985(b$$13) {
      var oldFirstBits = this.firstBits;
      this.firstBits = this.firstBits & ~b$$13.firstBits;
      if(this.restOfBits) {
        var k$$12 = 0;
        var len$$37 = this.restOfBits.length;
        var v4396 = k$$12 < len$$37;
        for(;v4396;) {
          var v4393 = this.restOfBits;
          introspect(JAM.policy.p1) {
            var myBits$$4 = v4393[k$$12]
          }
          var v4394 = b$$13.restOfBits;
          introspect(JAM.policy.p1) {
            var bBits$$3 = v4394[k$$12]
          }
          var v4395 = this.restOfBits;
          introspect(JAM.policy.p1) {
            var v19796 = v4395[k$$12]
          }
          v4395[k$$12] = v19796 & ~bBits$$3;
          k$$12 = k$$12 + 1;
          v4396 = k$$12 < len$$37
        }
      }
      return
    }
    function v984(b$$12) {
      if(this.firstBits != b$$12.firstBits) {
        return true
      }
      if(this.restOfBits) {
        var k$$11 = 0;
        var len$$36 = this.restOfBits.length;
        var v4403 = k$$11 < len$$36;
        for(;v4403;) {
          var v4400 = this.restOfBits;
          introspect(JAM.policy.p1) {
            var myBits$$3 = v4400[k$$11]
          }
          var v4401 = b$$12.restOfBits;
          introspect(JAM.policy.p1) {
            var bBits$$2 = v4401[k$$11]
          }
          if(myBits$$3 != bBits$$2) {
            return true
          }
          k$$11 = k$$11 + 1;
          v4403 = k$$11 < len$$36
        }
      }
      return false
    }
    function v983(b$$11) {
      this.firstBits = this.firstBits & b$$11.firstBits;
      if(this.restOfBits) {
        var k$$10 = 0;
        var len$$35 = this.restOfBits.length;
        var v4409 = k$$10 < len$$35;
        for(;v4409;) {
          var v4406 = this.restOfBits;
          introspect(JAM.policy.p1) {
            var myBits$$2 = v4406[k$$10]
          }
          var v4407 = b$$11.restOfBits;
          introspect(JAM.policy.p1) {
            var bBits$$1 = v4407[k$$10]
          }
          this.restOfBits[k$$10] = myBits$$2 & bBits$$1;
          k$$10 = k$$10 + 1;
          v4409 = k$$10 < len$$35
        }
      }
      return
    }
    function v982(b$$10) {
      this.firstBits = this.firstBits | b$$10.firstBits;
      if(this.restOfBits) {
        var k$$9 = 0;
        var len$$34 = this.restOfBits.length;
        var v4415 = k$$9 < len$$34;
        for(;v4415;) {
          var v4412 = this.restOfBits;
          introspect(JAM.policy.p1) {
            var myBits$$1 = v4412[k$$9]
          }
          var v4413 = b$$10.restOfBits;
          introspect(JAM.policy.p1) {
            var bBits = v4413[k$$9]
          }
          this.restOfBits[k$$9] = myBits$$1 | bBits;
          k$$9 = k$$9 + 1;
          v4415 = k$$9 < len$$34
        }
      }
      return
    }
    function v981(fn$$7) {
      var k$$8;
      k$$8 = 0;
      var v4419 = k$$8 < BitVector$$1.packBits;
      for(;v4419;) {
        if(k$$8 == this.bitCount) {
          return
        }
        if((1 << k$$8 & this.firstBits) != 0) {
          JAM.call(fn$$7, null, [k$$8])
        }
        k$$8 = k$$8 + 1;
        v4419 = k$$8 < BitVector$$1.packBits
      }
      if(this.restOfBits) {
        var len$$33;
        var cumu = BitVector$$1.packBits;
        k$$8 = 0;
        len$$33 = this.restOfBits.length;
        var v4424 = k$$8 < len$$33;
        for(;v4424;) {
          var v4420 = this.restOfBits;
          introspect(JAM.policy.p1) {
            var myBits = v4420[k$$8]
          }
          var j$$11 = 0;
          var v4423 = j$$11 < BitVector$$1.packBits;
          for(;v4423;) {
            if((1 << j$$11 & myBits) != 0) {
              JAM.call(fn$$7, null, [cumu])
            }
            cumu = cumu + 1;
            if(cumu == this.bitCount) {
              return
            }
            j$$11 = j$$11 + 1;
            v4423 = j$$11 < BitVector$$1.packBits
          }
          k$$8 = k$$8 + 1;
          v4424 = k$$8 < len$$33
        }
      }
      return
    }
    function v980(bitIndex, value$$42) {
      if(bitIndex < BitVector$$1.packBits) {
        if(value$$42) {
          this.firstBits = this.firstBits | 1 << bitIndex
        }else {
          this.firstBits = this.firstBits & ~(1 << bitIndex)
        }
      }else {
        var offset$$13 = Math.floor(bitIndex / BitVector$$1.packBits) - 1;
        var localIndex = bitIndex % BitVector$$1.packBits;
        if(value$$42) {
          var v4428 = this.restOfBits;
          introspect(JAM.policy.p1) {
            var v19803 = v4428[offset$$13]
          }
          v4428[offset$$13] = v19803 | 1 << localIndex
        }else {
          var v4429 = this.restOfBits;
          introspect(JAM.policy.p1) {
            var v19805 = v4429[offset$$13]
          }
          v4429[offset$$13] = v19805 & ~(1 << localIndex)
        }
      }
      return
    }
    function BitVector$$1(bitCount$$1) {
      this.bitCount = bitCount$$1;
      this.firstBits = 0;
      this.restOfBits = null;
      if(this.bitCount > BitVector$$1.packBits) {
        var v26907 = new Array;
        this.restOfBits = v26907;
        var len$$32 = Math.floor(this.bitCount / BitVector$$1.packBits);
        var i$$86 = 0;
        var v4433 = i$$86 < len$$32;
        for(;v4433;) {
          this.restOfBits[i$$86] = 0;
          i$$86 = i$$86 + 1;
          v4433 = i$$86 < len$$32
        }
      }
      return
    }
    BitVector$$1.packBits = 30;
    BitVector$$1.prototype.set = v980;
    BitVector$$1.prototype.map = v981;
    BitVector$$1.prototype.union = v982;
    BitVector$$1.prototype.intersection = v983;
    BitVector$$1.prototype.notEq = v984;
    BitVector$$1.prototype.difference = v985;
    return BitVector$$1
  }
  function v979() {
    function v978(sym$$33, bbUses) {
      var v4441 = this.symbolMap;
      var index$$54 = JAM.call(v4441.lookup, v4441, [sym$$33.name]);
      var v4443 = this.useIndexBySymbol;
      introspect(JAM.policy.p1) {
        var usesOfSym = v4443[index$$54]
      }
      var k$$7 = 0;
      var len$$31 = usesOfSym.length;
      var v4445 = k$$7 < len$$31;
      for(;v4445;) {
        introspect(JAM.policy.p1) {
          var v4444 = usesOfSym[k$$7]
        }
        JAM.call(bbUses.set, bbUses, [v4444, true]);
        k$$7 = k$$7 + 1;
        v4445 = k$$7 < len$$31
      }
      return
    }
    function v977(sym$$32) {
      var v4446 = sym$$32;
      if(v4446) {
        var v14039 = sym$$32.container == this.func;
        if(v14039) {
          v14039 = sym$$32.kind() == TypeScript$$25.SymbolKind.Variable
        }
        v4446 = v14039
      }
      return v4446
    }
    function v976(ast$$76) {
      JAM.set(this.uses, this.uses.length, ast$$76);
      return this.uses.length - 1
    }
    function v975(symIndex$$1, astIndex$$1) {
      var v4450 = this.useIndexBySymbol;
      introspect(JAM.policy.p1) {
        var useBySym = v4450[symIndex$$1]
      }
      if(useBySym == undefined) {
        useBySym = new Array;
        JAM.set(this.useIndexBySymbol, symIndex$$1, useBySym)
      }
      JAM.set(useBySym, useBySym.length, astIndex$$1);
      return
    }
    function v974(sym$$31) {
      var name$$86 = sym$$31.name;
      var v4454 = this.symbolMap;
      var index$$53 = JAM.call(v4454.lookup, v4454, [name$$86]);
      if(index$$53 == null) {
        index$$53 = this.symbolCount;
        this.symbolCount = this.symbolCount + 1;
        JAM.set(this.symbols, index$$53, sym$$31);
        var v4456 = this.symbolMap;
        JAM.call(v4456.add, v4456, [name$$86, index$$53])
      }
      return index$$53
    }
    function UseDefContext$$1() {
      var v26908 = new Array;
      this.useIndexBySymbol = v26908;
      var v26909 = new Array;
      this.uses = v26909;
      var v26910 = new Array;
      this.symbols = v26910;
      var v26911 = new TypeScript$$25.StringHashTable;
      this.symbolMap = v26911;
      this.symbolCount = 0;
      return
    }
    UseDefContext$$1.prototype.getSymbolIndex = v974;
    UseDefContext$$1.prototype.addUse = v975;
    UseDefContext$$1.prototype.getUseIndex = v976;
    UseDefContext$$1.prototype.isLocalSym = v977;
    UseDefContext$$1.prototype.killSymbol = v978;
    return UseDefContext$$1
  }
  function v973() {
    function v972(useDefContext$$2) {
      var v26912 = JAM.new(BitVector, [this.gen.bitCount]);
      this.kill = v26912;
      var s$$25 = 0;
      var symbolLen$$1 = this.defsBySymbol.length;
      var v4471 = s$$25 < symbolLen$$1;
      for(;v4471;) {
        var v14044 = this.defsBySymbol;
        introspect(JAM.policy.p1) {
          var v4470 = v14044[s$$25]
        }
        if(v4470) {
          var v4466 = useDefContext$$2.useIndexBySymbol;
          introspect(JAM.policy.p1) {
            var globalSymUses = v4466[s$$25]
          }
          if(globalSymUses) {
            var u$$1 = 0;
            var useLen = globalSymUses.length;
            var v4469 = u$$1 < useLen;
            for(;v4469;) {
              var v4467 = this.kill;
              introspect(JAM.policy.p1) {
                var v4468 = globalSymUses[u$$1]
              }
              JAM.call(v4467.set, v4467, [v4468, true]);
              u$$1 = u$$1 + 1;
              v4469 = u$$1 < useLen
            }
          }
        }
        s$$25 = s$$25 + 1;
        v4471 = s$$25 < symbolLen$$1
      }
      return
    }
    function v971(useDefContext$$1) {
      var symbolLen = this.useIndexBySymbol.length;
      var bitCount = useDefContext$$1.uses.length;
      var v26913 = JAM.new(BitVector, [bitCount]);
      this.gen = v26913;
      var s$$24 = 0;
      var v4479 = s$$24 < symbolLen;
      for(;v4479;) {
        var v4474 = this.useIndexBySymbol;
        introspect(JAM.policy.p1) {
          var symUses$$1 = v4474[s$$24]
        }
        var v14045 = symUses$$1 != undefined;
        if(v14045) {
          v14045 = symUses$$1.length > 0
        }
        if(v14045) {
          var u = 0;
          var uLen = symUses$$1.length;
          var v4477 = u < uLen;
          for(;v4477;) {
            var v4475 = this.gen;
            introspect(JAM.policy.p1) {
              var v4476 = symUses$$1[u]
            }
            JAM.call(v4475.set, v4475, [v4476, true]);
            u = u + 1;
            v4477 = u < uLen
          }
        }
        s$$24 = s$$24 + 1;
        v4479 = s$$24 < symbolLen
      }
      this.top = this.gen;
      return
    }
    function v970(useDefContext) {
      function defSym(sym$$29, context$$62) {
        if(JAM.call(context$$62.isLocalSym, context$$62, [sym$$29])) {
          var index$$52 = JAM.call(context$$62.getSymbolIndex, context$$62, [sym$$29]);
          var v4480 = _this$$3.useIndexBySymbol;
          var v4481 = index$$52;
          var v26914 = new Array;
          JAM.set(v4480, v4481, v26914);
          JAM.set(_this$$3.defsBySymbol, index$$52, true)
        }
        return
      }
      function initUseDefPre(cur$$9, parent$$63, walker$$48) {
        var context$$61 = walker$$48.state;
        if(cur$$9 == null) {
          cur$$9 = null
        }
        if(cur$$9.nodeType == TypeScript$$25.NodeType.VarDecl) {
          var varDecl$$13 = cur$$9;
          var v14048 = varDecl$$13.init;
          if(!v14048) {
            v14048 = JAM.call(TypeScript$$25.hasFlag, TypeScript$$25, [varDecl$$13.varFlags, TypeScript$$25.VarFlags.AutoInit])
          }
          if(v14048) {
            defSym(varDecl$$13.sym, context$$61)
          }
        }else {
          if(cur$$9.nodeType == TypeScript$$25.NodeType.Name) {
            if(parent$$63) {
              if(parent$$63.nodeType == TypeScript$$25.NodeType.Asg) {
                var asg = parent$$63;
                if(asg.operand1 == cur$$9) {
                  return cur$$9
                }
              }else {
                if(parent$$63.nodeType == TypeScript$$25.NodeType.VarDecl) {
                  var parentDecl = parent$$63;
                  if(parentDecl.id == cur$$9) {
                    return cur$$9
                  }
                }
              }
            }
            var id$$21 = cur$$9;
            var sym$$inline_16 = id$$21.sym;
            var context$$inline_17 = context$$61;
            var ast$$inline_18 = cur$$9;
            if(JAM.call(context$$inline_17.isLocalSym, context$$inline_17, [sym$$inline_16])) {
              var symIndex$$inline_19 = JAM.call(context$$inline_17.getSymbolIndex, context$$inline_17, [sym$$inline_16]);
              var v19819 = _this$$3.useIndexBySymbol;
              introspect(JAM.policy.p1) {
                var v14057 = v19819[symIndex$$inline_19]
              }
              if(v14057 == undefined) {
                var v4491 = _this$$3.useIndexBySymbol;
                var v4492 = symIndex$$inline_19;
                var v26915 = new Array;
                JAM.set(v4491, v4492, v26915)
              }
              var v4494 = _this$$3.useIndexBySymbol;
              introspect(JAM.policy.p1) {
                var symUses$$inline_20 = v4494[symIndex$$inline_19]
              }
              var astIndex$$inline_21 = JAM.call(context$$inline_17.getUseIndex, context$$inline_17, [ast$$inline_18]);
              JAM.call(context$$inline_17.addUse, context$$inline_17, [symIndex$$inline_19, astIndex$$inline_21]);
              JAM.call(symUses$$inline_20.push, symUses$$inline_20, [astIndex$$inline_21])
            }
          }else {
            var v14058 = cur$$9.nodeType >= TypeScript$$25.NodeType.Asg;
            if(v14058) {
              v14058 = cur$$9.nodeType <= TypeScript$$25.NodeType.LastAsg
            }
            if(v14058) {
              asg = cur$$9;
              var v14059 = asg.operand1;
              if(v14059) {
                v14059 = asg.operand1.nodeType == TypeScript$$25.NodeType.Name
              }
              if(v14059) {
                id$$21 = asg.operand1;
                defSym(id$$21.sym, context$$61)
              }
            }else {
              if(cur$$9.nodeType == TypeScript$$25.NodeType.FuncDecl) {
                walker$$48.options.goChildren = false
              }
            }
          }
        }
        return cur$$9
      }
      var _this$$3 = this;
      var options$$6 = new TypeScript$$25.AstWalkOptions;
      options$$6.reverseSiblings = true;
      var v4504 = TypeScript$$25.getAstWalkerFactory();
      JAM.call(v4504.walk, v4504, [this.bb.content, initUseDefPre, null, options$$6, useDefContext]);
      return
    }
    function v969() {
      var temp$$16 = JAM.new(BitVector, [this.top.bitCount]);
      var i$$85 = 0;
      var succLen = this.bb.successors.length;
      var v4511 = i$$85 < succLen;
      for(;v4511;) {
        var v4508 = this.bb.successors;
        introspect(JAM.policy.p1) {
          var succ = v4508[i$$85]
        }
        if(succ.useDef) {
          JAM.call(temp$$16.union, temp$$16, [succ.useDef.top])
        }
        i$$85 = i$$85 + 1;
        v4511 = i$$85 < succLen
      }
      JAM.call(temp$$16.difference, temp$$16, [this.kill]);
      JAM.call(temp$$16.union, temp$$16, [this.gen]);
      var changed = JAM.call(temp$$16.notEq, temp$$16, [this.top]);
      this.top = temp$$16;
      return changed
    }
    function BBUseDefInfo$$1(bb$$1) {
      this.bb = bb$$1;
      var v26916 = new Array;
      this.defsBySymbol = v26916;
      var v26917 = new Array;
      this.useIndexBySymbol = v26917;
      return
    }
    BBUseDefInfo$$1.prototype.updateTop = v969;
    BBUseDefInfo$$1.prototype.initialize = v970;
    BBUseDefInfo$$1.prototype.initializeGen = v971;
    BBUseDefInfo$$1.prototype.initializeKill = v972;
    return BBUseDefInfo$$1
  }
  function v968() {
    function ScopeChain$$1(container$$14, previous$$1, scope$$29) {
      this.container = container$$14;
      this.previous = previous$$1;
      this.scope = scope$$29;
      return
    }
    return ScopeChain$$1
  }
  var ScopeChain = v968();
  TypeScript$$25.ScopeChain = ScopeChain;
  var BBUseDefInfo = v973();
  TypeScript$$25.BBUseDefInfo = BBUseDefInfo;
  var UseDefContext = v979();
  TypeScript$$25.UseDefContext = UseDefContext;
  var BitVector = v986();
  TypeScript$$25.BitVector = BitVector;
  var BasicBlock = v990();
  TypeScript$$25.BasicBlock = BasicBlock;
  var ControlFlowContext = v1008();
  TypeScript$$25.ControlFlowContext = ControlFlowContext;
  var ResolutionDataCache = v1011();
  TypeScript$$25.ResolutionDataCache = ResolutionDataCache;
  var TypeFlow = v1112();
  TypeScript$$25.TypeFlow = TypeFlow;
  return
}
function v967(TypeScript$$24) {
  function v966() {
    function Continuation$$1(normalBlock) {
      this.normalBlock = normalBlock;
      this.exceptionBlock = -1;
      return
    }
    return Continuation$$1
  }
  function getBaseTypeLinks(bases$$3, baseTypeLinks) {
    if(bases$$3) {
      var len$$30 = bases$$3.members.length;
      if(baseTypeLinks == null) {
        baseTypeLinks = new Array
      }
      var i$$83 = 0;
      var v4524 = i$$83 < len$$30;
      for(;v4524;) {
        var v4521 = bases$$3.members;
        introspect(JAM.policy.p1) {
          var baseExpr$$1 = v4521[i$$83]
        }
        var name$$83 = baseExpr$$1;
        var typeLink$$3 = new TypeScript$$24.TypeLink;
        typeLink$$3.ast = name$$83;
        JAM.set(baseTypeLinks, baseTypeLinks.length, typeLink$$3);
        i$$83 = i$$83 + 1;
        v4524 = i$$83 < len$$30
      }
    }
    return baseTypeLinks
  }
  function getBases(type$$44, typeDecl) {
    var v4525 = type$$44;
    var v26918 = getBaseTypeLinks(typeDecl.extendsList, type$$44.extendsTypeLinks);
    v4525.extendsTypeLinks = v26918;
    var v4526 = type$$44;
    var v26919 = getBaseTypeLinks(typeDecl.implementsList, type$$44.implementsTypeLinks);
    v4526.implementsTypeLinks = v26919;
    return
  }
  function createNewConstructGroupForType(type$$45) {
    var signature$$6 = new TypeScript$$24.Signature;
    var v4528 = signature$$6;
    var v26920 = new TypeScript$$24.TypeLink;
    v4528.returnType = v26920;
    signature$$6.returnType.type = type$$45.instanceType;
    signature$$6.parameters = [];
    var v4530 = type$$45;
    var v26921 = new TypeScript$$24.SignatureGroup;
    v4530.construct = v26921;
    var v4531 = type$$45.construct;
    JAM.call(v4531.addSignature, v4531, [signature$$6]);
    return
  }
  function cloneParentConstructGroupForChildType(child$$1, parent$$53) {
    var v4532 = child$$1;
    var v26922 = new TypeScript$$24.SignatureGroup;
    v4532.construct = v26922;
    var sig$$1 = null;
    if(!parent$$53.construct) {
      createNewConstructGroupForType(parent$$53)
    }
    var i$$84 = 0;
    var v4542 = i$$84 < parent$$53.construct.signatures.length;
    for(;v4542;) {
      sig$$1 = new TypeScript$$24.Signature;
      var v14076 = parent$$53.construct.signatures;
      introspect(JAM.policy.p1) {
        var v4535 = v14076[i$$84]
      }
      sig$$1.parameters = v4535.parameters;
      var v14077 = parent$$53.construct.signatures;
      introspect(JAM.policy.p1) {
        var v4536 = v14077[i$$84]
      }
      sig$$1.nonOptionalParameterCount = v4536.nonOptionalParameterCount;
      var v14078 = parent$$53.construct.signatures;
      introspect(JAM.policy.p1) {
        var v4537 = v14078[i$$84]
      }
      sig$$1.typeCheckStatus = v4537.typeCheckStatus;
      var v14079 = parent$$53.construct.signatures;
      introspect(JAM.policy.p1) {
        var v4538 = v14079[i$$84]
      }
      sig$$1.declAST = v4538.declAST;
      var v4539 = sig$$1;
      var v26923 = new TypeScript$$24.TypeLink;
      v4539.returnType = v26923;
      sig$$1.returnType.type = child$$1.instanceType;
      var v4541 = child$$1.construct;
      JAM.call(v4541.addSignature, v4541, [sig$$1]);
      i$$84 = i$$84 + 1;
      v4542 = i$$84 < parent$$53.construct.signatures.length
    }
    return
  }
  function findTypeSymbolInScopeChain(name$$84, scopeChain$$2) {
    var v4543 = scopeChain$$2.scope;
    var symbol$$14 = JAM.call(v4543.find, v4543, [name$$84, false, true]);
    var v14082 = symbol$$14 == null;
    if(v14082) {
      v14082 = scopeChain$$2.previous
    }
    if(v14082) {
      symbol$$14 = findTypeSymbolInScopeChain(name$$84, scopeChain$$2.previous)
    }
    return symbol$$14
  }
  function findSymbolFromAlias(alias$$2, context$$51) {
    function v965(id$$20) {
      if(context$$51.members) {
        var v4546 = context$$51.members;
        return JAM.call(v4546.lookup, v4546, [name$$85])
      }else {
        return findTypeSymbolInScopeChain(name$$85, context$$51.topLevelScope)
      }
      return
    }
    var symbol$$15 = null;
    switch(alias$$2.nodeType) {
      case TypeScript$$24.NodeType.Name:
        var name$$85 = alias$$2.text;
        var isDynamic = JAM.call(TypeScript$$24.isQuoted, TypeScript$$24, [name$$85]);
        var findSym = v965;
        if(isDynamic) {
          var v4549 = context$$51.tcContext.checker;
          symbol$$15 = JAM.call(v4549.findSymbolForDynamicModule, v4549, [name$$85, context$$51.tcContext.script.locationInfo.filename, findSym])
        }else {
          symbol$$15 = JAM.call(findSym, null, [name$$85])
        }
        break;
      case TypeScript$$24.NodeType.Dot:
        var dottedExpr = alias$$2;
        var op1Sym = findSymbolFromAlias(dottedExpr.operand1, context$$51);
        var v14085 = op1Sym;
        if(v14085) {
          v14085 = op1Sym.getType()
        }
        if(v14085) {
          symbol$$15 = findSymbolFromAlias(dottedExpr.operand2, context$$51)
        }
      ;
      default:
    }
    if(symbol$$15) {
      var symType$$1 = symbol$$15.getType();
      if(symType$$1) {
        var members$$25 = symType$$1.members;
        if(members$$25) {
          context$$51.members = members$$25.publicMembers
        }
      }
    }
    return symbol$$15
  }
  function preCollectImportTypes(ast$$66, parent$$54, context$$52) {
    var scopeChain$$3 = context$$52.scopeChain;
    var typeSymbol$$2 = null;
    var modType = null;
    var importDecl$$1 = ast$$66;
    var aliasedModSymbol = findSymbolFromAlias(importDecl$$1.alias, {topLevelScope:scopeChain$$3, members:null, tcContext:context$$52});
    var isGlobal$$1 = context$$52.scopeChain.container == context$$52.checker.gloMod;
    if(aliasedModSymbol) {
      var aliasedModType = aliasedModSymbol.getType();
      if(aliasedModType) {
        modType = aliasedModType
      }
    }
    typeSymbol$$2 = JAM.new(TypeScript$$24.TypeSymbol, [importDecl$$1.id.text, importDecl$$1.id.minChar, importDecl$$1.limChar - importDecl$$1.minChar, context$$52.checker.locationInfo.unitIndex, modType]);
    typeSymbol$$2.aliasLink = importDecl$$1;
    if(context$$52.scopeChain.moduleDecl) {
      typeSymbol$$2.flags = typeSymbol$$2.flags | TypeScript$$24.SymbolFlags.ModuleMember;
      typeSymbol$$2.declModule = context$$52.scopeChain.moduleDecl
    }
    typeSymbol$$2.declAST = importDecl$$1;
    importDecl$$1.id.sym = typeSymbol$$2;
    var v4567 = scopeChain$$3.scope;
    JAM.call(v4567.enter, v4567, [scopeChain$$3.container, ast$$66, typeSymbol$$2, context$$52.checker.errorReporter, isGlobal$$1, true, false]);
    var v4570 = scopeChain$$3.scope;
    JAM.call(v4570.enter, v4570, [scopeChain$$3.container, ast$$66, typeSymbol$$2, context$$52.checker.errorReporter, isGlobal$$1, false, false]);
    return true
  }
  function preCollectModuleTypes(ast$$67, parent$$55, context$$53) {
    var scopeChain$$4 = context$$53.scopeChain;
    var moduleDecl$$6 = ast$$67;
    var isAmbient$$5 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [moduleDecl$$6.modFlags, TypeScript$$24.ModuleFlags.Ambient]);
    var isEnum = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [moduleDecl$$6.modFlags, TypeScript$$24.ModuleFlags.IsEnum]);
    var isGlobal$$2 = context$$53.scopeChain.container == context$$53.checker.gloMod;
    var isExported$$2 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [moduleDecl$$6.modFlags, TypeScript$$24.ModuleFlags.Exported]);
    var modName$$3 = moduleDecl$$6.name.text;
    var isDynamic$$1 = JAM.call(TypeScript$$24.isQuoted, TypeScript$$24, [modName$$3]);
    var v4582 = scopeChain$$4.scope;
    var symbol$$16 = JAM.call(v4582.findLocal, v4582, [modName$$3, false, false]);
    var typeSymbol$$3 = null;
    var modType$$1 = null;
    var v14103 = symbol$$16 == null;
    if(!v14103) {
      v14103 = symbol$$16.kind() != TypeScript$$24.SymbolKind.Type
    }
    if(v14103) {
      if(modType$$1 == null) {
        var enclosedTypes$$3 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
        var ambientEnclosedTypes$$3 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
        modType$$1 = JAM.new(TypeScript$$24.ModuleType, [enclosedTypes$$3, ambientEnclosedTypes$$3]);
        if(isEnum) {
          modType$$1.typeFlags = modType$$1.typeFlags | TypeScript$$24.TypeFlags.IsEnum
        }
        var v4588 = modType$$1;
        var v26924 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
        v4588.members = v26924;
        var v4589 = modType$$1;
        var v26925 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
        v4589.ambientMembers = v26925;
        modType$$1.setHasImplementation()
      }
      typeSymbol$$3 = JAM.new(TypeScript$$24.TypeSymbol, [modName$$3, moduleDecl$$6.name.minChar, modName$$3.length, context$$53.checker.locationInfo.unitIndex, modType$$1]);
      var v4595 = typeSymbol$$3;
      var v26926 = JAM.call(TypeScript$$24.isQuoted, TypeScript$$24, [moduleDecl$$6.prettyName]);
      v4595.isDynamic = v26926;
      if(context$$53.scopeChain.moduleDecl) {
        typeSymbol$$3.declModule = context$$53.scopeChain.moduleDecl
      }
      typeSymbol$$3.declAST = moduleDecl$$6;
      typeSymbol$$3.prettyName = moduleDecl$$6.prettyName;
      var v4598 = scopeChain$$4.scope;
      JAM.call(v4598.enter, v4598, [scopeChain$$4.container, ast$$67, typeSymbol$$3, context$$53.checker.errorReporter, isExported$$2 || isGlobal$$2, true, isAmbient$$5]);
      var v4602 = scopeChain$$4.scope;
      JAM.call(v4602.enter, v4602, [scopeChain$$4.container, ast$$67, typeSymbol$$3, context$$53.checker.errorReporter, isExported$$2 || isGlobal$$2, false, isAmbient$$5]);
      modType$$1.symbol = typeSymbol$$3
    }else {
      var v14122 = symbol$$16;
      if(v14122) {
        var v19851 = symbol$$16.declAST;
        if(v19851) {
          v19851 = symbol$$16.declAST.nodeType != TypeScript$$24.NodeType.ModuleDeclaration
        }
        v14122 = v19851
      }
      if(v14122) {
        var v4606 = context$$53.checker.errorReporter;
        JAM.call(v4606.simpleError, v4606, [moduleDecl$$6, "Conflicting symbol name for module '" + modName$$3 + "'"])
      }
      typeSymbol$$3 = symbol$$16;
      var publicEnclosedTypes = typeSymbol$$3.type.getAllEnclosedTypes().publicMembers;
      var v4610;
      if(publicEnclosedTypes == null) {
        v4610 = new TypeScript$$24.StringHashTable
      }else {
        v4610 = publicEnclosedTypes
      }
      var publicEnclosedTypesTable = v4610;
      enclosedTypes$$3 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [publicEnclosedTypesTable, new TypeScript$$24.StringHashTable])]);
      var publicEnclosedAmbientTypes = typeSymbol$$3.type.getAllAmbientEnclosedTypes().publicMembers;
      var v4614;
      if(publicEnclosedAmbientTypes == null) {
        v4614 = new TypeScript$$24.StringHashTable
      }else {
        v4614 = publicEnclosedAmbientTypes
      }
      var publicAmbientEnclosedTypesTable = v4614;
      ambientEnclosedTypes$$3 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [publicAmbientEnclosedTypesTable, new TypeScript$$24.StringHashTable])]);
      var publicMembers = typeSymbol$$3.type.members.publicMembers;
      var v4618;
      if(publicMembers == null) {
        v4618 = new TypeScript$$24.StringHashTable
      }else {
        v4618 = publicMembers
      }
      var publicMembersTable = v4618;
      var members$$26 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [publicMembersTable, new TypeScript$$24.StringHashTable])]);
      var publicAmbientMembers = typeSymbol$$3.type.ambientMembers.publicMembers;
      var v4622;
      if(publicAmbientMembers == null) {
        v4622 = new TypeScript$$24.StringHashTable
      }else {
        v4622 = publicAmbientMembers
      }
      var publicAmbientMembersTable = v4622;
      var ambientMembers$$2 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [publicAmbientMembersTable, new TypeScript$$24.StringHashTable])]);
      modType$$1 = JAM.new(TypeScript$$24.ModuleType, [enclosedTypes$$3, ambientEnclosedTypes$$3]);
      if(isEnum) {
        modType$$1.typeFlags = modType$$1.typeFlags | TypeScript$$24.TypeFlags.IsEnum
      }
      modType$$1.members = members$$26;
      modType$$1.ambientMembers = ambientMembers$$2;
      modType$$1.setHasImplementation();
      modType$$1.symbol = typeSymbol$$3;
      JAM.call(typeSymbol$$3.addLocation, typeSymbol$$3, [moduleDecl$$6.minChar]);
      var v4627 = typeSymbol$$3.expansions;
      JAM.call(v4627.push, v4627, [modType$$1]);
      var v4628 = typeSymbol$$3.expansionsDeclAST;
      JAM.call(v4628.push, v4628, [moduleDecl$$6])
    }
    if(context$$53.scopeChain.moduleDecl) {
      context$$53.scopeChain.moduleDecl.recordNonInterface()
    }
    if(isExported$$2) {
      typeSymbol$$3.flags = typeSymbol$$3.flags | TypeScript$$24.SymbolFlags.Exported
    }
    var v14151 = context$$53.scopeChain.moduleDecl;
    if(!v14151) {
      v14151 = context$$53.scopeChain.container == context$$53.checker.gloMod
    }
    if(v14151) {
      typeSymbol$$3.flags = typeSymbol$$3.flags | TypeScript$$24.SymbolFlags.ModuleMember
    }
    moduleDecl$$6.mod = modType$$1;
    JAM.call(TypeScript$$24.pushTypeCollectionScope, TypeScript$$24, [typeSymbol$$3, modType$$1.members, modType$$1.ambientMembers, modType$$1.enclosedTypes, modType$$1.ambientEnclosedTypes, context$$53, null, null, moduleDecl$$6]);
    return true
  }
  function preCollectClassTypes(ast$$68, parent$$56, context$$54) {
    var scopeChain$$5 = context$$54.scopeChain;
    var classDecl$$7 = ast$$68;
    var classType$$5;
    var instanceType$$4;
    var typeSymbol$$4 = null;
    var className$$4 = classDecl$$7.name.text;
    var alreadyInScope = false;
    var isAmbient$$6 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [classDecl$$7.varFlags, TypeScript$$24.VarFlags.Ambient]);
    var isExported$$3 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [classDecl$$7.varFlags, TypeScript$$24.VarFlags.Exported]);
    var isGlobal$$3 = context$$54.scopeChain.container == context$$54.checker.gloMod;
    var containerMod = scopeChain$$5.container;
    var foundValSymbol = false;
    var v4644 = scopeChain$$5.scope;
    typeSymbol$$4 = JAM.call(v4644.findLocal, v4644, [className$$4, false, true]);
    if(!typeSymbol$$4) {
      var v4645 = scopeChain$$5.scope;
      var valTypeSymbol = JAM.call(v4645.findLocal, v4645, [className$$4, false, false]);
      var v14158 = valTypeSymbol;
      if(v14158) {
        var v19863 = valTypeSymbol.isType();
        if(v19863) {
          var v23377 = valTypeSymbol.declAST;
          if(v23377) {
            var v25039 = valTypeSymbol.declAST.nodeType == TypeScript$$24.NodeType.FuncDecl;
            if(v25039) {
              v25039 = valTypeSymbol.declAST.isSignature()
            }
            v23377 = v25039
          }
          v19863 = v23377
        }
        v14158 = v19863
      }
      if(v14158) {
        typeSymbol$$4 = valTypeSymbol;
        foundValSymbol = true;
        if(isExported$$3) {
          typeSymbol$$4.flags = typeSymbol$$4.flags | TypeScript$$24.SymbolFlags.Exported
        }
        if(isAmbient$$6) {
          typeSymbol$$4.flags = typeSymbol$$4.flags | TypeScript$$24.SymbolFlags.Ambient
        }
        var v4646 = context$$54.scopeChain.scope;
        JAM.call(v4646.enter, v4646, [context$$54.scopeChain.container, ast$$68, typeSymbol$$4, context$$54.checker.errorReporter, isExported$$3 || isGlobal$$3, true, isAmbient$$6])
      }
    }
    var v14166 = typeSymbol$$4;
    if(v14166) {
      var v19866 = !foundValSymbol;
      if(v19866) {
        v19866 = typeSymbol$$4.declAST != classDecl$$7
      }
      v14166 = v19866
    }
    if(v14166) {
      typeSymbol$$4 = null
    }
    if(typeSymbol$$4 == null) {
      var v4653 = scopeChain$$5.scope;
      var valueSymbol = JAM.call(v4653.findLocal, v4653, [className$$4, false, false]);
      classType$$5 = new TypeScript$$24.Type;
      classType$$5.setHasImplementation();
      instanceType$$4 = new TypeScript$$24.Type;
      instanceType$$4.setHasImplementation();
      classType$$5.instanceType = instanceType$$4;
      var v4656 = classType$$5;
      var v26927 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
      v4656.members = v26927;
      var v4657 = classType$$5;
      var v26928 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
      v4657.ambientMembers = v26928;
      var classType$$inline_10 = classType$$5;
      var ast$$inline_11 = classDecl$$7;
      var context$$inline_12 = context$$54;
      var field$$inline_13 = new TypeScript$$24.ValueLocation;
      var v4659 = field$$inline_13;
      var v26929 = new TypeScript$$24.TypeLink;
      v4659.typeLink = v26929;
      field$$inline_13.typeLink.ast = ast$$inline_11;
      field$$inline_13.typeLink.type = classType$$inline_10.instanceType;
      var fieldSymbol$$inline_14 = JAM.new(TypeScript$$24.FieldSymbol, ["prototype", ast$$inline_11.minChar, context$$inline_12.checker.locationInfo.unitIndex, true, field$$inline_13]);
      fieldSymbol$$inline_14.flags = fieldSymbol$$inline_14.flags | TypeScript$$24.SymbolFlags.Property | TypeScript$$24.SymbolFlags.BuiltIn;
      field$$inline_13.symbol = fieldSymbol$$inline_14;
      fieldSymbol$$inline_14.declAST = ast$$inline_11;
      var v4665 = classType$$inline_10.members;
      JAM.call(v4665.addPublicMember, v4665, ["prototype", fieldSymbol$$inline_14]);
      var v4666 = instanceType$$4;
      var v26930 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
      v4666.members = v26930;
      var v4667 = instanceType$$4;
      var v26931 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
      v4667.ambientMembers = v26931;
      typeSymbol$$4 = JAM.new(TypeScript$$24.TypeSymbol, [className$$4, classDecl$$7.name.minChar, className$$4.length, context$$54.checker.locationInfo.unitIndex, classType$$5]);
      typeSymbol$$4.declAST = classDecl$$7;
      typeSymbol$$4.instanceType = instanceType$$4;
      classType$$5.symbol = typeSymbol$$4;
      instanceType$$4.symbol = typeSymbol$$4;
      if(context$$54.scopeChain.moduleDecl) {
        context$$54.scopeChain.moduleDecl.recordNonInterface();
        typeSymbol$$4.declModule = context$$54.scopeChain.moduleDecl;
        typeSymbol$$4.flags = typeSymbol$$4.flags | TypeScript$$24.SymbolFlags.ModuleMember
      }
      if(isExported$$3) {
        typeSymbol$$4.flags = typeSymbol$$4.flags | TypeScript$$24.SymbolFlags.Exported
      }
      if(isAmbient$$6) {
        typeSymbol$$4.flags = typeSymbol$$4.flags | TypeScript$$24.SymbolFlags.Ambient
      }
      ast$$68.type = classType$$5;
      var v4675 = context$$54.scopeChain.scope;
      JAM.call(v4675.enter, v4675, [context$$54.scopeChain.container, ast$$68, typeSymbol$$4, context$$54.checker.errorReporter, isExported$$3 || isGlobal$$3, true, isAmbient$$6]);
      if(valueSymbol == null) {
        var v4679 = context$$54.scopeChain.scope;
        JAM.call(v4679.enter, v4679, [context$$54.scopeChain.container, ast$$68, typeSymbol$$4, context$$54.checker.errorReporter, isExported$$3 || isGlobal$$3, false, isAmbient$$6])
      }
    }else {
      classType$$5 = typeSymbol$$4.type;
      if(classType$$5.instanceType == null) {
        var v4684 = classType$$5;
        var v26932 = new TypeScript$$24.Type;
        v4684.instanceType = v26932;
        classType$$5.instanceType.setHasImplementation();
        var v4686 = classType$$5.instanceType;
        var v26933 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
        v4686.members = v26933;
        classType$$5.instanceType.symbol = classType$$5.symbol;
        var v4688 = classType$$5;
        var v26934 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
        v4688.members = v26934;
        var v4689 = classType$$5;
        var v26935 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
        v4689.ambientMembers = v26935
      }
      instanceType$$4 = classType$$5.instanceType;
      ast$$68.type = classType$$5
    }
    if(!classDecl$$7.constructorDecl) {
      var v14204 = typeSymbol$$4;
      if(v14204) {
        var v19895 = typeSymbol$$4.declAST;
        if(v19895) {
          var v23395 = typeSymbol$$4.declAST.type;
          if(v23395) {
            var v25041 = typeSymbol$$4.declAST.type.call;
            if(v25041) {
              v25041 = !typeSymbol$$4.declAST.isOverload
            }
            v23395 = v25041
          }
          v19895 = v23395
        }
        v14204 = v19895
      }
      if(v14204) {
        var v4692 = context$$54.checker.errorReporter;
        JAM.call(v4692.duplicateIdentifier, v4692, [typeSymbol$$4.declAST, typeSymbol$$4.name])
      }
      createNewConstructGroupForType(classDecl$$7.type)
    }
    classType$$5.typeFlags = classType$$5.typeFlags | TypeScript$$24.TypeFlags.IsClass;
    instanceType$$4.typeFlags = instanceType$$4.typeFlags | TypeScript$$24.TypeFlags.IsClass;
    getBases(instanceType$$4, classDecl$$7);
    JAM.call(TypeScript$$24.pushTypeCollectionScope, TypeScript$$24, [typeSymbol$$4, instanceType$$4.members, instanceType$$4.ambientMembers, null, null, context$$54, instanceType$$4, classType$$5, null]);
    return true
  }
  function preCollectInterfaceTypes(ast$$69, parent$$57, context$$55) {
    var scopeChain$$6 = context$$55.scopeChain;
    var interfaceDecl$$4 = ast$$69;
    var interfaceSymbol$$1 = null;
    var interfaceType$$2 = null;
    var isExported$$4 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [interfaceDecl$$4.varFlags, TypeScript$$24.VarFlags.Exported]);
    var isGlobal$$4 = context$$55.scopeChain.container == context$$55.checker.gloMod;
    var alreadyInScope$$1 = true;
    alreadyInScope$$1 = false;
    var interfaceName = interfaceDecl$$4.name.text;
    var v4705 = scopeChain$$6.scope;
    interfaceSymbol$$1 = JAM.call(v4705.findLocal, v4705, [interfaceName, false, true]);
    if(interfaceSymbol$$1 == null) {
      interfaceType$$2 = new TypeScript$$24.Type;
      interfaceSymbol$$1 = JAM.new(TypeScript$$24.TypeSymbol, [interfaceName, interfaceDecl$$4.name.minChar, interfaceName.length, context$$55.checker.locationInfo.unitIndex, interfaceType$$2]);
      interfaceType$$2.symbol = interfaceSymbol$$1;
      var v4711 = interfaceType$$2;
      var v26936 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
      v4711.members = v26936;
      var v4712 = interfaceType$$2;
      var v26937 = JAM.new(TypeScript$$24.ScopedMembers, [JAM.new(TypeScript$$24.DualStringHashTable, [new TypeScript$$24.StringHashTable, new TypeScript$$24.StringHashTable])]);
      v4712.ambientMembers = v26937;
      interfaceSymbol$$1.declAST = interfaceDecl$$4;
      interfaceSymbol$$1.declModule = context$$55.scopeChain.moduleDecl
    }else {
      alreadyInScope$$1 = true;
      interfaceType$$2 = interfaceSymbol$$1.type
    }
    if(!interfaceType$$2) {
      interfaceType$$2 = context$$55.checker.anyType
    }
    ast$$69.type = interfaceType$$2;
    getBases(interfaceType$$2, interfaceDecl$$4);
    if(isExported$$4) {
      interfaceSymbol$$1.flags = interfaceSymbol$$1.flags | TypeScript$$24.SymbolFlags.Exported
    }
    if(context$$55.scopeChain.moduleDecl) {
      interfaceSymbol$$1.flags = interfaceSymbol$$1.flags | TypeScript$$24.SymbolFlags.ModuleMember
    }
    if(!alreadyInScope$$1) {
      var v4718 = context$$55.scopeChain.scope;
      JAM.call(v4718.enter, v4718, [context$$55.scopeChain.container, ast$$69, interfaceSymbol$$1, context$$55.checker.errorReporter, isGlobal$$4 || isExported$$4, true, false])
    }
    JAM.call(TypeScript$$24.pushTypeCollectionScope, TypeScript$$24, [interfaceSymbol$$1, interfaceType$$2.members, interfaceType$$2.ambientMembers, null, null, context$$55, interfaceType$$2, null, null]);
    return true
  }
  function preCollectArgDeclTypes(ast$$70, parent$$58, context$$56) {
    var scopeChain$$7 = context$$56.scopeChain;
    var argDecl$$1 = ast$$70;
    if(JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [argDecl$$1.varFlags, TypeScript$$24.VarFlags.Public | TypeScript$$24.VarFlags.Private])) {
      var field$$4 = new TypeScript$$24.ValueLocation;
      var isPrivate$$2 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [argDecl$$1.varFlags, TypeScript$$24.VarFlags.Private]);
      var fieldSymbol$$2 = JAM.new(TypeScript$$24.FieldSymbol, [argDecl$$1.id.text, argDecl$$1.id.minChar, context$$56.checker.locationInfo.unitIndex, !JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [argDecl$$1.varFlags, TypeScript$$24.VarFlags.Readonly]), field$$4]);
      JAM.call(fieldSymbol$$2.transferVarFlags, fieldSymbol$$2, [argDecl$$1.varFlags]);
      field$$4.symbol = fieldSymbol$$2;
      fieldSymbol$$2.declAST = ast$$70;
      argDecl$$1.parameterPropertySym = fieldSymbol$$2;
      var v4734 = context$$56.scopeChain.scope;
      JAM.call(v4734.enter, v4734, [context$$56.scopeChain.container, ast$$70, fieldSymbol$$2, context$$56.checker.errorReporter, !isPrivate$$2, false, false]);
      var v4738 = field$$4;
      var v26938 = JAM.call(TypeScript$$24.getTypeLink, TypeScript$$24, [argDecl$$1.typeExpr, context$$56.checker, argDecl$$1.init == null]);
      v4738.typeLink = v26938;
      argDecl$$1.sym = fieldSymbol$$2
    }
    return false
  }
  function preCollectVarDeclTypes(ast$$71, parent$$59, context$$57) {
    var scopeChain$$8 = context$$57.scopeChain;
    var varDecl$$12 = ast$$71;
    var isAmbient$$7 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [varDecl$$12.varFlags, TypeScript$$24.VarFlags.Ambient]);
    var isExported$$5 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [varDecl$$12.varFlags, TypeScript$$24.VarFlags.Exported]);
    var isGlobal$$5 = context$$57.scopeChain.container == context$$57.checker.gloMod;
    var isProperty = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [varDecl$$12.varFlags, TypeScript$$24.VarFlags.Property]);
    var isStatic$$8 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [varDecl$$12.varFlags, TypeScript$$24.VarFlags.Static]);
    var isPrivate$$3 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [varDecl$$12.varFlags, TypeScript$$24.VarFlags.Private]);
    var isOptional$$1 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [varDecl$$12.id.flags, TypeScript$$24.ASTFlags.OptionalName]);
    if(context$$57.scopeChain.moduleDecl) {
      context$$57.scopeChain.moduleDecl.recordNonInterface()
    }
    var v14251 = isProperty;
    if(!v14251) {
      var v19913 = isExported$$5;
      if(!v19913) {
        var v23403 = context$$57.scopeChain.container == context$$57.checker.gloMod;
        if(!v23403) {
          v23403 = context$$57.scopeChain.moduleDecl
        }
        v19913 = v23403
      }
      v14251 = v19913
    }
    if(v14251) {
      if(isAmbient$$7) {
        var v4756 = scopeChain$$8.scope;
        var existingSym = JAM.call(v4756.findLocal, v4756, [varDecl$$12.id.text, false, false]);
        if(existingSym) {
          varDecl$$12.sym = existingSym;
          return false
        }
      }
      if(varDecl$$12.id == null) {
        var v4758 = context$$57.checker.errorReporter;
        JAM.call(v4758.simpleError, v4758, [varDecl$$12, "Expected variable identifier at this location"]);
        return false
      }
      var field$$5 = new TypeScript$$24.ValueLocation;
      var fieldSymbol$$3 = JAM.new(TypeScript$$24.FieldSymbol, [varDecl$$12.id.text, varDecl$$12.id.minChar, context$$57.checker.locationInfo.unitIndex, (varDecl$$12.varFlags & TypeScript$$24.VarFlags.Readonly) == TypeScript$$24.VarFlags.None, field$$5]);
      JAM.call(fieldSymbol$$3.transferVarFlags, fieldSymbol$$3, [varDecl$$12.varFlags]);
      if(isOptional$$1) {
        fieldSymbol$$3.flags = fieldSymbol$$3.flags | TypeScript$$24.SymbolFlags.Optional
      }
      field$$5.symbol = fieldSymbol$$3;
      fieldSymbol$$3.declAST = ast$$71;
      var v14262 = context$$57.scopeChain.moduleDecl;
      if(!v14262) {
        v14262 = context$$57.scopeChain.container == context$$57.checker.gloMod
      }
      if(v14262) {
        fieldSymbol$$3.flags = fieldSymbol$$3.flags | TypeScript$$24.SymbolFlags.ModuleMember;
        fieldSymbol$$3.declModule = context$$57.scopeChain.moduleDecl
      }
      var v14265 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [varDecl$$12.varFlags, TypeScript$$24.VarFlags.Property]);
      if(v14265) {
        var v19927 = isStatic$$8;
        if(v19927) {
          v19927 = context$$57.scopeChain.classType
        }
        v14265 = v19927
      }
      if(v14265) {
        var v19928 = context$$57.scopeChain.classType.members.publicMembers;
        if(!JAM.call(v19928.add, v19928, [varDecl$$12.id.text, fieldSymbol$$3])) {
          var v4769 = context$$57.checker.errorReporter;
          JAM.call(v4769.duplicateIdentifier, v4769, [ast$$71, fieldSymbol$$3.name])
        }
        fieldSymbol$$3.container = context$$57.scopeChain.classType.symbol
      }else {
        var v4773 = context$$57.scopeChain.scope;
        var v4774 = context$$57.scopeChain.container;
        var v4775 = context$$57.checker.errorReporter;
        var v14272 = !isPrivate$$3;
        if(v14272) {
          var v19930 = isProperty;
          if(!v19930) {
            var v23412 = isExported$$5;
            if(!v23412) {
              v23412 = isGlobal$$5 || isStatic$$8
            }
            v19930 = v23412
          }
          v14272 = v19930
        }
        JAM.call(v4773.enter, v4773, [v4774, ast$$71, fieldSymbol$$3, v4775, v14272, false, isAmbient$$7])
      }
      if(JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [varDecl$$12.varFlags, TypeScript$$24.VarFlags.Exported])) {
        fieldSymbol$$3.flags = fieldSymbol$$3.flags | TypeScript$$24.SymbolFlags.Exported
      }
      var v4779 = field$$5;
      var v26939 = JAM.call(TypeScript$$24.getTypeLink, TypeScript$$24, [varDecl$$12.typeExpr, context$$57.checker, varDecl$$12.init == null]);
      v4779.typeLink = v26939;
      varDecl$$12.sym = fieldSymbol$$3
    }
    return false
  }
  function preCollectFuncDeclTypes(ast$$72, parent$$60, context$$58) {
    var scopeChain$$9 = context$$58.scopeChain;
    if(context$$58.scopeChain.moduleDecl) {
      context$$58.scopeChain.moduleDecl.recordNonInterface()
    }
    var funcDecl$$22 = ast$$72;
    var fgSym$$3 = null;
    var nameText$$3 = funcDecl$$22.getNameText();
    var isExported$$6 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [funcDecl$$22.fncFlags, TypeScript$$24.FncFlags.Exported | TypeScript$$24.FncFlags.ClassPropertyMethodExported]);
    var isStatic$$9 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [funcDecl$$22.fncFlags, TypeScript$$24.FncFlags.Static]);
    var isPrivate$$4 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [funcDecl$$22.fncFlags, TypeScript$$24.FncFlags.Private]);
    var v4789 = funcDecl$$22.isConstructMember();
    if(!v4789) {
      v4789 = funcDecl$$22.isConstructor
    }
    var isConstructor$$3 = v4789;
    var v4790;
    var v25048 = funcDecl$$22.isMethod();
    if(v25048) {
      v25048 = isStatic$$9
    }
    var v23414 = v25048;
    if(!v23414) {
      v23414 = funcDecl$$22.isAccessor()
    }
    var v19936 = v23414;
    if(v19936) {
      v19936 = context$$58.scopeChain.classType
    }
    if(v19936) {
      v4790 = context$$58.scopeChain.classType.symbol
    }else {
      v4790 = context$$58.scopeChain.container
    }
    var containerSym = v4790;
    var containerScope = context$$58.scopeChain.scope;
    var isGlobal$$6 = containerSym == context$$58.checker.gloMod;
    var v4793 = funcDecl$$22.name;
    if(v4793) {
      v4793 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [funcDecl$$22.name.flags, TypeScript$$24.ASTFlags.OptionalName])
    }
    var isOptional$$2 = v4793;
    var go$$2 = false;
    var foundSymbol = false;
    var v14293 = isConstructor$$3;
    if(v14293) {
      v14293 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [funcDecl$$22.fncFlags, TypeScript$$24.FncFlags.ClassMethod])
    }
    if(v14293) {
      containerSym = containerSym.container;
      containerScope = scopeChain$$9.previous.scope
    }
    funcDecl$$22.unitIndex = context$$58.checker.locationInfo.unitIndex;
    var v14295 = !funcDecl$$22.isConstructor;
    if(v14295) {
      var v19943 = containerSym;
      if(v19943) {
        var v23417 = containerSym.declAST;
        if(v23417) {
          var v25050 = containerSym.declAST.nodeType == TypeScript$$24.NodeType.FuncDecl;
          if(v25050) {
            var v25879 = containerSym.declAST.isConstructor;
            if(v25879) {
              v25879 = !funcDecl$$22.isMethod()
            }
            v25050 = v25879
          }
          v23417 = v25050
        }
        v19943 = v23417
      }
      v14295 = v19943
    }
    if(v14295) {
      return go$$2
    }
    if(JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [funcDecl$$22.fncFlags, TypeScript$$24.FncFlags.Signature])) {
      var instType$$1 = context$$58.scopeChain.thisType;
      var v14298 = nameText$$3;
      if(v14298) {
        v14298 = nameText$$3 != "__missing"
      }
      if(v14298) {
        if(isStatic$$9) {
          var v4799 = containerSym.type.members.allMembers;
          fgSym$$3 = JAM.call(v4799.lookup, v4799, [nameText$$3])
        }else {
          fgSym$$3 = JAM.call(containerScope.findLocal, containerScope, [nameText$$3, false, false]);
          if(fgSym$$3 == null) {
            fgSym$$3 = JAM.call(containerScope.findLocal, containerScope, [nameText$$3, false, true])
          }
        }
        if(fgSym$$3) {
          foundSymbol = true;
          var v14300 = !funcDecl$$22.isSignature();
          if(v14300) {
            v14300 = JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [funcDecl$$22.fncFlags, TypeScript$$24.FncFlags.Ambient]) != JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [fgSym$$3.flags, TypeScript$$24.SymbolFlags.Ambient])
          }
          if(v14300) {
            fgSym$$3 = null
          }
        }
      }
      if(fgSym$$3 == null) {
        if(!funcDecl$$22.isSpecialFn()) {
          var v23422 = context$$58.checker;
          fgSym$$3 = JAM.call(v23422.createFunctionSignature, v23422, [funcDecl$$22, containerSym, containerScope, null, !foundSymbol]).declAST.type.symbol
        }else {
          var v23424 = context$$58.checker;
          fgSym$$3 = JAM.call(v23424.createFunctionSignature, v23424, [funcDecl$$22, containerSym, containerScope, containerSym, false]).declAST.type.symbol
        }
        var v14304 = fgSym$$3.declAST == null;
        if(!v14304) {
          v14304 = !funcDecl$$22.isSpecialFn()
        }
        if(v14304) {
          fgSym$$3.declAST = ast$$72
        }
      }else {
        if(fgSym$$3.kind() == TypeScript$$24.SymbolKind.Type) {
          var v23425 = context$$58.checker;
          fgSym$$3 = JAM.call(v23425.createFunctionSignature, v23425, [funcDecl$$22, containerSym, containerScope, fgSym$$3, false]).declAST.type.symbol
        }else {
          var v4808 = context$$58.checker.errorReporter;
          JAM.call(v4808.simpleError, v4808, [funcDecl$$22, "Function or method '" + funcDecl$$22.name.actualText + "' already declared as a property"])
        }
      }
      var v14310 = funcDecl$$22.isSpecialFn();
      if(v14310) {
        v14310 = !isStatic$$9
      }
      if(v14310) {
        var v4812;
        if(instType$$1) {
          v4812 = instType$$1
        }else {
          v4812 = fgSym$$3.type
        }
        funcDecl$$22.type = v4812
      }else {
        funcDecl$$22.type = fgSym$$3.type
      }
    }else {
      if(nameText$$3) {
        if(isStatic$$9) {
          var v4814 = containerSym.type.members.allMembers;
          fgSym$$3 = JAM.call(v4814.lookup, v4814, [nameText$$3])
        }else {
          var v14312 = funcDecl$$22.isConstructor;
          if(v14312) {
            v14312 = context$$58.scopeChain.previous
          }
          if(v14312) {
            var v4815 = context$$58.scopeChain.previous.scope;
            fgSym$$3 = JAM.call(v4815.findLocal, v4815, [nameText$$3, false, false])
          }
          if(fgSym$$3 == null) {
            fgSym$$3 = JAM.call(containerScope.findLocal, containerScope, [nameText$$3, false, false])
          }
        }
        if(fgSym$$3) {
          foundSymbol = true;
          var v14314 = !isConstructor$$3;
          if(v14314) {
            var v19960 = fgSym$$3.declAST.nodeType == TypeScript$$24.NodeType.FuncDecl;
            if(v19960) {
              var v23429 = !fgSym$$3.declAST.isAccessor();
              if(v23429) {
                v23429 = !fgSym$$3.declAST.isSignature()
              }
              v19960 = v23429
            }
            v14314 = v19960
          }
          if(v14314) {
            fgSym$$3 = null;
            foundSymbol = false
          }
        }
      }
      var v14315 = fgSym$$3;
      if(v14315) {
        var v19961 = !fgSym$$3.isAccessor();
        if(v19961) {
          var v23431 = fgSym$$3.type;
          if(v23431) {
            var v25057 = fgSym$$3.type.construct;
            if(v25057) {
              var v25883 = fgSym$$3.type.construct.signatures != [];
              if(v25883) {
                var v26532 = fgSym$$3.type.construct.signatures[0].declAST == null;
                if(!v26532) {
                  v26532 = !JAM.call(TypeScript$$24.hasFlag, TypeScript$$24, [fgSym$$3.type.construct.signatures[0].declAST.fncFlags, TypeScript$$24.FncFlags.Ambient])
                }
                var v26329 = v26532;
                if(v26329) {
                  v26329 = !funcDecl$$22.isConstructor
                }
                v25883 = v26329
              }
              v25057 = v25883
            }
            v23431 = v25057
          }
          v19961 = v23431
        }
        v14315 = v19961
      }
      if(v14315) {
        var v4819 = context$$58.checker.errorReporter;
        JAM.call(v4819.simpleError, v4819, [funcDecl$$22, "Functions may not have class overloads"])
      }
      var v14317 = fgSym$$3;
      if(v14317) {
        var v19962 = !(fgSym$$3.kind() == TypeScript$$24.SymbolKind.Type);
        if(v19962) {
          var v23433 = funcDecl$$22.isMethod();
          if(v23433) {
            var v25060 = !funcDecl$$22.isAccessor();
            if(v25060) {
              v25060 = !funcDecl$$22.isConstructor
            }
            v23433 = v25060
          }
          v19962 = v23433
        }
        v14317 = v19962
      }
      if(v14317) {
        var v4821 = context$$58.checker.errorReporter;
        JAM.call(v4821.simpleError, v4821, [funcDecl$$22, "Function or method '" + funcDecl$$22.name.actualText + "' already declared as a property"]);
        fgSym$$3.type = context$$58.checker.anyType
      }
      var v4825 = context$$58.checker;
      var sig$$2 = JAM.call(v4825.createFunctionSignature, v4825, [funcDecl$$22, containerSym, containerScope, fgSym$$3, !foundSymbol]);
      var v23435 = !fgSym$$3;
      if(!v23435) {
        v23435 = fgSym$$3.declAST.nodeType != TypeScript$$24.NodeType.FuncDecl
      }
      var v19964 = v23435;
      if(v19964) {
        v19964 = funcDecl$$22.isAccessor()
      }
      var v14320 = v19964;
      if(!v14320) {
        var v19965 = fgSym$$3;
        if(v19965) {
          v19965 = fgSym$$3.isAccessor()
        }
        v14320 = v19965
      }
      if(v14320) {
        var v4827 = funcDecl$$22;
        var v14321 = context$$58.checker;
        var v14322 = containerSym.type;
        var v19967 = funcDecl$$22.isMethod();
        if(v19967) {
          v19967 = isStatic$$9
        }
        var v26940 = JAM.call(v14321.createAccessorSymbol, v14321, [funcDecl$$22, fgSym$$3, v14322, v19967, true, containerScope, containerSym]);
        v4827.accessorSymbol = v26940
      }
      funcDecl$$22.type.symbol.declAST = ast$$72;
      if(funcDecl$$22.isConstructor) {
        go$$2 = true
      }
    }
    if(isExported$$6) {
      if(funcDecl$$22.type.call) {
        var v4832 = funcDecl$$22.type.symbol;
        v4832.flags = v4832.flags | TypeScript$$24.SymbolFlags.Exported
      }
      var v14327 = fgSym$$3;
      if(v14327) {
        var v19970 = !fgSym$$3.isAccessor();
        if(v19970) {
          var v23438 = fgSym$$3.kind() == TypeScript$$24.SymbolKind.Type;
          if(v23438) {
            v23438 = fgSym$$3.type.call
          }
          v19970 = v23438
        }
        v14327 = v19970
      }
      if(v14327) {
        fgSym$$3.flags = fgSym$$3.flags | TypeScript$$24.SymbolFlags.Exported
      }
    }
    var v14330 = context$$58.scopeChain.moduleDecl;
    if(v14330) {
      v14330 = !funcDecl$$22.isSpecialFn()
    }
    if(v14330) {
      var v4835 = funcDecl$$22.type.symbol;
      v4835.flags = v4835.flags | TypeScript$$24.SymbolFlags.ModuleMember;
      funcDecl$$22.type.symbol.declModule = context$$58.scopeChain.moduleDecl
    }
    if(fgSym$$3 && isOptional$$2) {
      fgSym$$3.flags = fgSym$$3.flags | TypeScript$$24.SymbolFlags.Optional
    }
    return go$$2
  }
  function preCollectTypes(ast$$73, parent$$61, walker$$46) {
    var context$$59 = walker$$46.state;
    var go$$3 = false;
    var scopeChain$$10 = context$$59.scopeChain;
    if(ast$$73.nodeType == TypeScript$$24.NodeType.Script) {
      var script$$15 = ast$$73;
      context$$59.script = script$$15;
      go$$3 = true
    }else {
      if(ast$$73.nodeType == TypeScript$$24.NodeType.List) {
        go$$3 = true
      }else {
        if(ast$$73.nodeType == TypeScript$$24.NodeType.ImportDeclaration) {
          go$$3 = preCollectImportTypes(ast$$73, parent$$61, context$$59)
        }else {
          if(ast$$73.nodeType == TypeScript$$24.NodeType.With) {
            go$$3 = false
          }else {
            if(ast$$73.nodeType == TypeScript$$24.NodeType.ModuleDeclaration) {
              go$$3 = preCollectModuleTypes(ast$$73, parent$$61, context$$59)
            }else {
              if(ast$$73.nodeType == TypeScript$$24.NodeType.ClassDeclaration) {
                go$$3 = preCollectClassTypes(ast$$73, parent$$61, context$$59)
              }else {
                if(ast$$73.nodeType == TypeScript$$24.NodeType.Block) {
                  go$$3 = true
                }else {
                  if(ast$$73.nodeType == TypeScript$$24.NodeType.InterfaceDeclaration) {
                    go$$3 = preCollectInterfaceTypes(ast$$73, parent$$61, context$$59)
                  }else {
                    if(ast$$73.nodeType == TypeScript$$24.NodeType.ArgDecl) {
                      go$$3 = preCollectArgDeclTypes(ast$$73, parent$$61, context$$59)
                    }else {
                      if(ast$$73.nodeType == TypeScript$$24.NodeType.VarDecl) {
                        go$$3 = preCollectVarDeclTypes(ast$$73, parent$$61, context$$59)
                      }else {
                        if(ast$$73.nodeType == TypeScript$$24.NodeType.FuncDecl) {
                          go$$3 = preCollectFuncDeclTypes(ast$$73, parent$$61, context$$59)
                        }else {
                          var v14358 = ast$$73.isStatementOrExpression();
                          if(v14358) {
                            v14358 = context$$59.scopeChain.moduleDecl
                          }
                          if(v14358) {
                            context$$59.scopeChain.moduleDecl.recordNonInterface()
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    walker$$46.options.goChildren = go$$3;
    return ast$$73
  }
  function postCollectTypes(ast$$74, parent$$62, walker$$47) {
    var context$$60 = walker$$47.state;
    if(ast$$74.nodeType == TypeScript$$24.NodeType.ModuleDeclaration) {
      JAM.call(TypeScript$$24.popTypeCollectionScope, TypeScript$$24, [context$$60])
    }else {
      if(ast$$74.nodeType == TypeScript$$24.NodeType.ClassDeclaration) {
        JAM.call(TypeScript$$24.popTypeCollectionScope, TypeScript$$24, [context$$60])
      }else {
        if(ast$$74.nodeType == TypeScript$$24.NodeType.InterfaceDeclaration) {
          JAM.call(TypeScript$$24.popTypeCollectionScope, TypeScript$$24, [context$$60])
        }
      }
    }
    return ast$$74
  }
  var Continuation = v966();
  TypeScript$$24.Continuation = Continuation;
  TypeScript$$24.createNewConstructGroupForType = createNewConstructGroupForType;
  TypeScript$$24.cloneParentConstructGroupForChildType = cloneParentConstructGroupForChildType;
  TypeScript$$24.globalId = "__GLO";
  TypeScript$$24.preCollectImportTypes = preCollectImportTypes;
  TypeScript$$24.preCollectModuleTypes = preCollectModuleTypes;
  TypeScript$$24.preCollectClassTypes = preCollectClassTypes;
  TypeScript$$24.preCollectInterfaceTypes = preCollectInterfaceTypes;
  TypeScript$$24.preCollectArgDeclTypes = preCollectArgDeclTypes;
  TypeScript$$24.preCollectVarDeclTypes = preCollectVarDeclTypes;
  TypeScript$$24.preCollectFuncDeclTypes = preCollectFuncDeclTypes;
  TypeScript$$24.preCollectTypes = preCollectTypes;
  TypeScript$$24.postCollectTypes = postCollectTypes;
  return
}
function v964(TypeScript$$23) {
  function v963() {
    function v962(sourceSig, targetSig, assignableTo$$2, comparisonCache$$2, comparisonInfo$$11) {
      var v14366 = !sourceSig.parameters;
      if(!v14366) {
        v14366 = !targetSig.parameters
      }
      if(v14366) {
        return false
      }
      var v4857;
      if(targetSig.hasVariableArgList) {
        v4857 = targetSig.nonOptionalParameterCount - 1
      }else {
        v4857 = targetSig.nonOptionalParameterCount
      }
      var targetVarArgCount = v4857;
      var v4858;
      if(sourceSig.hasVariableArgList) {
        v4858 = sourceSig.nonOptionalParameterCount - 1
      }else {
        v4858 = sourceSig.nonOptionalParameterCount
      }
      var sourceVarArgCount = v4858;
      var v14371 = sourceVarArgCount > targetVarArgCount;
      if(v14371) {
        v14371 = !targetSig.hasVariableArgList
      }
      if(v14371) {
        if(comparisonInfo$$11) {
          comparisonInfo$$11.flags = comparisonInfo$$11.flags | TypeScript$$23.TypeRelationshipFlags.SourceSignatureHasTooManyParameters;
          JAM.call(comparisonInfo$$11.addMessageToFront, comparisonInfo$$11, ["Call signature expects " + targetVarArgCount + " or fewer parameters"])
        }
        return false
      }
      var sourceReturnType = sourceSig.returnType.type;
      var targetReturnType = targetSig.returnType.type;
      if(targetReturnType != this.voidType) {
        if(!JAM.call(this.sourceIsRelatableToTarget, this, [sourceReturnType, targetReturnType, assignableTo$$2, comparisonCache$$2, comparisonInfo$$11])) {
          if(comparisonInfo$$11) {
            comparisonInfo$$11.flags = comparisonInfo$$11.flags | TypeScript$$23.TypeRelationshipFlags.IncompatibleReturnTypes
          }
          return false
        }
      }
      var v4865;
      var v19998 = sourceVarArgCount < targetVarArgCount;
      if(v19998) {
        v19998 = sourceSig.hasVariableArgList
      }
      if(v19998) {
        v4865 = targetVarArgCount
      }else {
        v4865 = sourceVarArgCount
      }
      var len$$29 = v4865;
      var sourceParamType = null;
      var targetParamType = null;
      var sourceParamName = "";
      var targetParamName = "";
      var iSource = 0;
      var iTarget = 0;
      var v4881 = iSource < len$$29;
      for(;v4881;) {
        var v14380 = !sourceSig.hasVariableArgList;
        if(!v14380) {
          v14380 = iSource < sourceVarArgCount
        }
        if(v14380) {
          var v23440 = sourceSig.parameters;
          introspect(JAM.policy.p1) {
            var v20001 = v23440[iSource]
          }
          sourceParamType = v20001.parameter.typeLink.type;
          var v23441 = sourceSig.parameters;
          introspect(JAM.policy.p1) {
            var v20002 = v23441[iSource]
          }
          sourceParamName = v20002.parameter.symbol.name
        }else {
          if(iSource == sourceVarArgCount) {
            var v23442 = sourceSig.parameters;
            introspect(JAM.policy.p1) {
              var v20003 = v23442[iSource]
            }
            sourceParamType = v20003.parameter.typeLink.type;
            if(sourceParamType.elementType) {
              sourceParamType = sourceParamType.elementType
            }
            var v23443 = sourceSig.parameters;
            introspect(JAM.policy.p1) {
              var v20004 = v23443[iSource]
            }
            sourceParamName = v20004.parameter.symbol.name
          }
        }
        var v14385 = iTarget < targetSig.parameters.length;
        if(v14385) {
          v14385 = iTarget < targetVarArgCount
        }
        if(v14385) {
          var v23445 = targetSig.parameters;
          introspect(JAM.policy.p1) {
            var v20006 = v23445[iTarget]
          }
          targetParamType = v20006.parameter.typeLink.type;
          var v23446 = targetSig.parameters;
          introspect(JAM.policy.p1) {
            var v20007 = v23446[iTarget]
          }
          targetParamName = v20007.parameter.symbol.name
        }else {
          var v14388 = targetSig.hasVariableArgList;
          if(v14388) {
            v14388 = iTarget == targetVarArgCount
          }
          if(v14388) {
            var v23447 = targetSig.parameters;
            introspect(JAM.policy.p1) {
              var v20008 = v23447[iTarget]
            }
            targetParamType = v20008.parameter.typeLink.type;
            if(targetParamType.elementType) {
              targetParamType = targetParamType.elementType
            }
            var v23448 = targetSig.parameters;
            introspect(JAM.policy.p1) {
              var v20009 = v23448[iTarget]
            }
            targetParamName = v20009.parameter.symbol.name
          }
        }
        var v20010 = JAM.call(this.sourceIsRelatableToTarget, this, [sourceParamType, targetParamType, assignableTo$$2, comparisonCache$$2, comparisonInfo$$11]);
        if(!v20010) {
          v20010 = JAM.call(this.sourceIsRelatableToTarget, this, [targetParamType, sourceParamType, assignableTo$$2, comparisonCache$$2, comparisonInfo$$11])
        }
        if(!v20010) {
          if(comparisonInfo$$11) {
            comparisonInfo$$11.flags = comparisonInfo$$11.flags | TypeScript$$23.TypeRelationshipFlags.IncompatibleParameterTypes
          }
          return false
        }
        iSource = iSource + 1;
        iTarget = iTarget + 1;
        v4881 = iSource < len$$29
      }
      return true
    }
    function v961(sourceSG, targetSG, assignableTo$$1, comparisonCache$$1, comparisonInfo$$10) {
      if(sourceSG == targetSG) {
        return true
      }
      if(!(sourceSG && targetSG)) {
        return false
      }
      var mSig = null;
      var nSig = null;
      var foundMatch = false;
      var iMSig = 0;
      var v4888 = iMSig < targetSG.signatures.length;
      for(;v4888;) {
        mSig = targetSG.signatures[iMSig];
        var iNSig = 0;
        var v4887 = iNSig < sourceSG.signatures.length;
        for(;v4887;) {
          nSig = sourceSG.signatures[iNSig];
          if(JAM.call(this.signatureIsRelatableToTarget, this, [nSig, mSig, assignableTo$$1, comparisonCache$$1, comparisonInfo$$10])) {
            foundMatch = true;
            break
          }
          iNSig = iNSig + 1;
          v4887 = iNSig < sourceSG.signatures.length
        }
        if(foundMatch) {
          foundMatch = false;
          iMSig = iMSig + 1;
          v4888 = iMSig < targetSG.signatures.length;
          continue
        }
        return false
      }
      return true
    }
    function v960(source$$3, target$$44, assignableTo, comparisonCache, comparisonInfo$$9) {
      if(source$$3 == target$$44) {
        return true
      }
      if(!(source$$3 && target$$44)) {
        return true
      }
      var comboId$$1 = source$$3.typeID << 16 | target$$44.typeID;
      introspect(JAM.policy.p1) {
        var v14401 = comparisonCache[comboId$$1]
      }
      if(v14401 != undefined) {
        return true
      }
      if(assignableTo) {
        var v14402 = source$$3 == this.anyType;
        if(!v14402) {
          v14402 = target$$44 == this.anyType
        }
        if(v14402) {
          return true
        }
      }else {
        if(target$$44 == this.anyType) {
          return true
        }
      }
      if(source$$3 == this.undefinedType) {
        return true
      }
      var v14405 = source$$3 == this.nullType;
      if(v14405) {
        var v20020 = target$$44 != this.undefinedType;
        if(v20020) {
          v20020 = target$$44 != this.voidType
        }
        v14405 = v20020
      }
      if(v14405) {
        return true
      }
      var v14406 = target$$44 == this.numberType;
      if(v14406) {
        v14406 = source$$3.typeFlags & TypeScript$$23.TypeFlags.IsEnum
      }
      if(v14406) {
        return true
      }
      var v14407 = source$$3 == this.numberType;
      if(v14407) {
        v14407 = target$$44.typeFlags & TypeScript$$23.TypeFlags.IsEnum
      }
      if(v14407) {
        return true
      }
      var v14408 = source$$3.typeFlags & TypeScript$$23.TypeFlags.IsEnum;
      if(!v14408) {
        v14408 = target$$44.typeFlags & TypeScript$$23.TypeFlags.IsEnum
      }
      if(v14408) {
        return false
      }
      var v14409 = source$$3.isArray();
      if(!v14409) {
        v14409 = target$$44.isArray()
      }
      if(v14409) {
        var v20033 = source$$3.isArray();
        if(v20033) {
          v20033 = target$$44.isArray()
        }
        if(!v20033) {
          return false
        }
        comparisonCache[comboId$$1] = false;
        var ret$$1 = JAM.call(this.sourceIsRelatableToTarget, this, [source$$3.elementType, target$$44.elementType, assignableTo, comparisonCache, comparisonInfo$$9]);
        if(ret$$1) {
          comparisonCache[comboId$$1] = true
        }else {
          comparisonCache[comboId$$1] = undefined
        }
        return ret$$1
      }
      if(source$$3.primitiveTypeClass != target$$44.primitiveTypeClass) {
        if(target$$44.primitiveTypeClass == TypeScript$$23.Primitive.None) {
          var v14415 = source$$3 == this.numberType;
          if(v14415) {
            v14415 = this.typeFlow.numberInterfaceType
          }
          if(v14415) {
            source$$3 = this.typeFlow.numberInterfaceType
          }else {
            var v14416 = source$$3 == this.stringType;
            if(v14416) {
              v14416 = this.typeFlow.stringInterfaceType
            }
            if(v14416) {
              source$$3 = this.typeFlow.stringInterfaceType
            }else {
              var v14417 = source$$3 == this.booleanType;
              if(v14417) {
                v14417 = this.typeFlow.booleanInterfaceType
              }
              if(v14417) {
                source$$3 = this.typeFlow.booleanInterfaceType
              }else {
                return false
              }
            }
          }
        }else {
          return false
        }
      }
      comparisonCache[comboId$$1] = false;
      if(JAM.call(source$$3.hasBase, source$$3, [target$$44])) {
        comparisonCache[comboId$$1] = true;
        return true
      }
      var v14418 = this.typeFlow.objectInterfaceType;
      if(v14418) {
        v14418 = target$$44 == this.typeFlow.objectInterfaceType
      }
      if(v14418) {
        return true
      }
      var v14419 = this.typeFlow.functionInterfaceType;
      if(v14419) {
        var v23457 = source$$3.call;
        if(!v23457) {
          v23457 = source$$3.construct
        }
        var v20044 = v23457;
        if(v20044) {
          v20044 = target$$44 == this.typeFlow.functionInterfaceType
        }
        v14419 = v20044
      }
      if(v14419) {
        return true
      }
      var v14420 = target$$44.isClass();
      if(!v14420) {
        v14420 = target$$44.isClassInstance()
      }
      if(v14420) {
        comparisonCache[comboId$$1] = undefined;
        return false
      }
      var v14421 = target$$44.memberScope;
      if(v14421) {
        v14421 = source$$3.memberScope
      }
      if(v14421) {
        var v4917 = target$$44.memberScope;
        var mPropKeys = JAM.call(v4917.getAllValueSymbolNames, v4917, [true]);
        var mProp = null;
        var nProp = null;
        var mPropType = null;
        var nPropType = null;
        var inferenceSymbol = null;
        var iMProp = 0;
        var v4945 = iMProp < mPropKeys.length;
        for(;v4945;) {
          var v4918 = target$$44.memberScope;
          introspect(JAM.policy.p1) {
            var v4919 = mPropKeys[iMProp]
          }
          mProp = JAM.call(v4918.find, v4918, [v4919, false, false]);
          var v4920 = source$$3.memberScope;
          introspect(JAM.policy.p1) {
            var v4921 = mPropKeys[iMProp]
          }
          nProp = JAM.call(v4920.find, v4920, [v4921, false, false]);
          var v14423 = mProp.name == "arguments";
          if(v14423) {
            var v20047 = this.typeFlow.iargumentsInterfaceType;
            if(v20047) {
              var v23460 = this.typeFlow.iargumentsInterfaceType.symbol.flags & TypeScript$$23.SymbolFlags.CompilerGenerated;
              if(v23460) {
                var v25071 = mProp.kind() == TypeScript$$23.SymbolKind.Variable;
                if(v25071) {
                  v25071 = mProp.variable.typeLink.type == this.typeFlow.iargumentsInterfaceType
                }
                v23460 = v25071
              }
              v20047 = v23460
            }
            v14423 = v20047
          }
          if(v14423) {
            iMProp = iMProp + 1;
            v4945 = iMProp < mPropKeys.length;
            continue
          }
          if(mProp.isInferenceSymbol()) {
            inferenceSymbol = mProp;
            if(inferenceSymbol.typeCheckStatus == TypeScript$$23.TypeCheckStatus.NotStarted) {
              var v4923 = this.typeFlow;
              JAM.call(v4923.typeCheck, v4923, [mProp.declAST])
            }
          }
          mPropType = mProp.getType();
          if(!nProp) {
            if(this.typeFlow.objectInterfaceType) {
              var v4927 = this.typeFlow.objectInterfaceType.memberScope;
              introspect(JAM.policy.p1) {
                var v4928 = mPropKeys[iMProp]
              }
              nProp = JAM.call(v4927.find, v4927, [v4928, false, false])
            }
            if(!nProp) {
              var v14429 = this.typeFlow.functionInterfaceType;
              if(v14429) {
                var v20051 = mPropType.call;
                if(!v20051) {
                  v20051 = mPropType.construct
                }
                v14429 = v20051
              }
              if(v14429) {
                var v4930 = this.typeFlow.functionInterfaceType.memberScope;
                introspect(JAM.policy.p1) {
                  var v4931 = mPropKeys[iMProp]
                }
                nProp = JAM.call(v4930.find, v4930, [v4931, false, false])
              }
              if(!nProp) {
                if(!(mProp.flags & TypeScript$$23.SymbolFlags.Optional)) {
                  comparisonCache[comboId$$1] = undefined;
                  if(comparisonInfo$$9) {
                    comparisonInfo$$9.flags = comparisonInfo$$9.flags | TypeScript$$23.TypeRelationshipFlags.RequiredPropertyIsMissing;
                    var v25072 = "Type '" + source$$3.getTypeName() + "' is missing property '";
                    introspect(JAM.policy.p1) {
                      var v25073 = mPropKeys[iMProp]
                    }
                    JAM.call(comparisonInfo$$9.addMessageToFront, comparisonInfo$$9, [v25072 + v25073 + "' from type '" + target$$44.getTypeName() + "'"])
                  }
                  return false
                }else {
                  iMProp = iMProp + 1;
                  v4945 = iMProp < mPropKeys.length;
                  continue
                }
              }
            }
          }
          if(nProp.isInferenceSymbol()) {
            inferenceSymbol = nProp;
            if(inferenceSymbol.typeCheckStatus == TypeScript$$23.TypeCheckStatus.NotStarted) {
              var v4938 = this.typeFlow;
              JAM.call(v4938.typeCheck, v4938, [nProp.declAST])
            }
          }
          nPropType = nProp.getType();
          var v14438 = mPropType;
          if(v14438) {
            var v20059 = nPropType;
            if(v20059) {
              var v25074 = nPropType.typeID << 16 | mPropType.typeID;
              introspect(JAM.policy.p1) {
                var v23464 = comparisonCache[v25074]
              }
              v20059 = v23464 != undefined
            }
            v14438 = v20059
          }
          if(v14438) {
            iMProp = iMProp + 1;
            v4945 = iMProp < mPropKeys.length;
            continue
          }
          if(!JAM.call(this.sourceIsRelatableToTarget, this, [nPropType, mPropType, assignableTo, comparisonCache, comparisonInfo$$9])) {
            comparisonCache[comboId$$1] = undefined;
            if(comparisonInfo$$9) {
              comparisonInfo$$9.flags = comparisonInfo$$9.flags | TypeScript$$23.TypeRelationshipFlags.IncompatiblePropertyTypes;
              JAM.call(comparisonInfo$$9.addMessageToFront, comparisonInfo$$9, ["Types of property '" + mProp.name + "' of types '" + source$$3.getTypeName() + "' and '" + target$$44.getTypeName() + "' are incompatible"])
            }
            return false
          }
          iMProp = iMProp + 1;
          v4945 = iMProp < mPropKeys.length
        }
      }
      var v14445 = source$$3.call;
      if(!v14445) {
        v14445 = target$$44.call
      }
      if(v14445) {
        if(!JAM.call(this.signatureGroupIsRelatableToTarget, this, [source$$3.call, target$$44.call, assignableTo, comparisonCache, comparisonInfo$$9])) {
          if(comparisonInfo$$9) {
            var v14447 = source$$3.call;
            if(v14447) {
              v14447 = target$$44.call
            }
            if(v14447) {
              JAM.call(comparisonInfo$$9.addMessageToFront, comparisonInfo$$9, ["Call signatures of types '" + source$$3.getTypeName() + "' and '" + target$$44.getTypeName() + "' are incompatible"])
            }else {
              var v4948;
              if(target$$44.call) {
                v4948 = target$$44.getTypeName()
              }else {
                v4948 = source$$3.getTypeName()
              }
              var hasSig = v4948;
              var v4949;
              if(!target$$44.call) {
                v4949 = target$$44.getTypeName()
              }else {
                v4949 = source$$3.getTypeName()
              }
              var lacksSig = v4949;
              JAM.call(comparisonInfo$$9.setMessage, comparisonInfo$$9, ["Type '" + hasSig + "' requires a call signature, but Type '" + lacksSig + "' lacks one"])
            }
            comparisonInfo$$9.flags = comparisonInfo$$9.flags | TypeScript$$23.TypeRelationshipFlags.IncompatibleSignatures
          }
          comparisonCache[comboId$$1] = undefined;
          return false
        }
      }
      var v14454 = source$$3.construct;
      if(!v14454) {
        v14454 = target$$44.construct
      }
      if(v14454) {
        if(!JAM.call(this.signatureGroupIsRelatableToTarget, this, [source$$3.construct, target$$44.construct, assignableTo, comparisonCache, comparisonInfo$$9])) {
          if(comparisonInfo$$9) {
            var v14456 = source$$3.construct;
            if(v14456) {
              v14456 = target$$44.construct
            }
            if(v14456) {
              JAM.call(comparisonInfo$$9.addMessageToFront, comparisonInfo$$9, ["Construct signatures of types '" + source$$3.getTypeName() + "' and '" + target$$44.getTypeName() + "' are incompatible"])
            }else {
              var v4955;
              if(target$$44.construct) {
                v4955 = target$$44.getTypeName()
              }else {
                v4955 = source$$3.getTypeName()
              }
              hasSig = v4955;
              var v4956;
              if(!target$$44.construct) {
                v4956 = target$$44.getTypeName()
              }else {
                v4956 = source$$3.getTypeName()
              }
              lacksSig = v4956;
              JAM.call(comparisonInfo$$9.setMessage, comparisonInfo$$9, ["Type '" + hasSig + "' requires a construct signature, but Type '" + lacksSig + "' lacks one"])
            }
            comparisonInfo$$9.flags = comparisonInfo$$9.flags | TypeScript$$23.TypeRelationshipFlags.IncompatibleSignatures
          }
          comparisonCache[comboId$$1] = undefined;
          return false
        }
      }
      if(target$$44.index) {
        var v4961;
        var v20079 = !target$$44.index;
        if(v20079) {
          v20079 = this.typeFlow.objectInterfaceType
        }
        if(v20079) {
          v4961 = this.typeFlow.objectInterfaceType.index
        }else {
          v4961 = target$$44.index
        }
        var targetIndex = v4961;
        var v4962;
        var v20081 = !source$$3.index;
        if(v20081) {
          v20081 = this.typeFlow.objectInterfaceType
        }
        if(v20081) {
          v4962 = this.typeFlow.objectInterfaceType.index
        }else {
          v4962 = source$$3.index
        }
        var sourceIndex = v4962;
        if(!JAM.call(this.signatureGroupIsRelatableToTarget, this, [sourceIndex, targetIndex, assignableTo, comparisonCache, comparisonInfo$$9])) {
          if(comparisonInfo$$9) {
            JAM.call(comparisonInfo$$9.addMessageToFront, comparisonInfo$$9, ["Index signatures of types '" + source$$3.getTypeName() + "' and '" + target$$44.getTypeName() + "' are incompatible"]);
            comparisonInfo$$9.flags = comparisonInfo$$9.flags | TypeScript$$23.TypeRelationshipFlags.IncompatibleSignatures
          }
          comparisonCache[comboId$$1] = undefined;
          return false
        }
      }
      comparisonCache[comboId$$1] = true;
      return true
    }
    function v959(s1$$2, s2$$2, comparisonInfo$$8) {
      return JAM.call(this.signatureIsRelatableToTarget, this, [s1$$2, s2$$2, true, this.assignableCache, comparisonInfo$$8])
    }
    function v958(sg1$$2, sg2$$2, comparisonInfo$$7) {
      return JAM.call(this.signatureGroupIsRelatableToTarget, this, [sg1$$2, sg2$$2, true, this.assignableCache, comparisonInfo$$7])
    }
    function v957(source$$2, target$$43, comparisonInfo$$6) {
      return JAM.call(this.sourceIsRelatableToTarget, this, [source$$2, target$$43, true, this.assignableCache, comparisonInfo$$6])
    }
    function v956(s1$$1, s2$$1, comparisonInfo$$5) {
      return JAM.call(this.signatureIsRelatableToTarget, this, [s1$$1, s2$$1, false, this.subtypeCache, comparisonInfo$$5])
    }
    function v955(sg1$$1, sg2$$1, comparisonInfo$$4) {
      return JAM.call(this.signatureGroupIsRelatableToTarget, this, [sg1$$1, sg2$$1, false, this.subtypeCache, comparisonInfo$$4])
    }
    function v954(source$$1, target$$42, comparisonInfo$$3) {
      return JAM.call(this.sourceIsRelatableToTarget, this, [source$$1, target$$42, false, this.subtypeCache, comparisonInfo$$3])
    }
    function v953(s1, s2) {
      if(s1.hasVariableArgList != s2.hasVariableArgList) {
        return false
      }
      if(s1.nonOptionalParameterCount != s2.nonOptionalParameterCount) {
        return false
      }
      if(s1.parameters.length != s2.parameters.length) {
        return false
      }
      if(!JAM.call(this.typesAreIdentical, this, [s1.returnType.type, s2.returnType.type])) {
        return false
      }
      var iParam = 0;
      var v4977 = iParam < s1.parameters.length;
      for(;v4977;) {
        var v26337 = s1.parameters;
        introspect(JAM.policy.p1) {
          var v25900 = v26337[iParam]
        }
        var v20091 = v25900.parameter.typeLink.type;
        var v26338 = s2.parameters;
        introspect(JAM.policy.p1) {
          var v25901 = v26338[iParam]
        }
        if(!JAM.call(this.typesAreIdentical, this, [v20091, v25901.parameter.typeLink.type])) {
          return false
        }
        iParam = iParam + 1;
        v4977 = iParam < s1.parameters.length
      }
      return true
    }
    function v952(sg1, sg2) {
      if(sg1 == sg2) {
        return true
      }
      var v14481 = !sg1;
      if(!v14481) {
        v14481 = !sg2
      }
      if(v14481) {
        return false
      }
      if(sg1.signatures.length != sg2.signatures.length) {
        return false
      }
      var sig1 = null;
      var sig2 = null;
      var sigsMatch = false;
      var iSig1 = 0;
      var v4985 = iSig1 < sg1.signatures.length;
      for(;v4985;) {
        sig1 = sg1.signatures[iSig1];
        var iSig2 = 0;
        var v4984 = iSig2 < sg2.signatures.length;
        for(;v4984;) {
          sig2 = sg2.signatures[iSig2];
          if(JAM.call(this.signaturesAreIdentical, this, [sig1, sig2])) {
            sigsMatch = true;
            break
          }
          iSig2 = iSig2 + 1;
          v4984 = iSig2 < sg2.signatures.length
        }
        if(sigsMatch) {
          sigsMatch = false;
          iSig1 = iSig1 + 1;
          v4985 = iSig1 < sg1.signatures.length;
          continue
        }
        return false
      }
      return true
    }
    function v951(t1$$1, t2$$1) {
      if(t1$$1 == t2$$1) {
        return true
      }
      var v14488 = !t1$$1;
      if(!v14488) {
        v14488 = !t2$$1
      }
      if(v14488) {
        return false
      }
      var v14489 = t1$$1.isClass();
      if(!v14489) {
        v14489 = t1$$1.isClassInstance()
      }
      if(v14489) {
        return false
      }
      var comboId = t2$$1.typeID << 16 | t1$$1.typeID;
      var v14491 = this.identicalCache;
      introspect(JAM.policy.p1) {
        var v4991 = v14491[comboId]
      }
      if(v4991) {
        return true
      }
      var v14492 = t1$$1.typeFlags & TypeScript$$23.TypeFlags.IsEnum;
      if(!v14492) {
        v14492 = t2$$1.typeFlags & TypeScript$$23.TypeFlags.IsEnum
      }
      if(v14492) {
        return false
      }
      var v14493 = t1$$1.isArray();
      if(!v14493) {
        v14493 = t2$$1.isArray()
      }
      if(v14493) {
        var v20109 = t1$$1.isArray();
        if(v20109) {
          v20109 = t2$$1.isArray()
        }
        if(!v20109) {
          return false
        }
        this.identicalCache[comboId] = false;
        var ret = JAM.call(this.typesAreIdentical, this, [t1$$1.elementType, t2$$1.elementType]);
        if(ret) {
          this.subtypeCache[comboId] = true
        }else {
          this.subtypeCache[comboId] = undefined
        }
        return ret
      }
      if(t1$$1.primitiveTypeClass != t2$$1.primitiveTypeClass) {
        return false
      }
      this.identicalCache[comboId] = false;
      var v14497 = t1$$1.memberScope;
      if(v14497) {
        v14497 = t2$$1.memberScope
      }
      if(v14497) {
        var v14498 = t1$$1.memberScope;
        var t1MemberKeys = JAM.call(v14498.getAllValueSymbolNames, v14498, [true]).sort();
        var v14499 = t2$$1.memberScope;
        var t2MemberKeys = JAM.call(v14499.getAllValueSymbolNames, v14499, [true]).sort();
        if(t1MemberKeys.length != t2MemberKeys.length) {
          this.identicalCache[comboId] = undefined;
          return false
        }
        var t1MemberSymbol = null;
        var t2MemberSymbol = null;
        var t1MemberType = null;
        var t2MemberType = null;
        var iMember$$1 = 0;
        var v5017 = iMember$$1 < t1MemberKeys.length;
        for(;v5017;) {
          introspect(JAM.policy.p1) {
            var v14503 = t1MemberKeys[iMember$$1]
          }
          introspect(JAM.policy.p1) {
            var v14504 = t2MemberKeys[iMember$$1]
          }
          if(v14503 != v14504) {
            this.identicalCache[comboId] = undefined;
            return false
          }
          var v5008 = t1$$1.memberScope;
          introspect(JAM.policy.p1) {
            var v5009 = t1MemberKeys[iMember$$1]
          }
          t1MemberSymbol = JAM.call(v5008.find, v5008, [v5009, false, false]);
          var v5010 = t2$$1.memberScope;
          introspect(JAM.policy.p1) {
            var v5011 = t2MemberKeys[iMember$$1]
          }
          t2MemberSymbol = JAM.call(v5010.find, v5010, [v5011, false, false]);
          if((t1MemberSymbol.flags & TypeScript$$23.SymbolFlags.Optional) != (t2MemberSymbol.flags & TypeScript$$23.SymbolFlags.Optional)) {
            this.identicalCache[comboId] = undefined;
            return false
          }
          t1MemberType = t1MemberSymbol.getType();
          t2MemberType = t2MemberSymbol.getType();
          var v14507 = t1MemberType;
          if(v14507) {
            var v20114 = t2MemberType;
            if(v20114) {
              var v25082 = this.identicalCache;
              var v25083 = t2MemberType.typeID << 16 | t1MemberType.typeID;
              introspect(JAM.policy.p1) {
                var v23483 = v25082[v25083]
              }
              v20114 = v23483 != undefined
            }
            v14507 = v20114
          }
          if(v14507) {
            iMember$$1 = iMember$$1 + 1;
            v5017 = iMember$$1 < t1MemberKeys.length;
            continue
          }
          if(!JAM.call(this.typesAreIdentical, this, [t1MemberType, t2MemberType])) {
            this.identicalCache[comboId] = undefined;
            return false
          }
          iMember$$1 = iMember$$1 + 1;
          v5017 = iMember$$1 < t1MemberKeys.length
        }
      }else {
        var v14511 = t1$$1.memberScope;
        if(!v14511) {
          v14511 = t2$$1.memberScope
        }
        if(v14511) {
          this.identicalCache[comboId] = undefined;
          return false
        }
      }
      if(!JAM.call(this.signatureGroupsAreIdentical, this, [t1$$1.call, t2$$1.call])) {
        this.identicalCache[comboId] = undefined;
        return false
      }
      if(!JAM.call(this.signatureGroupsAreIdentical, this, [t1$$1.construct, t2$$1.construct])) {
        this.identicalCache[comboId] = undefined;
        return false
      }
      if(!JAM.call(this.signatureGroupsAreIdentical, this, [t1$$1.index, t2$$1.index])) {
        this.identicalCache[comboId] = undefined;
        return false
      }
      this.identicalCache[comboId] = true;
      return true
    }
    function v950(initialType, targetType$$4, collection$$1, acceptVoid, comparisonInfo$$2) {
      var i$$82 = 0;
      var len$$28 = collection$$1.getLength();
      var nlastChecked = 0;
      var bestCommonType = initialType;
      if(targetType$$4) {
        var v5028;
        if(bestCommonType) {
          v5028 = JAM.call(bestCommonType.mergeOrdered, bestCommonType, [targetType$$4, this, acceptVoid])
        }else {
          v5028 = targetType$$4
        }
        bestCommonType = v5028
      }
      var convergenceType = bestCommonType;
      var v5035 = nlastChecked < len$$28;
      for(;v5035;) {
        i$$82 = 0;
        var v5032 = i$$82 < len$$28;
        for(;v5032;) {
          if(i$$82 == nlastChecked) {
            i$$82 = i$$82 + 1;
            v5032 = i$$82 < len$$28;
            continue
          }
          var v14515 = convergenceType;
          if(v14515) {
            v14515 = bestCommonType = JAM.call(convergenceType.mergeOrdered, convergenceType, [JAM.call(collection$$1.getTypeAtIndex, collection$$1, [i$$82]), this, acceptVoid, comparisonInfo$$2])
          }
          if(v14515) {
            convergenceType = bestCommonType
          }
          var v14516 = bestCommonType == this.anyType;
          if(!v14516) {
            v14516 = bestCommonType == null
          }
          if(v14516) {
            break
          }else {
            if(targetType$$4) {
              JAM.call(collection$$1.setTypeAtIndex, collection$$1, [i$$82, targetType$$4])
            }
          }
          i$$82 = i$$82 + 1;
          v5032 = i$$82 < len$$28
        }
        if(convergenceType && bestCommonType) {
          break
        }
        nlastChecked = nlastChecked + 1;
        if(nlastChecked < len$$28) {
          convergenceType = JAM.call(collection$$1.getTypeAtIndex, collection$$1, [nlastChecked])
        }
        v5035 = nlastChecked < len$$28
      }
      var v5036;
      if(acceptVoid) {
        v5036 = bestCommonType
      }else {
        var v14517;
        if(bestCommonType == this.voidType) {
          v14517 = null
        }else {
          v14517 = bestCommonType
        }
        v5036 = v14517
      }
      return v5036
    }
    function v949(t$$1) {
      var v5037 = t$$1 == this.undefinedType;
      if(!v5037) {
        v5037 = t$$1 == this.nullType
      }
      return v5037
    }
    function v948(t) {
      var v14521 = t == this.undefinedType;
      if(!v14521) {
        v14521 = t == this.nullType
      }
      if(v14521) {
        return this.anyType
      }
      return t
    }
    function v947(targetType$$3, objectLit$$1) {
      if(targetType$$3 == this.typeFlow.objectInterfaceType) {
        return true
      }
      var memberDecls = objectLit$$1.operand;
      var v20130 = memberDecls;
      if(v20130) {
        v20130 = targetType$$3.memberScope
      }
      if(!v20130) {
        return false
      }
      var id$$19 = null;
      var targetMember = null;
      var text$$23 = "";
      var foundSyms = {};
      var i$$81 = 0;
      var v5047 = i$$81 < memberDecls.members.length;
      for(;v5047;) {
        var v14525 = memberDecls.members;
        introspect(JAM.policy.p1) {
          var v5041 = v14525[i$$81]
        }
        id$$19 = v5041.operand1;
        if(id$$19.nodeType == TypeScript$$23.NodeType.Name) {
          text$$23 = id$$19.text
        }else {
          if(id$$19.nodeType == TypeScript$$23.NodeType.QString) {
            var idText$$3 = id$$19.text;
            text$$23 = JAM.call(idText$$3.substring, idText$$3, [1, idText$$3.length - 1])
          }else {
            return false
          }
        }
        var v5045 = targetType$$3.memberScope;
        targetMember = JAM.call(v5045.find, v5045, [text$$23, true, false]);
        if(!targetMember) {
          return false
        }
        JAM.set(foundSyms, text$$23, true);
        i$$81 = i$$81 + 1;
        v5047 = i$$81 < memberDecls.members.length
      }
      var v5048 = targetType$$3.memberScope;
      var targetMembers = JAM.call(v5048.getAllValueSymbolNames, v5048, [true]);
      i$$81 = 0;
      var v5051 = i$$81 < targetMembers.length;
      for(;v5051;) {
        introspect(JAM.policy.p1) {
          var memberName$$2 = targetMembers[i$$81]
        }
        var v5049 = targetType$$3.memberScope;
        var memberSym = JAM.call(v5049.find, v5049, [memberName$$2, true, false]);
        introspect(JAM.policy.p1) {
          var v23485 = targetMembers[i$$81]
        }
        introspect(JAM.policy.p1) {
          var v20135 = foundSyms[v23485]
        }
        var v14533 = !v20135;
        if(v14533) {
          v14533 = !JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [memberSym.flags, TypeScript$$23.SymbolFlags.Optional])
        }
        if(v14533) {
          return false
        }
        i$$81 = i$$81 + 1;
        v5051 = i$$81 < targetMembers.length
      }
      return true
    }
    function v946(candidateType, funcDecl$$21, beStringent) {
      var v14535 = funcDecl$$21.isParenthesized;
      if(!v14535) {
        var v20137 = funcDecl$$21.isMethod();
        if(!v20137) {
          var v25085 = beStringent;
          if(v25085) {
            v25085 = funcDecl$$21.returnTypeAnnotation
          }
          var v23488 = v25085;
          if(!v23488) {
            v23488 = funcDecl$$21.isInlineCallLiteral
          }
          v20137 = v23488
        }
        v14535 = v20137
      }
      if(v14535) {
        return false
      }
      var v5053 = beStringent;
      if(!v5053) {
        v5053 = this.typeFlow.functionInterfaceType == candidateType
      }
      beStringent = v5053;
      if(!beStringent) {
        return true
      }
      if(!funcDecl$$21.signature) {
        JAM.call(this.createFunctionSignature, this, [funcDecl$$21, this.typeFlow.scope.container, this.typeFlow.scope, null, null]);
        var v5057 = this.typeFlow;
        JAM.call(v5057.typeCheck, v5057, [funcDecl$$21])
      }
      var signature$$5 = funcDecl$$21.signature;
      var paramLen$$2 = signature$$5.parameters.length;
      var i$$80 = 0;
      var v5062 = i$$80 < paramLen$$2;
      for(;v5062;) {
        var v5060 = signature$$5.parameters;
        introspect(JAM.policy.p1) {
          var param$$6 = v5060[i$$80]
        }
        var symbol$$13 = param$$6;
        var argDecl = symbol$$13.declAST;
        var v14541 = beStringent;
        if(v14541) {
          v14541 = argDecl.typeExpr
        }
        if(v14541) {
          return false
        }
        i$$80 = i$$80 + 1;
        v5062 = i$$80 < paramLen$$2
      }
      var v14542 = candidateType.construct;
      if(v14542) {
        v14542 = candidateType.call
      }
      if(v14542) {
        return false
      }
      var v5064;
      if(candidateType.construct) {
        v5064 = candidateType.construct
      }else {
        v5064 = candidateType.call
      }
      var candidateSigs = v5064;
      var v14544 = !candidateSigs;
      if(!v14544) {
        v14544 = candidateSigs.signatures.length > 1
      }
      if(v14544) {
        return false
      }
      return true
    }
    function v945(signatures$$3, args$$13, comparisonInfo$$1) {
      var applicableSigs = [];
      var memberType = null;
      var miss = false;
      var cxt = null;
      var hadProvisionalErrors = false;
      var i$$79 = 0;
      var v5093 = i$$79 < signatures$$3.length;
      for(;v5093;) {
        miss = false;
        var j$$10 = 0;
        var v5090 = j$$10 < args$$13.members.length;
        for(;v5090;) {
          introspect(JAM.policy.p1) {
            var v23491 = signatures$$3[i$$79]
          }
          if(j$$10 >= v23491.parameters.length) {
            j$$10 = j$$10 + 1;
            v5090 = j$$10 < args$$13.members.length;
            continue
          }
          introspect(JAM.policy.p1) {
            var v20146 = signatures$$3[i$$79]
          }
          var v14549 = v20146.parameters;
          introspect(JAM.policy.p1) {
            var v5067 = v14549[j$$10]
          }
          memberType = v5067.getType();
          introspect(JAM.policy.p1) {
            var v23492 = signatures$$3[i$$79]
          }
          var v14550 = v23492.declAST.variableArgList;
          if(v14550) {
            introspect(JAM.policy.p1) {
              var v25904 = signatures$$3[i$$79]
            }
            var v20148 = j$$10 >= v25904.nonOptionalParameterCount - 1;
            if(v20148) {
              v20148 = memberType.isArray()
            }
            v14550 = v20148
          }
          if(v14550) {
            memberType = memberType.elementType
          }
          if(memberType == this.anyType) {
          }else {
            var v23494 = args$$13.members;
            introspect(JAM.policy.p1) {
              var v20149 = v23494[j$$10]
            }
            if(v20149.nodeType == TypeScript$$23.NodeType.FuncDecl) {
              var v14554 = this.typeFlow.functionInterfaceType;
              if(v14554) {
                v14554 = memberType == this.typeFlow.functionInterfaceType
              }
              if(v14554) {
                j$$10 = j$$10 + 1;
                v5090 = j$$10 < args$$13.members.length;
                continue
              }
              var v23496 = args$$13.members;
              introspect(JAM.policy.p1) {
                var v20154 = v23496[j$$10]
              }
              if(!JAM.call(this.canContextuallyTypeFunction, this, [memberType, v20154, true])) {
                var v20155 = args$$13.members;
                introspect(JAM.policy.p1) {
                  var v14557 = v20155[j$$10]
                }
                if(JAM.call(this.canContextuallyTypeFunction, this, [memberType, v14557, false])) {
                  var v5070 = this.typeFlow;
                  var v14558 = args$$13.members;
                  introspect(JAM.policy.p1) {
                    var v5071 = v14558[j$$10]
                  }
                  JAM.call(v5070.typeCheck, v5070, [v5071]);
                  var v25088 = args$$13.members;
                  introspect(JAM.policy.p1) {
                    var v23497 = v25088[j$$10]
                  }
                  if(!JAM.call(this.sourceIsAssignableToTarget, this, [v23497.type, memberType, comparisonInfo$$1])) {
                    break
                  }
                }else {
                  break
                }
              }else {
                var v14560 = args$$13.members;
                introspect(JAM.policy.p1) {
                  var v5074 = v14560[j$$10]
                }
                JAM.call(this.typeCheckWithContextualType, this, [memberType, true, true, v5074]);
                this.cleanStartedPTO();
                hadProvisionalErrors = this.hadProvisionalErrors();
                var v25089 = args$$13.members;
                introspect(JAM.policy.p1) {
                  var v23498 = v25089[j$$10]
                }
                if(!JAM.call(this.sourceIsAssignableToTarget, this, [v23498.type, memberType, comparisonInfo$$1])) {
                  if(comparisonInfo$$1) {
                    var v20158 = "Could not apply type '" + memberType.getTypeName() + "' to argument " + (j$$10 + 1) + ", which is of type '";
                    var v25906 = args$$13.members;
                    introspect(JAM.policy.p1) {
                      var v25092 = v25906[j$$10]
                    }
                    JAM.call(comparisonInfo$$1.setMessage, comparisonInfo$$1, [v20158 + v25092.type.getTypeName() + "'"])
                  }
                  miss = true
                }
                this.resetProvisionalErrors();
                if(miss) {
                  break
                }
              }
            }else {
              var v23501 = args$$13.members;
              introspect(JAM.policy.p1) {
                var v20160 = v23501[j$$10]
              }
              if(v20160.nodeType == TypeScript$$23.NodeType.ObjectLit) {
                var v14565 = this.typeFlow.objectInterfaceType;
                if(v14565) {
                  v14565 = memberType == this.typeFlow.objectInterfaceType
                }
                if(v14565) {
                  j$$10 = j$$10 + 1;
                  v5090 = j$$10 < args$$13.members.length;
                  continue
                }
                var v14567 = args$$13.members;
                introspect(JAM.policy.p1) {
                  var v5079 = v14567[j$$10]
                }
                JAM.call(this.typeCheckWithContextualType, this, [memberType, true, true, v5079]);
                this.cleanStartedPTO();
                hadProvisionalErrors = this.hadProvisionalErrors();
                var v25093 = args$$13.members;
                introspect(JAM.policy.p1) {
                  var v23503 = v25093[j$$10]
                }
                if(!JAM.call(this.sourceIsAssignableToTarget, this, [v23503.type, memberType, comparisonInfo$$1])) {
                  if(comparisonInfo$$1) {
                    var v20166 = "Could not apply type '" + memberType.getTypeName() + "' to argument " + (j$$10 + 1) + ", which is of type '";
                    var v25908 = args$$13.members;
                    introspect(JAM.policy.p1) {
                      var v25096 = v25908[j$$10]
                    }
                    JAM.call(comparisonInfo$$1.setMessage, comparisonInfo$$1, [v20166 + v25096.type.getTypeName() + "'"])
                  }
                  miss = true
                }
                this.resetProvisionalErrors();
                if(miss) {
                  break
                }
              }else {
                var v23506 = args$$13.members;
                introspect(JAM.policy.p1) {
                  var v20168 = v23506[j$$10]
                }
                if(v20168.nodeType == TypeScript$$23.NodeType.ArrayLit) {
                  var v14572 = this.typeFlow.arrayInterfaceType;
                  if(v14572) {
                    v14572 = memberType == this.typeFlow.arrayInterfaceType
                  }
                  if(v14572) {
                    j$$10 = j$$10 + 1;
                    v5090 = j$$10 < args$$13.members.length;
                    continue
                  }
                  var v14574 = args$$13.members;
                  introspect(JAM.policy.p1) {
                    var v5083 = v14574[j$$10]
                  }
                  JAM.call(this.typeCheckWithContextualType, this, [memberType, true, true, v5083]);
                  this.cleanStartedPTO();
                  hadProvisionalErrors = this.hadProvisionalErrors();
                  var v25097 = args$$13.members;
                  introspect(JAM.policy.p1) {
                    var v23508 = v25097[j$$10]
                  }
                  if(!JAM.call(this.sourceIsAssignableToTarget, this, [v23508.type, memberType, comparisonInfo$$1])) {
                    if(comparisonInfo$$1) {
                      var v20174 = "Could not apply type '" + memberType.getTypeName() + "' to argument " + (j$$10 + 1) + ", which is of type '";
                      var v25910 = args$$13.members;
                      introspect(JAM.policy.p1) {
                        var v25100 = v25910[j$$10]
                      }
                      JAM.call(comparisonInfo$$1.setMessage, comparisonInfo$$1, [v20174 + v25100.type.getTypeName() + "'"])
                    }
                    break
                  }
                  this.resetProvisionalErrors();
                  if(miss) {
                    break
                  }
                }
              }
            }
          }
          j$$10 = j$$10 + 1;
          v5090 = j$$10 < args$$13.members.length
        }
        if(j$$10 == args$$13.members.length) {
          var v5091 = applicableSigs.length;
          introspect(JAM.policy.p1) {
            var v14579 = signatures$$3[i$$79]
          }
          applicableSigs[v5091] = {signature:v14579, hadProvisionalErrors:hadProvisionalErrors}
        }
        hadProvisionalErrors = false;
        i$$79 = i$$79 + 1;
        v5093 = i$$79 < signatures$$3.length
      }
      return applicableSigs
    }
    function v944(signatures$$2, args$$12) {
      function v943(index$$51) {
        var v5094;
        if(index$$51) {
          v5094 = Q.signature.returnType.type
        }else {
          v5094 = best.signature.returnType.type
        }
        return v5094
      }
      function v942(index$$50, type$$43) {
        return
      }
      function v941() {
        return 2
      }
      if(signatures$$2.length == 1) {
        return{sig:signatures$$2[0].signature, ambiguous:false}
      }
      var best = signatures$$2[0];
      var Q = null;
      var AType = null;
      var PType = null;
      var QType = null;
      var ambiguous = false;
      var qSig = 1;
      var v5110 = qSig < signatures$$2.length;
      for(;v5110;) {
        Q = signatures$$2[qSig];
        var i$$78 = 0;
        i$$78 = 0;
        var v14586 = args$$12;
        if(v14586) {
          v14586 = i$$78 < args$$12.members.length
        }
        var v5107 = v14586;
        for(;v5107;) {
          var v14587 = args$$12.members;
          introspect(JAM.policy.p1) {
            var v5097 = v14587[i$$78]
          }
          AType = v5097.type;
          var v5098;
          if(i$$78 < best.signature.parameters.length) {
            var v20182 = best.signature.parameters;
            introspect(JAM.policy.p1) {
              var v14588 = v20182[i$$78]
            }
            v5098 = v14588.getType()
          }else {
            var v23514 = best.signature.parameters;
            var v23515 = best.signature.parameters.length - 1;
            introspect(JAM.policy.p1) {
              var v20183 = v23514[v23515]
            }
            v5098 = v20183.getType().elementType
          }
          PType = v5098;
          var v5099;
          if(i$$78 < Q.signature.parameters.length) {
            var v20185 = Q.signature.parameters;
            introspect(JAM.policy.p1) {
              var v14591 = v20185[i$$78]
            }
            v5099 = v14591.getType()
          }else {
            var v23518 = Q.signature.parameters;
            var v23519 = Q.signature.parameters.length - 1;
            introspect(JAM.policy.p1) {
              var v20186 = v23518[v23519]
            }
            v5099 = v20186.getType().elementType
          }
          QType = v5099;
          if(JAM.call(this.typesAreIdentical, this, [PType, QType])) {
          }else {
            if(JAM.call(this.typesAreIdentical, this, [AType, PType])) {
              break
            }else {
              if(JAM.call(this.typesAreIdentical, this, [AType, QType])) {
                best = Q;
                break
              }else {
                if(JAM.call(this.sourceIsSubtypeOfTarget, this, [PType, QType])) {
                  break
                }else {
                  if(JAM.call(this.sourceIsSubtypeOfTarget, this, [QType, PType])) {
                    best = Q;
                    break
                  }else {
                    if(Q.hadProvisionalErrors) {
                      break
                    }else {
                      if(best.hadProvisionalErrors) {
                        best = Q;
                        break
                      }
                    }
                  }
                }
              }
            }
          }
          i$$78 = i$$78 + 1;
          var v14594 = args$$12;
          if(v14594) {
            v14594 = i$$78 < args$$12.members.length
          }
          v5107 = v14594
        }
        var v14595 = !args$$12;
        if(!v14595) {
          v14595 = i$$78 == args$$12.members.length
        }
        if(v14595) {
          var collection = {getLength:v941, setTypeAtIndex:v942, getTypeAtIndex:v943};
          var bct = JAM.call(this.findBestCommonType, this, [best.signature.returnType.type, null, collection, true]);
          ambiguous = !bct
        }else {
          ambiguous = false
        }
        qSig = qSig + 1;
        v5110 = qSig < signatures$$2.length
      }
      return{sig:best.signature, ambiguous:ambiguous}
    }
    function v940(typeLink$$2, scope$$28) {
      this.resolvingBases = true;
      JAM.call(this.resolveTypeLink, this, [scope$$28, typeLink$$2, true]);
      this.resolvingBases = false;
      var extendsType = null;
      if(typeLink$$2.type.isClass()) {
        extendsType = typeLink$$2.type.instanceType
      }else {
        extendsType = typeLink$$2.type
      }
      return extendsType
    }
    function v939(scope$$27, typeLink$$1, supplyVar$$1) {
      var arrayCount$$1 = 0;
      if(typeLink$$1.type == null) {
        var ast$$64 = typeLink$$1.ast;
        if(ast$$64) {
          var v5150 = typeLink$$1.type == null;
          for(;v5150;) {
            switch(ast$$64.nodeType) {
              case TypeScript$$23.NodeType.Name:
                var identifier$$2 = ast$$64;
                var symbol$$12 = JAM.call(scope$$27.find, scope$$27, [identifier$$2.text, false, true]);
                if(symbol$$12 == null) {
                  typeLink$$1.type = this.anyType;
                  var v5115 = this.errorReporter;
                  JAM.call(v5115.unresolvedSymbol, v5115, [identifier$$2, identifier$$2.actualText])
                }else {
                  if(symbol$$12.isType()) {
                    if(!JAM.call(symbol$$12.visible, symbol$$12, [scope$$27, this])) {
                      var v5117 = this.errorReporter;
                      JAM.call(v5117.simpleError, v5117, [ast$$64, "The symbol '" + identifier$$2.actualText + "' is not visible at this point"])
                    }
                    identifier$$2.sym = symbol$$12;
                    var v5120 = typeLink$$1;
                    var v26941 = symbol$$12.getType();
                    v5120.type = v26941;
                    if(typeLink$$1.type) {
                      if(typeLink$$1.type.isClass()) {
                        typeLink$$1.type = typeLink$$1.type.instanceType
                      }
                    }else {
                      typeLink$$1.type = this.anyType
                    }
                  }else {
                    typeLink$$1.type = this.anyType;
                    var v5124 = this.errorReporter;
                    JAM.call(v5124.simpleError, v5124, [ast$$64, "Expected type"])
                  }
                }
                break;
              case TypeScript$$23.NodeType.Dot:
                var v5127 = typeLink$$1;
                var v26942 = JAM.call(this.resolveTypeMember, this, [scope$$27, ast$$64]);
                v5127.type = v26942;
                break;
              case TypeScript$$23.NodeType.TypeRef:
                var typeRef$$2 = ast$$64;
                arrayCount$$1 = typeRef$$2.arrayCount;
                ast$$64 = typeRef$$2.term;
                if(ast$$64 == null) {
                  typeLink$$1.type = this.anyType
                }
                break;
              case TypeScript$$23.NodeType.InterfaceDeclaration:
                var interfaceDecl$$3 = ast$$64;
                var interfaceType$$1 = new TypeScript$$23.Type;
                var interfaceSymbol = JAM.new(TypeScript$$23.TypeSymbol, [interfaceDecl$$3.name.text, ast$$64.minChar, ast$$64.limChar - ast$$64.minChar, this.locationInfo.unitIndex, interfaceType$$1]);
                interfaceType$$1.symbol = interfaceSymbol;
                var v5135 = interfaceType$$1;
                var v26943 = JAM.new(TypeScript$$23.ScopedMembers, [JAM.new(TypeScript$$23.DualStringHashTable, [new TypeScript$$23.StringHashTable, new TypeScript$$23.StringHashTable])]);
                v5135.members = v26943;
                var v5136 = interfaceType$$1;
                var v26944 = JAM.new(TypeScript$$23.SymbolTableScope, [interfaceType$$1.members, null, null, null, interfaceSymbol]);
                v5136.containedScope = v26944;
                interfaceType$$1.containedScope.container = interfaceSymbol;
                interfaceType$$1.memberScope = interfaceType$$1.containedScope;
                var memberList = interfaceDecl$$3.members;
                var props$$1 = memberList.members;
                var propsLen = props$$1.length;
                var j$$9 = 0;
                var v5147 = j$$9 < propsLen;
                for(;v5147;) {
                  introspect(JAM.policy.p1) {
                    var propDecl = props$$1[j$$9]
                  }
                  var propSym = null;
                  var addMember = true;
                  var id$$18 = null;
                  if(propDecl.nodeType == TypeScript$$23.NodeType.FuncDecl) {
                    var funcDecl$$20 = propDecl;
                    id$$18 = funcDecl$$20.name;
                    var v5138 = interfaceType$$1.members.allMembers;
                    propSym = JAM.call(v5138.lookup, v5138, [funcDecl$$20.getNameText()]);
                    addMember = propSym == null;
                    if(funcDecl$$20.isSpecialFn()) {
                      addMember = false;
                      propSym = JAM.call(this.resolveFuncDecl, this, [funcDecl$$20, scope$$27, interfaceSymbol])
                    }else {
                      propSym = JAM.call(this.resolveFuncDecl, this, [funcDecl$$20, scope$$27, propSym])
                    }
                    funcDecl$$20.type = propSym.type
                  }else {
                    id$$18 = propDecl.id;
                    propSym = JAM.call(this.resolveVarDecl, this, [propDecl, scope$$27]);
                    addMember = !id$$18.isMissing()
                  }
                  if(addMember) {
                    var v14615 = id$$18;
                    if(v14615) {
                      v14615 = JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [id$$18.flags, TypeScript$$23.ASTFlags.OptionalName])
                    }
                    if(v14615) {
                      propSym.flags = propSym.flags | TypeScript$$23.SymbolFlags.Optional
                    }
                    var v20199 = interfaceType$$1.members.allMembers;
                    if(!JAM.call(v20199.add, v20199, [propSym.name, propSym])) {
                      var v5144 = this.errorReporter;
                      JAM.call(v5144.duplicateIdentifier, v5144, [ast$$64, propSym.name])
                    }
                  }
                  j$$9 = j$$9 + 1;
                  v5147 = j$$9 < propsLen
                }
                ast$$64.type = interfaceType$$1;
                typeLink$$1.type = interfaceType$$1;
                break;
              case TypeScript$$23.NodeType.FuncDecl:
                var tsym = JAM.call(this.resolveFuncDecl, this, [ast$$64, scope$$27, null]);
                typeLink$$1.type = tsym.type;
                break;
              default:
                typeLink$$1.type = this.anyType;
                var v5148 = this.errorReporter;
                JAM.call(v5148.simpleError, v5148, [ast$$64, "Expected type"])
            }
            v5150 = typeLink$$1.type == null
          }
        }
        var count$$8 = arrayCount$$1;
        var v5152 = count$$8 > 0;
        for(;v5152;) {
          var v5151 = typeLink$$1;
          var v26945 = JAM.call(this.makeArrayType, this, [typeLink$$1.type]);
          v5151.type = v26945;
          count$$8 = count$$8 - 1;
          v5152 = count$$8 > 0
        }
        var v14621 = supplyVar$$1;
        if(v14621) {
          v14621 = typeLink$$1.type == null
        }
        if(v14621) {
          typeLink$$1.type = this.anyType
        }
        if(typeLink$$1.ast) {
          typeLink$$1.ast.type = typeLink$$1.type
        }
      }
      return
    }
    function v938(varDecl$$11, scope$$26) {
      var field$$2 = new TypeScript$$23.ValueLocation;
      var fieldSymbol = JAM.new(TypeScript$$23.FieldSymbol, [varDecl$$11.id.text, varDecl$$11.minChar, this.locationInfo.unitIndex, (varDecl$$11.varFlags & TypeScript$$23.VarFlags.Readonly) == TypeScript$$23.VarFlags.None, field$$2]);
      JAM.call(fieldSymbol.transferVarFlags, fieldSymbol, [varDecl$$11.varFlags]);
      field$$2.symbol = fieldSymbol;
      fieldSymbol.declAST = varDecl$$11;
      var v5164 = field$$2;
      var v26946 = JAM.call(TypeScript$$23.getTypeLink, TypeScript$$23, [varDecl$$11.typeExpr, this, varDecl$$11.init == null]);
      v5164.typeLink = v26946;
      JAM.call(this.resolveTypeLink, this, [scope$$26, field$$2.typeLink, true]);
      varDecl$$11.sym = fieldSymbol;
      varDecl$$11.type = field$$2.typeLink.type;
      return fieldSymbol
    }
    function v937(funcDecl$$19, scope$$25, fgSym$$2) {
      var functionGroupSymbol = JAM.call(this.createFunctionSignature, this, [funcDecl$$19, scope$$25.container, scope$$25, fgSym$$2, false]).declAST.type.symbol;
      var signatures$$1;
      if(funcDecl$$19.isConstructMember()) {
        signatures$$1 = functionGroupSymbol.type.construct.signatures
      }else {
        if(funcDecl$$19.isIndexerMember()) {
          signatures$$1 = functionGroupSymbol.type.getInstanceType().index.signatures
        }else {
          signatures$$1 = functionGroupSymbol.type.call.signatures
        }
      }
      var v5173 = signatures$$1.length - 1;
      introspect(JAM.policy.p1) {
        var signature$$4 = signatures$$1[v5173]
      }
      var len$$27 = signature$$4.parameters.length;
      var i$$77 = 0;
      var v5177 = i$$77 < len$$27;
      for(;v5177;) {
        var v5175 = signature$$4.parameters;
        introspect(JAM.policy.p1) {
          var paramSym$$2 = v5175[i$$77]
        }
        JAM.call(this.resolveTypeLink, this, [scope$$25, paramSym$$2.parameter.typeLink, true]);
        i$$77 = i$$77 + 1;
        v5177 = i$$77 < len$$27
      }
      var v14634 = len$$27;
      if(v14634) {
        v14634 = funcDecl$$19.variableArgList
      }
      if(v14634) {
        var v26345 = signature$$4.parameters;
        var v26346 = len$$27 - 1;
        introspect(JAM.policy.p1) {
          var v25913 = v26345[v26346]
        }
        if(!v25913.parameter.typeLink.type.elementType) {
          var v5178 = this.errorReporter;
          var v23529 = signature$$4.parameters;
          var v23530 = len$$27 - 1;
          introspect(JAM.policy.p1) {
            var v20209 = v23529[v23530]
          }
          JAM.call(v5178.simpleErrorFromSym, v5178, [v20209.parameter.symbol, "... parameter must have array type"]);
          var v23531 = signature$$4.parameters;
          var v23532 = len$$27 - 1;
          introspect(JAM.policy.p1) {
            var v20210 = v23531[v23532]
          }
          var v5180 = v20210.parameter.typeLink;
          var v25914 = signature$$4.parameters;
          var v25915 = len$$27 - 1;
          introspect(JAM.policy.p1) {
            var v25108 = v25914[v25915]
          }
          var v26947 = JAM.call(this.makeArrayType, this, [v25108.parameter.typeLink.type]);
          v5180.type = v26947
        }
      }
      JAM.call(this.resolveTypeLink, this, [scope$$25, signature$$4.returnType, funcDecl$$19.isSignature()]);
      return functionGroupSymbol
    }
    function v936(scope$$24, dotNode$$2) {
      function v935(id$$17) {
        return JAM.call(scope$$24.find, scope$$24, [id$$17, false, true])
      }
      var lhs = dotNode$$2.operand1;
      var rhs = dotNode$$2.operand2;
      var resultType = this.anyType;
      var lhsType = this.anyType;
      var v14639 = lhs;
      if(v14639) {
        var v20212 = rhs;
        if(v20212) {
          v20212 = rhs.nodeType == TypeScript$$23.NodeType.Name
        }
        v14639 = v20212
      }
      if(v14639) {
        if(lhs.nodeType == TypeScript$$23.NodeType.Dot) {
          lhsType = JAM.call(this.resolveTypeMember, this, [scope$$24, lhs])
        }else {
          if(lhs.nodeType == TypeScript$$23.NodeType.Name) {
            var identifier$$1 = lhs;
            var symbol$$11 = JAM.call(scope$$24.find, scope$$24, [identifier$$1.text, false, true]);
            if(symbol$$11 == null) {
              var v5186 = this.errorReporter;
              JAM.call(v5186.unresolvedSymbol, v5186, [identifier$$1, identifier$$1.actualText])
            }else {
              if(symbol$$11.isType()) {
                var typeSymbol$$1 = symbol$$11;
                var v14644 = typeSymbol$$1.aliasLink;
                if(v14644) {
                  var v20215 = !typeSymbol$$1.type;
                  if(v20215) {
                    v20215 = typeSymbol$$1.aliasLink.alias.nodeType == TypeScript$$23.NodeType.Name
                  }
                  v14644 = v20215
                }
                if(v14644) {
                  var modPath$$2 = typeSymbol$$1.aliasLink.alias.text;
                  var modSym$$1 = JAM.call(this.findSymbolForDynamicModule, this, [modPath$$2, this.locationInfo.filename, v935]);
                  if(modSym$$1) {
                    var v5190 = typeSymbol$$1;
                    var v26948 = modSym$$1.getType();
                    v5190.type = v26948
                  }
                }
                var v14647 = TypeScript$$23.optimizeModuleCodeGen;
                if(v14647) {
                  v14647 = symbol$$11
                }
                if(v14647) {
                  var symType = symbol$$11.getType();
                  var v14648 = symType;
                  if(v14648) {
                    var v20216 = typeSymbol$$1.aliasLink;
                    if(v20216) {
                      v20216 = typeSymbol$$1.onlyReferencedAsTypeRef
                    }
                    v14648 = v20216
                  }
                  if(v14648) {
                    var modDecl$$1 = symType.symbol.declAST;
                    var v14649 = modDecl$$1;
                    if(v14649) {
                      v14649 = JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [modDecl$$1.modFlags, TypeScript$$23.ModuleFlags.IsDynamic])
                    }
                    if(v14649) {
                      typeSymbol$$1.onlyReferencedAsTypeRef = !this.resolvingBases
                    }
                  }
                }
                if(!JAM.call(symbol$$11.visible, symbol$$11, [scope$$24, this])) {
                  var v5197 = this.errorReporter;
                  JAM.call(v5197.simpleError, v5197, [lhs, "The symbol '" + identifier$$1.actualText + "' is not visible at this point"])
                }
                lhsType = symbol$$11.getType();
                identifier$$1.sym = symbol$$11
              }else {
                var v5200 = this.errorReporter;
                JAM.call(v5200.simpleError, v5200, [lhs, "Expected type"])
              }
            }
          }
        }
        if(!lhsType) {
          lhsType = this.anyType
        }
        if(lhsType != this.anyType) {
          var rhsIdentifier = rhs;
          var resultSymbol = JAM.call(this.lookupMemberTypeSymbol, this, [lhsType, rhsIdentifier.text]);
          if(resultSymbol == null) {
            resultType = this.anyType;
            var v5207 = this.errorReporter;
            JAM.call(v5207.simpleError, v5207, [dotNode$$2, "Expected type"])
          }else {
            resultType = resultSymbol.getType();
            if(!JAM.call(resultSymbol.visible, resultSymbol, [scope$$24, this])) {
              var v5208 = this.errorReporter;
              JAM.call(v5208.simpleError, v5208, [lhs, "The symbol '" + rhs.actualText + "' is not visible at this point"])
            }
          }
          rhsIdentifier.sym = resultType.symbol
        }
      }
      if(resultType.isClass()) {
        resultType = resultType.instanceType
      }
      return resultType
    }
    function v934(idText$$2, currentFileName, search) {
      var originalIdText = idText$$2;
      var symbol$$10 = JAM.call(search, null, [idText$$2]);
      if(symbol$$10 == null) {
        if(!symbol$$10) {
          idText$$2 = JAM.call(TypeScript$$23.swapQuotes, TypeScript$$23, [originalIdText]);
          symbol$$10 = JAM.call(search, null, [idText$$2])
        }
        if(!symbol$$10) {
          idText$$2 = JAM.call(TypeScript$$23.stripQuotes, TypeScript$$23, [originalIdText]) + ".ts";
          symbol$$10 = JAM.call(search, null, [idText$$2])
        }
        if(!symbol$$10) {
          idText$$2 = JAM.call(TypeScript$$23.stripQuotes, TypeScript$$23, [originalIdText]) + ".str";
          symbol$$10 = JAM.call(search, null, [idText$$2])
        }
        if(!symbol$$10) {
          idText$$2 = JAM.call(TypeScript$$23.stripQuotes, TypeScript$$23, [originalIdText]) + ".d.ts";
          symbol$$10 = JAM.call(search, null, [idText$$2])
        }
        if(!symbol$$10) {
          idText$$2 = JAM.call(TypeScript$$23.stripQuotes, TypeScript$$23, [originalIdText]) + ".d.str";
          symbol$$10 = JAM.call(search, null, [idText$$2])
        }
        var v14655 = !symbol$$10;
        if(v14655) {
          v14655 = !JAM.call(TypeScript$$23.isRelative, TypeScript$$23, [originalIdText])
        }
        if(v14655) {
          idText$$2 = originalIdText;
          var strippedIdText = JAM.call(TypeScript$$23.stripQuotes, TypeScript$$23, [idText$$2]);
          var path$$7 = JAM.call(TypeScript$$23.getRootFilePath, TypeScript$$23, [JAM.call(TypeScript$$23.switchToForwardSlashes, TypeScript$$23, [currentFileName])]);
          var v14656 = symbol$$10 == null;
          if(v14656) {
            v14656 = path$$7 != ""
          }
          var v5233 = v14656;
          for(;v5233;) {
            idText$$2 = JAM.call(TypeScript$$23.normalizePath, TypeScript$$23, [path$$7 + strippedIdText + ".ts"]);
            symbol$$10 = JAM.call(search, null, [idText$$2]);
            if(symbol$$10 == null) {
              idText$$2 = JAM.call(TypeScript$$23.changePathToSTR, TypeScript$$23, [idText$$2]);
              symbol$$10 = JAM.call(search, null, [idText$$2])
            }
            if(symbol$$10 == null) {
              idText$$2 = JAM.call(TypeScript$$23.changePathToDTS, TypeScript$$23, [idText$$2]);
              symbol$$10 = JAM.call(search, null, [idText$$2])
            }
            if(symbol$$10 == null) {
              idText$$2 = JAM.call(TypeScript$$23.changePathToDSTR, TypeScript$$23, [idText$$2]);
              symbol$$10 = JAM.call(search, null, [idText$$2])
            }
            if(symbol$$10 == null) {
              if(path$$7 === "/") {
                path$$7 = ""
              }else {
                path$$7 = JAM.call(TypeScript$$23.normalizePath, TypeScript$$23, [path$$7 + ".."]);
                var v5230;
                var v20222 = path$$7;
                if(v20222) {
                  v20222 = path$$7 != "/"
                }
                if(v20222) {
                  v5230 = path$$7 + "/"
                }else {
                  v5230 = path$$7
                }
                path$$7 = v5230
              }
            }
            var v14659 = symbol$$10 == null;
            if(v14659) {
              v14659 = path$$7 != ""
            }
            v5233 = v14659
          }
        }
      }
      return symbol$$10
    }
    function v933(containingType, name$$82) {
      var symbol$$9 = null;
      if(containingType.containedScope) {
        var v5236 = containingType.containedScope;
        symbol$$9 = JAM.call(v5236.find, v5236, [name$$82, false, true])
      }else {
        if(containingType.members) {
          var v5237 = containingType.members.allMembers;
          symbol$$9 = JAM.call(v5237.lookup, v5237, [name$$82]);
          var v14661 = symbol$$9 == null;
          if(v14661) {
            v14661 = containingType.ambientMembers
          }
          if(v14661) {
            var v5238 = containingType.ambientMembers.allMembers;
            symbol$$9 = JAM.call(v5238.lookup, v5238, [name$$82])
          }
        }
      }
      if(symbol$$9 == null) {
        var typeMembers$$1 = containingType.getAllEnclosedTypes();
        var ambientTypeMembers$$1 = containingType.getAllAmbientEnclosedTypes();
        if(typeMembers$$1) {
          var v5242 = typeMembers$$1.allMembers;
          symbol$$9 = JAM.call(v5242.lookup, v5242, [name$$82]);
          var v14663 = symbol$$9 == null;
          if(v14663) {
            v14663 = ambientTypeMembers$$1
          }
          if(v14663) {
            var v5243 = ambientTypeMembers$$1.allMembers;
            symbol$$9 = JAM.call(v5243.lookup, v5243, [name$$82])
          }
        }
      }
      var v14664 = symbol$$9;
      if(v14664) {
        v14664 = symbol$$9.isType()
      }
      if(v14664) {
        return symbol$$9
      }else {
        return null
      }
      return
    }
    function v932(type$$42) {
      var resultScope$$1 = JAM.new(TypeScript$$23.SymbolAggregateScope, [type$$42.symbol]);
      var v14665;
      var v23540 = type$$42.symbol;
      if(v23540) {
        v23540 = type$$42.symbol.name
      }
      if(v23540) {
        v14665 = type$$42.symbol.name
      }else {
        v14665 = "{}"
      }
      var baseContext$$1 = {base:v14665, baseId:type$$42.typeID};
      JAM.call(this.addBases, this, [resultScope$$1, type$$42, baseContext$$1]);
      return resultScope$$1
    }
    function v931(resultScope, type$$41, baseContext) {
      JAM.call(resultScope.addParentScope, resultScope, [JAM.new(TypeScript$$23.SymbolTableScope, [type$$41.members, type$$41.ambientMembers, type$$41.getAllEnclosedTypes(), type$$41.getAllAmbientEnclosedTypes(), type$$41.symbol])]);
      var i$$76 = 0;
      var parent$$52;
      if(type$$41.extendsList) {
        var len$$26 = type$$41.extendsList.length;
        var v5259 = i$$76 < len$$26;
        for(;v5259;) {
          parent$$52 = type$$41.extendsList[i$$76];
          if(baseContext.baseId == parent$$52.typeID) {
            var v5254 = this.errorReporter;
            JAM.call(v5254.reportErrorFromSym, v5254, [parent$$52.symbol, "Type '" + baseContext.base + "' is recursively referenced as a base class of itself"]);
            var v5257 = parent$$52.symbol;
            v5257.flags = v5257.flags | TypeScript$$23.SymbolFlags.RecursivelyReferenced;
            break
          }
          JAM.call(this.addBases, this, [resultScope, parent$$52, baseContext]);
          i$$76 = i$$76 + 1;
          v5259 = i$$76 < len$$26
        }
      }
      return
    }
    function v930(funcDecl$$18, fgSym$$1, enclosingClass, addToMembers, isClassProperty, scope$$23, container$$13) {
      var accessorSym = null;
      var sig = funcDecl$$18.signature;
      var nameText$$2 = funcDecl$$18.name.text;
      var isStatic$$7 = JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [funcDecl$$18.fncFlags, TypeScript$$23.FncFlags.Static]);
      var isPrivate$$1 = JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [funcDecl$$18.fncFlags, TypeScript$$23.FncFlags.Private]);
      if(fgSym$$1 == null) {
        var field$$1 = new TypeScript$$23.ValueLocation;
        accessorSym = JAM.new(TypeScript$$23.FieldSymbol, [nameText$$2, funcDecl$$18.minChar, this.locationInfo.unitIndex, false, field$$1]);
        field$$1.symbol = accessorSym;
        accessorSym.declAST = funcDecl$$18;
        if(JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [funcDecl$$18.fncFlags, TypeScript$$23.FncFlags.GetAccessor])) {
          if(accessorSym.getter) {
            var v5270 = this.errorReporter;
            JAM.call(v5270.simpleError, v5270, [funcDecl$$18, "Redeclaration of property getter"])
          }
          accessorSym.getter = sig.declAST.type.symbol
        }else {
          if(accessorSym.setter) {
            var v5273 = this.errorReporter;
            JAM.call(v5273.simpleError, v5273, [funcDecl$$18, "Redeclaration of property setter"])
          }
          accessorSym.setter = sig.declAST.type.symbol
        }
        var v5277 = field$$1;
        var v26949 = JAM.call(TypeScript$$23.getTypeLink, TypeScript$$23, [null, this, false]);
        v5277.typeLink = v26949;
        if(addToMembers) {
          if(enclosingClass) {
            var v20229 = enclosingClass.members.publicMembers;
            if(!JAM.call(v20229.add, v20229, [nameText$$2, accessorSym])) {
              var v5278 = this.errorReporter;
              JAM.call(v5278.duplicateIdentifier, v5278, [funcDecl$$18, accessorSym.name])
            }
            accessorSym.container = enclosingClass.symbol
          }else {
            var v5281 = this.errorReporter;
            JAM.call(v5281.simpleError, v5281, [funcDecl$$18, "Accessor property may not be added in this context"])
          }
        }else {
          var v5282 = this.errorReporter;
          var v14683 = !isPrivate$$1;
          if(!v14683) {
            v14683 = isStatic$$7
          }
          JAM.call(scope$$23.enter, scope$$23, [container$$13, funcDecl$$18, accessorSym, v5282, v14683, false, false])
        }
        if(isClassProperty) {
          accessorSym.flags = accessorSym.flags | TypeScript$$23.SymbolFlags.Property
        }
        if(isStatic$$7) {
          accessorSym.flags = accessorSym.flags | TypeScript$$23.SymbolFlags.Static
        }
        if(isPrivate$$1) {
          accessorSym.flags = accessorSym.flags | TypeScript$$23.SymbolFlags.Private
        }else {
          accessorSym.flags = accessorSym.flags | TypeScript$$23.SymbolFlags.Public
        }
      }else {
        accessorSym = fgSym$$1;
        if(isPrivate$$1 != JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [accessorSym.flags, TypeScript$$23.SymbolFlags.Private])) {
          var v5284 = this.errorReporter;
          JAM.call(v5284.simpleError, v5284, [funcDecl$$18, "Getter and setter accessors do not agree in visibility"])
        }
        if(JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [funcDecl$$18.fncFlags, TypeScript$$23.FncFlags.GetAccessor])) {
          if(accessorSym.getter) {
            var v5286 = this.errorReporter;
            JAM.call(v5286.simpleError, v5286, [funcDecl$$18, "Redeclaration of property getter"])
          }
          accessorSym.getter = funcDecl$$18.type.symbol
        }else {
          if(accessorSym.setter) {
            var v5289 = this.errorReporter;
            JAM.call(v5289.simpleError, v5289, [funcDecl$$18, "Redeclaration of property setter"])
          }
          accessorSym.setter = funcDecl$$18.type.symbol
        }
      }
      return accessorSym
    }
    function v929(funcDecl$$17, container$$12, scope$$22, overloadGroupSym, addToScope) {
      var v5294 = JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [funcDecl$$17.fncFlags, TypeScript$$23.FncFlags.Exported | TypeScript$$23.FncFlags.ClassPropertyMethodExported]);
      if(!v5294) {
        v5294 = container$$12 == this.gloMod
      }
      var isExported$$1 = v5294;
      var isStatic$$6 = JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [funcDecl$$17.fncFlags, TypeScript$$23.FncFlags.Static]);
      var isPrivate = JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [funcDecl$$17.fncFlags, TypeScript$$23.FncFlags.Private]);
      var isDefinition = JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [funcDecl$$17.fncFlags, TypeScript$$23.FncFlags.Definition]);
      var isAmbient$$4 = JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [funcDecl$$17.fncFlags, TypeScript$$23.FncFlags.Ambient]);
      var v5303 = funcDecl$$17.isConstructMember();
      if(!v5303) {
        v5303 = funcDecl$$17.isConstructor
      }
      var isConstructor$$2 = v5303;
      var isGlobal = container$$12 == this.gloMod;
      var signature$$3 = new TypeScript$$23.Signature;
      var isLambda$$2 = funcDecl$$17.fncFlags & TypeScript$$23.FncFlags.IsFunctionExpression;
      var v14706 = funcDecl$$17.returnTypeAnnotation;
      if(!v14706) {
        v14706 = isDefinition
      }
      if(v14706) {
        var v5308 = signature$$3;
        var v26950 = JAM.call(TypeScript$$23.getTypeLink, TypeScript$$23, [funcDecl$$17.returnTypeAnnotation, this, false]);
        v5308.returnType = v26950
      }else {
        var v5309 = signature$$3;
        var v26951 = new TypeScript$$23.TypeLink;
        v5309.returnType = v26951;
        signature$$3.returnType.type = this.anyType
      }
      signature$$3.hasVariableArgList = funcDecl$$17.variableArgList;
      var sigData = JAM.call(this.getParameterList, this, [funcDecl$$17, container$$12]);
      signature$$3.parameters = sigData.parameters;
      signature$$3.nonOptionalParameterCount = sigData.nonOptionalParameterCount;
      funcDecl$$17.signature = signature$$3;
      signature$$3.declAST = funcDecl$$17;
      var v5312 = overloadGroupSym;
      if(v5312) {
        var v14709 = overloadGroupSym.getType();
        if(v14709) {
          var v20241 = !overloadGroupSym.isAccessor();
          if(v20241) {
            var v23547 = funcDecl$$17.isSignature();
            if(!v23547) {
              v23547 = isAmbient$$4 == JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [overloadGroupSym.flags, TypeScript$$23.SymbolFlags.Ambient])
            }
            v20241 = v23547
          }
          v14709 = v20241
        }
        v5312 = v14709
      }
      var useOverloadGroupSym = v5312;
      var v14710 = useOverloadGroupSym;
      if(v14710) {
        v14710 = isPrivate != JAM.call(TypeScript$$23.hasFlag, TypeScript$$23, [overloadGroupSym.flags, TypeScript$$23.SymbolFlags.Private])
      }
      if(v14710) {
        var v5313 = this.errorReporter;
        JAM.call(v5313.simpleError, v5313, [funcDecl$$17, "Public/Private visibility of overloads does not agree"])
      }
      var v5315;
      if(useOverloadGroupSym) {
        v5315 = overloadGroupSym.getType()
      }else {
        v5315 = new TypeScript$$23.Type
      }
      var groupType = v5315;
      if(isConstructor$$2) {
        if(groupType.construct == null) {
          var v5316 = groupType;
          var v26952 = new TypeScript$$23.SignatureGroup;
          v5316.construct = v26952
        }
        var v5318 = groupType.construct;
        JAM.call(v5318.addSignature, v5318, [signature$$3]);
        groupType.construct.hasImplementation = !funcDecl$$17.isSignature();
        if(groupType.construct.hasImplementation) {
          groupType.setHasImplementation()
        }
      }else {
        if(funcDecl$$17.isIndexerMember()) {
          if(groupType.index == null) {
            var v5321 = groupType;
            var v26953 = new TypeScript$$23.SignatureGroup;
            v5321.index = v26953;
            var v5322 = groupType.index;
            v5322.flags = v5322.flags | TypeScript$$23.SignatureFlags.IsIndexer
          }
          var v5324 = groupType.index;
          JAM.call(v5324.addSignature, v5324, [signature$$3]);
          groupType.index.hasImplementation = !funcDecl$$17.isSignature();
          if(groupType.index.hasImplementation) {
            groupType.setHasImplementation()
          }
        }else {
          if(groupType.call == null) {
            var v5327 = groupType;
            var v26954 = new TypeScript$$23.SignatureGroup;
            v5327.call = v26954
          }
          var v5329 = groupType.call;
          JAM.call(v5329.addSignature, v5329, [signature$$3]);
          groupType.call.hasImplementation = !funcDecl$$17.isSignature();
          if(groupType.call.hasImplementation) {
            groupType.setHasImplementation()
          }
        }
      }
      var instanceType$$3 = groupType.instanceType;
      var funcName$$1 = null;
      var usedHint = false;
      var v14724 = funcDecl$$17.name;
      if(v14724) {
        v14724 = !funcDecl$$17.name.isMissing()
      }
      if(v14724) {
        funcName$$1 = funcDecl$$17.name.text
      }else {
        if(funcDecl$$17.hint) {
          funcName$$1 = funcDecl$$17.hint;
          usedHint = true
        }
      }
      if(groupType.symbol == null) {
        var v5336 = groupType;
        var v14726 = TypeScript$$23.TypeSymbol;
        var v20247;
        if(funcName$$1) {
          v20247 = funcName$$1
        }else {
          v20247 = this.anon
        }
        var v26955 = JAM.new(v14726, [v20247, funcDecl$$17.minChar, funcDecl$$17.limChar - funcDecl$$17.minChar, this.locationInfo.unitIndex, groupType]);
        v5336.symbol = v26955;
        if(!useOverloadGroupSym) {
          groupType.symbol.declAST = funcDecl$$17
        }
      }
      if(isStatic$$6) {
        var v5340 = groupType.symbol;
        v5340.flags = v5340.flags | TypeScript$$23.SymbolFlags.Static
      }
      if(isAmbient$$4) {
        var v5341 = groupType.symbol;
        v5341.flags = v5341.flags | TypeScript$$23.SymbolFlags.Ambient
      }
      if(isPrivate) {
        var v5342 = groupType.symbol;
        v5342.flags = v5342.flags | TypeScript$$23.SymbolFlags.Private
      }
      var v5343 = groupType.symbol;
      var v26956 = funcDecl$$17.isMethod();
      v5343.isMethod = v26956;
      if(groupType.symbol.isMethod) {
        var v5344 = groupType.symbol;
        v5344.flags = v5344.flags | TypeScript$$23.SymbolFlags.Property
      }
      funcDecl$$17.type = groupType;
      if(!isConstructor$$2) {
        var v14732 = funcName$$1;
        if(v14732) {
          var v20259 = !isLambda$$2;
          if(v20259) {
            var v23556 = !funcDecl$$17.isAccessor();
            if(v23556) {
              v23556 = !usedHint
            }
            v20259 = v23556
          }
          v14732 = v20259
        }
        if(v14732) {
          if(addToScope) {
            var v14733 = funcDecl$$17.isMethod();
            if(v14733) {
              v14733 = isStatic$$6
            }
            if(v14733) {
              var v20260 = container$$12.type.members.publicMembers;
              if(!JAM.call(v20260.add, v20260, [funcName$$1, groupType.symbol])) {
                var v5346 = this.errorReporter;
                JAM.call(v5346.duplicateIdentifier, v5346, [funcDecl$$17, funcName$$1])
              }
              groupType.symbol.container = container$$12
            }else {
              var v14735 = overloadGroupSym == null;
              if(!v14735) {
                var v20262 = overloadGroupSym.declAST;
                if(v20262) {
                  var v23558 = !overloadGroupSym.declAST.isOverload;
                  if(v23558) {
                    v23558 = container$$12.isType()
                  }
                  v20262 = v23558
                }
                v14735 = v20262
              }
              if(v14735) {
                var v5349 = groupType.symbol;
                var v5350 = this.errorReporter;
                var v14736 = !isPrivate;
                if(v14736) {
                  var v20264 = isExported$$1;
                  if(!v20264) {
                    v20264 = isStatic$$6 || isGlobal
                  }
                  v14736 = v20264
                }
                JAM.call(scope$$22.enter, scope$$22, [container$$12, funcDecl$$17, v5349, v5350, v14736, false, isAmbient$$4])
              }
            }
          }else {
            if(!funcDecl$$17.isSpecialFn()) {
              groupType.symbol.container = container$$12
            }
          }
        }else {
          if(!funcDecl$$17.isSpecialFn()) {
            groupType.symbol.container = container$$12
          }
        }
      }
      if(useOverloadGroupSym) {
        var v5360;
        if(overloadGroupSym) {
          v5360 = overloadGroupSym.getType()
        }else {
          v5360 = null
        }
        var overloadGroupType = v5360;
        var classType$$3 = groupType;
        if(classType$$3 != overloadGroupType) {
          if(classType$$3.construct == null) {
            var v14740 = overloadGroupType;
            if(v14740) {
              v14740 = overloadGroupType.construct
            }
            if(v14740) {
              classType$$3.construct = overloadGroupType.construct
            }else {
              var v5361 = classType$$3;
              var v26957 = new TypeScript$$23.SignatureGroup;
              v5361.construct = v26957
            }
          }else {
            if(overloadGroupType) {
              if(overloadGroupType.construct) {
                classType$$3.construct.signatures.concat(overloadGroupType.construct.signatures)
              }
            }
          }
          if(overloadGroupType) {
            if(classType$$3.call == null) {
              classType$$3.call = overloadGroupType.call
            }else {
              if(overloadGroupType.call) {
                classType$$3.call.signatures.concat(overloadGroupType.call.signatures)
              }
            }
            if(!isStatic$$6) {
              if(classType$$3.instanceType == null) {
                classType$$3.instanceType = overloadGroupType.instanceType
              }
              instanceType$$3 = classType$$3.instanceType;
              if(instanceType$$3) {
                if(instanceType$$3.call == null) {
                  instanceType$$3.call = overloadGroupType.call
                }else {
                  if(overloadGroupType.call) {
                    instanceType$$3.call.signatures.concat(overloadGroupType.call.signatures)
                  }
                }
              }
            }
            if(classType$$3.index == null) {
              classType$$3.index = overloadGroupType.index
            }else {
              if(overloadGroupType.index) {
                classType$$3.index.signatures.concat(overloadGroupType.index.signatures)
              }
            }
          }
        }
      }
      return signature$$3
    }
    function v928(funcDecl$$16, container$$11) {
      var args$$11 = funcDecl$$16.arguments;
      var parameterTable = null;
      var parameterBuilder = null;
      var len$$25 = args$$11.members.length;
      var nonOptionalParams = 0;
      var result$$27 = [];
      if(len$$25 > 0) {
        parameterTable = JAM.new(TypeScript$$23.ScopedMembers, [JAM.new(TypeScript$$23.DualStringHashTable, [new TypeScript$$23.StringHashTable, new TypeScript$$23.StringHashTable])]);
        parameterBuilder = JAM.new(TypeScript$$23.SymbolScopeBuilder, [parameterTable, null, null, null, null, container$$11]);
        var i$$75 = 0;
        var v5397 = i$$75 < len$$25;
        for(;v5397;) {
          var v5386 = args$$11.members;
          introspect(JAM.policy.p1) {
            var parameter$$1 = v5386[i$$75]
          }
          var paramDef$$2 = new TypeScript$$23.ValueLocation;
          var parameterSymbol = JAM.new(TypeScript$$23.ParameterSymbol, [parameter$$1.id.text, parameter$$1.minChar, this.locationInfo.unitIndex, paramDef$$2]);
          parameterSymbol.declAST = parameter$$1;
          parameterSymbol.funcDecl = funcDecl$$16;
          parameter$$1.id.sym = parameterSymbol;
          parameter$$1.sym = parameterSymbol;
          paramDef$$2.symbol = parameterSymbol;
          var v5393 = paramDef$$2;
          var v26958 = JAM.call(TypeScript$$23.getTypeLink, TypeScript$$23, [parameter$$1.typeExpr, this, false]);
          v5393.typeLink = v26958;
          JAM.call(parameterBuilder.enter, parameterBuilder, [null, parameter$$1, parameterSymbol, this.errorReporter, true, false, false]);
          result$$27[result$$27.length] = parameterSymbol;
          if(!parameter$$1.isOptionalArg()) {
            nonOptionalParams = nonOptionalParams + 1
          }
          i$$75 = i$$75 + 1;
          v5397 = i$$75 < len$$25
        }
      }
      return{parameters:result$$27, nonOptionalParameterCount:nonOptionalParams}
    }
    function v927(type$$40) {
      if(type$$40.arrayCache == null) {
        var v5399 = type$$40;
        var v26959 = new ArrayCache;
        v5399.arrayCache = v26959;
        var v5400 = type$$40.arrayCache;
        var v26960 = new TypeScript$$23.Type;
        v5400.arrayType = v26960;
        type$$40.arrayCache.arrayType.elementType = type$$40;
        type$$40.arrayCache.arrayType.symbol = type$$40.symbol
      }
      return type$$40.arrayCache.arrayType
    }
    function v926(ast$$63) {
      if(ast$$63.nodeType == TypeScript$$23.NodeType.Script) {
        var script$$14 = ast$$63;
        this.locationInfo = script$$14.locationInfo
      }
      var globalChain = JAM.new(TypeScript$$23.ScopeChain, [this.gloMod, null, this.globalScope]);
      var context$$49 = JAM.new(TypeScript$$23.TypeCollectionContext, [globalChain, this]);
      var v5410 = TypeScript$$23.getAstWalkerFactory();
      JAM.call(v5410.walk, v5410, [ast$$63, TypeScript$$23.preCollectTypes, TypeScript$$23.postCollectTypes, null, context$$49]);
      return
    }
    function v925() {
      var i$$74 = 0;
      var v5415 = i$$74 < this.provisionalStartedTypecheckObjects.length;
      for(;v5415;) {
        var v23560 = this.provisionalStartedTypecheckObjects;
        introspect(JAM.policy.p1) {
          var v20269 = v23560[i$$74]
        }
        if(v20269.typeCheckStatus >= this.typingContextStack.getContextID()) {
          var v14770 = this.provisionalStartedTypecheckObjects;
          introspect(JAM.policy.p1) {
            var v5413 = v14770[i$$74]
          }
          v5413.typeCheckStatus = TypeScript$$23.TypeCheckStatus.NotStarted
        }
        i$$74 = i$$74 + 1;
        v5415 = i$$74 < this.provisionalStartedTypecheckObjects.length
      }
      this.provisionalStartedTypecheckObjects = [];
      return
    }
    function v924(pto) {
      if(this.inProvisionalTypecheckMode()) {
        JAM.set(this.provisionalStartedTypecheckObjects, this.provisionalStartedTypecheckObjects.length, pto)
      }
      return
    }
    function v923(status) {
      var v5419 = status == TypeScript$$23.TypeCheckStatus.Finished;
      if(!v5419) {
        var v14775 = this.inProvisionalTypecheckMode();
        if(v14775) {
          v14775 = status == this.typingContextStack.getContextID()
        }
        v5419 = v14775
      }
      return v5419
    }
    function v922() {
      if(this.inProvisionalTypecheckMode()) {
        return this.typingContextStack.getContextID()
      }
      return TypeScript$$23.TypeCheckStatus.Finished
    }
    function v921() {
      return this.typingContextStack.isProvisional()
    }
    function v920() {
      return this.currentContextualTypeContext
    }
    function v919() {
      var v5424 = this.currentContextualTypeContext;
      if(v5424) {
        v5424 = this.currentContextualTypeContext.contextualType
      }
      return v5424
    }
    function v918() {
      this.currentContextualTypeContext = null;
      this.errorReporter.pushToErrorSink = false;
      return
    }
    function v917() {
      var v26961 = this.typingContextStack.getContextualType();
      this.currentContextualTypeContext = v26961;
      return
    }
    function v916(contextType, provisional$$3, condition, ast$$62) {
      if(condition) {
        var v14778 = this.typingContextStack.isProvisional();
        if(!v14778) {
          v14778 = provisional$$3
        }
        JAM.call(this.setContextualType, this, [contextType, v14778])
      }
      var v5428 = this.typeFlow;
      JAM.call(v5428.typeCheck, v5428, [ast$$62]);
      if(condition) {
        this.unsetContextualType()
      }
      return
    }
    function v915() {
      if(!this.typingContextStack.getContextualType()) {
        this.typingContextStack.hadProvisionalErrors = false
      }
      return
    }
    function v914() {
      return this.typingContextStack.hadProvisionalErrors
    }
    function v913() {
      var lastTC = this.typingContextStack.popContextualType();
      var v26962 = this.typingContextStack.getContextualType();
      this.currentContextualTypeContext = v26962;
      return lastTC
    }
    function v912(type$$39, provisional$$2) {
      var v5434 = this.typingContextStack;
      JAM.call(v5434.pushContextualType, v5434, [type$$39, provisional$$2]);
      var v26963 = this.typingContextStack.getContextualType();
      this.currentContextualTypeContext = v26963;
      return
    }
    function v911(style) {
      this.styleSettings = style;
      return
    }
    function TypeChecker$$1(persistentState) {
      this.persistentState = persistentState;
      this.errorReporter = null;
      this.checkControlFlow = false;
      this.printControlFlowGraph = false;
      this.checkControlFlowUseDef = false;
      this.styleSettings = null;
      this.units = null;
      this.anon = "_anonymous";
      this.locationInfo = null;
      this.typeFlow = null;
      this.currentCompareA = null;
      this.currentCompareB = null;
      this.currentModDecl = null;
      this.inBind = false;
      this.inWith = false;
      this.errorsOnWith = true;
      this.currentContextualTypeContext = null;
      this.resolvingBases = false;
      this.canCallDefinitionSignature = false;
      this.assignableCache = {};
      this.subtypeCache = {};
      this.identicalCache = {};
      this.provisionalStartedTypecheckObjects = [];
      this.mustCaptureGlobalThis = false;
      this.voidType = this.persistentState.voidType;
      this.booleanType = this.persistentState.booleanType;
      this.numberType = this.persistentState.doubleType;
      this.stringType = this.persistentState.stringType;
      this.anyType = this.persistentState.anyType;
      this.nullType = this.persistentState.nullType;
      this.undefinedType = this.persistentState.undefinedType;
      this.globals = this.persistentState.dualGlobalValues;
      this.globalTypes = this.persistentState.dualGlobalTypes;
      this.ambientGlobals = this.persistentState.dualAmbientGlobalValues;
      this.ambientGlobalTypes = this.persistentState.dualAmbientGlobalTypes;
      this.gloModType = this.persistentState.mod;
      this.gloMod = this.persistentState.gloMod;
      this.wildElm = this.persistentState.wildElm;
      this.globalScope = this.persistentState.globalScope;
      var v26964 = JAM.new(ContextualTypingContextStack, [this]);
      this.typingContextStack = v26964;
      return
    }
    TypeChecker$$1.prototype.setStyleOptions = v911;
    TypeChecker$$1.prototype.setContextualType = v912;
    TypeChecker$$1.prototype.unsetContextualType = v913;
    TypeChecker$$1.prototype.hadProvisionalErrors = v914;
    TypeChecker$$1.prototype.resetProvisionalErrors = v915;
    TypeChecker$$1.prototype.typeCheckWithContextualType = v916;
    TypeChecker$$1.prototype.resetTargetType = v917;
    TypeChecker$$1.prototype.killCurrentContextualType = v918;
    TypeChecker$$1.prototype.hasTargetType = v919;
    TypeChecker$$1.prototype.getTargetTypeContext = v920;
    TypeChecker$$1.prototype.inProvisionalTypecheckMode = v921;
    TypeChecker$$1.prototype.getTypeCheckFinishedStatus = v922;
    TypeChecker$$1.prototype.typeStatusIsFinished = v923;
    TypeChecker$$1.prototype.addStartedPTO = v924;
    TypeChecker$$1.prototype.cleanStartedPTO = v925;
    TypeChecker$$1.prototype.collectTypes = v926;
    TypeChecker$$1.prototype.makeArrayType = v927;
    TypeChecker$$1.prototype.getParameterList = v928;
    TypeChecker$$1.prototype.createFunctionSignature = v929;
    TypeChecker$$1.prototype.createAccessorSymbol = v930;
    TypeChecker$$1.prototype.addBases = v931;
    TypeChecker$$1.prototype.scopeOf = v932;
    TypeChecker$$1.prototype.lookupMemberTypeSymbol = v933;
    TypeChecker$$1.prototype.findSymbolForDynamicModule = v934;
    TypeChecker$$1.prototype.resolveTypeMember = v936;
    TypeChecker$$1.prototype.resolveFuncDecl = v937;
    TypeChecker$$1.prototype.resolveVarDecl = v938;
    TypeChecker$$1.prototype.resolveTypeLink = v939;
    TypeChecker$$1.prototype.resolveBaseTypeLink = v940;
    TypeChecker$$1.prototype.findMostApplicableSignature = v944;
    TypeChecker$$1.prototype.getApplicableSignatures = v945;
    TypeChecker$$1.prototype.canContextuallyTypeFunction = v946;
    TypeChecker$$1.prototype.canContextuallyTypeObjectLiteral = v947;
    TypeChecker$$1.prototype.widenType = v948;
    TypeChecker$$1.prototype.isNullOrUndefinedType = v949;
    TypeChecker$$1.prototype.findBestCommonType = v950;
    TypeChecker$$1.prototype.typesAreIdentical = v951;
    TypeChecker$$1.prototype.signatureGroupsAreIdentical = v952;
    TypeChecker$$1.prototype.signaturesAreIdentical = v953;
    TypeChecker$$1.prototype.sourceIsSubtypeOfTarget = v954;
    TypeChecker$$1.prototype.signatureGroupIsSubtypeOfTarget = v955;
    TypeChecker$$1.prototype.signatureIsSubtypeOfTarget = v956;
    TypeChecker$$1.prototype.sourceIsAssignableToTarget = v957;
    TypeChecker$$1.prototype.signatureGroupIsAssignableToTarget = v958;
    TypeChecker$$1.prototype.signatureIsAssignableToTarget = v959;
    TypeChecker$$1.prototype.sourceIsRelatableToTarget = v960;
    TypeChecker$$1.prototype.signatureGroupIsRelatableToTarget = v961;
    TypeChecker$$1.prototype.signatureIsRelatableToTarget = v962;
    return TypeChecker$$1
  }
  function v910() {
    function v909() {
      var v5499;
      if(!this.contextStack.length) {
        v5499 = false
      }else {
        var v20279 = this.contextStack;
        var v20280 = this.contextStack.length - 1;
        introspect(JAM.policy.p1) {
          var v14780 = v20279[v20280]
        }
        v5499 = v14780.provisional
      }
      return v5499
    }
    function v908() {
      var v5500;
      if(!this.contextStack.length) {
        v5500 = TypeScript$$23.TypeCheckStatus.Finished
      }else {
        var v20282 = this.contextStack;
        var v20283 = this.contextStack.length - 1;
        introspect(JAM.policy.p1) {
          var v14783 = v20282[v20283]
        }
        v5500 = v14783.contextID
      }
      return v5500
    }
    function v907() {
      var v5501;
      if(!this.contextStack.length) {
        v5501 = null
      }else {
        v5501 = this.contextStack[this.contextStack.length - 1]
      }
      return v5501
    }
    function v906() {
      var tc$$2 = this.contextStack.pop();
      var v5503 = this.checker.errorReporter;
      var v26965 = this.isProvisional();
      v5503.pushToErrorSink = v26965;
      var v5504 = this.hadProvisionalErrors;
      if(!v5504) {
        var v14789 = tc$$2.provisional;
        if(v14789) {
          v14789 = this.checker.errorReporter.errorSink.length
        }
        v5504 = v14789
      }
      this.hadProvisionalErrors = v5504;
      this.checker.errorReporter.freeCapturedErrors();
      return tc$$2
    }
    function v905(type$$38, provisional$$1) {
      var v5506 = this.contextStack;
      var v14792 = ContextualTypingContextStack$$1.contextID;
      ContextualTypingContextStack$$1.contextID = ContextualTypingContextStack$$1.contextID + 1;
      JAM.call(v5506.push, v5506, [JAM.new(ContextualTypeContext, [type$$38, provisional$$1, v14792])]);
      this.checker.errorReporter.pushToErrorSink = provisional$$1;
      return
    }
    function ContextualTypingContextStack$$1(checker$$16) {
      this.checker = checker$$16;
      this.contextStack = [];
      this.hadProvisionalErrors = false;
      return
    }
    ContextualTypingContextStack$$1.contextID = TypeScript$$23.TypeCheckStatus.Finished + 1;
    ContextualTypingContextStack$$1.prototype.pushContextualType = v905;
    ContextualTypingContextStack$$1.prototype.popContextualType = v906;
    ContextualTypingContextStack$$1.prototype.getContextualType = v907;
    ContextualTypingContextStack$$1.prototype.getContextID = v908;
    ContextualTypingContextStack$$1.prototype.isProvisional = v909;
    return ContextualTypingContextStack$$1
  }
  function v904() {
    function ContextualTypeContext$$1(contextualType, provisional, contextID) {
      this.contextualType = contextualType;
      this.provisional = provisional;
      this.contextID = contextID;
      this.targetSig = null;
      this.targetThis = null;
      this.targetAccessorType = null;
      return
    }
    return ContextualTypeContext$$1
  }
  function v903() {
    function v902(name$$81, type$$37) {
      var valueLocation = new TypeScript$$23.ValueLocation;
      var v5516 = valueLocation;
      var v26966 = new TypeScript$$23.TypeLink;
      v5516.typeLink = v26966;
      var sym$$28 = JAM.new(TypeScript$$23.VariableSymbol, [name$$81, 0, -1, valueLocation]);
      JAM.call(sym$$28.setType, sym$$28, [type$$37]);
      sym$$28.typeCheckStatus = TypeScript$$23.TypeCheckStatus.Finished;
      sym$$28.container = this.gloMod;
      var v5519 = this.importedGlobalsTable;
      JAM.call(v5519.addPublicMember, v5519, [name$$81, sym$$28]);
      return
    }
    function v901() {
      var v26967 = new TypeScript$$23.StringHashTable;
      this.globals = v26967;
      var v26968 = new TypeScript$$23.StringHashTable;
      this.globalTypes = v26968;
      var v26969 = new TypeScript$$23.StringHashTable;
      this.ambientGlobals = v26969;
      var v26970 = new TypeScript$$23.StringHashTable;
      this.ambientGlobalTypes = v26970;
      var v5524 = this.globalTypes;
      JAM.call(v5524.add, v5524, [this.voidType.symbol.name, this.voidType.symbol]);
      var v5527 = this.globalTypes;
      JAM.call(v5527.add, v5527, [this.booleanType.symbol.name, this.booleanType.symbol]);
      var v5530 = this.globalTypes;
      JAM.call(v5530.add, v5530, [this.doubleType.symbol.name, this.doubleType.symbol]);
      var v5533 = this.globalTypes;
      JAM.call(v5533.add, v5533, ["number", this.doubleType.symbol]);
      var v5535 = this.globalTypes;
      JAM.call(v5535.add, v5535, [this.stringType.symbol.name, this.stringType.symbol]);
      var v5538 = this.globalTypes;
      JAM.call(v5538.add, v5538, [this.anyType.symbol.name, this.anyType.symbol]);
      var v5541 = this.globalTypes;
      JAM.call(v5541.add, v5541, [this.nullType.symbol.name, this.nullType.symbol]);
      var v5544 = this.globalTypes;
      JAM.call(v5544.add, v5544, [this.undefinedType.symbol.name, this.undefinedType.symbol]);
      this.dualGlobalValues.secondaryTable = this.globals;
      this.dualGlobalTypes.secondaryTable = this.globalTypes;
      this.dualAmbientGlobalValues.secondaryTable = this.ambientGlobals;
      this.dualAmbientGlobalTypes.secondaryTable = this.ambientGlobalTypes;
      return
    }
    function v900(mode$$8) {
      this.residentTypeCheck = this.dualGlobalValues.insertPrimary = this.dualGlobalTypes.insertPrimary = this.dualAmbientGlobalValues.insertPrimary = this.dualAmbientGlobalTypes.insertPrimary = mode$$8 == TypeCheckCollectionMode.Resident;
      return
    }
    function v899(flags$$3, name$$80) {
      var primitive = new TypeScript$$23.Type;
      primitive.primitiveTypeClass = flags$$3;
      var symbol$$8 = JAM.new(TypeScript$$23.TypeSymbol, [name$$80, -1, name$$80.length, -1, primitive]);
      symbol$$8.typeCheckStatus = TypeScript$$23.TypeCheckStatus.Finished;
      primitive.symbol = symbol$$8;
      var v5556 = this.importedGlobals;
      JAM.call(v5556.enter, v5556, [null, null, symbol$$8, this.errorReporter, true, true, true]);
      return primitive
    }
    function PersistentGlobalTypeState$$1(errorReporter$$4) {
      this.errorReporter = errorReporter$$4;
      var v26971 = JAM.new(TypeScript$$23.ScopedMembers, [JAM.new(TypeScript$$23.DualStringHashTable, [new TypeScript$$23.StringHashTable, new TypeScript$$23.StringHashTable])]);
      this.importedGlobalsTable = v26971;
      var v26972 = JAM.new(TypeScript$$23.ScopedMembers, [JAM.new(TypeScript$$23.DualStringHashTable, [new TypeScript$$23.StringHashTable, new TypeScript$$23.StringHashTable])]);
      this.importedGlobalsTypeTable = v26972;
      this.globals = null;
      this.globalTypes = null;
      this.ambientGlobals = null;
      this.ambientGlobalTypes = null;
      var v26973 = new TypeScript$$23.StringHashTable;
      this.residentGlobalValues = v26973;
      var v26974 = new TypeScript$$23.StringHashTable;
      this.residentGlobalTypes = v26974;
      var v26975 = new TypeScript$$23.StringHashTable;
      this.residentGlobalAmbientValues = v26975;
      var v26976 = new TypeScript$$23.StringHashTable;
      this.residentGlobalAmbientTypes = v26976;
      this.residentTypeCheck = true;
      this.mod = null;
      this.gloMod = null;
      this.wildElm = null;
      var v26977 = JAM.new(TypeScript$$23.SymbolScopeBuilder, [null, this.importedGlobalsTable, null, this.importedGlobalsTypeTable, null, null]);
      this.importedGlobals = v26977;
      var v26978 = JAM.new(TypeScript$$23.DualStringHashTable, [this.residentGlobalValues, new TypeScript$$23.StringHashTable]);
      this.dualGlobalValues = v26978;
      var v26979 = JAM.new(TypeScript$$23.DualStringHashTable, [this.residentGlobalTypes, new TypeScript$$23.StringHashTable]);
      this.dualGlobalTypes = v26979;
      var v26980 = JAM.new(TypeScript$$23.DualStringHashTable, [this.residentGlobalAmbientValues, new TypeScript$$23.StringHashTable]);
      this.dualAmbientGlobalValues = v26980;
      var v26981 = JAM.new(TypeScript$$23.DualStringHashTable, [this.residentGlobalAmbientTypes, new TypeScript$$23.StringHashTable]);
      this.dualAmbientGlobalTypes = v26981;
      var dualGlobalScopedMembers = JAM.new(TypeScript$$23.ScopedMembers, [JAM.new(TypeScript$$23.DualStringHashTable, [this.dualGlobalValues, new TypeScript$$23.StringHashTable])]);
      var dualGlobalScopedAmbientMembers = JAM.new(TypeScript$$23.ScopedMembers, [JAM.new(TypeScript$$23.DualStringHashTable, [this.dualAmbientGlobalValues, new TypeScript$$23.StringHashTable])]);
      var dualGlobalScopedEnclosedTypes = JAM.new(TypeScript$$23.ScopedMembers, [JAM.new(TypeScript$$23.DualStringHashTable, [this.dualGlobalTypes, new TypeScript$$23.StringHashTable])]);
      var dualGlobalScopedAmbientEnclosedTypes = JAM.new(TypeScript$$23.ScopedMembers, [JAM.new(TypeScript$$23.DualStringHashTable, [this.dualAmbientGlobalTypes, new TypeScript$$23.StringHashTable])]);
      var v26982 = JAM.new(TypeScript$$23.SymbolScopeBuilder, [dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, this.importedGlobals, null]);
      this.globalScope = v26982;
      var v26983 = JAM.call(this.enterPrimitive, this, [TypeScript$$23.Primitive.Void, "void"]);
      this.voidType = v26983;
      var v26984 = JAM.call(this.enterPrimitive, this, [TypeScript$$23.Primitive.Boolean, "bool"]);
      this.booleanType = v26984;
      var v26985 = JAM.call(this.enterPrimitive, this, [TypeScript$$23.Primitive.Double, "number"]);
      this.doubleType = v26985;
      var v5594 = this.importedGlobals.ambientEnclosedTypes;
      JAM.call(v5594.addPublicMember, v5594, ["number", this.doubleType.symbol]);
      var v26986 = JAM.call(this.enterPrimitive, this, [TypeScript$$23.Primitive.String, "string"]);
      this.stringType = v26986;
      var v26987 = JAM.call(this.enterPrimitive, this, [TypeScript$$23.Primitive.Any, "any"]);
      this.anyType = v26987;
      var v26988 = JAM.call(this.enterPrimitive, this, [TypeScript$$23.Primitive.Null, "null"]);
      this.nullType = v26988;
      var v26989 = JAM.call(this.enterPrimitive, this, [TypeScript$$23.Primitive.Undefined, "undefined"]);
      this.undefinedType = v26989;
      JAM.call(this.setCollectionMode, this, [TypeCheckCollectionMode.Resident]);
      var v26990 = JAM.new(TypeScript$$23.TypeSymbol, ["_element", -1, 0, -1, new TypeScript$$23.Type]);
      this.wildElm = v26990;
      var v5603 = this.importedGlobalsTypeTable;
      JAM.call(v5603.addPublicMember, v5603, [this.wildElm.name, this.wildElm]);
      var v26991 = JAM.new(TypeScript$$23.ModuleType, [dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes]);
      this.mod = v26991;
      this.mod.members = dualGlobalScopedMembers;
      this.mod.ambientMembers = dualGlobalScopedAmbientMembers;
      this.mod.containedScope = this.globalScope;
      var v26992 = JAM.new(TypeScript$$23.TypeSymbol, [TypeScript$$23.globalId, -1, 0, -1, this.mod]);
      this.gloMod = v26992;
      var v5613 = this.mod.members;
      JAM.call(v5613.addPublicMember, v5613, [this.gloMod.name, this.gloMod]);
      JAM.call(this.defineGlobalValue, this, ["undefined", this.undefinedType]);
      return
    }
    PersistentGlobalTypeState$$1.prototype.enterPrimitive = v899;
    PersistentGlobalTypeState$$1.prototype.setCollectionMode = v900;
    PersistentGlobalTypeState$$1.prototype.refreshPersistentState = v901;
    PersistentGlobalTypeState$$1.prototype.defineGlobalValue = v902;
    return PersistentGlobalTypeState$$1
  }
  function v898(TypeCheckCollectionMode$$1) {
    TypeCheckCollectionMode$$1._map = [];
    TypeCheckCollectionMode$$1._map[0] = "Resident";
    TypeCheckCollectionMode$$1.Resident = 0;
    TypeCheckCollectionMode$$1._map[1] = "Transient";
    TypeCheckCollectionMode$$1.Transient = 1;
    return
  }
  function v897() {
    function v896(message$$19) {
      this.message = message$$19;
      return
    }
    function v895(message$$18) {
      if(!this.onlyCaptureFirstError) {
        var v5623;
        if(this.message) {
          v5623 = message$$18 + ":\n\t" + this.message
        }else {
          v5623 = message$$18
        }
        this.message = v5623
      }else {
        JAM.call(this.setMessage, this, [message$$18])
      }
      return
    }
    function TypeComparisonInfo$$1() {
      this.onlyCaptureFirstError = false;
      this.flags = TypeScript$$23.TypeRelationshipFlags.SuccessfulComparison;
      this.message = "";
      return
    }
    TypeComparisonInfo$$1.prototype.addMessageToFront = v895;
    TypeComparisonInfo$$1.prototype.setMessage = v896;
    return TypeComparisonInfo$$1
  }
  function v894() {
    function v893(arrInstType, checker$$15) {
      if(this.arrayBase == null) {
        var v26993 = JAM.call(arrInstType.specializeType, arrInstType, [checker$$15.wildElm.type, this.arrayType.elementType, checker$$15, true]);
        this.arrayBase = v26993
      }
      return this.arrayBase
    }
    function ArrayCache$$1() {
      this.arrayBase = null;
      return
    }
    ArrayCache$$1.prototype.specialize = v893;
    return ArrayCache$$1
  }
  var ArrayCache = v894();
  TypeScript$$23.ArrayCache = ArrayCache;
  var TypeComparisonInfo = v897();
  TypeScript$$23.TypeComparisonInfo = TypeComparisonInfo;
  var v14854 = TypeScript$$23.TypeCheckCollectionMode;
  if(!v14854) {
    v14854 = TypeScript$$23.TypeCheckCollectionMode = {}
  }
  v898(v14854);
  var TypeCheckCollectionMode = TypeScript$$23.TypeCheckCollectionMode;
  var PersistentGlobalTypeState = v903();
  TypeScript$$23.PersistentGlobalTypeState = PersistentGlobalTypeState;
  var ContextualTypeContext = v904();
  TypeScript$$23.ContextualTypeContext = ContextualTypeContext;
  var ContextualTypingContextStack = v910();
  TypeScript$$23.ContextualTypingContextStack = ContextualTypingContextStack;
  var TypeChecker = v963();
  TypeScript$$23.TypeChecker = TypeChecker;
  return
}
function v892(TypeScript$$22) {
  function v891(_super$$64) {
    function v890() {
      return TokenClass.RegExpLiteral
    }
    function v889() {
      return this.regex.toString()
    }
    function RegularExpressionLiteralToken$$1(regex$$3) {
      JAM.call(_super$$64.call, _super$$64, [this, TokenID.RegularExpressionLiteral]);
      this.regex = regex$$3;
      return
    }
    JAM.call(__extends, null, [RegularExpressionLiteralToken$$1, _super$$64]);
    RegularExpressionLiteralToken$$1.prototype.getText = v889;
    RegularExpressionLiteralToken$$1.prototype.classification = v890;
    return RegularExpressionLiteralToken$$1
  }
  function v888(_super$$63) {
    function v887() {
      return TokenClass.Comment
    }
    function v886() {
      return this.value
    }
    function CommentToken$$1(tokenID, value$$41, isBlock, startPos$$2, line$$11, endsLine$$2) {
      JAM.call(_super$$63.call, _super$$63, [this, tokenID]);
      this.value = value$$41;
      this.isBlock = isBlock;
      this.startPos = startPos$$2;
      this.line = line$$11;
      this.endsLine = endsLine$$2;
      return
    }
    JAM.call(__extends, null, [CommentToken$$1, _super$$63]);
    CommentToken$$1.prototype.getText = v886;
    CommentToken$$1.prototype.classification = v887;
    return CommentToken$$1
  }
  function v885(_super$$62) {
    function v884() {
      return TokenClass.Whitespace
    }
    function v883() {
      return this.value
    }
    function WhitespaceToken$$1(tokenId$$48, value$$40) {
      JAM.call(_super$$62.call, _super$$62, [this, tokenId$$48]);
      this.value = value$$40;
      return
    }
    JAM.call(__extends, null, [WhitespaceToken$$1, _super$$62]);
    WhitespaceToken$$1.prototype.getText = v883;
    WhitespaceToken$$1.prototype.classification = v884;
    return WhitespaceToken$$1
  }
  function v882(_super$$61) {
    function v881() {
      return TokenClass.Identifier
    }
    function v880() {
      return this.value
    }
    function IdentifierToken$$1(value$$39, hasEscapeSequence$$3) {
      JAM.call(_super$$61.call, _super$$61, [this, TokenID.Identifier]);
      this.value = value$$39;
      this.hasEscapeSequence = hasEscapeSequence$$3;
      return
    }
    JAM.call(__extends, null, [IdentifierToken$$1, _super$$61]);
    IdentifierToken$$1.prototype.getText = v880;
    IdentifierToken$$1.prototype.classification = v881;
    return IdentifierToken$$1
  }
  function v879(_super$$60) {
    function v878() {
      return TokenClass.StringLiteral
    }
    function v877() {
      return this.value
    }
    function StringLiteralToken$$1(value$$38) {
      JAM.call(_super$$60.call, _super$$60, [this, TokenID.StringLiteral]);
      this.value = value$$38;
      return
    }
    JAM.call(__extends, null, [StringLiteralToken$$1, _super$$60]);
    StringLiteralToken$$1.prototype.getText = v877;
    StringLiteralToken$$1.prototype.classification = v878;
    return StringLiteralToken$$1
  }
  function v876(_super$$59) {
    function v875() {
      return TokenClass.NumberLiteral
    }
    function v874() {
      var v5647;
      if(this.hasEmptyFraction) {
        v5647 = this.value.toString() + ".0"
      }else {
        v5647 = this.value.toString()
      }
      return v5647
    }
    function NumberLiteralToken$$1(value$$37, hasEmptyFraction$$1) {
      JAM.call(_super$$59.call, _super$$59, [this, TokenID.NumberLiteral]);
      this.value = value$$37;
      this.hasEmptyFraction = hasEmptyFraction$$1;
      return
    }
    JAM.call(__extends, null, [NumberLiteralToken$$1, _super$$59]);
    NumberLiteralToken$$1.prototype.getText = v874;
    NumberLiteralToken$$1.prototype.classification = v875;
    return NumberLiteralToken$$1
  }
  function v873() {
    function v872() {
      if(this.tokenId <= TokenID.LimKeyword) {
        return TokenClass.Keyword
      }else {
        var tokenInfo$$2 = lookupToken(this.tokenId);
        if(tokenInfo$$2 != undefined) {
          var v14860 = tokenInfo$$2.unopNodeType != TypeScript$$22.NodeType.None;
          if(!v14860) {
            v14860 = tokenInfo$$2.binopNodeType != TypeScript$$22.NodeType.None
          }
          if(v14860) {
            return TokenClass.Operator
          }
        }
      }
      return TokenClass.Punctuation
    }
    function v871() {
      var v14861 = TypeScript$$22.tokenTable;
      var v14862 = this.tokenId;
      introspect(JAM.policy.p1) {
        var v5655 = v14861[v14862]
      }
      return v5655.text
    }
    function v870(line$$10, outfile$$11) {
      JAM.call(outfile$$11.WriteLine, outfile$$11, [this.toString() + ",on line" + line$$10]);
      return
    }
    function v869() {
      var v14864 = "token: " + this.tokenId + " " + this.getText() + " (";
      var v20312 = TokenID._map;
      var v20313 = this.tokenId;
      introspect(JAM.policy.p1) {
        var v14865 = v20312[v20313]
      }
      return v14864 + v14865 + ")"
    }
    function Token$$1(tokenId$$47) {
      this.tokenId = tokenId$$47;
      return
    }
    Token$$1.prototype.toString = v869;
    Token$$1.prototype.print = v870;
    Token$$1.prototype.getText = v871;
    Token$$1.prototype.classification = v872;
    return Token$$1
  }
  function v868() {
    function SavedToken$$1(tok$$4, minChar$$32, limChar$$11) {
      this.tok = tok$$4;
      this.minChar = minChar$$32;
      this.limChar = limChar$$11;
      return
    }
    return SavedToken$$1
  }
  function v867(TokenClass$$1) {
    TokenClass$$1._map = [];
    TokenClass$$1._map[0] = "Punctuation";
    TokenClass$$1.Punctuation = 0;
    TokenClass$$1._map[1] = "Keyword";
    TokenClass$$1.Keyword = 1;
    TokenClass$$1._map[2] = "Operator";
    TokenClass$$1.Operator = 2;
    TokenClass$$1._map[3] = "Comment";
    TokenClass$$1.Comment = 3;
    TokenClass$$1._map[4] = "Whitespace";
    TokenClass$$1.Whitespace = 4;
    TokenClass$$1._map[5] = "Identifier";
    TokenClass$$1.Identifier = 5;
    TokenClass$$1._map[6] = "NumberLiteral";
    TokenClass$$1.NumberLiteral = 6;
    TokenClass$$1._map[7] = "StringLiteral";
    TokenClass$$1.StringLiteral = 7;
    TokenClass$$1._map[8] = "RegExpLiteral";
    TokenClass$$1.RegExpLiteral = 8;
    return
  }
  function v866() {
    function TokenInfo$$1(tokenId$$46, reservation$$1, binopPrecedence$$1, binopNodeType$$1, unopPrecedence$$1, unopNodeType$$1, text$$22, ers$$2) {
      this.tokenId = tokenId$$46;
      this.reservation = reservation$$1;
      this.binopPrecedence = binopPrecedence$$1;
      this.binopNodeType = binopNodeType$$1;
      this.unopPrecedence = unopPrecedence$$1;
      this.unopNodeType = unopNodeType$$1;
      this.text = text$$22;
      this.ers = ers$$2;
      return
    }
    return TokenInfo$$1
  }
  function v865(Reservation$$1) {
    Reservation$$1._map = [];
    Reservation$$1.None = 0;
    Reservation$$1.Javascript = 1;
    Reservation$$1.JavascriptFuture = 2;
    Reservation$$1.TypeScript = 4;
    Reservation$$1.JavascriptFutureStrict = 8;
    Reservation$$1.TypeScriptAndJS = Reservation$$1.Javascript | Reservation$$1.TypeScript;
    Reservation$$1.TypeScriptAndJSFuture = Reservation$$1.JavascriptFuture | Reservation$$1.TypeScript;
    Reservation$$1.TypeScriptAndJSFutureStrict = Reservation$$1.JavascriptFutureStrict | Reservation$$1.TypeScript;
    return
  }
  function v864(OperatorPrecedence$$1) {
    OperatorPrecedence$$1._map = [];
    OperatorPrecedence$$1._map[0] = "None";
    OperatorPrecedence$$1.None = 0;
    OperatorPrecedence$$1._map[1] = "Comma";
    OperatorPrecedence$$1.Comma = 1;
    OperatorPrecedence$$1._map[2] = "Assignment";
    OperatorPrecedence$$1.Assignment = 2;
    OperatorPrecedence$$1._map[3] = "Conditional";
    OperatorPrecedence$$1.Conditional = 3;
    OperatorPrecedence$$1._map[4] = "LogicalOr";
    OperatorPrecedence$$1.LogicalOr = 4;
    OperatorPrecedence$$1._map[5] = "LogicalAnd";
    OperatorPrecedence$$1.LogicalAnd = 5;
    OperatorPrecedence$$1._map[6] = "BitwiseOr";
    OperatorPrecedence$$1.BitwiseOr = 6;
    OperatorPrecedence$$1._map[7] = "BitwiseExclusiveOr";
    OperatorPrecedence$$1.BitwiseExclusiveOr = 7;
    OperatorPrecedence$$1._map[8] = "BitwiseAnd";
    OperatorPrecedence$$1.BitwiseAnd = 8;
    OperatorPrecedence$$1._map[9] = "Equality";
    OperatorPrecedence$$1.Equality = 9;
    OperatorPrecedence$$1._map[10] = "Relational";
    OperatorPrecedence$$1.Relational = 10;
    OperatorPrecedence$$1._map[11] = "Shift";
    OperatorPrecedence$$1.Shift = 11;
    OperatorPrecedence$$1._map[12] = "Additive";
    OperatorPrecedence$$1.Additive = 12;
    OperatorPrecedence$$1._map[13] = "Multiplicative";
    OperatorPrecedence$$1.Multiplicative = 13;
    OperatorPrecedence$$1._map[14] = "Unary";
    OperatorPrecedence$$1.Unary = 14;
    OperatorPrecedence$$1._map[15] = "Lim";
    OperatorPrecedence$$1.Lim = 15;
    return
  }
  function v863(TokenID$$1) {
    TokenID$$1._map = [];
    TokenID$$1._map[0] = "Any";
    TokenID$$1.Any = 0;
    TokenID$$1._map[1] = "Bool";
    TokenID$$1.Bool = 1;
    TokenID$$1._map[2] = "Break";
    TokenID$$1.Break = 2;
    TokenID$$1._map[3] = "Case";
    TokenID$$1.Case = 3;
    TokenID$$1._map[4] = "Catch";
    TokenID$$1.Catch = 4;
    TokenID$$1._map[5] = "Class";
    TokenID$$1.Class = 5;
    TokenID$$1._map[6] = "Const";
    TokenID$$1.Const = 6;
    TokenID$$1._map[7] = "Continue";
    TokenID$$1.Continue = 7;
    TokenID$$1._map[8] = "Debugger";
    TokenID$$1.Debugger = 8;
    TokenID$$1._map[9] = "Default";
    TokenID$$1.Default = 9;
    TokenID$$1._map[10] = "Delete";
    TokenID$$1.Delete = 10;
    TokenID$$1._map[11] = "Do";
    TokenID$$1.Do = 11;
    TokenID$$1._map[12] = "Else";
    TokenID$$1.Else = 12;
    TokenID$$1._map[13] = "Enum";
    TokenID$$1.Enum = 13;
    TokenID$$1._map[14] = "Export";
    TokenID$$1.Export = 14;
    TokenID$$1._map[15] = "Extends";
    TokenID$$1.Extends = 15;
    TokenID$$1._map[16] = "Declare";
    TokenID$$1.Declare = 16;
    TokenID$$1._map[17] = "False";
    TokenID$$1.False = 17;
    TokenID$$1._map[18] = "Finally";
    TokenID$$1.Finally = 18;
    TokenID$$1._map[19] = "For";
    TokenID$$1.For = 19;
    TokenID$$1._map[20] = "Function";
    TokenID$$1.Function = 20;
    TokenID$$1._map[21] = "Constructor";
    TokenID$$1.Constructor = 21;
    TokenID$$1._map[22] = "Get";
    TokenID$$1.Get = 22;
    TokenID$$1._map[23] = "If";
    TokenID$$1.If = 23;
    TokenID$$1._map[24] = "Implements";
    TokenID$$1.Implements = 24;
    TokenID$$1._map[25] = "Import";
    TokenID$$1.Import = 25;
    TokenID$$1._map[26] = "In";
    TokenID$$1.In = 26;
    TokenID$$1._map[27] = "InstanceOf";
    TokenID$$1.InstanceOf = 27;
    TokenID$$1._map[28] = "Interface";
    TokenID$$1.Interface = 28;
    TokenID$$1._map[29] = "Let";
    TokenID$$1.Let = 29;
    TokenID$$1._map[30] = "Module";
    TokenID$$1.Module = 30;
    TokenID$$1._map[31] = "New";
    TokenID$$1.New = 31;
    TokenID$$1._map[32] = "Number";
    TokenID$$1.Number = 32;
    TokenID$$1._map[33] = "Null";
    TokenID$$1.Null = 33;
    TokenID$$1._map[34] = "Package";
    TokenID$$1.Package = 34;
    TokenID$$1._map[35] = "Private";
    TokenID$$1.Private = 35;
    TokenID$$1._map[36] = "Protected";
    TokenID$$1.Protected = 36;
    TokenID$$1._map[37] = "Public";
    TokenID$$1.Public = 37;
    TokenID$$1._map[38] = "Return";
    TokenID$$1.Return = 38;
    TokenID$$1._map[39] = "Set";
    TokenID$$1.Set = 39;
    TokenID$$1._map[40] = "Static";
    TokenID$$1.Static = 40;
    TokenID$$1._map[41] = "String";
    TokenID$$1.String = 41;
    TokenID$$1._map[42] = "Super";
    TokenID$$1.Super = 42;
    TokenID$$1._map[43] = "Switch";
    TokenID$$1.Switch = 43;
    TokenID$$1._map[44] = "This";
    TokenID$$1.This = 44;
    TokenID$$1._map[45] = "Throw";
    TokenID$$1.Throw = 45;
    TokenID$$1._map[46] = "True";
    TokenID$$1.True = 46;
    TokenID$$1._map[47] = "Try";
    TokenID$$1.Try = 47;
    TokenID$$1._map[48] = "TypeOf";
    TokenID$$1.TypeOf = 48;
    TokenID$$1._map[49] = "Var";
    TokenID$$1.Var = 49;
    TokenID$$1._map[50] = "Void";
    TokenID$$1.Void = 50;
    TokenID$$1._map[51] = "With";
    TokenID$$1.With = 51;
    TokenID$$1._map[52] = "While";
    TokenID$$1.While = 52;
    TokenID$$1._map[53] = "Yield";
    TokenID$$1.Yield = 53;
    TokenID$$1._map[54] = "Semicolon";
    TokenID$$1.Semicolon = 54;
    TokenID$$1._map[55] = "OpenParen";
    TokenID$$1.OpenParen = 55;
    TokenID$$1._map[56] = "CloseParen";
    TokenID$$1.CloseParen = 56;
    TokenID$$1._map[57] = "OpenBracket";
    TokenID$$1.OpenBracket = 57;
    TokenID$$1._map[58] = "CloseBracket";
    TokenID$$1.CloseBracket = 58;
    TokenID$$1._map[59] = "OpenBrace";
    TokenID$$1.OpenBrace = 59;
    TokenID$$1._map[60] = "CloseBrace";
    TokenID$$1.CloseBrace = 60;
    TokenID$$1._map[61] = "Comma";
    TokenID$$1.Comma = 61;
    TokenID$$1._map[62] = "Equals";
    TokenID$$1.Equals = 62;
    TokenID$$1._map[63] = "PlusEquals";
    TokenID$$1.PlusEquals = 63;
    TokenID$$1._map[64] = "MinusEquals";
    TokenID$$1.MinusEquals = 64;
    TokenID$$1._map[65] = "AsteriskEquals";
    TokenID$$1.AsteriskEquals = 65;
    TokenID$$1._map[66] = "SlashEquals";
    TokenID$$1.SlashEquals = 66;
    TokenID$$1._map[67] = "PercentEquals";
    TokenID$$1.PercentEquals = 67;
    TokenID$$1._map[68] = "AmpersandEquals";
    TokenID$$1.AmpersandEquals = 68;
    TokenID$$1._map[69] = "CaretEquals";
    TokenID$$1.CaretEquals = 69;
    TokenID$$1._map[70] = "BarEquals";
    TokenID$$1.BarEquals = 70;
    TokenID$$1._map[71] = "LessThanLessThanEquals";
    TokenID$$1.LessThanLessThanEquals = 71;
    TokenID$$1._map[72] = "GreaterThanGreaterThanEquals";
    TokenID$$1.GreaterThanGreaterThanEquals = 72;
    TokenID$$1._map[73] = "GreaterThanGreaterThanGreaterThanEquals";
    TokenID$$1.GreaterThanGreaterThanGreaterThanEquals = 73;
    TokenID$$1._map[74] = "Question";
    TokenID$$1.Question = 74;
    TokenID$$1._map[75] = "Colon";
    TokenID$$1.Colon = 75;
    TokenID$$1._map[76] = "BarBar";
    TokenID$$1.BarBar = 76;
    TokenID$$1._map[77] = "AmpersandAmpersand";
    TokenID$$1.AmpersandAmpersand = 77;
    TokenID$$1._map[78] = "Bar";
    TokenID$$1.Bar = 78;
    TokenID$$1._map[79] = "Caret";
    TokenID$$1.Caret = 79;
    TokenID$$1._map[80] = "And";
    TokenID$$1.And = 80;
    TokenID$$1._map[81] = "EqualsEquals";
    TokenID$$1.EqualsEquals = 81;
    TokenID$$1._map[82] = "ExclamationEquals";
    TokenID$$1.ExclamationEquals = 82;
    TokenID$$1._map[83] = "EqualsEqualsEquals";
    TokenID$$1.EqualsEqualsEquals = 83;
    TokenID$$1._map[84] = "ExclamationEqualsEquals";
    TokenID$$1.ExclamationEqualsEquals = 84;
    TokenID$$1._map[85] = "LessThan";
    TokenID$$1.LessThan = 85;
    TokenID$$1._map[86] = "LessThanEquals";
    TokenID$$1.LessThanEquals = 86;
    TokenID$$1._map[87] = "GreaterThan";
    TokenID$$1.GreaterThan = 87;
    TokenID$$1._map[88] = "GreaterThanEquals";
    TokenID$$1.GreaterThanEquals = 88;
    TokenID$$1._map[89] = "LessThanLessThan";
    TokenID$$1.LessThanLessThan = 89;
    TokenID$$1._map[90] = "GreaterThanGreaterThan";
    TokenID$$1.GreaterThanGreaterThan = 90;
    TokenID$$1._map[91] = "GreaterThanGreaterThanGreaterThan";
    TokenID$$1.GreaterThanGreaterThanGreaterThan = 91;
    TokenID$$1._map[92] = "Plus";
    TokenID$$1.Plus = 92;
    TokenID$$1._map[93] = "Minus";
    TokenID$$1.Minus = 93;
    TokenID$$1._map[94] = "Asterisk";
    TokenID$$1.Asterisk = 94;
    TokenID$$1._map[95] = "Slash";
    TokenID$$1.Slash = 95;
    TokenID$$1._map[96] = "Percent";
    TokenID$$1.Percent = 96;
    TokenID$$1._map[97] = "Tilde";
    TokenID$$1.Tilde = 97;
    TokenID$$1._map[98] = "Exclamation";
    TokenID$$1.Exclamation = 98;
    TokenID$$1._map[99] = "PlusPlus";
    TokenID$$1.PlusPlus = 99;
    TokenID$$1._map[100] = "MinusMinus";
    TokenID$$1.MinusMinus = 100;
    TokenID$$1._map[101] = "Dot";
    TokenID$$1.Dot = 101;
    TokenID$$1._map[102] = "DotDotDot";
    TokenID$$1.DotDotDot = 102;
    TokenID$$1._map[103] = "Error";
    TokenID$$1.Error = 103;
    TokenID$$1._map[104] = "EndOfFile";
    TokenID$$1.EndOfFile = 104;
    TokenID$$1._map[105] = "EqualsGreaterThan";
    TokenID$$1.EqualsGreaterThan = 105;
    TokenID$$1._map[106] = "Identifier";
    TokenID$$1.Identifier = 106;
    TokenID$$1._map[107] = "StringLiteral";
    TokenID$$1.StringLiteral = 107;
    TokenID$$1._map[108] = "RegularExpressionLiteral";
    TokenID$$1.RegularExpressionLiteral = 108;
    TokenID$$1._map[109] = "NumberLiteral";
    TokenID$$1.NumberLiteral = 109;
    TokenID$$1._map[110] = "Whitespace";
    TokenID$$1.Whitespace = 110;
    TokenID$$1._map[111] = "Comment";
    TokenID$$1.Comment = 111;
    TokenID$$1._map[112] = "Lim";
    TokenID$$1.Lim = 112;
    TokenID$$1.LimFixed = TokenID$$1.EqualsGreaterThan;
    TokenID$$1.LimKeyword = TokenID$$1.Yield;
    return
  }
  function setTokenInfo(tokenId$$44, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text$$21, ers$$1) {
    if(tokenId$$44 !== undefined) {
      var v5806 = TypeScript$$22.tokenTable;
      var v5807 = tokenId$$44;
      var v26994 = JAM.new(TokenInfo, [tokenId$$44, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text$$21, ers$$1]);
      JAM.set(v5806, v5807, v26994);
      if(binopNodeType != TypeScript$$22.NodeType.None) {
        JAM.set(TypeScript$$22.nodeTypeTable, binopNodeType, text$$21);
        JAM.set(TypeScript$$22.nodeTypeToTokTable, binopNodeType, tokenId$$44)
      }
      if(unopNodeType != TypeScript$$22.NodeType.None) {
        JAM.set(TypeScript$$22.nodeTypeTable, unopNodeType, text$$21)
      }
    }
    return
  }
  function lookupToken(tokenId$$45) {
    var v5814 = TypeScript$$22.tokenTable;
    introspect(JAM.policy.p1) {
      return v5814[tokenId$$45]
    }
  }
  function initializeStaticTokens() {
    var i$$73 = 0;
    var v5817 = i$$73 <= TokenID.LimFixed;
    for(;v5817;) {
      var v5815 = TypeScript$$22.staticTokens;
      var v5816 = i$$73;
      var v26995 = JAM.new(Token, [i$$73]);
      v5815[v5816] = v26995;
      i$$73 = i$$73 + 1;
      v5817 = i$$73 <= TokenID.LimFixed
    }
    return
  }
  var v14870 = TypeScript$$22.TokenID;
  if(!v14870) {
    v14870 = TypeScript$$22.TokenID = {}
  }
  v863(v14870);
  var TokenID = TypeScript$$22.TokenID;
  var v5819 = TypeScript$$22;
  var v26996 = new Array;
  v5819.tokenTable = v26996;
  var v5820 = TypeScript$$22;
  var v26997 = new Array;
  v5820.nodeTypeTable = v26997;
  var v5821 = TypeScript$$22;
  var v26998 = new Array;
  v5821.nodeTypeToTokTable = v26998;
  var v5822 = TypeScript$$22;
  var v26999 = new Array;
  v5822.noRegexTable = v26999;
  JAM.set(TypeScript$$22.noRegexTable, TokenID.Identifier, true);
  JAM.set(TypeScript$$22.noRegexTable, TokenID.StringLiteral, true);
  JAM.set(TypeScript$$22.noRegexTable, TokenID.NumberLiteral, true);
  JAM.set(TypeScript$$22.noRegexTable, TokenID.RegularExpressionLiteral, true);
  JAM.set(TypeScript$$22.noRegexTable, TokenID.This, true);
  JAM.set(TypeScript$$22.noRegexTable, TokenID.PlusPlus, true);
  JAM.set(TypeScript$$22.noRegexTable, TokenID.MinusMinus, true);
  JAM.set(TypeScript$$22.noRegexTable, TokenID.CloseParen, true);
  JAM.set(TypeScript$$22.noRegexTable, TokenID.CloseBracket, true);
  JAM.set(TypeScript$$22.noRegexTable, TokenID.CloseBrace, true);
  JAM.set(TypeScript$$22.noRegexTable, TokenID.True, true);
  JAM.set(TypeScript$$22.noRegexTable, TokenID.False, true);
  var v14871 = TypeScript$$22.OperatorPrecedence;
  if(!v14871) {
    v14871 = TypeScript$$22.OperatorPrecedence = {}
  }
  v864(v14871);
  var OperatorPrecedence = TypeScript$$22.OperatorPrecedence;
  var v14872 = TypeScript$$22.Reservation;
  if(!v14872) {
    v14872 = TypeScript$$22.Reservation = {}
  }
  v865(v14872);
  var Reservation = TypeScript$$22.Reservation;
  var TokenInfo = v866();
  TypeScript$$22.TokenInfo = TokenInfo;
  setTokenInfo(TokenID.Any, Reservation.TypeScript, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "any", TypeScript$$22.ErrorRecoverySet.PrimType);
  setTokenInfo(TokenID.Bool, Reservation.TypeScript, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "bool", TypeScript$$22.ErrorRecoverySet.PrimType);
  setTokenInfo(TokenID.Break, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "break", TypeScript$$22.ErrorRecoverySet.Stmt);
  setTokenInfo(TokenID.Case, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "case", TypeScript$$22.ErrorRecoverySet.SCase);
  setTokenInfo(TokenID.Catch, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "catch", TypeScript$$22.ErrorRecoverySet.Catch);
  setTokenInfo(TokenID.Class, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "class", TypeScript$$22.ErrorRecoverySet.TypeScriptS);
  setTokenInfo(TokenID.Const, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "const", TypeScript$$22.ErrorRecoverySet.Var);
  setTokenInfo(TokenID.Continue, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "continue", TypeScript$$22.ErrorRecoverySet.Stmt);
  setTokenInfo(TokenID.Debugger, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.Debugger, "debugger", TypeScript$$22.ErrorRecoverySet.Stmt);
  setTokenInfo(TokenID.Default, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "default", TypeScript$$22.ErrorRecoverySet.SCase);
  setTokenInfo(TokenID.Delete, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.Unary, TypeScript$$22.NodeType.Delete, "delete", TypeScript$$22.ErrorRecoverySet.Prefix);
  setTokenInfo(TokenID.Do, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "do", TypeScript$$22.ErrorRecoverySet.Stmt);
  setTokenInfo(TokenID.Else, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "else", TypeScript$$22.ErrorRecoverySet.Else);
  setTokenInfo(TokenID.Enum, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "enum", TypeScript$$22.ErrorRecoverySet.TypeScriptS);
  setTokenInfo(TokenID.Export, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "export", TypeScript$$22.ErrorRecoverySet.TypeScriptS);
  setTokenInfo(TokenID.Extends, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "extends", TypeScript$$22.ErrorRecoverySet.None);
  setTokenInfo(TokenID.Declare, Reservation.TypeScript, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "declare", TypeScript$$22.ErrorRecoverySet.Stmt);
  setTokenInfo(TokenID.False, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "false", TypeScript$$22.ErrorRecoverySet.RLit);
  setTokenInfo(TokenID.Finally, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "finally", TypeScript$$22.ErrorRecoverySet.Catch);
  setTokenInfo(TokenID.For, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "for", TypeScript$$22.ErrorRecoverySet.Stmt);
  setTokenInfo(TokenID.Function, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "function", TypeScript$$22.ErrorRecoverySet.Func);
  setTokenInfo(TokenID.Constructor, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "constructor", TypeScript$$22.ErrorRecoverySet.Func);
  setTokenInfo(TokenID.Get, Reservation.TypeScript, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "get", TypeScript$$22.ErrorRecoverySet.Func);
  setTokenInfo(TokenID.Set, Reservation.TypeScript, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "set", TypeScript$$22.ErrorRecoverySet.Func);
  setTokenInfo(TokenID.If, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "if", TypeScript$$22.ErrorRecoverySet.Stmt);
  setTokenInfo(TokenID.Implements, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "implements", TypeScript$$22.ErrorRecoverySet.None);
  setTokenInfo(TokenID.Import, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "import", TypeScript$$22.ErrorRecoverySet.TypeScriptS);
  setTokenInfo(TokenID.In, Reservation.TypeScriptAndJS, OperatorPrecedence.Relational, TypeScript$$22.NodeType.In, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "in", TypeScript$$22.ErrorRecoverySet.None);
  setTokenInfo(TokenID.InstanceOf, Reservation.TypeScriptAndJS, OperatorPrecedence.Relational, TypeScript$$22.NodeType.InstOf, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "instanceof", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.Interface, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "interface", TypeScript$$22.ErrorRecoverySet.TypeScriptS);
  setTokenInfo(TokenID.Let, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "let", TypeScript$$22.ErrorRecoverySet.None);
  setTokenInfo(TokenID.Module, Reservation.TypeScript, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "module", TypeScript$$22.ErrorRecoverySet.TypeScriptS);
  setTokenInfo(TokenID.New, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "new", TypeScript$$22.ErrorRecoverySet.PreOp);
  setTokenInfo(TokenID.Number, Reservation.TypeScript, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "number", TypeScript$$22.ErrorRecoverySet.PrimType);
  setTokenInfo(TokenID.Null, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "null", TypeScript$$22.ErrorRecoverySet.RLit);
  setTokenInfo(TokenID.Package, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "package", TypeScript$$22.ErrorRecoverySet.None);
  setTokenInfo(TokenID.Private, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "private", TypeScript$$22.ErrorRecoverySet.TypeScriptS);
  setTokenInfo(TokenID.Protected, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "protected", TypeScript$$22.ErrorRecoverySet.None);
  setTokenInfo(TokenID.Public, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "public", TypeScript$$22.ErrorRecoverySet.TypeScriptS);
  setTokenInfo(TokenID.Return, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "return", TypeScript$$22.ErrorRecoverySet.Stmt);
  setTokenInfo(TokenID.Static, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "static", TypeScript$$22.ErrorRecoverySet.None);
  setTokenInfo(TokenID.String, Reservation.TypeScript, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "string", TypeScript$$22.ErrorRecoverySet.PrimType);
  setTokenInfo(TokenID.Super, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "super", TypeScript$$22.ErrorRecoverySet.RLit);
  setTokenInfo(TokenID.Switch, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "switch", TypeScript$$22.ErrorRecoverySet.Stmt);
  setTokenInfo(TokenID.This, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "this", TypeScript$$22.ErrorRecoverySet.RLit);
  setTokenInfo(TokenID.Throw, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "throw", TypeScript$$22.ErrorRecoverySet.Stmt);
  setTokenInfo(TokenID.True, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "true", TypeScript$$22.ErrorRecoverySet.RLit);
  setTokenInfo(TokenID.Try, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "try", TypeScript$$22.ErrorRecoverySet.Stmt);
  setTokenInfo(TokenID.TypeOf, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.Unary, TypeScript$$22.NodeType.Typeof, "typeof", TypeScript$$22.ErrorRecoverySet.Prefix);
  setTokenInfo(TokenID.Var, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "var", TypeScript$$22.ErrorRecoverySet.Var);
  setTokenInfo(TokenID.Void, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.Unary, TypeScript$$22.NodeType.Void, "void", TypeScript$$22.ErrorRecoverySet.Prefix);
  setTokenInfo(TokenID.With, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.With, "with", TypeScript$$22.ErrorRecoverySet.Stmt);
  setTokenInfo(TokenID.While, Reservation.TypeScriptAndJS, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "while", TypeScript$$22.ErrorRecoverySet.While);
  setTokenInfo(TokenID.Yield, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "yield", TypeScript$$22.ErrorRecoverySet.None);
  setTokenInfo(TokenID.Identifier, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "identifier", TypeScript$$22.ErrorRecoverySet.ID);
  setTokenInfo(TokenID.NumberLiteral, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "numberLiteral", TypeScript$$22.ErrorRecoverySet.Literal);
  setTokenInfo(TokenID.RegularExpressionLiteral, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "regex", TypeScript$$22.ErrorRecoverySet.RegExp);
  setTokenInfo(TokenID.StringLiteral, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "qstring", TypeScript$$22.ErrorRecoverySet.Literal);
  setTokenInfo(TokenID.Semicolon, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, ";", TypeScript$$22.ErrorRecoverySet.SColon);
  setTokenInfo(TokenID.CloseParen, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, ")", TypeScript$$22.ErrorRecoverySet.RParen);
  setTokenInfo(TokenID.CloseBracket, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "]", TypeScript$$22.ErrorRecoverySet.RBrack);
  setTokenInfo(TokenID.OpenBrace, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "{", TypeScript$$22.ErrorRecoverySet.LCurly);
  setTokenInfo(TokenID.CloseBrace, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "}", TypeScript$$22.ErrorRecoverySet.RCurly);
  setTokenInfo(TokenID.DotDotDot, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "...", TypeScript$$22.ErrorRecoverySet.None);
  setTokenInfo(TokenID.Comma, Reservation.None, OperatorPrecedence.Comma, TypeScript$$22.NodeType.Comma, OperatorPrecedence.None, TypeScript$$22.NodeType.None, ",", TypeScript$$22.ErrorRecoverySet.Comma);
  setTokenInfo(TokenID.Equals, Reservation.None, OperatorPrecedence.Assignment, TypeScript$$22.NodeType.Asg, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "=", TypeScript$$22.ErrorRecoverySet.Asg);
  setTokenInfo(TokenID.PlusEquals, Reservation.None, OperatorPrecedence.Assignment, TypeScript$$22.NodeType.AsgAdd, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "+=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.MinusEquals, Reservation.None, OperatorPrecedence.Assignment, TypeScript$$22.NodeType.AsgSub, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "-=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.AsteriskEquals, Reservation.None, OperatorPrecedence.Assignment, TypeScript$$22.NodeType.AsgMul, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "*=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.SlashEquals, Reservation.None, OperatorPrecedence.Assignment, TypeScript$$22.NodeType.AsgDiv, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "/=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.PercentEquals, Reservation.None, OperatorPrecedence.Assignment, TypeScript$$22.NodeType.AsgMod, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "%=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.AmpersandEquals, Reservation.None, OperatorPrecedence.Assignment, TypeScript$$22.NodeType.AsgAnd, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "&=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.CaretEquals, Reservation.None, OperatorPrecedence.Assignment, TypeScript$$22.NodeType.AsgXor, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "^=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.BarEquals, Reservation.None, OperatorPrecedence.Assignment, TypeScript$$22.NodeType.AsgOr, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "|=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.LessThanLessThanEquals, Reservation.None, OperatorPrecedence.Assignment, TypeScript$$22.NodeType.AsgLsh, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "<<=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.GreaterThanGreaterThanEquals, Reservation.None, OperatorPrecedence.Assignment, TypeScript$$22.NodeType.AsgRsh, OperatorPrecedence.None, TypeScript$$22.NodeType.None, ">>=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThanEquals, Reservation.None, OperatorPrecedence.Assignment, TypeScript$$22.NodeType.AsgRs2, OperatorPrecedence.None, TypeScript$$22.NodeType.None, ">>>=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.Question, Reservation.None, OperatorPrecedence.Conditional, TypeScript$$22.NodeType.ConditionalExpression, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "?", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.Colon, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, ":", TypeScript$$22.ErrorRecoverySet.Colon);
  setTokenInfo(TokenID.BarBar, Reservation.None, OperatorPrecedence.LogicalOr, TypeScript$$22.NodeType.LogOr, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "||", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.AmpersandAmpersand, Reservation.None, OperatorPrecedence.LogicalAnd, TypeScript$$22.NodeType.LogAnd, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "&&", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.Bar, Reservation.None, OperatorPrecedence.BitwiseOr, TypeScript$$22.NodeType.Or, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "|", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.Caret, Reservation.None, OperatorPrecedence.BitwiseExclusiveOr, TypeScript$$22.NodeType.Xor, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "^", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.And, Reservation.None, OperatorPrecedence.BitwiseAnd, TypeScript$$22.NodeType.And, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "&", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.EqualsEquals, Reservation.None, OperatorPrecedence.Equality, TypeScript$$22.NodeType.Eq, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "==", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.ExclamationEquals, Reservation.None, OperatorPrecedence.Equality, TypeScript$$22.NodeType.Ne, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "!=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.EqualsEqualsEquals, Reservation.None, OperatorPrecedence.Equality, TypeScript$$22.NodeType.Eqv, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "===", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.ExclamationEqualsEquals, Reservation.None, OperatorPrecedence.Equality, TypeScript$$22.NodeType.NEqv, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "!==", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.LessThan, Reservation.None, OperatorPrecedence.Relational, TypeScript$$22.NodeType.Lt, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "<", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.LessThanEquals, Reservation.None, OperatorPrecedence.Relational, TypeScript$$22.NodeType.Le, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "<=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.GreaterThan, Reservation.None, OperatorPrecedence.Relational, TypeScript$$22.NodeType.Gt, OperatorPrecedence.None, TypeScript$$22.NodeType.None, ">", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.GreaterThanEquals, Reservation.None, OperatorPrecedence.Relational, TypeScript$$22.NodeType.Ge, OperatorPrecedence.None, TypeScript$$22.NodeType.None, ">=", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.LessThanLessThan, Reservation.None, OperatorPrecedence.Shift, TypeScript$$22.NodeType.Lsh, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "<<", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.GreaterThanGreaterThan, Reservation.None, OperatorPrecedence.Shift, TypeScript$$22.NodeType.Rsh, OperatorPrecedence.None, TypeScript$$22.NodeType.None, ">>", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThan, Reservation.None, OperatorPrecedence.Shift, TypeScript$$22.NodeType.Rs2, OperatorPrecedence.None, TypeScript$$22.NodeType.None, ">>>", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.Plus, Reservation.None, OperatorPrecedence.Additive, TypeScript$$22.NodeType.Add, OperatorPrecedence.Unary, TypeScript$$22.NodeType.Pos, "+", TypeScript$$22.ErrorRecoverySet.AddOp);
  setTokenInfo(TokenID.Minus, Reservation.None, OperatorPrecedence.Additive, TypeScript$$22.NodeType.Sub, OperatorPrecedence.Unary, TypeScript$$22.NodeType.Neg, "-", TypeScript$$22.ErrorRecoverySet.AddOp);
  setTokenInfo(TokenID.Asterisk, Reservation.None, OperatorPrecedence.Multiplicative, TypeScript$$22.NodeType.Mul, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "*", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.Slash, Reservation.None, OperatorPrecedence.Multiplicative, TypeScript$$22.NodeType.Div, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "/", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.Percent, Reservation.None, OperatorPrecedence.Multiplicative, TypeScript$$22.NodeType.Mod, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "%", TypeScript$$22.ErrorRecoverySet.BinOp);
  setTokenInfo(TokenID.Tilde, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.Unary, TypeScript$$22.NodeType.Not, "~", TypeScript$$22.ErrorRecoverySet.PreOp);
  setTokenInfo(TokenID.Exclamation, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.Unary, TypeScript$$22.NodeType.LogNot, "!", TypeScript$$22.ErrorRecoverySet.PreOp);
  setTokenInfo(TokenID.PlusPlus, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.Unary, TypeScript$$22.NodeType.IncPre, "++", TypeScript$$22.ErrorRecoverySet.PreOp);
  setTokenInfo(TokenID.MinusMinus, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.Unary, TypeScript$$22.NodeType.DecPre, "--", TypeScript$$22.ErrorRecoverySet.PreOp);
  setTokenInfo(TokenID.OpenParen, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "(", TypeScript$$22.ErrorRecoverySet.LParen);
  setTokenInfo(TokenID.OpenBracket, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "[", TypeScript$$22.ErrorRecoverySet.LBrack);
  setTokenInfo(TokenID.Dot, Reservation.None, OperatorPrecedence.Unary, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, ".", TypeScript$$22.ErrorRecoverySet.Dot);
  setTokenInfo(TokenID.EndOfFile, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "<EOF>", TypeScript$$22.ErrorRecoverySet.EOF);
  setTokenInfo(TokenID.EqualsGreaterThan, Reservation.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, OperatorPrecedence.None, TypeScript$$22.NodeType.None, "=>", TypeScript$$22.ErrorRecoverySet.None);
  TypeScript$$22.lookupToken = lookupToken;
  var v15200 = TypeScript$$22.TokenClass;
  if(!v15200) {
    v15200 = TypeScript$$22.TokenClass = {}
  }
  v867(v15200);
  var TokenClass = TypeScript$$22.TokenClass;
  var SavedToken = v868();
  TypeScript$$22.SavedToken = SavedToken;
  var Token = v873();
  TypeScript$$22.Token = Token;
  var NumberLiteralToken = v876(Token);
  TypeScript$$22.NumberLiteralToken = NumberLiteralToken;
  var StringLiteralToken = v879(Token);
  TypeScript$$22.StringLiteralToken = StringLiteralToken;
  var IdentifierToken = v882(Token);
  TypeScript$$22.IdentifierToken = IdentifierToken;
  var WhitespaceToken = v885(Token);
  TypeScript$$22.WhitespaceToken = WhitespaceToken;
  var CommentToken = v888(Token);
  TypeScript$$22.CommentToken = CommentToken;
  var RegularExpressionLiteralToken = v891(Token);
  TypeScript$$22.RegularExpressionLiteralToken = RegularExpressionLiteralToken;
  var v6613 = TypeScript$$22;
  var v27000 = new Array;
  v6613.staticTokens = v27000;
  TypeScript$$22.initializeStaticTokens = initializeStaticTokens;
  return
}
function v862(TypeScript$$21) {
  function v861(_super$$58) {
    function v860(name$$79, publicOnly$$23, typespace$$23) {
      var v6614 = _super$$58.prototype.findLocal;
      var sym$$27 = JAM.call(v6614.call, v6614, [this, name$$79, publicOnly$$23, typespace$$23]);
      if(sym$$27) {
        if(!JAM.call(this.filter, this, [sym$$27])) {
          return null
        }
      }
      var v6616 = _super$$58.prototype.find;
      return JAM.call(v6616.call, v6616, [this, name$$79, publicOnly$$23, typespace$$23])
    }
    function v859(filter$$6, name$$78, publicOnly$$22, typespace$$22) {
      throw new Error("please implement");
    }
    function v858(name$$77, publicOnly$$21, typespace$$21) {
      var v6617 = _super$$58.prototype.findLocal;
      var sym$$26 = JAM.call(v6617.call, v6617, [this, name$$77, publicOnly$$21, typespace$$21]);
      if(sym$$26) {
        if(!JAM.call(this.filter, this, [sym$$26])) {
          return null
        }
      }
      return sym$$26
    }
    function FilteredSymbolScopeBuilder$$1(valueMembers$$3, parent$$51, container$$10, filter$$5) {
      JAM.call(_super$$58.call, _super$$58, [this, valueMembers$$3, null, null, null, parent$$51, container$$10]);
      this.filter = filter$$5;
      return
    }
    JAM.call(__extends, null, [FilteredSymbolScopeBuilder$$1, _super$$58]);
    FilteredSymbolScopeBuilder$$1.prototype.findLocal = v858;
    FilteredSymbolScopeBuilder$$1.prototype.search = v859;
    FilteredSymbolScopeBuilder$$1.prototype.find = v860;
    return FilteredSymbolScopeBuilder$$1
  }
  function v857(_super$$57) {
    function v856(name$$76, publicOnly$$20, typespace$$20) {
      var v6622 = this.scope;
      return JAM.call(v6622.findLocal, v6622, [name$$76, publicOnly$$20, typespace$$20])
    }
    function v855(name$$75, publicOnly$$19, typespace$$19) {
      this.filter.reset();
      var v6624 = this.scope;
      return JAM.call(v6624.search, v6624, [this.filter, name$$75, publicOnly$$19, typespace$$19])
    }
    function v854(outfile$$10) {
      var v6626 = this.scope;
      JAM.call(v6626.print, v6626, [outfile$$10]);
      return
    }
    function FilteredSymbolScope$$1(scope$$21, container$$9, filter$$4) {
      JAM.call(_super$$57.call, _super$$57, [this, container$$9]);
      this.scope = scope$$21;
      this.filter = filter$$4;
      return
    }
    JAM.call(__extends, null, [FilteredSymbolScope$$1, _super$$57]);
    FilteredSymbolScope$$1.prototype.print = v854;
    FilteredSymbolScope$$1.prototype.find = v855;
    FilteredSymbolScope$$1.prototype.findLocal = v856;
    return FilteredSymbolScope$$1
  }
  function v853(_super$$56) {
    function v852() {
      return this.valueMembers.allMembers
    }
    function v851(container$$8, ast$$61, symbol$$7, errorReporter$$3, insertAsPublic, typespace$$18, ambient$$1) {
      var table$$6 = null;
      if(ambient$$1) {
        if(typespace$$18) {
          var v6631;
          if(this.ambientEnclosedTypes == null) {
            v6631 = null
          }else {
            var v15206;
            if(insertAsPublic) {
              v15206 = this.ambientEnclosedTypes.publicMembers
            }else {
              v15206 = this.ambientEnclosedTypes.privateMembers
            }
            v6631 = v15206
          }
          table$$6 = v6631
        }else {
          var v6632;
          if(this.ambientValueMembers == null) {
            v6632 = null
          }else {
            var v15208;
            if(insertAsPublic) {
              v15208 = this.ambientValueMembers.publicMembers
            }else {
              v15208 = this.ambientValueMembers.privateMembers
            }
            v6632 = v15208
          }
          table$$6 = v6632
        }
      }else {
        if(typespace$$18) {
          var v6633;
          if(this.enclosedTypes == null) {
            v6633 = null
          }else {
            var v15210;
            if(insertAsPublic) {
              v15210 = this.enclosedTypes.publicMembers
            }else {
              v15210 = this.enclosedTypes.privateMembers
            }
            v6633 = v15210
          }
          table$$6 = v6633
        }else {
          var v6634;
          if(this.valueMembers == null) {
            v6634 = null
          }else {
            var v15212;
            if(insertAsPublic) {
              v15212 = this.valueMembers.publicMembers
            }else {
              v15212 = this.valueMembers.privateMembers
            }
            v6634 = v15212
          }
          table$$6 = v6634
        }
      }
      if(table$$6) {
        if(!JAM.call(table$$6.add, table$$6, [symbol$$7.name, symbol$$7])) {
          JAM.call(errorReporter$$3.duplicateIdentifier, errorReporter$$3, [ast$$61, symbol$$7.name])
        }
      }else {
        var v6637 = TypeScript$$21.CompilerDiagnostics;
        JAM.call(v6637.Alert, v6637, ["YYYYY"])
      }
      symbol$$7.container = container$$8;
      return
    }
    function v850(name$$74, publicOnly$$18, typespace$$17) {
      var sym$$25 = null;
      var v6638;
      if(this.valueMembers == null) {
        v6638 = null
      }else {
        var v15215;
        if(publicOnly$$18) {
          v15215 = this.valueMembers.publicMembers
        }else {
          v15215 = this.valueMembers.allMembers
        }
        v6638 = v15215
      }
      var table$$5 = v6638;
      var v6639;
      if(this.ambientValueMembers == null) {
        v6639 = null
      }else {
        var v15217;
        if(publicOnly$$18) {
          v15217 = this.ambientValueMembers.publicMembers
        }else {
          v15217 = this.ambientValueMembers.allMembers
        }
        v6639 = v15217
      }
      var ambientTable$$5 = v6639;
      if(typespace$$17) {
        var v6640;
        if(this.enclosedTypes == null) {
          v6640 = null
        }else {
          var v15219;
          if(publicOnly$$18) {
            v15219 = this.enclosedTypes.publicMembers
          }else {
            v15219 = this.enclosedTypes.allMembers
          }
          v6640 = v15219
        }
        table$$5 = v6640;
        var v6641;
        if(this.ambientEnclosedTypes == null) {
          v6641 = null
        }else {
          var v15221;
          if(publicOnly$$18) {
            v15221 = this.ambientEnclosedTypes.publicMembers
          }else {
            v15221 = this.ambientEnclosedTypes.allMembers
          }
          v6641 = v15221
        }
        ambientTable$$5 = v6641
      }
      if(table$$5) {
        if((sym$$25 = JAM.call(table$$5.lookup, table$$5, [name$$74])) != null) {
          if(sym$$25) {
            return sym$$25
          }
        }
      }
      if(ambientTable$$5) {
        if((sym$$25 = JAM.call(ambientTable$$5.lookup, ambientTable$$5, [name$$74])) != null) {
          if(sym$$25) {
            return sym$$25
          }
        }
      }
      return null
    }
    function v849(name$$73, publicOnly$$17, typespace$$16) {
      var sym$$24 = null;
      var v6644;
      if(this.ambientValueMembers == null) {
        v6644 = null
      }else {
        var v15225;
        if(publicOnly$$17) {
          v15225 = this.ambientValueMembers.publicMembers
        }else {
          v15225 = this.ambientValueMembers.allMembers
        }
        v6644 = v15225
      }
      var ambientTable$$4 = v6644;
      if(typespace$$16) {
        var v6645;
        if(this.ambientEnclosedTypes == null) {
          v6645 = null
        }else {
          var v15227;
          if(publicOnly$$17) {
            v15227 = this.ambientEnclosedTypes.publicMembers
          }else {
            v15227 = this.ambientEnclosedTypes.allMembers
          }
          v6645 = v15227
        }
        ambientTable$$4 = v6645
      }
      var v15229 = ambientTable$$4;
      if(v15229) {
        v15229 = (sym$$24 = JAM.call(ambientTable$$4.lookup, ambientTable$$4, [name$$73])) != null
      }
      if(v15229) {
        return sym$$24
      }
      if(this.parent) {
        var v6647 = this.parent;
        return JAM.call(v6647.findAmbient, v6647, [name$$73, publicOnly$$17, typespace$$16])
      }
      return null
    }
    function v848(name$$72, publicOnly$$16, typespace$$15) {
      var sym$$23 = null;
      var v6649;
      if(this.valueMembers == null) {
        v6649 = null
      }else {
        var v15230;
        if(publicOnly$$16) {
          v15230 = this.valueMembers.publicMembers
        }else {
          v15230 = this.valueMembers.allMembers
        }
        v6649 = v15230
      }
      var table$$4 = v6649;
      var v6650;
      if(this.ambientValueMembers == null) {
        v6650 = null
      }else {
        var v15232;
        if(publicOnly$$16) {
          v15232 = this.ambientValueMembers.publicMembers
        }else {
          v15232 = this.ambientValueMembers.allMembers
        }
        v6650 = v15232
      }
      var ambientTable$$3 = v6650;
      if(typespace$$15) {
        var v6651;
        if(this.enclosedTypes == null) {
          v6651 = null
        }else {
          var v15234;
          if(publicOnly$$16) {
            v15234 = this.enclosedTypes.publicMembers
          }else {
            v15234 = this.enclosedTypes.allMembers
          }
          v6651 = v15234
        }
        table$$4 = v6651;
        var v6652;
        if(this.ambientEnclosedTypes == null) {
          v6652 = null
        }else {
          var v15236;
          if(publicOnly$$16) {
            v15236 = this.ambientEnclosedTypes.publicMembers
          }else {
            v15236 = this.ambientEnclosedTypes.allMembers
          }
          v6652 = v15236
        }
        ambientTable$$3 = v6652
      }
      var v15238 = ambientTable$$3;
      if(v15238) {
        v15238 = (sym$$23 = JAM.call(ambientTable$$3.lookup, ambientTable$$3, [name$$72])) != null
      }
      if(v15238) {
        return sym$$23
      }
      var v15239 = table$$4;
      if(v15239) {
        v15239 = (sym$$23 = JAM.call(table$$4.lookup, table$$4, [name$$72])) != null
      }
      if(v15239) {
        return sym$$23
      }
      if(this.parent) {
        var v6655 = this.parent;
        return JAM.call(v6655.find, v6655, [name$$72, publicOnly$$16, typespace$$15])
      }
      return null
    }
    function v847(outfile$$9) {
      function v846(key$$42, s$$23, context$$48) {
        var sym$$22 = s$$23;
        JAM.call(outfile$$9.WriteLine, outfile$$9, ["  " + key$$42]);
        return
      }
      function v845(key$$41, s$$22, context$$47) {
        var sym$$21 = s$$22;
        JAM.call(outfile$$9.WriteLine, outfile$$9, ["  " + key$$41]);
        return
      }
      function v844(key$$40, s$$21, context$$46) {
        var sym$$20 = s$$21;
        JAM.call(outfile$$9.WriteLine, outfile$$9, ["  " + key$$40]);
        return
      }
      function v843(key$$39, s$$20, context$$45) {
        var sym$$19 = s$$20;
        JAM.call(outfile$$9.WriteLine, outfile$$9, ["  " + key$$39]);
        return
      }
      var v6661 = _super$$56.prototype.print;
      JAM.call(v6661.call, v6661, [this, outfile$$9]);
      if(this.ambientValueMembers) {
        var v6662 = this.ambientValueMembers.allMembers;
        JAM.call(v6662.map, v6662, [v843, null])
      }
      if(this.valueMembers) {
        var v6664 = this.valueMembers.allMembers;
        JAM.call(v6664.map, v6664, [v844, null])
      }
      if(this.ambientEnclosedTypes) {
        var v6666 = this.ambientEnclosedTypes.allMembers;
        JAM.call(v6666.map, v6666, [v845, null])
      }
      if(this.enclosedTypes) {
        var v6668 = this.enclosedTypes.allMembers;
        JAM.call(v6668.map, v6668, [v846, null])
      }
      if(this.parent) {
        var v6670 = this.parent;
        JAM.call(v6670.print, v6670, [outfile$$9])
      }
      return
    }
    function v842(filter$$3, name$$71, publicOnly$$15, typespace$$14) {
      var sym$$18 = null;
      var v6672;
      if(this.valueMembers == null) {
        v6672 = null
      }else {
        var v15245;
        if(publicOnly$$15) {
          v15245 = this.valueMembers.publicMembers
        }else {
          v15245 = this.valueMembers.allMembers
        }
        v6672 = v15245
      }
      var table$$3 = v6672;
      var v6673;
      if(this.ambientValueMembers == null) {
        v6673 = null
      }else {
        var v15247;
        if(publicOnly$$15) {
          v15247 = this.ambientValueMembers.publicMembers
        }else {
          v15247 = this.ambientValueMembers.allMembers
        }
        v6673 = v15247
      }
      var ambientTable$$2 = v6673;
      if(typespace$$14) {
        var v6674;
        if(this.enclosedTypes == null) {
          v6674 = null
        }else {
          var v15249;
          if(publicOnly$$15) {
            v15249 = this.enclosedTypes.publicMembers
          }else {
            v15249 = this.enclosedTypes.allMembers
          }
          v6674 = v15249
        }
        table$$3 = v6674;
        var v6675;
        if(this.ambientEnclosedTypes == null) {
          v6675 = null
        }else {
          var v15251;
          if(publicOnly$$15) {
            v15251 = this.ambientEnclosedTypes.publicMembers
          }else {
            v15251 = this.ambientEnclosedTypes.allMembers
          }
          v6675 = v15251
        }
        ambientTable$$2 = v6675
      }
      if(ambientTable$$2) {
        if((sym$$18 = JAM.call(ambientTable$$2.lookup, ambientTable$$2, [name$$71])) != null) {
          if(JAM.call(filter$$3.update, filter$$3, [sym$$18])) {
            return sym$$18
          }
        }
      }
      if(table$$3) {
        if((sym$$18 = JAM.call(table$$3.lookup, table$$3, [name$$71])) != null) {
          if(JAM.call(filter$$3.update, filter$$3, [sym$$18])) {
            return sym$$18
          }
        }
      }
      if(this.parent) {
        var v6680 = this.parent;
        sym$$18 = JAM.call(v6680.search, v6680, [filter$$3, name$$71, publicOnly$$15, typespace$$14]);
        if(sym$$18) {
          if(JAM.call(filter$$3.update, filter$$3, [sym$$18])) {
            return sym$$18
          }
        }
      }
      return filter$$3.result
    }
    function v841(members$$24) {
      var result$$26 = [];
      if(this.ambientValueMembers) {
        result$$26 = result$$26.concat(this.ambientValueMembers.allMembers.getAllKeys())
      }
      if(this.valueMembers) {
        result$$26 = result$$26.concat(this.valueMembers.allMembers.getAllKeys())
      }
      var v15257 = !members$$24;
      if(v15257) {
        v15257 = this.parent
      }
      if(v15257) {
        var v6687 = this.parent;
        var parentResult$$4 = JAM.call(v6687.getAllValueSymbolNames, v6687, [members$$24]);
        if(parentResult$$4) {
          result$$26 = result$$26.concat(parentResult$$4)
        }
      }
      return result$$26
    }
    function v840(members$$23) {
      var result$$25 = [];
      if(this.ambientEnclosedTypes) {
        result$$25 = result$$25.concat(this.ambientEnclosedTypes.allMembers.getAllKeys())
      }
      if(this.enclosedTypes) {
        result$$25 = result$$25.concat(this.enclosedTypes.allMembers.getAllKeys())
      }
      var v15260 = !members$$23;
      if(v15260) {
        v15260 = this.parent
      }
      if(v15260) {
        var v6693 = this.parent;
        var parentResult$$3 = JAM.call(v6693.getAllTypeSymbolNames, v6693, [members$$23]);
        if(parentResult$$3) {
          result$$25 = result$$25.concat(parentResult$$3)
        }
      }
      return result$$25
    }
    function v839(members$$22) {
      var result$$24 = JAM.call(this.getAllTypeSymbolNames, this, [members$$22]);
      return result$$24.concat(JAM.call(this.getAllValueSymbolNames, this, [members$$22]))
    }
    function v838() {
      return"builder"
    }
    function SymbolScopeBuilder$$1(valueMembers$$2, ambientValueMembers$$2, enclosedTypes$$2, ambientEnclosedTypes$$2, parent$$50, container$$7) {
      JAM.call(_super$$56.call, _super$$56, [this, container$$7]);
      this.valueMembers = valueMembers$$2;
      this.ambientValueMembers = ambientValueMembers$$2;
      this.enclosedTypes = enclosedTypes$$2;
      this.ambientEnclosedTypes = ambientEnclosedTypes$$2;
      this.parent = parent$$50;
      this.container = container$$7;
      return
    }
    JAM.call(__extends, null, [SymbolScopeBuilder$$1, _super$$56]);
    SymbolScopeBuilder$$1.prototype.printLabel = v838;
    SymbolScopeBuilder$$1.prototype.getAllSymbolNames = v839;
    SymbolScopeBuilder$$1.prototype.getAllTypeSymbolNames = v840;
    SymbolScopeBuilder$$1.prototype.getAllValueSymbolNames = v841;
    SymbolScopeBuilder$$1.prototype.search = v842;
    SymbolScopeBuilder$$1.prototype.print = v847;
    SymbolScopeBuilder$$1.prototype.find = v848;
    SymbolScopeBuilder$$1.prototype.findAmbient = v849;
    SymbolScopeBuilder$$1.prototype.findLocal = v850;
    SymbolScopeBuilder$$1.prototype.enter = v851;
    SymbolScopeBuilder$$1.prototype.getTable = v852;
    return SymbolScopeBuilder$$1
  }
  function v837(_super$$55) {
    function v836() {
      return this.valueMembers.publicMembers
    }
    function v835(name$$70, publicOnly$$14, typespace$$13) {
      var sym$$17 = JAM.call(this.find, this, [name$$70, publicOnly$$14, typespace$$13]);
      if(sym$$17) {
        if(sym$$17.kind() == SymbolKind.Type) {
          var typeSym$$1 = sym$$17;
          if(!typeSym$$1.type.hasImplementation()) {
            sym$$17 = null
          }
        }else {
          if(sym$$17.container) {
            if(sym$$17.container.kind() == SymbolKind.Type) {
              var ctypeSym = sym$$17.container;
              if(!ctypeSym.type.hasImplementation()) {
                sym$$17 = null
              }
            }
          }
        }
      }
      return sym$$17
    }
    function v834(outfile$$8) {
      function v833(key$$38, sym$$16, context$$44) {
        JAM.call(outfile$$8.WriteLine, outfile$$8, ["  " + key$$38]);
        return
      }
      function v832(key$$37, sym$$15, context$$43) {
        JAM.call(outfile$$8.WriteLine, outfile$$8, ["  " + key$$37]);
        return
      }
      function v831(key$$36, sym$$14, context$$42) {
        JAM.call(outfile$$8.WriteLine, outfile$$8, ["  " + key$$36]);
        return
      }
      function v830(key$$35, sym$$13, context$$41) {
        JAM.call(outfile$$8.WriteLine, outfile$$8, ["  " + key$$35]);
        return
      }
      var v6717 = _super$$55.prototype.print;
      JAM.call(v6717.call, v6717, [this, outfile$$8]);
      if(this.ambientValueMembers) {
        var v6718 = this.ambientValueMembers.allMembers;
        JAM.call(v6718.map, v6718, [v830, null])
      }
      if(this.valueMembers) {
        var v6720 = this.valueMembers.allMembers;
        JAM.call(v6720.map, v6720, [v831, null])
      }
      if(this.ambientEnclosedTypes) {
        var v6722 = this.ambientEnclosedTypes.allMembers;
        JAM.call(v6722.map, v6722, [v832, null])
      }
      if(this.enclosedTypes) {
        var v6724 = this.enclosedTypes.allMembers;
        JAM.call(v6724.map, v6724, [v833, null])
      }
      return
    }
    function v829(name$$69, publicOnly$$13, typespace$$12) {
      var v6726;
      if(this.ambientValueMembers == null) {
        v6726 = null
      }else {
        var v15272;
        if(publicOnly$$13) {
          v15272 = this.ambientValueMembers.publicMembers
        }else {
          v15272 = this.ambientValueMembers.allMembers
        }
        v6726 = v15272
      }
      var ambientTable$$1 = v6726;
      if(typespace$$12) {
        var v6727;
        if(this.ambientEnclosedTypes == null) {
          v6727 = null
        }else {
          var v15274;
          if(publicOnly$$13) {
            v15274 = this.ambientEnclosedTypes.publicMembers
          }else {
            v15274 = this.ambientEnclosedTypes.allMembers
          }
          v6727 = v15274
        }
        ambientTable$$1 = v6727
      }
      if(ambientTable$$1) {
        var s$$19 = JAM.call(ambientTable$$1.lookup, ambientTable$$1, [name$$69]);
        if(s$$19) {
          return s$$19
        }
      }
      return null
    }
    function v828(name$$68, publicOnly$$12, typespace$$11) {
      var table$$2 = null;
      var ambientTable = null;
      if(typespace$$11) {
        var v6728;
        if(this.enclosedTypes == null) {
          v6728 = null
        }else {
          var v15276;
          if(publicOnly$$12) {
            v15276 = this.enclosedTypes.publicMembers
          }else {
            v15276 = this.enclosedTypes.allMembers
          }
          v6728 = v15276
        }
        table$$2 = v6728;
        var v6729;
        if(this.ambientEnclosedTypes == null) {
          v6729 = null
        }else {
          var v15278;
          if(publicOnly$$12) {
            v15278 = this.ambientEnclosedTypes.publicMembers
          }else {
            v15278 = this.ambientEnclosedTypes.allMembers
          }
          v6729 = v15278
        }
        ambientTable = v6729
      }else {
        var v6730;
        if(this.valueMembers == null) {
          v6730 = null
        }else {
          var v15280;
          if(publicOnly$$12) {
            v15280 = this.valueMembers.publicMembers
          }else {
            v15280 = this.valueMembers.allMembers
          }
          v6730 = v15280
        }
        table$$2 = v6730;
        var v6731;
        if(this.ambientValueMembers == null) {
          v6731 = null
        }else {
          var v15282;
          if(publicOnly$$12) {
            v15282 = this.ambientValueMembers.publicMembers
          }else {
            v15282 = this.ambientValueMembers.allMembers
          }
          v6731 = v15282
        }
        ambientTable = v6731
      }
      if(ambientTable) {
        var s$$18 = JAM.call(ambientTable.lookup, ambientTable, [name$$68]);
        if(s$$18) {
          return s$$18
        }
      }
      if(table$$2) {
        s$$18 = JAM.call(table$$2.lookup, table$$2, [name$$68]);
        if(s$$18) {
          return s$$18
        }
      }
      return null
    }
    function v827(filter$$2, name$$67, publicOnly$$11, typespace$$10) {
      var sym$$12 = JAM.call(this.find, this, [name$$67, publicOnly$$11, typespace$$10]);
      JAM.call(filter$$2.update, filter$$2, [sym$$12]);
      return filter$$2.result
    }
    function v826(members$$21) {
      var result$$23 = [];
      if(this.ambientValueMembers) {
        result$$23 = result$$23.concat(this.ambientValueMembers.allMembers.getAllKeys())
      }
      if(this.valueMembers) {
        result$$23 = result$$23.concat(this.valueMembers.allMembers.getAllKeys())
      }
      return result$$23
    }
    function v825(members$$20) {
      var result$$22 = [];
      if(this.ambientEnclosedTypes) {
        result$$22 = result$$22.concat(this.ambientEnclosedTypes.allMembers.getAllKeys())
      }
      if(this.enclosedTypes) {
        result$$22 = result$$22.concat(this.enclosedTypes.allMembers.getAllKeys())
      }
      return result$$22
    }
    function v824(members$$19) {
      var result$$21 = JAM.call(this.getAllTypeSymbolNames, this, [members$$19]);
      return result$$21.concat(JAM.call(this.getAllValueSymbolNames, this, [members$$19]))
    }
    function v823() {
      return"table"
    }
    function SymbolTableScope$$1(valueMembers$$1, ambientValueMembers$$1, enclosedTypes$$1, ambientEnclosedTypes$$1, container$$6) {
      JAM.call(_super$$55.call, _super$$55, [this, container$$6]);
      this.valueMembers = valueMembers$$1;
      this.ambientValueMembers = ambientValueMembers$$1;
      this.enclosedTypes = enclosedTypes$$1;
      this.ambientEnclosedTypes = ambientEnclosedTypes$$1;
      this.container = container$$6;
      return
    }
    JAM.call(__extends, null, [SymbolTableScope$$1, _super$$55]);
    SymbolTableScope$$1.prototype.printLabel = v823;
    SymbolTableScope$$1.prototype.getAllSymbolNames = v824;
    SymbolTableScope$$1.prototype.getAllTypeSymbolNames = v825;
    SymbolTableScope$$1.prototype.getAllValueSymbolNames = v826;
    SymbolTableScope$$1.prototype.search = v827;
    SymbolTableScope$$1.prototype.find = v828;
    SymbolTableScope$$1.prototype.findAmbient = v829;
    SymbolTableScope$$1.prototype.print = v834;
    SymbolTableScope$$1.prototype.findImplementation = v835;
    SymbolTableScope$$1.prototype.getTable = v836;
    return SymbolTableScope$$1
  }
  function v822(_super$$54) {
    function v821(parent$$49) {
      if(this.parents == null) {
        var v27001 = new Array;
        this.parents = v27001
      }
      JAM.set(this.parents, this.parents.length, parent$$49);
      return
    }
    function v820(name$$66, publicOnly$$10, typespace$$9) {
      var sym$$11 = null;
      var i$$72 = 0;
      var cache$$1 = this.valueAmbientCache;
      if(typespace$$9) {
        cache$$1 = this.typeAmbientCache
      }
      var v15290 = cache$$1;
      if(v15290) {
        v15290 = (sym$$11 = JAM.call(cache$$1.lookup, cache$$1, [name$$66])) != null
      }
      if(v15290) {
        return sym$$11
      }
      if(this.parents) {
        i$$72 = 0;
        var v6756 = i$$72 < this.parents.length;
        for(;v6756;) {
          var v15292 = this.parents;
          introspect(JAM.policy.p1) {
            var v6755 = v15292[i$$72]
          }
          sym$$11 = JAM.call(v6755.findAmbient, v6755, [name$$66, publicOnly$$10, typespace$$9]);
          if(sym$$11) {
            break
          }
          i$$72 = i$$72 + 1;
          v6756 = i$$72 < this.parents.length
        }
      }
      if(cache$$1 == null) {
        if(typespace$$9) {
          var v27002 = new TypeScript$$21.StringHashTable;
          this.typeAmbientCache = v27002;
          cache$$1 = this.typeAmbientCache
        }else {
          var v27003 = new TypeScript$$21.StringHashTable;
          this.valueAmbientCache = v27003;
          cache$$1 = this.valueAmbientCache
        }
      }
      JAM.call(cache$$1.add, cache$$1, [name$$66, sym$$11]);
      return sym$$11
    }
    function v819(name$$65, publicOnly$$9, typespace$$8) {
      var sym$$10 = null;
      var i$$71 = 0;
      var cache = this.valueCache;
      if(typespace$$8) {
        cache = this.typeCache
      }
      var v15294 = cache;
      if(v15294) {
        var v20410 = (sym$$10 = JAM.call(cache.lookup, cache, [name$$65])) != null;
        if(v20410) {
          var v23576;
          if(publicOnly$$9) {
            var v25921 = JAM.call(TypeScript$$21.hasFlag, TypeScript$$21, [sym$$10.flags, TypeScript$$21.SymbolFlags.Private]);
            if(!v25921) {
              var v26350 = sym$$10.declAST;
              if(v26350) {
                var v26537 = sym$$10.declAST.nodeType == TypeScript$$21.NodeType.FuncDecl;
                if(v26537) {
                  v26537 = JAM.call(TypeScript$$21.hasFlag, TypeScript$$21, [sym$$10.declAST.fncFlags, TypeScript$$21.FncFlags.Private])
                }
                v26350 = v26537
              }
              v25921 = v26350
            }
            v23576 = !v25921
          }else {
            v23576 = true
          }
          v20410 = v23576
        }
        v15294 = v20410
      }
      if(v15294) {
        return sym$$10
      }
      if(this.parents) {
        i$$71 = 0;
        var v6763 = i$$71 < this.parents.length;
        for(;v6763;) {
          var v15296 = this.parents;
          introspect(JAM.policy.p1) {
            var v6762 = v15296[i$$71]
          }
          sym$$10 = JAM.call(v6762.find, v6762, [name$$65, publicOnly$$9, typespace$$8]);
          if(sym$$10) {
            break
          }
          i$$71 = i$$71 + 1;
          v6763 = i$$71 < this.parents.length
        }
      }
      if(cache == null) {
        if(typespace$$8) {
          var v27004 = new TypeScript$$21.StringHashTable;
          this.typeCache = v27004;
          cache = this.typeCache
        }else {
          var v27005 = new TypeScript$$21.StringHashTable;
          this.valueCache = v27005;
          cache = this.valueCache
        }
      }
      JAM.call(cache.add, cache, [name$$65, sym$$10]);
      return sym$$10
    }
    function v818(name$$64, publicOnly$$8, typespace$$7) {
      var sym$$9 = null;
      var i$$70 = 0;
      var implCache = this.valueImplCache;
      if(typespace$$7) {
        implCache = this.typeImplCache
      }
      var v15298 = implCache;
      if(v15298) {
        var v20413 = (sym$$9 = JAM.call(implCache.lookup, implCache, [name$$64])) != null;
        if(v20413) {
          var v23578;
          if(publicOnly$$8) {
            var v25922 = JAM.call(TypeScript$$21.hasFlag, TypeScript$$21, [sym$$9.flags, TypeScript$$21.SymbolFlags.Private]);
            if(!v25922) {
              var v26354 = sym$$9.declAST;
              if(v26354) {
                var v26539 = sym$$9.declAST.nodeType == TypeScript$$21.NodeType.FuncDecl;
                if(v26539) {
                  v26539 = JAM.call(TypeScript$$21.hasFlag, TypeScript$$21, [sym$$9.declAST.fncFlags, TypeScript$$21.FncFlags.Private])
                }
                v26354 = v26539
              }
              v25922 = v26354
            }
            v23578 = !v25922
          }else {
            v23578 = true
          }
          v20413 = v23578
        }
        v15298 = v20413
      }
      if(v15298) {
        return sym$$9
      }
      if(this.parents) {
        i$$70 = 0;
        var v6770 = i$$70 < this.parents.length;
        for(;v6770;) {
          var v15300 = this.parents;
          introspect(JAM.policy.p1) {
            var v6769 = v15300[i$$70]
          }
          sym$$9 = JAM.call(v6769.findImplementation, v6769, [name$$64, publicOnly$$8, typespace$$7]);
          if(sym$$9) {
            break
          }
          i$$70 = i$$70 + 1;
          v6770 = i$$70 < this.parents.length
        }
      }
      if(implCache) {
        if(typespace$$7) {
          var v27006 = new TypeScript$$21.StringHashTable;
          this.typeImplCache = v27006;
          implCache = this.typeImplCache
        }else {
          var v27007 = new TypeScript$$21.StringHashTable;
          this.valueImplCache = v27007;
          implCache = this.valueImplCache
        }
      }
      JAM.call(implCache.add, implCache, [name$$64, sym$$9]);
      return sym$$9
    }
    function v817(outfile$$7) {
      var v6774 = _super$$54.prototype.print;
      JAM.call(v6774.call, v6774, [this, outfile$$7]);
      if(this.parents) {
        var i$$69 = 0;
        var v6776 = i$$69 < this.parents.length;
        for(;v6776;) {
          var v15304 = this.parents;
          introspect(JAM.policy.p1) {
            var v6775 = v15304[i$$69]
          }
          JAM.call(v6775.print, v6775, [outfile$$7]);
          i$$69 = i$$69 + 1;
          v6776 = i$$69 < this.parents.length
        }
      }
      return
    }
    function v816(members$$18) {
      var result$$20 = [];
      if(this.parents) {
        var i$$68 = 0;
        var v6779 = i$$68 < this.parents.length;
        for(;v6779;) {
          var v15307 = this.parents;
          introspect(JAM.policy.p1) {
            var v6778 = v15307[i$$68]
          }
          var parentResult$$2 = JAM.call(v6778.getAllValueSymbolNames, v6778, [members$$18]);
          if(parentResult$$2) {
            result$$20 = result$$20.concat(parentResult$$2)
          }
          i$$68 = i$$68 + 1;
          v6779 = i$$68 < this.parents.length
        }
      }
      return result$$20
    }
    function v815(members$$17) {
      var result$$19 = [];
      if(this.parents) {
        var i$$67 = 0;
        var v6782 = i$$67 < this.parents.length;
        for(;v6782;) {
          var v15310 = this.parents;
          introspect(JAM.policy.p1) {
            var v6781 = v15310[i$$67]
          }
          var parentResult$$1 = JAM.call(v6781.getAllTypeSymbolNames, v6781, [members$$17]);
          if(parentResult$$1) {
            result$$19 = result$$19.concat(parentResult$$1)
          }
          i$$67 = i$$67 + 1;
          v6782 = i$$67 < this.parents.length
        }
      }
      return result$$19
    }
    function v814(members$$16) {
      var result$$18 = [];
      if(this.parents) {
        var i$$66 = 0;
        var v6785 = i$$66 < this.parents.length;
        for(;v6785;) {
          var v15313 = this.parents;
          introspect(JAM.policy.p1) {
            var v6784 = v15313[i$$66]
          }
          var parentResult = JAM.call(v6784.getAllSymbolNames, v6784, [members$$16]);
          if(parentResult) {
            result$$18 = result$$18.concat(parentResult)
          }
          i$$66 = i$$66 + 1;
          v6785 = i$$66 < this.parents.length
        }
      }
      return result$$18
    }
    function v813(filter$$1, name$$63, publicOnly$$7, typespace$$6) {
      if(this.parents) {
        var i$$65 = 0;
        var v6789 = i$$65 < this.parents.length;
        for(;v6789;) {
          var v15316 = this.parents;
          introspect(JAM.policy.p1) {
            var v6787 = v15316[i$$65]
          }
          var sym$$8 = JAM.call(v6787.search, v6787, [filter$$1, name$$63, publicOnly$$7, typespace$$6]);
          if(sym$$8) {
            if(JAM.call(filter$$1.update, filter$$1, [sym$$8])) {
              return sym$$8
            }
          }
          i$$65 = i$$65 + 1;
          v6789 = i$$65 < this.parents.length
        }
      }
      return filter$$1.result
    }
    function v812() {
      return"agg"
    }
    function SymbolAggregateScope$$1(container$$5) {
      JAM.call(_super$$54.call, _super$$54, [this, container$$5]);
      this.valueCache = null;
      this.valueImplCache = null;
      this.valueAmbientCache = null;
      this.typeCache = null;
      this.typeImplCache = null;
      this.typeAmbientCache = null;
      this.parents = null;
      this.container = container$$5;
      return
    }
    JAM.call(__extends, null, [SymbolAggregateScope$$1, _super$$54]);
    SymbolAggregateScope$$1.prototype.printLabel = v812;
    SymbolAggregateScope$$1.prototype.search = v813;
    SymbolAggregateScope$$1.prototype.getAllSymbolNames = v814;
    SymbolAggregateScope$$1.prototype.getAllTypeSymbolNames = v815;
    SymbolAggregateScope$$1.prototype.getAllValueSymbolNames = v816;
    SymbolAggregateScope$$1.prototype.print = v817;
    SymbolAggregateScope$$1.prototype.findImplementation = v818;
    SymbolAggregateScope$$1.prototype.find = v819;
    SymbolAggregateScope$$1.prototype.findAmbient = v820;
    SymbolAggregateScope$$1.prototype.addParentScope = v821;
    return SymbolAggregateScope$$1
  }
  function v811() {
    function v810() {
      throw new Error("please implement in derived class");
    }
    function v809(container$$4, ast$$60, symbol$$6, errorReporter$$2, publicOnly$$6, typespace$$5, ambient) {
      throw new Error("please implement in derived class");
    }
    function v808(outfile$$6) {
      if(this.container) {
        JAM.call(outfile$$6.WriteLine, outfile$$6, [this.printLabel() + " scope with container: " + this.container.name + "..."])
      }else {
        JAM.call(outfile$$6.WriteLine, outfile$$6, [this.printLabel() + " scope..."])
      }
      return
    }
    function v807(name$$62, publicOnly$$5, typespace$$4) {
      return null
    }
    function v806(name$$61, publicOnly$$4, typespace$$3) {
      return null
    }
    function v805(name$$60, publicOnly$$3, typespace$$2) {
      return null
    }
    function v804(name$$59, publicOnly$$2, typespace$$1) {
      return null
    }
    function v803(filter, name$$58, publicOnly$$1, typespace) {
      return null
    }
    function v802(members$$15) {
      return["please", "implement", "in", "derived", "classes"]
    }
    function v801(members$$14) {
      return["please", "implement", "in", "derived", "classes"]
    }
    function v800(members$$13) {
      return["please", "implement", "in", "derived", "classes"]
    }
    function v799() {
      return"base"
    }
    function SymbolScope$$1(container$$3) {
      this.container = container$$3;
      return
    }
    SymbolScope$$1.prototype.printLabel = v799;
    SymbolScope$$1.prototype.getAllSymbolNames = v800;
    SymbolScope$$1.prototype.getAllTypeSymbolNames = v801;
    SymbolScope$$1.prototype.getAllValueSymbolNames = v802;
    SymbolScope$$1.prototype.search = v803;
    SymbolScope$$1.prototype.findLocal = v804;
    SymbolScope$$1.prototype.find = v805;
    SymbolScope$$1.prototype.findImplementation = v806;
    SymbolScope$$1.prototype.findAmbient = v807;
    SymbolScope$$1.prototype.print = v808;
    SymbolScope$$1.prototype.enter = v809;
    SymbolScope$$1.prototype.getTable = v810;
    return SymbolScope$$1
  }
  function v798(SymbolKind$$1) {
    SymbolKind$$1._map = [];
    SymbolKind$$1._map[0] = "None";
    SymbolKind$$1.None = 0;
    SymbolKind$$1._map[1] = "Type";
    SymbolKind$$1.Type = 1;
    SymbolKind$$1._map[2] = "Field";
    SymbolKind$$1.Field = 2;
    SymbolKind$$1._map[3] = "Parameter";
    SymbolKind$$1.Parameter = 3;
    SymbolKind$$1._map[4] = "Variable";
    SymbolKind$$1.Variable = 4;
    return
  }
  function v797() {
    function v796(key$$34, data$$34) {
      var v6821 = this.dualMembers.secondaryTable;
      return JAM.call(v6821.add, v6821, [key$$34, data$$34])
    }
    function v795(key$$33, data$$33) {
      var v6822 = this.dualMembers.primaryTable;
      return JAM.call(v6822.add, v6822, [key$$33, data$$33])
    }
    function ScopedMembers$$1(dualMembers) {
      this.dualMembers = dualMembers;
      this.allMembers = this.dualMembers;
      this.publicMembers = this.dualMembers.primaryTable;
      this.privateMembers = this.dualMembers.secondaryTable;
      return
    }
    ScopedMembers$$1.prototype.addPublicMember = v795;
    ScopedMembers$$1.prototype.addPrivateMember = v796;
    return ScopedMembers$$1
  }
  var ScopedMembers = v797();
  TypeScript$$21.ScopedMembers = ScopedMembers;
  var v15322 = TypeScript$$21.SymbolKind;
  if(!v15322) {
    v15322 = TypeScript$$21.SymbolKind = {}
  }
  v798(v15322);
  var SymbolKind = TypeScript$$21.SymbolKind;
  var SymbolScope = v811();
  TypeScript$$21.SymbolScope = SymbolScope;
  var SymbolAggregateScope = v822(SymbolScope);
  TypeScript$$21.SymbolAggregateScope = SymbolAggregateScope;
  var SymbolTableScope = v837(SymbolScope);
  TypeScript$$21.SymbolTableScope = SymbolTableScope;
  var SymbolScopeBuilder = v853(SymbolScope);
  TypeScript$$21.SymbolScopeBuilder = SymbolScopeBuilder;
  var FilteredSymbolScope = v857(SymbolScope);
  TypeScript$$21.FilteredSymbolScope = FilteredSymbolScope;
  var FilteredSymbolScopeBuilder = v861(SymbolScopeBuilder);
  TypeScript$$21.FilteredSymbolScopeBuilder = FilteredSymbolScopeBuilder;
  return
}
function v794(TypeScript$$20) {
  function v793(_super$$53) {
    function v792() {
      return true
    }
    function v791(type$$36) {
      this.variable.typeLink.type = type$$36;
      return
    }
    function v790(scope$$20) {
      var v6829 = TypeScript$$20.MemberName;
      var v15324 = this.getType();
      return JAM.call(v6829.create, v6829, [JAM.call(v15324.getScopedTypeNameEx, v15324, [scope$$20]), this.name + ": ", ""])
    }
    function v789() {
      return this.variable.typeLink.type
    }
    function v788() {
      return true
    }
    function v787() {
      return TypeScript$$20.SymbolKind.Variable
    }
    function VariableSymbol$$1(name$$57, location$$27, unitIndex$$9, variable) {
      JAM.call(_super$$53.call, _super$$53, [this, name$$57, location$$27, name$$57.length, unitIndex$$9]);
      this.variable = variable;
      return
    }
    JAM.call(__extends, null, [VariableSymbol$$1, _super$$53]);
    VariableSymbol$$1.prototype.kind = v787;
    VariableSymbol$$1.prototype.writeable = v788;
    VariableSymbol$$1.prototype.getType = v789;
    VariableSymbol$$1.prototype.getTypeNameEx = v790;
    VariableSymbol$$1.prototype.setType = v791;
    VariableSymbol$$1.prototype.isVariable = v792;
    return VariableSymbol$$1
  }
  function v786(_super$$52) {
    function v785() {
      if(!this.paramDocComment) {
        var parameterComments = [];
        if(this.funcDecl) {
          var fncDocComments$$1 = this.funcDecl.getDocComments();
          var v6842 = TypeScript$$20.Comment;
          var paramComment = JAM.call(v6842.getParameterDocCommentText, v6842, [this.name, fncDocComments$$1]);
          if(paramComment != "") {
            JAM.call(parameterComments.push, parameterComments, [paramComment])
          }
        }
        var v6846 = TypeScript$$20.Comment;
        var docComments$$1 = JAM.call(v6846.getDocCommentText, v6846, [this.getDocComments()]);
        if(docComments$$1 != "") {
          JAM.call(parameterComments.push, parameterComments, [docComments$$1])
        }
        var v27008 = parameterComments.join("\n");
        this.paramDocComment = v27008
      }
      return this.paramDocComment
    }
    function v784(pattern$$7, replacement$$5, checker$$14) {
      var v6850 = this.parameter.typeLink.type;
      var rType$$1 = JAM.call(v6850.specializeType, v6850, [pattern$$7, replacement$$5, checker$$14, false]);
      if(this.parameter.typeLink.type != rType$$1) {
        var paramDef$$1 = new ValueLocation;
        var result$$17 = new ParameterSymbol$$1(this.name, 0, checker$$14.locationInfo.unitIndex, paramDef$$1);
        paramDef$$1.symbol = result$$17;
        JAM.call(result$$17.setType, result$$17, [rType$$1]);
        return result$$17
      }else {
        return this
      }
      return
    }
    function v783() {
      return JAM.call(this.getTypeNameEx, this, [null]).toString()
    }
    function v782(scope$$19) {
      var v6855 = TypeScript$$20.MemberName;
      var v15331 = this.getType();
      var v6856 = JAM.call(v15331.getScopedTypeNameEx, v15331, [scope$$19]);
      var v20431 = this.name;
      var v23582;
      if(this.isOptional()) {
        v23582 = "?"
      }else {
        v23582 = ""
      }
      return JAM.call(v6855.create, v6855, [v6856, v20431 + v23582 + ": ", ""])
    }
    function v781() {
      var v15333 = this.parameter;
      if(v15333) {
        var v20433 = this.parameter.symbol;
        if(v20433) {
          v20433 = this.parameter.symbol.declAST
        }
        v15333 = v20433
      }
      if(v15333) {
        return this.parameter.symbol.declAST.isOptional
      }else {
        return false
      }
      return
    }
    function v780() {
      return true
    }
    function v779(type$$35) {
      this.parameter.typeLink.type = type$$35;
      return
    }
    function v778() {
      return this.parameter.typeLink.type
    }
    function v777() {
      return true
    }
    function v776() {
      return TypeScript$$20.SymbolKind.Parameter
    }
    function ParameterSymbol$$1(name$$56, location$$26, unitIndex$$8, parameter) {
      JAM.call(_super$$52.call, _super$$52, [this, name$$56, location$$26, name$$56.length, unitIndex$$8]);
      this.parameter = parameter;
      this.paramDocComment = null;
      this.funcDecl = null;
      this.argsOffset = -1;
      this.name = name$$56;
      this.location = location$$26;
      return
    }
    JAM.call(__extends, null, [ParameterSymbol$$1, _super$$52]);
    ParameterSymbol$$1.prototype.kind = v776;
    ParameterSymbol$$1.prototype.writeable = v777;
    ParameterSymbol$$1.prototype.getType = v778;
    ParameterSymbol$$1.prototype.setType = v779;
    ParameterSymbol$$1.prototype.isVariable = v780;
    ParameterSymbol$$1.prototype.isOptional = v781;
    ParameterSymbol$$1.prototype.getTypeNameEx = v782;
    ParameterSymbol$$1.prototype.toString = v783;
    ParameterSymbol$$1.prototype.specializeType = v784;
    ParameterSymbol$$1.prototype.getParameterDocComments = v785;
    return ParameterSymbol$$1
  }
  function v775(_super$$51) {
    function v774() {
      var v15337 = this.getter != null;
      if(!v15337) {
        v15337 = this.setter != null
      }
      if(v15337) {
        var comments$$11 = [];
        if(this.getter != null) {
          comments$$11 = comments$$11.concat(this.getter.getDocComments())
        }
        if(this.setter != null) {
          comments$$11 = comments$$11.concat(this.setter.getDocComments())
        }
        return comments$$11
      }else {
        if(this.declAST != null) {
          return this.declAST.getDocComments()
        }
      }
      return[]
    }
    function v773(pattern$$6, replacement$$4, checker$$13) {
      var v6881 = this.field.typeLink.type;
      var rType = JAM.call(v6881.specializeType, v6881, [pattern$$6, replacement$$4, checker$$13, false]);
      if(rType != this.field.typeLink.type) {
        var fieldDef = new ValueLocation;
        var result$$16 = new FieldSymbol$$1(this.name, 0, checker$$13.locationInfo.unitIndex, this.canWrite, fieldDef);
        result$$16.flags = this.flags;
        fieldDef.symbol = result$$16;
        var v6885 = fieldDef;
        var v27009 = new TypeScript$$20.TypeLink;
        v6885.typeLink = v27009;
        JAM.call(result$$16.setType, result$$16, [rType]);
        result$$16.typeCheckStatus = TypeCheckStatus.Finished;
        return result$$16
      }else {
        return this
      }
      return
    }
    function v772() {
      return JAM.call(this.getTypeNameEx, this, [null]).toString()
    }
    function v771() {
      return true
    }
    function v770() {
      var v6888 = this.getter != null;
      if(!v6888) {
        v6888 = this.setter != null
      }
      return v6888
    }
    function v769(type$$34) {
      this.field.typeLink.type = type$$34;
      return
    }
    function v768() {
      return true
    }
    function v767(scope$$18) {
      var v6890 = TypeScript$$20.MemberName;
      var v15351 = this.field.typeLink.type;
      return JAM.call(v6890.create, v6890, [JAM.call(v15351.getScopedTypeNameEx, v15351, [scope$$18]), this.name + this.getOptionalNameString() + ": ", ""])
    }
    function v766() {
      return this.field.typeLink.type
    }
    function v765() {
      var v6894;
      if(this.isAccessor()) {
        v6894 = this.setter != null
      }else {
        v6894 = this.canWrite
      }
      return v6894
    }
    function v764() {
      return TypeScript$$20.SymbolKind.Field
    }
    function FieldSymbol$$1(name$$55, location$$25, unitIndex$$7, canWrite, field) {
      JAM.call(_super$$51.call, _super$$51, [this, name$$55, location$$25, name$$55.length, unitIndex$$7]);
      this.canWrite = canWrite;
      this.field = field;
      this.getter = null;
      this.setter = null;
      this.hasBeenEmitted = false;
      this.name = name$$55;
      this.location = location$$25;
      return
    }
    JAM.call(__extends, null, [FieldSymbol$$1, _super$$51]);
    FieldSymbol$$1.prototype.kind = v764;
    FieldSymbol$$1.prototype.writeable = v765;
    FieldSymbol$$1.prototype.getType = v766;
    FieldSymbol$$1.prototype.getTypeNameEx = v767;
    FieldSymbol$$1.prototype.isMember = v768;
    FieldSymbol$$1.prototype.setType = v769;
    FieldSymbol$$1.prototype.isAccessor = v770;
    FieldSymbol$$1.prototype.isVariable = v771;
    FieldSymbol$$1.prototype.toString = v772;
    FieldSymbol$$1.prototype.specializeType = v773;
    FieldSymbol$$1.prototype.getDocComments = v774;
    return FieldSymbol$$1
  }
  function v763(_super$$50) {
    function v762() {
      return true
    }
    function WithSymbol$$1(location$$24, unitIndex$$6, withType$$1) {
      JAM.call(_super$$50.call, _super$$50, [this, "with", location$$24, 4, unitIndex$$6, withType$$1]);
      return
    }
    JAM.call(__extends, null, [WithSymbol$$1, _super$$50]);
    WithSymbol$$1.prototype.isWith = v762;
    return WithSymbol$$1
  }
  function v761(_super$$49) {
    function v760() {
      var comments$$10 = [];
      if(this.declAST != null) {
        comments$$10 = comments$$10.concat(this.declAST.getDocComments())
      }
      var i$$64 = 0;
      var v6912 = i$$64 < this.expansionsDeclAST.length;
      for(;v6912;) {
        var v20444 = this.expansionsDeclAST;
        introspect(JAM.policy.p1) {
          var v15359 = v20444[i$$64]
        }
        comments$$10 = comments$$10.concat(v15359.getDocComments());
        i$$64 = i$$64 + 1;
        v6912 = i$$64 < this.expansionsDeclAST.length
      }
      return comments$$10
    }
    function v759(scopeSymbolPath) {
      var scopeSymbolPathLength = scopeSymbolPath.length;
      var externalSymbol = null;
      var v15361 = scopeSymbolPath.length > 0;
      if(v15361) {
        var v25923 = scopeSymbolPathLength - 1;
        introspect(JAM.policy.p1) {
          var v25129 = scopeSymbolPath[v25923]
        }
        var v20447 = v25129.getType().isModuleType();
        if(v20447) {
          var v25130 = scopeSymbolPathLength - 1;
          introspect(JAM.policy.p1) {
            var v23588 = scopeSymbolPath[v25130]
          }
          v20447 = v23588.isDynamic
        }
        v15361 = v20447
      }
      if(v15361) {
        var v15362 = scopeSymbolPathLength > 1;
        if(v15362) {
          var v25924 = scopeSymbolPathLength - 2;
          introspect(JAM.policy.p1) {
            var v25131 = scopeSymbolPath[v25924]
          }
          var v20448 = v25131.getType().isModuleType();
          if(v20448) {
            var v25132 = scopeSymbolPathLength - 2;
            introspect(JAM.policy.p1) {
              var v23590 = scopeSymbolPath[v25132]
            }
            v20448 = v23590.isDynamic
          }
          v15362 = v20448
        }
        if(v15362) {
          var v15363 = scopeSymbolPathLength - 2;
          introspect(JAM.policy.p1) {
            var v6913 = scopeSymbolPath[v15363]
          }
          var moduleType = v6913.getType();
          externalSymbol = JAM.call(moduleType.findDynamicModuleName, moduleType, [this.type])
        }
        if(externalSymbol == null) {
          var v15364 = scopeSymbolPathLength - 1;
          introspect(JAM.policy.p1) {
            var v6916 = scopeSymbolPath[v15364]
          }
          moduleType = v6916.getType();
          externalSymbol = JAM.call(moduleType.findDynamicModuleName, moduleType, [this.type])
        }
      }
      return externalSymbol
    }
    function v758(scopeSymbol$$1) {
      var v15365 = !!scopeSymbol$$1;
      if(v15365) {
        var v20450 = JAM.call(TypeScript$$20.isQuoted, TypeScript$$20, [this.prettyName]);
        if(v20450) {
          v20450 = this.type.isModuleType()
        }
        v15365 = v20450
      }
      if(v15365) {
        var symbolPath = scopeSymbol$$1.pathToRoot();
        var prettyName$$1 = JAM.call(this.getPrettyNameOfDynamicModule, this, [symbolPath]);
        if(prettyName$$1 != null) {
          return prettyName$$1.name
        }
      }
      return this.prettyName
    }
    function v757(pattern$$5, replacement$$3, checker$$12) {
      if(this.type == pattern$$5) {
        return replacement$$3.symbol
      }else {
        var v6922 = this.type;
        var replType = JAM.call(v6922.specializeType, v6922, [pattern$$5, replacement$$3, checker$$12, false]);
        if(replType != this.type) {
          var result$$15 = new TypeSymbol$$1(this.name, -1, 0, -1, replType);
          return result$$15
        }else {
          return this
        }
      }
      return
    }
    function v756() {
      var v6926 = this.declAST != null;
      if(v6926) {
        v6926 = this.declAST.nodeType == TypeScript$$20.NodeType.FuncDecl
      }
      return v6926
    }
    function v755() {
      return this.instanceType != null
    }
    function v754() {
      var result$$14 = this.type.getTypeName();
      if(this.name) {
        result$$14 = this.name + ":" + result$$14
      }
      return result$$14
    }
    function v753() {
      var v15372 = !(this.type.typeFlags & TypeScript$$20.TypeFlags.IsClass);
      if(v15372) {
        v15372 = this.type.isClass()
      }
      if(v15372) {
        return this.type.instanceType.constructorScope
      }else {
        return this.type.containedScope
      }
      return
    }
    function v752(scope$$17) {
      var v6934 = this.type;
      var v15374;
      if(this.name) {
        v15374 = this.name + this.getOptionalNameString()
      }else {
        v15374 = ""
      }
      return JAM.call(v6934.getMemberTypeNameEx, v6934, [v15374, false, false, scope$$17])
    }
    function v751() {
      return this.type
    }
    function v750() {
      return true
    }
    function v749() {
      return TypeScript$$20.SymbolKind.Type
    }
    function v748(loc) {
      if(this.additionalLocations == null) {
        this.additionalLocations = []
      }
      JAM.set(this.additionalLocations, this.additionalLocations.length, loc);
      return
    }
    function TypeSymbol$$1(locName, location$$23, length$$17, unitIndex$$5, type$$33) {
      JAM.call(_super$$49.call, _super$$49, [this, locName, location$$23, length$$17, unitIndex$$5]);
      this.type = type$$33;
      this.expansions = [];
      this.expansionsDeclAST = [];
      this.isDynamic = false;
      this.isMethod = false;
      this.aliasLink = null;
      this.onlyReferencedAsTypeRef = TypeScript$$20.optimizeModuleCodeGen;
      this.prettyName = this.name;
      return
    }
    JAM.call(__extends, null, [TypeSymbol$$1, _super$$49]);
    TypeSymbol$$1.prototype.addLocation = v748;
    TypeSymbol$$1.prototype.kind = v749;
    TypeSymbol$$1.prototype.isType = v750;
    TypeSymbol$$1.prototype.getType = v751;
    TypeSymbol$$1.prototype.getTypeNameEx = v752;
    TypeSymbol$$1.prototype.instanceScope = v753;
    TypeSymbol$$1.prototype.toString = v754;
    TypeSymbol$$1.prototype.isClass = v755;
    TypeSymbol$$1.prototype.isFunction = v756;
    TypeSymbol$$1.prototype.specializeType = v757;
    TypeSymbol$$1.prototype.getPrettyName = v758;
    TypeSymbol$$1.prototype.getPrettyNameOfDynamicModule = v759;
    TypeSymbol$$1.prototype.getDocComments = v760;
    return TypeSymbol$$1
  }
  function v747(_super$$48) {
    function v746(varFlags) {
      if(JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [varFlags, TypeScript$$20.VarFlags.Ambient])) {
        this.flags = this.flags | TypeScript$$20.SymbolFlags.Ambient
      }
      if(JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [varFlags, TypeScript$$20.VarFlags.Constant])) {
        this.flags = this.flags | TypeScript$$20.SymbolFlags.Constant
      }
      if(JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [varFlags, TypeScript$$20.VarFlags.Static])) {
        this.flags = this.flags | TypeScript$$20.SymbolFlags.Static
      }
      if(JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [varFlags, TypeScript$$20.VarFlags.Property])) {
        this.flags = this.flags | TypeScript$$20.SymbolFlags.Property
      }
      if(JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [varFlags, TypeScript$$20.VarFlags.Private])) {
        this.flags = this.flags | TypeScript$$20.SymbolFlags.Private
      }
      if(JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [varFlags, TypeScript$$20.VarFlags.Public])) {
        this.flags = this.flags | TypeScript$$20.SymbolFlags.Public
      }
      if(JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [varFlags, TypeScript$$20.VarFlags.Readonly])) {
        this.flags = this.flags | TypeScript$$20.SymbolFlags.Readonly
      }
      if(JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [varFlags, TypeScript$$20.VarFlags.Exported])) {
        this.flags = this.flags | TypeScript$$20.SymbolFlags.Exported
      }
      return
    }
    function v745() {
      return true
    }
    function InferenceSymbol$$1(name$$54, location$$22, length$$16, unitIndex$$4) {
      JAM.call(_super$$48.call, _super$$48, [this, name$$54, location$$22, length$$16, unitIndex$$4]);
      this.typeCheckStatus = TypeCheckStatus.NotStarted;
      return
    }
    JAM.call(__extends, null, [InferenceSymbol$$1, _super$$48]);
    InferenceSymbol$$1.prototype.isInferenceSymbol = v745;
    InferenceSymbol$$1.prototype.transferVarFlags = v746;
    return InferenceSymbol$$1
  }
  function v744() {
    function ValueLocation$$1() {
      return
    }
    return ValueLocation$$1
  }
  function v743() {
    function v742() {
      return JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [this.flags, TypeScript$$20.SymbolFlags.Static])
    }
    function v741() {
      if(this.declAST != null) {
        return this.declAST.getDocComments()
      }
      return[]
    }
    function v740() {
      var v15403 = this.declAST != null;
      if(v15403) {
        v15403 = this.declAST.nodeType == TypeScript$$20.NodeType.VarDecl
      }
      if(v15403) {
        return this.declAST
      }
      return null
    }
    function v739(checker$$11) {
      if(this.declAST != null) {
        if(this.declAST.nodeType == TypeScript$$20.NodeType.InterfaceDeclaration) {
          return this.declAST
        }else {
          var v15407 = this.container != null;
          if(v15407) {
            var v20480 = this.container != checker$$11.gloMod;
            if(v20480) {
              v20480 = this.container.declAST.nodeType == TypeScript$$20.NodeType.InterfaceDeclaration
            }
            v15407 = v20480
          }
          if(v15407) {
            return this.container.declAST
          }
        }
      }
      return null
    }
    function v738() {
      throw new Error("please implement in derived class");
    }
    function v737(type$$32) {
      throw new Error("please implement in derived class");
    }
    function v736(pattern$$4, replacement$$2, checker$$10) {
      throw new Error("please implement in derived class");
    }
    function v735(outfile$$5) {
      JAM.call(outfile$$5.Write, outfile$$5, [this.toString()]);
      return
    }
    function v734() {
      if(this.name) {
        return this.name
      }else {
        return"_anonymous"
      }
      return
    }
    function v733(identifier) {
      if(!this.refs) {
        this.refs = []
      }
      JAM.set(this.refs, this.refs.length, identifier);
      return
    }
    function v732(scope$$16, checker$$9) {
      var v15410 = checker$$9 == null;
      if(!v15410) {
        v15410 = this.container == checker$$9.gloMod
      }
      if(v15410) {
        return true
      }
      if(JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [this.flags, TypeScript$$20.SymbolFlags.ModuleMember])) {
        if(JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [this.flags, TypeScript$$20.SymbolFlags.Exported])) {
          if(!JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [this.flags, TypeScript$$20.SymbolFlags.Private])) {
            return true
          }else {
            return aEnclosesB(this, scope$$16.container)
          }
        }else {
          var v15416 = checker$$9;
          if(v15416) {
            v15416 = checker$$9.currentModDecl == this.declModule
          }
          var v6980 = v15416;
          if(!v6980) {
            var v15417 = checker$$9.currentModDecl;
            if(v15417) {
              var v20490 = checker$$9.currentModDecl.mod;
              if(v20490) {
                var v23603 = checker$$9.currentModDecl.mod.symbol;
                if(v23603) {
                  var v25138 = this.declModule;
                  if(v25138) {
                    var v25927 = this.declModule.mod;
                    if(v25927) {
                      var v26357 = this.declModule.mod.symbol;
                      if(v26357) {
                        v26357 = aEnclosesB(checker$$9.currentModDecl.mod.symbol, this.declModule.mod.symbol)
                      }
                      v25927 = v26357
                    }
                    v25138 = v25927
                  }
                  v23603 = v25138
                }
                v20490 = v23603
              }
              v15417 = v20490
            }
            v6980 = v15417
          }
          return v6980
        }
      }else {
        var v6982 = this.declAST;
        if(v6982) {
          v6982 = this.declAST.nodeType == TypeScript$$20.NodeType.FuncDecl
        }
        var isFunction = v6982;
        var v6983 = isFunction;
        if(v6983) {
          v6983 = this.declAST.isMethod()
        }
        var isMethod$$2 = v6983;
        var v6984 = isFunction;
        if(v6984) {
          v6984 = JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [this.declAST.fncFlags, TypeScript$$20.FncFlags.Static])
        }
        var isStaticFunction = v6984;
        var v6985 = isMethod$$2;
        if(v6985) {
          v6985 = JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [this.declAST.fncFlags, TypeScript$$20.FncFlags.Private])
        }
        var isPrivateMethod = v6985;
        var v6986 = this.isType();
        if(v6986) {
          v6986 = this.aliasLink
        }
        var isAlias = v6986;
        var v15426 = this.isMember();
        if(!v15426) {
          var v20497 = isMethod$$2;
          if(!v20497) {
            v20497 = isStaticFunction || isAlias
          }
          v15426 = v20497
        }
        if(v15426) {
          var v15427 = JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [this.flags, TypeScript$$20.SymbolFlags.Private]);
          if(!v15427) {
            v15427 = isPrivateMethod
          }
          if(v15427) {
            var v15428 = scope$$16.container == null;
            if(v15428) {
              v15428 = this.container != scope$$16.container
            }
            if(v15428) {
              return false
            }else {
              var v6987;
              if(this.container == null) {
                v6987 = true
              }else {
                v6987 = aEnclosesB(scope$$16.container, this.container)
              }
              return v6987
            }
          }else {
            return true
          }
        }else {
          if(this.container) {
            return aEnclosesB(this, scope$$16.container)
          }else {
            return true
          }
        }
      }
      return
    }
    function v731(checker$$8) {
      if(this == checker$$8.gloMod) {
        return true
      }
      if(JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [this.flags, TypeScript$$20.SymbolFlags.Private])) {
        return false
      }
      if(!JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [this.flags, TypeScript$$20.SymbolFlags.Exported])) {
        return this.container == checker$$8.gloMod
      }
      var v6999 = this.container;
      return JAM.call(v6999.isExternallyVisible, v6999, [checker$$8])
    }
    function v730() {
      var builder$$4 = this.name;
      var ancestor = this.container;
      var v15436 = ancestor;
      if(v15436) {
        v15436 = ancestor.name != TypeScript$$20.globalId
      }
      var v7001 = v15436;
      for(;v7001;) {
        builder$$4 = ancestor.name + "." + builder$$4;
        ancestor = ancestor.container;
        var v15438 = ancestor;
        if(v15438) {
          v15438 = ancestor.name != TypeScript$$20.globalId
        }
        v7001 = v15438
      }
      return builder$$4
    }
    function v729(scope$$15) {
      if(scope$$15 == null) {
        return JAM.call(this.getPrettyName, this, [null]) + this.getOptionalNameString()
      }
      var lca = JAM.call(this.findCommonAncestorPath, this, [scope$$15.container]);
      var builder$$3 = "";
      var i$$63 = 0;
      var len$$24 = lca.length;
      var v7009 = i$$63 < len$$24;
      for(;v7009;) {
        introspect(JAM.policy.p1) {
          var v7006 = lca[i$$63]
        }
        var v15439;
        if(i$$63 == len$$24 - 1) {
          v15439 = scope$$15.container
        }else {
          v15439 = lca[i$$63 + 1]
        }
        var prettyName = JAM.call(v7006.getPrettyName, v7006, [v15439]);
        builder$$3 = prettyName + "." + builder$$3;
        i$$63 = i$$63 + 1;
        v7009 = i$$63 < len$$24
      }
      var v15440 = builder$$3;
      var v25139;
      if(len$$24 == 0) {
        v25139 = scope$$15.container
      }else {
        v25139 = lca[0]
      }
      builder$$3 = v15440 + (JAM.call(this.getPrettyName, this, [v25139]) + this.getOptionalNameString());
      return builder$$3
    }
    function v728(scopeSymbol) {
      return this.name
    }
    function v727(b$$9) {
      if(this.container == null) {
        return new Array
      }
      var aPath = this.container.pathToRoot();
      var bPath;
      if(b$$9) {
        bPath = b$$9.pathToRoot()
      }else {
        bPath = new Array
      }
      var commonNodeIndex = -1;
      var i$$62 = 0;
      var aLen = aPath.length;
      var v7015 = i$$62 < aLen;
      for(;v7015;) {
        introspect(JAM.policy.p1) {
          var aNode = aPath[i$$62]
        }
        var j$$8 = 0;
        var bLen = bPath.length;
        var v7013 = j$$8 < bLen;
        for(;v7013;) {
          introspect(JAM.policy.p1) {
            var bNode = bPath[j$$8]
          }
          if(aNode == bNode) {
            commonNodeIndex = i$$62;
            break
          }
          j$$8 = j$$8 + 1;
          v7013 = j$$8 < bLen
        }
        if(commonNodeIndex >= 0) {
          break
        }
        i$$62 = i$$62 + 1;
        v7015 = i$$62 < aLen
      }
      if(commonNodeIndex >= 0) {
        return aPath.slice(0, commonNodeIndex)
      }else {
        return aPath
      }
      return
    }
    function v726() {
      var path$$6 = new Array;
      var node$$2 = this;
      var v15443 = node$$2;
      if(v15443) {
        v15443 = node$$2.name != TypeScript$$20.globalId
      }
      var v7018 = v15443;
      for(;v7018;) {
        path$$6[path$$6.length] = node$$2;
        node$$2 = node$$2.container;
        var v15444 = node$$2;
        if(v15444) {
          v15444 = node$$2.name != TypeScript$$20.globalId
        }
        v7018 = v15444
      }
      return path$$6
    }
    function v725() {
      var v7019;
      if(JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [this.flags, TypeScript$$20.SymbolFlags.Optional])) {
        v7019 = "?"
      }else {
        v7019 = ""
      }
      return v7019
    }
    function v724(scope$$14) {
      var v7020 = TypeScript$$20.MemberName;
      return JAM.call(v7020.create, v7020, [this.toString()])
    }
    function v723(scope$$13) {
      return JAM.call(this.getTypeNameEx, this, [scope$$13]).toString()
    }
    function v722() {
      var v7023 = JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [this.flags, TypeScript$$20.SymbolFlags.Property]);
      if(v7023) {
        v7023 = !JAM.call(TypeScript$$20.hasFlag, TypeScript$$20, [this.flags, TypeScript$$20.SymbolFlags.ModuleMember])
      }
      return v7023
    }
    function v721() {
      return false
    }
    function v720() {
      return null
    }
    function v719() {
      return false
    }
    function v718() {
      return false
    }
    function v717() {
      return false
    }
    function v716() {
      return false
    }
    function v715() {
      return false
    }
    function v714() {
      return false
    }
    function v713() {
      return null
    }
    function Symbol$$1(name$$53, location$$21, length$$15, unitIndex$$3) {
      this.name = name$$53;
      this.location = location$$21;
      this.length = length$$15;
      this.unitIndex = unitIndex$$3;
      this.bound = false;
      this.flags = TypeScript$$20.SymbolFlags.None;
      this.isObjectLitField = false;
      this.declAST = null;
      this.declModule = null;
      this.passSymbolCreated = TypeScript$$20.CompilerDiagnostics.analysisPass;
      return
    }
    Symbol$$1.prototype.instanceScope = v713;
    Symbol$$1.prototype.isVariable = v714;
    Symbol$$1.prototype.isMember = v715;
    Symbol$$1.prototype.isInferenceSymbol = v716;
    Symbol$$1.prototype.isWith = v717;
    Symbol$$1.prototype.writeable = v718;
    Symbol$$1.prototype.isType = v719;
    Symbol$$1.prototype.getType = v720;
    Symbol$$1.prototype.isAccessor = v721;
    Symbol$$1.prototype.isInstanceProperty = v722;
    Symbol$$1.prototype.getTypeName = v723;
    Symbol$$1.prototype.getTypeNameEx = v724;
    Symbol$$1.prototype.getOptionalNameString = v725;
    Symbol$$1.prototype.pathToRoot = v726;
    Symbol$$1.prototype.findCommonAncestorPath = v727;
    Symbol$$1.prototype.getPrettyName = v728;
    Symbol$$1.prototype.scopeRelativeName = v729;
    Symbol$$1.prototype.fullName = v730;
    Symbol$$1.prototype.isExternallyVisible = v731;
    Symbol$$1.prototype.visible = v732;
    Symbol$$1.prototype.addRef = v733;
    Symbol$$1.prototype.toString = v734;
    Symbol$$1.prototype.print = v735;
    Symbol$$1.prototype.specializeType = v736;
    Symbol$$1.prototype.setType = v737;
    Symbol$$1.prototype.kind = v738;
    Symbol$$1.prototype.getInterfaceDeclFromSymbol = v739;
    Symbol$$1.prototype.getVarDeclFromSymbol = v740;
    Symbol$$1.prototype.getDocComments = v741;
    Symbol$$1.prototype.isStatic = v742;
    return Symbol$$1
  }
  function v712(TypeCheckStatus$$1) {
    TypeCheckStatus$$1._map = [];
    TypeCheckStatus$$1._map[0] = "NotStarted";
    TypeCheckStatus$$1.NotStarted = 0;
    TypeCheckStatus$$1._map[1] = "Started";
    TypeCheckStatus$$1.Started = 1;
    TypeCheckStatus$$1._map[2] = "Finished";
    TypeCheckStatus$$1.Finished = 2;
    return
  }
  function aLexicallyEnclosesB(a$$7, b$$7) {
    var v15449 = a$$7.declAST;
    if(v15449) {
      var v20526 = b$$7;
      if(v20526) {
        var v23611 = b$$7.declAST;
        if(v23611) {
          v23611 = a$$7.declAST.nodeType == TypeScript$$20.NodeType.FuncDecl
        }
        v20526 = v23611
      }
      v15449 = v20526
    }
    if(v15449) {
      var v7059 = a$$7.declAST.minChar <= b$$7.declAST.minChar;
      if(v7059) {
        v7059 = a$$7.declAST.limChar >= b$$7.declAST.limChar
      }
      return v7059
    }else {
      return false
    }
    return
  }
  function aEnclosesB(a$$8, b$$8) {
    var v7062 = a$$8.container;
    for(;v7062;) {
      var v15454 = a$$8 == b$$8;
      if(!v15454) {
        v15454 = aLexicallyEnclosesB(a$$8.container, b$$8)
      }
      if(v15454) {
        return true
      }
      a$$8 = a$$8.container;
      v7062 = a$$8.container
    }
    return false
  }
  var v15455 = TypeScript$$20.TypeCheckStatus;
  if(!v15455) {
    v15455 = TypeScript$$20.TypeCheckStatus = {}
  }
  v712(v15455);
  var TypeCheckStatus = TypeScript$$20.TypeCheckStatus;
  TypeScript$$20.aLexicallyEnclosesB = aLexicallyEnclosesB;
  TypeScript$$20.aEnclosesB = aEnclosesB;
  var Symbol = v743();
  TypeScript$$20.Symbol = Symbol;
  var ValueLocation = v744();
  TypeScript$$20.ValueLocation = ValueLocation;
  var InferenceSymbol = v747(Symbol);
  TypeScript$$20.InferenceSymbol = InferenceSymbol;
  var TypeSymbol = v761(InferenceSymbol);
  TypeScript$$20.TypeSymbol = TypeSymbol;
  var WithSymbol = v763(TypeSymbol);
  TypeScript$$20.WithSymbol = WithSymbol;
  var FieldSymbol = v775(InferenceSymbol);
  TypeScript$$20.FieldSymbol = FieldSymbol;
  var ParameterSymbol = v786(InferenceSymbol);
  TypeScript$$20.ParameterSymbol = ParameterSymbol;
  var VariableSymbol = v793(InferenceSymbol);
  TypeScript$$20.VariableSymbol = VariableSymbol;
  return
}
function v711(TypeScript$$19) {
  function v710() {
    function v709(checker$$7, ast$$59, hasConstruct) {
      if(this.hasBeenTypechecked) {
        return
      }
      this.hasBeenTypechecked = true;
      var len$$23 = 0;
      var v15456 = this.signatures;
      if(v15456) {
        v15456 = (len$$23 = this.signatures.length) > 0
      }
      if(v15456) {
        var i$$61 = 0;
        var v7073 = i$$61 < len$$23;
        for(;v7073;) {
          var v15457 = !hasConstruct;
          if(v15457) {
            var v20535 = !this.definitionSignature;
            if(v20535) {
              var v25931 = this.signatures;
              introspect(JAM.policy.p1) {
                var v25142 = v25931[i$$61]
              }
              var v23614 = v25142.declAST;
              if(v23614) {
                var v26543 = this.signatures;
                introspect(JAM.policy.p1) {
                  var v26358 = v26543[i$$61]
                }
                var v25143 = v26358.declAST.isOverload;
                if(v25143) {
                  var v26708 = this.signatures;
                  introspect(JAM.policy.p1) {
                    var v26646 = v26708[i$$61]
                  }
                  v25143 = !JAM.call(TypeScript$$19.hasFlag, TypeScript$$19, [v26646.declAST.fncFlags, TypeScript$$19.FncFlags.Ambient])
                }
                v23614 = v25143
              }
              v20535 = v23614
            }
            v15457 = v20535
          }
          if(v15457) {
            var v7065 = checker$$7.errorReporter;
            var v20536 = this.signatures;
            introspect(JAM.policy.p1) {
              var v15458 = v20536[i$$61]
            }
            JAM.call(v7065.simpleError, v7065, [v15458.declAST, "Overload declaration lacks definition"])
          }
          var v23615 = this.signatures;
          introspect(JAM.policy.p1) {
            var v20537 = v23615[i$$61]
          }
          var v15459 = v20537.declAST;
          if(v15459) {
            var v25934 = this.signatures;
            introspect(JAM.policy.p1) {
              var v25144 = v25934[i$$61]
            }
            var v20538 = v25144.declAST.isConstructor;
            if(v20538) {
              var v26361 = this.signatures;
              introspect(JAM.policy.p1) {
                var v25935 = v26361[i$$61]
              }
              var v23617 = v25935.declAST.classDecl;
              if(v23617) {
                var v26741 = this.signatures;
                introspect(JAM.policy.p1) {
                  var v26709 = v26741[i$$61]
                }
                v23617 = v26709.declAST.classDecl.type.symbol.typeCheckStatus == TypeScript$$19.TypeCheckStatus.NotStarted
              }
              v20538 = v23617
            }
            v15459 = v20538
          }
          if(v15459) {
            var v7068 = checker$$7.typeFlow;
            var v23618 = this.signatures;
            introspect(JAM.policy.p1) {
              var v20539 = v23618[i$$61]
            }
            JAM.call(v7068.typeCheck, v7068, [v20539.declAST.classDecl])
          }
          var v7071 = checker$$7.typeFlow;
          var v20540 = this.signatures;
          introspect(JAM.policy.p1) {
            var v15461 = v20540[i$$61]
          }
          JAM.call(v7071.typeCheck, v7071, [v15461.declAST]);
          i$$61 = i$$61 + 1;
          v7073 = i$$61 < len$$23
        }
        JAM.call(this.verifySignatures, this, [checker$$7])
      }
      return
    }
    function v708(checker$$6) {
      var len$$22 = 0;
      var v15462 = this.signatures;
      if(v15462) {
        v15462 = (len$$22 = this.signatures.length) > 0
      }
      if(v15462) {
        var i$$60 = 0;
        var v7084 = i$$60 < len$$22;
        for(;v7084;) {
          var j$$7 = i$$60 + 1;
          var v7079 = j$$7 < len$$22;
          for(;v7079;) {
            var v23620 = this.signatures;
            introspect(JAM.policy.p1) {
              var v20542 = v23620[i$$60]
            }
            var v15463 = v20542.declAST;
            if(v15463) {
              var v25148 = this.signatures;
              introspect(JAM.policy.p1) {
                var v23621 = v25148[j$$7]
              }
              var v20543 = v23621.declAST;
              if(v20543) {
                var v26710 = this.signatures;
                introspect(JAM.policy.p1) {
                  var v26648 = v26710[i$$60]
                }
                var v25149 = !JAM.call(TypeScript$$19.hasFlag, TypeScript$$19, [v26648.declAST.fncFlags, TypeScript$$19.FncFlags.Definition]);
                if(v25149) {
                  var v26711 = this.signatures;
                  introspect(JAM.policy.p1) {
                    var v26649 = v26711[j$$7]
                  }
                  v25149 = !JAM.call(TypeScript$$19.hasFlag, TypeScript$$19, [v26649.declAST.fncFlags, TypeScript$$19.FncFlags.Definition])
                }
                var v23622 = v25149;
                if(v23622) {
                  var v25940 = this.signatures;
                  introspect(JAM.policy.p1) {
                    var v25150 = v25940[i$$60]
                  }
                  var v25941 = this.signatures;
                  introspect(JAM.policy.p1) {
                    var v25151 = v25941[j$$7]
                  }
                  v23622 = JAM.call(checker$$6.signaturesAreIdentical, checker$$6, [v25150, v25151])
                }
                v20543 = v23622
              }
              v15463 = v20543
            }
            if(v15463) {
              var v7075 = checker$$6.errorReporter;
              var v20544 = this.signatures;
              introspect(JAM.policy.p1) {
                var v15464 = v20544[i$$60]
              }
              var v7076 = v15464.declAST;
              var v15465;
              var v25942 = this.signatures;
              introspect(JAM.policy.p1) {
                var v25152 = v25942[i$$60]
              }
              var v23623 = v25152.declAST;
              if(v23623) {
                var v26367 = this.signatures;
                introspect(JAM.policy.p1) {
                  var v25943 = v26367[i$$60]
                }
                v23623 = v25943.declAST.name
              }
              if(v23623) {
                var v26551 = this.signatures;
                introspect(JAM.policy.p1) {
                  var v26368 = v26551[i$$60]
                }
                v15465 = "Signature for '" + v26368.declAST.name.actualText + "' is duplicated"
              }else {
                v15465 = "Signature is duplicated"
              }
              JAM.call(v7075.simpleError, v7075, [v7076, v15465])
            }
            j$$7 = j$$7 + 1;
            v7079 = j$$7 < len$$22
          }
          if(this.definitionSignature) {
            var v20547 = this.definitionSignature;
            var v23625 = this.signatures;
            introspect(JAM.policy.p1) {
              var v20548 = v23625[i$$60]
            }
            if(!JAM.call(checker$$6.signatureIsAssignableToTarget, checker$$6, [v20547, v20548])) {
              var v7080 = checker$$6.errorReporter;
              var v20549 = this.signatures;
              introspect(JAM.policy.p1) {
                var v15467 = v20549[i$$60]
              }
              JAM.call(v7080.simpleError, v7080, [v15467.declAST, "Overload signature is not compatible with function definition"])
            }
          }
          i$$60 = i$$60 + 1;
          v7084 = i$$60 < len$$22
        }
      }
      return
    }
    function v707(pattern$$3, replacement$$1, checker$$5) {
      var result$$13 = new SignatureGroup$$1;
      if(this.signatures) {
        var i$$59 = 0;
        var len$$21 = this.signatures.length;
        var v7088 = i$$59 < len$$21;
        for(;v7088;) {
          var v20550 = this.signatures;
          introspect(JAM.policy.p1) {
            var v15468 = v20550[i$$59]
          }
          JAM.call(result$$13.addSignature, result$$13, [JAM.call(v15468.specializeType, v15468, [pattern$$3, replacement$$1, checker$$5])]);
          i$$59 = i$$59 + 1;
          v7088 = i$$59 < len$$21
        }
      }
      return result$$13
    }
    function v706(prefix$$3, shortform$$2, scope$$12) {
      var result$$12 = [];
      var len$$20 = this.signatures.length;
      if(len$$20 > 1) {
        shortform$$2 = false
      }
      var i$$58 = 0;
      var v7096 = i$$58 < len$$20;
      for(;v7096;) {
        var v15469 = len$$20 > 1;
        if(v15469) {
          var v23626 = this.signatures;
          introspect(JAM.policy.p1) {
            var v20551 = v23626[i$$58]
          }
          v15469 = v20551 == this.definitionSignature
        }
        if(v15469) {
          i$$58 = i$$58 + 1;
          v7096 = i$$58 < len$$20;
          continue
        }
        if(this.flags & TypeScript$$19.SignatureFlags.IsIndexer) {
          var v20554 = this.signatures;
          introspect(JAM.policy.p1) {
            var v15472 = v20554[i$$58]
          }
          JAM.call(result$$12.push, result$$12, [JAM.call(v15472.toStringHelperEx, v15472, [shortform$$2, true, scope$$12])])
        }else {
          var v20555 = this.signatures;
          introspect(JAM.policy.p1) {
            var v15473 = v20555[i$$58]
          }
          JAM.call(result$$12.push, result$$12, [JAM.call(v15473.toStringHelperEx, v15473, [shortform$$2, false, scope$$12, prefix$$3])])
        }
        i$$58 = i$$58 + 1;
        v7096 = i$$58 < len$$20
      }
      return result$$12
    }
    function v705() {
      return this.signatures.toString()
    }
    function v704(signature$$2) {
      if(this.signatures == null) {
        var v27010 = new Array;
        this.signatures = v27010
      }
      JAM.set(this.signatures, this.signatures.length, signature$$2);
      var v15476 = signature$$2.declAST;
      if(v15476) {
        var v20556 = !signature$$2.declAST.isOverload;
        if(v20556) {
          var v23628 = !signature$$2.declAST.isSignature();
          if(v23628) {
            var v25157 = !JAM.call(TypeScript$$19.hasFlag, TypeScript$$19, [signature$$2.declAST.fncFlags, TypeScript$$19.FncFlags.Ambient]);
            if(v25157) {
              v25157 = JAM.call(TypeScript$$19.hasFlag, TypeScript$$19, [signature$$2.declAST.fncFlags, TypeScript$$19.FncFlags.Definition])
            }
            v23628 = v25157
          }
          v20556 = v23628
        }
        v15476 = v20556
      }
      if(v15476) {
        this.definitionSignature = signature$$2
      }
      return
    }
    function SignatureGroup$$1() {
      this.signatures = [];
      this.hasImplementation = true;
      this.definitionSignature = null;
      this.hasBeenTypechecked = false;
      this.flags = TypeScript$$19.SignatureFlags.None;
      return
    }
    SignatureGroup$$1.prototype.addSignature = v704;
    SignatureGroup$$1.prototype.toString = v705;
    SignatureGroup$$1.prototype.toStrings = v706;
    SignatureGroup$$1.prototype.specializeType = v707;
    SignatureGroup$$1.prototype.verifySignatures = v708;
    SignatureGroup$$1.prototype.typeCheck = v709;
    return SignatureGroup$$1
  }
  function v703() {
    function v702(shortform$$1, brackets$$1, scope$$11, prefix$$2) {
      if(typeof prefix$$2 === "undefined") {
        prefix$$2 = ""
      }
      var builder$$2 = new TypeScript$$19.MemberNameArray;
      if(brackets$$1) {
        builder$$2.prefix = prefix$$2 + "["
      }else {
        builder$$2.prefix = prefix$$2 + "("
      }
      var paramLen$$1 = this.parameters.length;
      var v7112;
      if(this.hasVariableArgList) {
        v7112 = paramLen$$1 - 1
      }else {
        v7112 = paramLen$$1
      }
      var len$$19 = v7112;
      var i$$57 = 0;
      var v7117 = i$$57 < len$$19;
      for(;v7117;) {
        var v15479 = TypeScript$$19.MemberName;
        var v25949 = this.parameters;
        introspect(JAM.policy.p1) {
          var v25158 = v25949[i$$57]
        }
        var v23629 = v25158.name;
        var v25159;
        var v26554 = this.parameters;
        introspect(JAM.policy.p1) {
          var v26373 = v26554[i$$57]
        }
        if(v26373.isOptional()) {
          v25159 = "?"
        }else {
          v25159 = ""
        }
        JAM.call(builder$$2.add, builder$$2, [JAM.call(v15479.create, v15479, [v23629 + v25159 + ": "])]);
        var v23631 = this.parameters;
        introspect(JAM.policy.p1) {
          var v20558 = v23631[i$$57]
        }
        var v15481 = v20558.getType();
        JAM.call(builder$$2.add, builder$$2, [JAM.call(v15481.getScopedTypeNameEx, v15481, [scope$$11])]);
        if(i$$57 < paramLen$$1 - 1) {
          var v15483 = TypeScript$$19.MemberName;
          JAM.call(builder$$2.add, builder$$2, [JAM.call(v15483.create, v15483, [", "])])
        }
        i$$57 = i$$57 + 1;
        v7117 = i$$57 < len$$19
      }
      if(this.hasVariableArgList) {
        var v15484 = TypeScript$$19.MemberName;
        var v25951 = this.parameters;
        introspect(JAM.policy.p1) {
          var v25160 = v25951[i$$57]
        }
        JAM.call(builder$$2.add, builder$$2, [JAM.call(v15484.create, v15484, ["..." + v25160.name + ": "])]);
        var v23633 = this.parameters;
        introspect(JAM.policy.p1) {
          var v20560 = v23633[i$$57]
        }
        var v15486 = v20560.getType();
        JAM.call(builder$$2.add, builder$$2, [JAM.call(v15486.getScopedTypeNameEx, v15486, [scope$$11])])
      }
      if(shortform$$1) {
        if(brackets$$1) {
          var v15487 = TypeScript$$19.MemberName;
          JAM.call(builder$$2.add, builder$$2, [JAM.call(v15487.create, v15487, ["] => "])])
        }else {
          var v15488 = TypeScript$$19.MemberName;
          JAM.call(builder$$2.add, builder$$2, [JAM.call(v15488.create, v15488, [") => "])])
        }
      }else {
        if(brackets$$1) {
          var v15489 = TypeScript$$19.MemberName;
          JAM.call(builder$$2.add, builder$$2, [JAM.call(v15489.create, v15489, ["]: "])])
        }else {
          var v15490 = TypeScript$$19.MemberName;
          JAM.call(builder$$2.add, builder$$2, [JAM.call(v15490.create, v15490, ["): "])])
        }
      }
      if(this.returnType.type) {
        var v15492 = this.returnType.type;
        JAM.call(builder$$2.add, builder$$2, [JAM.call(v15492.getScopedTypeNameEx, v15492, [scope$$11])])
      }else {
        var v15493 = TypeScript$$19.MemberName;
        JAM.call(builder$$2.add, builder$$2, [JAM.call(v15493.create, v15493, ["any"])])
      }
      return builder$$2
    }
    function v701(shortform, brackets, scope$$10) {
      return JAM.call(this.toStringHelperEx, this, [shortform, brackets, scope$$10]).toString()
    }
    function v700() {
      return JAM.call(this.toStringHelper, this, [false, false, null])
    }
    function v699(pattern$$2, replacement, checker$$4) {
      var result$$11 = new Signature$$1;
      if(this.hasVariableArgList) {
        result$$11.hasVariableArgList = true
      }
      var v7130 = result$$11;
      var v27011 = new TypeScript$$19.TypeLink;
      v7130.returnType = v27011;
      if(this.returnType.type) {
        var v7131 = result$$11.returnType;
        var v15496 = this.returnType.type;
        var v27012 = JAM.call(v15496.specializeType, v15496, [pattern$$2, replacement, checker$$4, false]);
        v7131.type = v27012
      }else {
        result$$11.returnType.type = checker$$4.anyType
      }
      if(this.parameters) {
        result$$11.parameters = [];
        var i$$56 = 0;
        var len$$18 = this.parameters.length;
        var v7146 = i$$56 < len$$18;
        for(;v7146;) {
          var v7135 = this.parameters;
          introspect(JAM.policy.p1) {
            var oldSym = v7135[i$$56]
          }
          var paramDef = new TypeScript$$19.ValueLocation;
          var paramSym$$1 = JAM.new(TypeScript$$19.ParameterSymbol, [oldSym.name, oldSym.location, checker$$4.locationInfo.unitIndex, paramDef]);
          paramSym$$1.declAST = this.declAST;
          paramDef.symbol = paramSym$$1;
          var v7141 = paramDef;
          var v27013 = new TypeScript$$19.TypeLink;
          v7141.typeLink = v27013;
          result$$11.parameters[i$$56] = paramSym$$1;
          var oldType = oldSym.getType();
          if(oldType) {
            var v7143 = paramDef.typeLink;
            var v27014 = JAM.call(oldType.specializeType, oldType, [pattern$$2, replacement, checker$$4, false]);
            v7143.type = v27014;
            paramSym$$1.declAST.type = paramDef.typeLink.type
          }else {
            paramDef.typeLink.type = checker$$4.anyType
          }
          i$$56 = i$$56 + 1;
          v7146 = i$$56 < len$$18
        }
      }
      result$$11.nonOptionalParameterCount = this.nonOptionalParameterCount;
      result$$11.declAST = this.declAST;
      return result$$11
    }
    function Signature$$1() {
      this.hasVariableArgList = false;
      this.parameters = null;
      this.declAST = null;
      this.typeCheckStatus = TypeScript$$19.TypeCheckStatus.NotStarted;
      this.nonOptionalParameterCount = 0;
      return
    }
    Signature$$1.prototype.specializeType = v699;
    Signature$$1.prototype.toString = v700;
    Signature$$1.prototype.toStringHelper = v701;
    Signature$$1.prototype.toStringHelperEx = v702;
    return Signature$$1
  }
  var Signature = v703();
  TypeScript$$19.Signature = Signature;
  var SignatureGroup = v710();
  TypeScript$$19.SignatureGroup = SignatureGroup;
  return
}
function v698(TypeScript$$18) {
  function v697() {
    function v696() {
      if(this.scriptFragment == null) {
        var ast$$58 = this.scopeStartAST;
        var minChar$$31 = ast$$58.minChar;
        var v7153;
        if(this.isMemberCompletion) {
          v7153 = this.pos
        }else {
          v7153 = this.pos + 1
        }
        var limChar$$10 = v7153;
        this.scriptFragment = JAM.call(TypeScript$$18.quickParse, TypeScript$$18, [this.logger, ast$$58, this.text, minChar$$31, limChar$$10, null]).Script
      }
      return this.scriptFragment
    }
    function v695() {
      return this.scopeStartAST.minChar
    }
    function v694() {
      return this.scopeStartAST
    }
    function v693() {
      return this.scopeStartAST.minChar
    }
    function v692() {
      return this.scopeStartAST
    }
    function v691() {
      return this.objectLiteralScopeGetter()
    }
    function v690() {
      return this.scopeGetter()
    }
    function EnclosingScopeContext$$1(logger$$3, script$$13, text$$20, pos$$5, isMemberCompletion$$1) {
      this.logger = logger$$3;
      this.script = script$$13;
      this.text = text$$20;
      this.pos = pos$$5;
      this.isMemberCompletion = isMemberCompletion$$1;
      this.scopeGetter = null;
      this.objectLiteralScopeGetter = null;
      this.scopeStartAST = null;
      this.skipNextFuncDeclForClass = false;
      this.deepestModuleDecl = null;
      this.enclosingClassDecl = null;
      this.enclosingObjectLit = null;
      this.publicsOnly = true;
      this.useFullAst = false;
      return
    }
    EnclosingScopeContext$$1.prototype.getScope = v690;
    EnclosingScopeContext$$1.prototype.getObjectLiteralScope = v691;
    EnclosingScopeContext$$1.prototype.getScopeAST = v692;
    EnclosingScopeContext$$1.prototype.getScopePosition = v693;
    EnclosingScopeContext$$1.prototype.getScriptFragmentStartAST = v694;
    EnclosingScopeContext$$1.prototype.getScriptFragmentPosition = v695;
    EnclosingScopeContext$$1.prototype.getScriptFragment = v696;
    return EnclosingScopeContext$$1
  }
  function v689() {
    function MemberScopeContext$$1(flow, pos$$4, matchFlag) {
      this.flow = flow;
      this.pos = pos$$4;
      this.matchFlag = matchFlag;
      this.type = null;
      this.ast = null;
      var v27015 = new TypeScript$$18.AstWalkOptions;
      this.options = v27015;
      return
    }
    return MemberScopeContext$$1
  }
  function v688() {
    function TypeCollectionContext$$1(scopeChain$$1, checker$$3) {
      this.scopeChain = scopeChain$$1;
      this.checker = checker$$3;
      this.script = null;
      return
    }
    return TypeCollectionContext$$1
  }
  function preFindMemberScope(ast$$56, parent$$47, walker$$44) {
    var memScope = walker$$44.state;
    var v15505 = JAM.call(TypeScript$$18.hasFlag, TypeScript$$18, [ast$$56.flags, memScope.matchFlag]);
    if(v15505) {
      var v20565 = memScope.pos < 0;
      if(!v20565) {
        v20565 = memScope.pos == ast$$56.limChar
      }
      v15505 = v20565
    }
    if(v15505) {
      memScope.ast = ast$$56;
      var v15506 = ast$$56.type == null;
      if(v15506) {
        v15506 = memScope.pos >= 0
      }
      if(v15506) {
        var v7166 = memScope.flow;
        JAM.call(v7166.inScopeTypeCheck, v7166, [ast$$56, memScope.scope])
      }
      memScope.type = ast$$56.type;
      memScope.options.stopWalk()
    }
    return ast$$56
  }
  function pushTypeCollectionScope(container$$2, valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, context$$37, thisType$$1, classType$$2, moduleDecl$$5) {
    var builder$$1 = JAM.new(TypeScript$$18.SymbolScopeBuilder, [valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container$$2]);
    var chain$$1 = JAM.new(TypeScript$$18.ScopeChain, [container$$2, context$$37.scopeChain, builder$$1]);
    chain$$1.thisType = thisType$$1;
    chain$$1.classType = classType$$2;
    chain$$1.moduleDecl = moduleDecl$$5;
    context$$37.scopeChain = chain$$1;
    return
  }
  function popTypeCollectionScope(context$$38) {
    context$$38.scopeChain = context$$38.scopeChain.previous;
    return
  }
  function preFindEnclosingScope(ast$$57, parent$$48, walker$$45) {
    function v687() {
      var v15507 = funcDecl$$15.isConstructor;
      if(v15507) {
        v15507 = JAM.call(TypeScript$$18.hasFlag, TypeScript$$18, [funcDecl$$15.fncFlags, TypeScript$$18.FncFlags.ClassMethod])
      }
      if(v15507) {
        var v15508 = ast$$57.type;
        if(v15508) {
          v15508 = ast$$57.type.enclosingType
        }
        if(v15508) {
          return ast$$57.type.enclosingType.constructorScope
        }
      }
      if(funcDecl$$15.scopeType) {
        return funcDecl$$15.scopeType.containedScope
      }
      if(funcDecl$$15.type) {
        return funcDecl$$15.type.containedScope
      }
      return null
    }
    function v686() {
      var v7182;
      if(ast$$57.type === null) {
        v7182 = null
      }else {
        v7182 = ast$$57.type.containedScope
      }
      return v7182
    }
    function v685() {
      var v7183;
      if(ast$$57.type === null) {
        v7183 = null
      }else {
        v7183 = ast$$57.type.containedScope
      }
      return v7183
    }
    function v684() {
      return objectLit.targetType.memberScope
    }
    function v683() {
      return objectLit.targetType.containedScope
    }
    function v682() {
      var v7186;
      var v20573 = ast$$57.type === null;
      if(!v20573) {
        v20573 = ast$$57.type.instanceType.containedScope === null
      }
      if(v20573) {
        v7186 = null
      }else {
        v7186 = ast$$57.type.instanceType.containedScope
      }
      return v7186
    }
    function v681() {
      var v7187;
      if(script$$11.bod === null) {
        v7187 = null
      }else {
        v7187 = script$$11.bod.enclosingScope
      }
      return v7187
    }
    var context$$39 = walker$$45.state;
    var minChar$$30 = ast$$57.minChar;
    var limChar$$9 = ast$$57.limChar;
    var v15518 = ast$$57.nodeType == TypeScript$$18.NodeType.Script;
    if(v15518) {
      v15518 = context$$39.pos > limChar$$9
    }
    if(v15518) {
      limChar$$9 = context$$39.pos
    }
    var v15519 = minChar$$30 <= context$$39.pos;
    if(v15519) {
      v15519 = limChar$$9 >= context$$39.pos
    }
    if(v15519) {
      switch(ast$$57.nodeType) {
        case TypeScript$$18.NodeType.Script:
          var script$$11 = ast$$57;
          context$$39.scopeGetter = v681;
          context$$39.scopeStartAST = script$$11;
          break;
        case TypeScript$$18.NodeType.ClassDeclaration:
          context$$39.scopeGetter = v682;
          context$$39.scopeStartAST = ast$$57;
          context$$39.enclosingClassDecl = ast$$57;
          break;
        case TypeScript$$18.NodeType.ObjectLit:
          var objectLit = ast$$57;
          if(objectLit.targetType) {
            context$$39.scopeGetter = v683;
            context$$39.objectLiteralScopeGetter = v684;
            context$$39.enclosingObjectLit = objectLit
          }
          break;
        case TypeScript$$18.NodeType.ModuleDeclaration:
          context$$39.deepestModuleDecl = ast$$57;
          context$$39.scopeGetter = v685;
          context$$39.scopeStartAST = ast$$57;
          break;
        case TypeScript$$18.NodeType.InterfaceDeclaration:
          context$$39.scopeGetter = v686;
          context$$39.scopeStartAST = ast$$57;
          break;
        case TypeScript$$18.NodeType.FuncDecl:
          var funcDecl$$15 = ast$$57;
          if(context$$39.skipNextFuncDeclForClass) {
            context$$39.skipNextFuncDeclForClass = false
          }else {
            context$$39.scopeGetter = v687;
            context$$39.scopeStartAST = ast$$57
          }
      }
      walker$$45.options.goChildren = true
    }else {
      walker$$45.options.goChildren = false
    }
    return ast$$57
  }
  function findEnclosingScopeAt(logger$$2, script$$12, text$$19, pos$$3, isMemberCompletion) {
    var context$$40 = JAM.new(EnclosingScopeContext, [logger$$2, script$$12, text$$19, pos$$3, isMemberCompletion]);
    var v7195 = TypeScript$$18.getAstWalkerFactory();
    JAM.call(v7195.walk, v7195, [script$$12, preFindEnclosingScope, null, null, context$$40]);
    if(context$$40.scopeStartAST === null) {
      return null
    }
    return context$$40
  }
  var TypeCollectionContext = v688();
  TypeScript$$18.TypeCollectionContext = TypeCollectionContext;
  var MemberScopeContext = v689();
  TypeScript$$18.MemberScopeContext = MemberScopeContext;
  var EnclosingScopeContext = v697();
  TypeScript$$18.EnclosingScopeContext = EnclosingScopeContext;
  TypeScript$$18.preFindMemberScope = preFindMemberScope;
  TypeScript$$18.pushTypeCollectionScope = pushTypeCollectionScope;
  TypeScript$$18.popTypeCollectionScope = popTypeCollectionScope;
  TypeScript$$18.preFindEnclosingScope = preFindEnclosingScope;
  TypeScript$$18.findEnclosingScopeAt = findEnclosingScopeAt;
  return
}
function v680(TypeScript$$17) {
  function v679() {
    function v678(b$$6) {
      var v27016 = JAM.call(this.select, this, [this.result, b$$6]);
      this.result = v27016;
      if(this.result) {
        return JAM.call(this.stop, this, [this.result])
      }else {
        return false
      }
      return
    }
    function v677() {
      this.result = null;
      return
    }
    function ScopeSearchFilter$$1(select, stop$$1) {
      this.select = select;
      this.stop = stop$$1;
      this.result = null;
      return
    }
    ScopeSearchFilter$$1.prototype.reset = v677;
    ScopeSearchFilter$$1.prototype.update = v678;
    return ScopeSearchFilter$$1
  }
  function v676() {
    function AssignScopeContext$$1(scopeChain, typeFlow$$36, modDeclChain) {
      this.scopeChain = scopeChain;
      this.typeFlow = typeFlow$$36;
      this.modDeclChain = modDeclChain;
      return
    }
    return AssignScopeContext$$1
  }
  function pushAssignScope(scope$$9, context$$27, type$$31, classType, fnc) {
    var chain = JAM.new(TypeScript$$17.ScopeChain, [null, context$$27.scopeChain, scope$$9]);
    chain.thisType = type$$31;
    chain.classType = classType;
    chain.fnc = fnc;
    context$$27.scopeChain = chain;
    return
  }
  function popAssignScope(context$$28) {
    context$$28.scopeChain = context$$28.scopeChain.previous;
    return
  }
  function instanceCompare(a$$6, b$$5) {
    var v15521 = a$$6 == null;
    if(!v15521) {
      v15521 = !a$$6.isInstanceProperty()
    }
    if(v15521) {
      return b$$5
    }else {
      return a$$6
    }
    return
  }
  function instanceFilterStop(s$$17) {
    return s$$17.isInstanceProperty()
  }
  function preAssignModuleScopes(ast$$48, context$$29) {
    var moduleDecl$$4 = ast$$48;
    var memberScope$$1 = null;
    var aggScope = null;
    var v15522 = moduleDecl$$4.name;
    if(v15522) {
      v15522 = moduleDecl$$4.mod
    }
    if(v15522) {
      moduleDecl$$4.name.sym = moduleDecl$$4.mod.symbol
    }
    var mod$$1 = moduleDecl$$4.mod;
    if(!mod$$1) {
      return
    }
    memberScope$$1 = JAM.new(TypeScript$$17.SymbolTableScope, [mod$$1.members, mod$$1.ambientMembers, mod$$1.enclosedTypes, mod$$1.ambientEnclosedTypes, mod$$1.symbol]);
    mod$$1.memberScope = memberScope$$1;
    var v7215 = context$$29.modDeclChain;
    JAM.call(v7215.push, v7215, [moduleDecl$$4]);
    context$$29.typeFlow.checker.currentModDecl = moduleDecl$$4;
    aggScope = JAM.new(TypeScript$$17.SymbolAggregateScope, [mod$$1.symbol]);
    JAM.call(aggScope.addParentScope, aggScope, [memberScope$$1]);
    JAM.call(aggScope.addParentScope, aggScope, [context$$29.scopeChain.scope]);
    pushAssignScope(aggScope, context$$29, null, null, null);
    mod$$1.containedScope = aggScope;
    if(mod$$1.symbol) {
      var v7220 = context$$29.typeFlow;
      JAM.call(v7220.addLocalsFromScope, v7220, [mod$$1.containedScope, mod$$1.symbol, moduleDecl$$4.vars, mod$$1.members.privateMembers, true])
    }
    return
  }
  function preAssignClassScopes(ast$$49, context$$30) {
    var classDecl$$6 = ast$$49;
    var memberScope$$2 = null;
    var aggScope$$1 = null;
    var v15527 = classDecl$$6.name;
    if(v15527) {
      v15527 = classDecl$$6.type
    }
    if(v15527) {
      classDecl$$6.name.sym = classDecl$$6.type.symbol
    }
    var classType$$1 = ast$$49.type;
    if(classType$$1) {
      var classSym = classType$$1.symbol;
      var v7228 = context$$30.typeFlow.checker;
      memberScope$$2 = JAM.call(v7228.scopeOf, v7228, [classType$$1]);
      aggScope$$1 = JAM.new(TypeScript$$17.SymbolAggregateScope, [classType$$1.symbol]);
      JAM.call(aggScope$$1.addParentScope, aggScope$$1, [memberScope$$2]);
      JAM.call(aggScope$$1.addParentScope, aggScope$$1, [context$$30.scopeChain.scope]);
      classType$$1.containedScope = aggScope$$1;
      classType$$1.memberScope = memberScope$$2;
      var instanceType$$2 = classType$$1.instanceType;
      var v7232 = context$$30.typeFlow.checker;
      memberScope$$2 = JAM.call(v7232.scopeOf, v7232, [instanceType$$2]);
      instanceType$$2.memberScope = memberScope$$2;
      aggScope$$1 = JAM.new(TypeScript$$17.SymbolAggregateScope, [instanceType$$2.symbol]);
      JAM.call(aggScope$$1.addParentScope, aggScope$$1, [context$$30.scopeChain.scope]);
      pushAssignScope(aggScope$$1, context$$30, instanceType$$2, classType$$1, null);
      instanceType$$2.containedScope = aggScope$$1
    }else {
      ast$$49.type = context$$30.typeFlow.anyType
    }
    return
  }
  function preAssignInterfaceScopes(ast$$50, context$$31) {
    var interfaceDecl$$2 = ast$$50;
    var memberScope$$3 = null;
    var aggScope$$2 = null;
    var v15533 = interfaceDecl$$2.name;
    if(v15533) {
      v15533 = interfaceDecl$$2.type
    }
    if(v15533) {
      interfaceDecl$$2.name.sym = interfaceDecl$$2.type.symbol
    }
    var interfaceType = ast$$50.type;
    var v7239 = context$$31.typeFlow.checker;
    memberScope$$3 = JAM.call(v7239.scopeOf, v7239, [interfaceType]);
    interfaceType.memberScope = memberScope$$3;
    aggScope$$2 = JAM.new(TypeScript$$17.SymbolAggregateScope, [interfaceType.symbol]);
    JAM.call(aggScope$$2.addParentScope, aggScope$$2, [memberScope$$3]);
    JAM.call(aggScope$$2.addParentScope, aggScope$$2, [context$$31.scopeChain.scope]);
    pushAssignScope(aggScope$$2, context$$31, null, null, null);
    interfaceType.containedScope = aggScope$$2;
    return
  }
  function preAssignWithScopes(ast$$51, context$$32) {
    var withStmt$$1 = ast$$51;
    var withType = withStmt$$1.type;
    var members$$12 = JAM.new(TypeScript$$17.ScopedMembers, [JAM.new(TypeScript$$17.DualStringHashTable, [new TypeScript$$17.StringHashTable, new TypeScript$$17.StringHashTable])]);
    var ambientMembers$$1 = JAM.new(TypeScript$$17.ScopedMembers, [JAM.new(TypeScript$$17.DualStringHashTable, [new TypeScript$$17.StringHashTable, new TypeScript$$17.StringHashTable])]);
    withType = new TypeScript$$17.Type;
    var withSymbol = JAM.new(TypeScript$$17.WithSymbol, [withStmt$$1.minChar, context$$32.typeFlow.checker.locationInfo.unitIndex, withType]);
    withType.members = members$$12;
    withType.ambientMembers = ambientMembers$$1;
    withType.symbol = withSymbol;
    withType.setHasImplementation();
    withStmt$$1.type = withType;
    var withScope = JAM.new(TypeScript$$17.SymbolScopeBuilder, [withType.members, withType.ambientMembers, null, null, context$$32.scopeChain.scope, withType.symbol]);
    pushAssignScope(withScope, context$$32, null, null, null);
    withType.containedScope = withScope;
    return
  }
  function preAssignFuncDeclScopes(ast$$52, context$$33) {
    var funcDecl$$13 = ast$$52;
    var container$$1 = null;
    var localContainer = null;
    if(funcDecl$$13.type) {
      localContainer = ast$$52.type.symbol
    }
    var isStatic$$5 = JAM.call(TypeScript$$17.hasFlag, TypeScript$$17, [funcDecl$$13.fncFlags, TypeScript$$17.FncFlags.Static]);
    var v7260 = isStatic$$5;
    if(v7260) {
      v7260 = context$$33.scopeChain.fnc != null
    }
    var isInnerStatic = v7260;
    var v7261;
    if(isInnerStatic) {
      v7261 = context$$33.scopeChain.fnc.type.memberScope
    }else {
      v7261 = context$$33.scopeChain.scope
    }
    var parentScope = v7261;
    var v15549 = context$$33.scopeChain.thisType;
    if(v15549) {
      var v20591 = !funcDecl$$13.isConstructor;
      if(!v20591) {
        v20591 = JAM.call(TypeScript$$17.hasFlag, TypeScript$$17, [funcDecl$$13.fncFlags, TypeScript$$17.FncFlags.ClassMethod])
      }
      v15549 = v20591
    }
    if(v15549) {
      var instType = context$$33.scopeChain.thisType;
      var v15550 = !(instType.typeFlags & TypeScript$$17.TypeFlags.IsClass);
      if(v15550) {
        v15550 = !JAM.call(TypeScript$$17.hasFlag, TypeScript$$17, [funcDecl$$13.fncFlags, TypeScript$$17.FncFlags.ClassMethod])
      }
      if(v15550) {
        var v15551 = !funcDecl$$13.isMethod();
        if(!v15551) {
          v15551 = isStatic$$5
        }
        if(v15551) {
          parentScope = instType.constructorScope
        }else {
          parentScope = instType.containedScope
        }
      }else {
        var v15552 = context$$33.scopeChain.previous.scope.container;
        if(v15552) {
          var v20597 = context$$33.scopeChain.previous.scope.container.declAST;
          if(v20597) {
            var v23655 = context$$33.scopeChain.previous.scope.container.declAST.nodeType == TypeScript$$17.NodeType.FuncDecl;
            if(v23655) {
              v23655 = context$$33.scopeChain.previous.scope.container.declAST.isConstructor
            }
            v20597 = v23655
          }
          v15552 = v20597
        }
        if(v15552) {
          parentScope = instType.constructorScope
        }else {
          var v15553 = isStatic$$5;
          if(v15553) {
            v15553 = context$$33.scopeChain.classType
          }
          if(v15553) {
            parentScope = context$$33.scopeChain.classType.containedScope
          }else {
            parentScope = instType.containedScope
          }
        }
      }
      container$$1 = instType.symbol
    }else {
      var v15555 = funcDecl$$13.isConstructor;
      if(v15555) {
        v15555 = context$$33.scopeChain.thisType
      }
      if(v15555) {
        container$$1 = context$$33.scopeChain.thisType.symbol
      }
    }
    var v15557 = funcDecl$$13.type == null;
    if(!v15557) {
      v15557 = JAM.call(TypeScript$$17.hasFlag, TypeScript$$17, [funcDecl$$13.type.symbol.flags, TypeScript$$17.SymbolFlags.TypeSetDuringScopeAssignment])
    }
    if(v15557) {
      var v15558 = context$$33.scopeChain.fnc;
      if(v15558) {
        v15558 = context$$33.scopeChain.fnc.type
      }
      if(v15558) {
        container$$1 = context$$33.scopeChain.fnc.type.symbol
      }
      var funcScope = null;
      var outerFnc$$1 = context$$33.scopeChain.fnc;
      var v7274;
      if(funcDecl$$13.name) {
        v7274 = funcDecl$$13.name.actualText
      }else {
        v7274 = null
      }
      var nameText$$1 = v7274;
      var fgSym = null;
      if(isStatic$$5) {
        var v15562 = outerFnc$$1.type.members == null;
        if(v15562) {
          v15562 = container$$1.getType().memberScope
        }
        if(v15562) {
          outerFnc$$1.type.members = container$$1.type.memberScope.valueMembers
        }
        funcScope = context$$33.scopeChain.fnc.type.memberScope;
        JAM.set(outerFnc$$1.innerStaticFuncs, outerFnc$$1.innerStaticFuncs.length, funcDecl$$13)
      }else {
        funcScope = context$$33.scopeChain.scope
      }
      var v15566 = nameText$$1;
      if(v15566) {
        var v20611 = nameText$$1 != "__missing";
        if(v20611) {
          v20611 = !funcDecl$$13.isAccessor()
        }
        v15566 = v20611
      }
      if(v15566) {
        if(isStatic$$5) {
          fgSym = JAM.call(funcScope.findLocal, funcScope, [nameText$$1, false, false])
        }else {
          fgSym = JAM.call(funcScope.findLocal, funcScope, [nameText$$1, false, false])
        }
      }
      var v7282 = context$$33.typeFlow.checker;
      JAM.call(v7282.createFunctionSignature, v7282, [funcDecl$$13, container$$1, funcScope, fgSym, fgSym == null]);
      var v20612 = !funcDecl$$13.accessorSymbol;
      if(v20612) {
        var v23662 = funcDecl$$13.fncFlags & TypeScript$$17.FncFlags.ClassMethod;
        if(v23662) {
          var v25173 = container$$1;
          if(v25173) {
            var v26377 = !fgSym;
            if(!v26377) {
              v26377 = fgSym.declAST.nodeType != TypeScript$$17.NodeType.FuncDecl
            }
            var v25958 = v26377;
            if(v25958) {
              v25958 = funcDecl$$13.isAccessor()
            }
            v25173 = v25958
          }
          v23662 = v25173
        }
        v20612 = v23662
      }
      var v15568 = v20612;
      if(!v15568) {
        var v20613 = fgSym;
        if(v20613) {
          v20613 = fgSym.isAccessor()
        }
        v15568 = v20613
      }
      if(v15568) {
        var v7284 = funcDecl$$13;
        var v15569 = context$$33.typeFlow.checker;
        var v15570 = container$$1.getType();
        var v20616 = funcDecl$$13.isMethod();
        if(v20616) {
          v20616 = isStatic$$5
        }
        var v27017 = JAM.call(v15569.createAccessorSymbol, v15569, [funcDecl$$13, fgSym, v15570, v20616, true, funcScope, container$$1]);
        v7284.accessorSymbol = v27017
      }
      var v7286 = funcDecl$$13.type.symbol;
      v7286.flags = v7286.flags | TypeScript$$17.SymbolFlags.TypeSetDuringScopeAssignment
    }
    var v15573 = funcDecl$$13.name;
    if(v15573) {
      v15573 = funcDecl$$13.type
    }
    if(v15573) {
      funcDecl$$13.name.sym = funcDecl$$13.type.symbol
    }
    funcDecl$$13.scopeType = funcDecl$$13.type;
    if(funcDecl$$13.isOverload) {
      return
    }
    var funcTable = new TypeScript$$17.StringHashTable;
    var funcMembers = JAM.new(TypeScript$$17.ScopedMembers, [JAM.new(TypeScript$$17.DualStringHashTable, [funcTable, new TypeScript$$17.StringHashTable])]);
    var ambientFuncTable = new TypeScript$$17.StringHashTable;
    var ambientFuncMembers = JAM.new(TypeScript$$17.ScopedMembers, [JAM.new(TypeScript$$17.DualStringHashTable, [ambientFuncTable, new TypeScript$$17.StringHashTable])]);
    var funcStaticTable = new TypeScript$$17.StringHashTable;
    var funcStaticMembers = JAM.new(TypeScript$$17.ScopedMembers, [JAM.new(TypeScript$$17.DualStringHashTable, [funcStaticTable, new TypeScript$$17.StringHashTable])]);
    var ambientFuncStaticTable = new TypeScript$$17.StringHashTable;
    var ambientFuncStaticMembers = JAM.new(TypeScript$$17.ScopedMembers, [JAM.new(TypeScript$$17.DualStringHashTable, [ambientFuncStaticTable, new TypeScript$$17.StringHashTable])]);
    funcDecl$$13.unitIndex = context$$33.typeFlow.checker.locationInfo.unitIndex;
    var locals = JAM.new(TypeScript$$17.SymbolScopeBuilder, [funcMembers, ambientFuncMembers, null, null, parentScope, localContainer]);
    var statics$$1 = JAM.new(TypeScript$$17.SymbolScopeBuilder, [funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null]);
    var v15584 = funcDecl$$13.isConstructor;
    if(v15584) {
      v15584 = context$$33.scopeChain.thisType
    }
    if(v15584) {
      context$$33.scopeChain.thisType.constructorScope = locals
    }
    funcDecl$$13.symbols = funcTable;
    if(!funcDecl$$13.isSpecialFn()) {
      var group = funcDecl$$13.type;
      var signature$$1 = funcDecl$$13.signature;
      if(!funcDecl$$13.isConstructor) {
        group.containedScope = locals;
        locals.container = group.symbol;
        group.memberScope = statics$$1;
        statics$$1.container = group.symbol
      }
      funcDecl$$13.enclosingFnc = context$$33.scopeChain.fnc;
      var v7310;
      if(isStatic$$5) {
        v7310 = context$$33.scopeChain.classType
      }else {
        v7310 = context$$33.scopeChain.thisType
      }
      group.enclosingType = v7310;
      fgSym = ast$$52.type.symbol;
      var v15590 = (funcDecl$$13.fncFlags & TypeScript$$17.FncFlags.Signature) == TypeScript$$17.FncFlags.None;
      if(v15590) {
        v15590 = funcDecl$$13.vars
      }
      if(v15590) {
        var v7312 = context$$33.typeFlow;
        JAM.call(v7312.addLocalsFromScope, v7312, [locals, fgSym, funcDecl$$13.vars, funcTable, false]);
        var v7314 = context$$33.typeFlow;
        JAM.call(v7314.addLocalsFromScope, v7314, [statics$$1, fgSym, funcDecl$$13.statics, funcStaticTable, false])
      }
      if(signature$$1.parameters) {
        var len$$17 = signature$$1.parameters.length;
        var i$$55 = 0;
        var v7321 = i$$55 < len$$17;
        for(;v7321;) {
          var v7318 = signature$$1.parameters;
          introspect(JAM.policy.p1) {
            var paramSym = v7318[i$$55]
          }
          var v7319 = context$$33.typeFlow.checker;
          JAM.call(v7319.resolveTypeLink, v7319, [locals, paramSym.parameter.typeLink, true]);
          i$$55 = i$$55 + 1;
          v7321 = i$$55 < len$$17
        }
      }
      var v7323 = context$$33.typeFlow.checker;
      JAM.call(v7323.resolveTypeLink, v7323, [locals, signature$$1.returnType, funcDecl$$13.isSignature()])
    }
    var v15594 = !funcDecl$$13.isConstructor;
    if(!v15594) {
      v15594 = JAM.call(TypeScript$$17.hasFlag, TypeScript$$17, [funcDecl$$13.fncFlags, TypeScript$$17.FncFlags.ClassMethod])
    }
    if(v15594) {
      var v7327;
      var v20631 = funcDecl$$13.isConstructor;
      if(v20631) {
        v20631 = JAM.call(TypeScript$$17.hasFlag, TypeScript$$17, [funcDecl$$13.fncFlags, TypeScript$$17.FncFlags.ClassMethod])
      }
      if(v20631) {
        v7327 = context$$33.scopeChain.thisType
      }else {
        v7327 = null
      }
      var thisType = v7327;
      pushAssignScope(locals, context$$33, thisType, null, funcDecl$$13)
    }
    var v15597 = funcDecl$$13.name;
    if(v15597) {
      v15597 = JAM.call(TypeScript$$17.hasFlag, TypeScript$$17, [funcDecl$$13.fncFlags, TypeScript$$17.FncFlags.IsFunctionExpression])
    }
    if(v15597) {
      if(funcDecl$$13.name.sym) {
        JAM.call(funcTable.add, funcTable, [funcDecl$$13.name.actualText, funcDecl$$13.name.sym])
      }
    }
    return
  }
  function preAssignCatchScopes(ast$$53, context$$34) {
    var catchBlock = ast$$53;
    if(catchBlock.param) {
      var catchTable = JAM.new(TypeScript$$17.ScopedMembers, [JAM.new(TypeScript$$17.DualStringHashTable, [new TypeScript$$17.StringHashTable, new TypeScript$$17.StringHashTable])]);
      var catchLocals = JAM.new(TypeScript$$17.SymbolScopeBuilder, [catchTable, null, null, null, context$$34.scopeChain.scope, context$$34.scopeChain.scope.container]);
      catchBlock.containedScope = catchLocals;
      pushAssignScope(catchLocals, context$$34, context$$34.scopeChain.thisType, context$$34.scopeChain.classType, context$$34.scopeChain.fnc)
    }
    return
  }
  function preAssignScopes(ast$$54, parent$$45, walker$$42) {
    var context$$35 = walker$$42.state;
    var go = true;
    if(ast$$54) {
      if(ast$$54.nodeType == TypeScript$$17.NodeType.List) {
        var list$$2 = ast$$54;
        list$$2.enclosingScope = context$$35.scopeChain.scope
      }else {
        if(ast$$54.nodeType == TypeScript$$17.NodeType.ModuleDeclaration) {
          preAssignModuleScopes(ast$$54, context$$35)
        }else {
          if(ast$$54.nodeType == TypeScript$$17.NodeType.ClassDeclaration) {
            preAssignClassScopes(ast$$54, context$$35)
          }else {
            if(ast$$54.nodeType == TypeScript$$17.NodeType.InterfaceDeclaration) {
              preAssignInterfaceScopes(ast$$54, context$$35)
            }else {
              if(ast$$54.nodeType == TypeScript$$17.NodeType.With) {
                preAssignWithScopes(ast$$54, context$$35)
              }else {
                if(ast$$54.nodeType == TypeScript$$17.NodeType.FuncDecl) {
                  preAssignFuncDeclScopes(ast$$54, context$$35)
                }else {
                  if(ast$$54.nodeType == TypeScript$$17.NodeType.Catch) {
                    preAssignCatchScopes(ast$$54, context$$35)
                  }else {
                    if(ast$$54.nodeType == TypeScript$$17.NodeType.TypeRef) {
                      go = false
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    walker$$42.options.goChildren = go;
    return ast$$54
  }
  function postAssignScopes(ast$$55, parent$$46, walker$$43) {
    var context$$36 = walker$$43.state;
    var go$$1 = true;
    if(ast$$55) {
      if(ast$$55.nodeType == TypeScript$$17.NodeType.ModuleDeclaration) {
        var prevModDecl = ast$$55;
        popAssignScope(context$$36);
        context$$36.modDeclChain.pop();
        if(context$$36.modDeclChain.length >= 1) {
          context$$36.typeFlow.checker.currentModDecl = context$$36.modDeclChain[context$$36.modDeclChain.length - 1]
        }
      }else {
        if(ast$$55.nodeType == TypeScript$$17.NodeType.ClassDeclaration) {
          popAssignScope(context$$36)
        }else {
          if(ast$$55.nodeType == TypeScript$$17.NodeType.InterfaceDeclaration) {
            popAssignScope(context$$36)
          }else {
            if(ast$$55.nodeType == TypeScript$$17.NodeType.With) {
              popAssignScope(context$$36)
            }else {
              if(ast$$55.nodeType == TypeScript$$17.NodeType.FuncDecl) {
                var funcDecl$$14 = ast$$55;
                var v20652 = !funcDecl$$14.isConstructor;
                if(!v20652) {
                  v20652 = JAM.call(TypeScript$$17.hasFlag, TypeScript$$17, [funcDecl$$14.fncFlags, TypeScript$$17.FncFlags.ClassMethod])
                }
                var v15639 = v20652;
                if(v15639) {
                  v15639 = !funcDecl$$14.isOverload
                }
                if(v15639) {
                  popAssignScope(context$$36)
                }
              }else {
                if(ast$$55.nodeType == TypeScript$$17.NodeType.Catch) {
                  var catchBlock$$1 = ast$$55;
                  if(catchBlock$$1.param) {
                    popAssignScope(context$$36)
                  }
                }else {
                  go$$1 = false
                }
              }
            }
          }
        }
      }
    }
    walker$$43.options.goChildren = go$$1;
    return ast$$55
  }
  var AssignScopeContext = v676();
  TypeScript$$17.AssignScopeContext = AssignScopeContext;
  TypeScript$$17.pushAssignScope = pushAssignScope;
  TypeScript$$17.popAssignScope = popAssignScope;
  TypeScript$$17.instanceCompare = instanceCompare;
  TypeScript$$17.instanceFilterStop = instanceFilterStop;
  var ScopeSearchFilter = v679();
  TypeScript$$17.ScopeSearchFilter = ScopeSearchFilter;
  var v7364 = TypeScript$$17;
  var v27018 = JAM.new(ScopeSearchFilter, [instanceCompare, instanceFilterStop]);
  v7364.instanceFilter = v27018;
  TypeScript$$17.preAssignModuleScopes = preAssignModuleScopes;
  TypeScript$$17.preAssignClassScopes = preAssignClassScopes;
  TypeScript$$17.preAssignInterfaceScopes = preAssignInterfaceScopes;
  TypeScript$$17.preAssignWithScopes = preAssignWithScopes;
  TypeScript$$17.preAssignFuncDeclScopes = preAssignFuncDeclScopes;
  TypeScript$$17.preAssignCatchScopes = preAssignCatchScopes;
  TypeScript$$17.preAssignScopes = preAssignScopes;
  TypeScript$$17.postAssignScopes = postAssignScopes;
  return
}
function v675(TypeScript$$16) {
  function v674() {
    function v673(message$$17) {
      if(this.reportError) {
        JAM.call(this.reportError, this, [message$$17])
      }
      return
    }
    function v672() {
      var rtok$$1;
      this.tokenStart();
      var v27019 = this.peekChar();
      this.ch = v27019;
      var v7528 = this.pos < this.len;
      start:for(;v7528;) {
        var v20655 = this.ch;
        introspect(JAM.policy.p1) {
          var v15644 = lexIdStartTable[v20655]
        }
        if(!v15644) {
          var v20656 = this.ch == TypeScript$$16.LexCodeBSL;
          if(!v20656) {
            var v23678 = this.ch >= TypeScript$$16.LexCodeASCIIChars;
            if(v23678) {
              v23678 = LexIsUnicodeIdStart(this.ch)
            }
            v20656 = v23678
          }
          v15644 = v20656
        }
        if(v15644) {
          return this.scanIdentifier()
        }else {
          if(this.ch == TypeScript$$16.LexCodeSpace) {
            if(!this.interveningWhitespace) {
              this.interveningWhitespacePos = this.pos
            }
            var v7367 = this.ch == TypeScript$$16.LexCodeSpace;
            do {
              this.nextChar();
              v7367 = this.ch == TypeScript$$16.LexCodeSpace
            }while(v7367);
            if(this.mode == LexMode.Line) {
              var v7368 = this.src;
              var whitespaceText = JAM.call(v7368.substring, v7368, [this.startPos, this.pos]);
              return JAM.new(TypeScript$$16.WhitespaceToken, [TypeScript$$16.TokenID.Whitespace, whitespaceText])
            }else {
              this.tokenStart();
              this.interveningWhitespace = true
            }
          }else {
            if(this.ch == TypeScript$$16.LexCodeSLH) {
              this.nextChar();
              var commentText$$2;
              if(this.ch == TypeScript$$16.LexCodeSLH) {
                if(!this.interveningWhitespace) {
                  this.interveningWhitespacePos = this.pos - 1
                }
                var commentStartPos = this.pos - 1;
                var commentStartLine = this.line;
                this.finishSinglelineComment();
                var v7377 = this.src;
                commentText$$2 = JAM.call(v7377.substring, v7377, [commentStartPos, this.pos]);
                var commentToken = JAM.new(TypeScript$$16.CommentToken, [TypeScript$$16.TokenID.Comment, commentText$$2, false, commentStartPos, commentStartLine, false]);
                if(this.scanComments) {
                  this.startPos = commentStartPos;
                  return commentToken
                }else {
                  JAM.call(this.pushComment, this, [commentToken])
                }
                this.interveningWhitespace = true
              }else {
                if(this.ch == TypeScript$$16.LexCodeMUL) {
                  if(!this.interveningWhitespace) {
                    this.interveningWhitespacePos = this.pos - 1
                  }
                  commentStartPos = this.pos - 1;
                  commentStartLine = this.line;
                  this.nextChar();
                  this.finishMultilineComment();
                  var v7385 = this.src;
                  commentText$$2 = JAM.call(v7385.substring, v7385, [commentStartPos, this.pos]);
                  var endsLine$$1 = JAM.call(this.endsLine, this, [this.peekChar()]);
                  commentToken = JAM.new(TypeScript$$16.CommentToken, [TypeScript$$16.TokenID.Comment, commentText$$2, true, commentStartPos, commentStartLine, endsLine$$1]);
                  if(this.scanComments) {
                    this.startPos = commentStartPos;
                    return commentToken
                  }else {
                    JAM.call(this.pushComment, this, [commentToken])
                  }
                  this.interveningWhitespace = true
                }else {
                  var regexTok = this.speculateRegex();
                  if(regexTok) {
                    return regexTok
                  }else {
                    if(JAM.call(this.peekCharAt, this, [this.pos]) == TypeScript$$16.LexCodeEQ) {
                      this.nextChar();
                      var v7391 = TypeScript$$16.staticTokens;
                      var v7392 = TypeScript$$16.TokenID.SlashEquals;
                      introspect(JAM.policy.p1) {
                        return v7391[v7392]
                      }
                    }else {
                      var v7393 = TypeScript$$16.staticTokens;
                      var v7394 = TypeScript$$16.TokenID.Slash;
                      introspect(JAM.policy.p1) {
                        return v7393[v7394]
                      }
                    }
                  }
                }
              }
            }else {
              if(this.ch == TypeScript$$16.LexCodeSMC) {
                this.nextChar();
                var v7398 = TypeScript$$16.staticTokens;
                var v7399 = TypeScript$$16.TokenID.Semicolon;
                introspect(JAM.policy.p1) {
                  return v7398[v7399]
                }
              }else {
                var v15672 = this.ch == TypeScript$$16.LexCodeAPO;
                if(!v15672) {
                  v15672 = this.ch == TypeScript$$16.LexCodeQUO
                }
                if(v15672) {
                  return this.scanStringConstant()
                }else {
                  var v15673 = this.ch;
                  introspect(JAM.policy.p1) {
                    var v7522 = autoToken[v15673]
                  }
                  if(v7522) {
                    var v7400 = this.ch;
                    introspect(JAM.policy.p1) {
                      var atok = autoToken[v7400]
                    }
                    if(atok.tokenId == TypeScript$$16.TokenID.OpenBrace) {
                      this.leftCurlyCount = this.leftCurlyCount + 1
                    }else {
                      if(atok.tokenId == TypeScript$$16.TokenID.CloseBrace) {
                        this.rightCurlyCount = this.rightCurlyCount + 1
                      }
                    }
                    this.nextChar();
                    return atok
                  }else {
                    var v15680 = this.ch >= TypeScript$$16.LexCode_0;
                    if(v15680) {
                      v15680 = this.ch <= TypeScript$$16.LexCode_9
                    }
                    if(v15680) {
                      rtok$$1 = this.scanNumber();
                      if(rtok$$1) {
                        return rtok$$1
                      }else {
                        this.nextChar();
                        var v7403 = TypeScript$$16.staticTokens;
                        var v7404 = TypeScript$$16.TokenID.Error;
                        introspect(JAM.policy.p1) {
                          return v7403[v7404]
                        }
                      }
                    }else {
                      switch(this.ch) {
                        case TypeScript$$16.LexCodeTAB:
                        ;
                        case TypeScript$$16.LexCodeVTAB:
                          if(!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos
                          }
                          if(this.mode == LexMode.Line) {
                            var v15685 = this.ch == TypeScript$$16.LexCodeSpace;
                            if(!v15685) {
                              v15685 = this.ch == 9
                            }
                            var v7406 = v15685;
                            do {
                              this.nextChar();
                              var v15686 = this.ch == TypeScript$$16.LexCodeSpace;
                              if(!v15686) {
                                v15686 = this.ch == 9
                              }
                              v7406 = v15686
                            }while(v7406);
                            var v7407 = this.src;
                            var wsText = JAM.call(v7407.substring, v7407, [this.startPos, this.pos]);
                            return JAM.new(TypeScript$$16.WhitespaceToken, [TypeScript$$16.TokenID.Whitespace, wsText])
                          }else {
                            this.interveningWhitespace = true
                          }
                        ;
                        case 255:
                        ;
                        case 254:
                        ;
                        case 239:
                        ;
                        case 187:
                        ;
                        case 191:
                        ;
                        case TypeScript$$16.LexCodeLS:
                        ;
                        case TypeScript$$16.LexCodePS:
                        ;
                        case TypeScript$$16.LexCodeNWL:
                        ;
                        case TypeScript$$16.LexCodeRET:
                          if(this.ch == TypeScript$$16.LexCodeNWL) {
                            this.newLine();
                            if(this.mode == LexMode.Line) {
                              var v7413 = TypeScript$$16.staticTokens;
                              var v7414 = TypeScript$$16.TokenID.EndOfFile;
                              introspect(JAM.policy.p1) {
                                return v7413[v7414]
                              }
                            }
                          }
                          if(!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos
                          }
                          this.nextChar();
                          this.tokenStart();
                          this.interveningWhitespace = true;
                          break;
                        case TypeScript$$16.LexCodeDOT:
                          if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeDOT) {
                            if(JAM.call(this.peekCharAt, this, [this.pos + 2]) == TypeScript$$16.LexCodeDOT) {
                              JAM.call(this.advanceChar, this, [3]);
                              var v7418 = TypeScript$$16.staticTokens;
                              var v7419 = TypeScript$$16.TokenID.DotDotDot;
                              introspect(JAM.policy.p1) {
                                return v7418[v7419]
                              }
                            }else {
                              this.nextChar();
                              var v7420 = TypeScript$$16.staticTokens;
                              var v7421 = TypeScript$$16.TokenID.Dot;
                              introspect(JAM.policy.p1) {
                                return v7420[v7421]
                              }
                            }
                          }else {
                            this.nextChar();
                            rtok$$1 = this.scanFraction();
                            if(rtok$$1) {
                              return rtok$$1
                            }else {
                              var v7423 = TypeScript$$16.staticTokens;
                              var v7424 = TypeScript$$16.TokenID.Dot;
                              introspect(JAM.policy.p1) {
                                return v7423[v7424]
                              }
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeEQ:
                          if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeEQ) {
                            if(JAM.call(this.peekCharAt, this, [this.pos + 2]) == TypeScript$$16.LexCodeEQ) {
                              JAM.call(this.advanceChar, this, [3]);
                              var v7426 = TypeScript$$16.staticTokens;
                              var v7427 = TypeScript$$16.TokenID.EqualsEqualsEquals;
                              introspect(JAM.policy.p1) {
                                return v7426[v7427]
                              }
                            }else {
                              JAM.call(this.advanceChar, this, [2]);
                              var v7428 = TypeScript$$16.staticTokens;
                              var v7429 = TypeScript$$16.TokenID.EqualsEquals;
                              introspect(JAM.policy.p1) {
                                return v7428[v7429]
                              }
                            }
                          }else {
                            if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeGT) {
                              JAM.call(this.advanceChar, this, [2]);
                              var v7431 = TypeScript$$16.staticTokens;
                              var v7432 = TypeScript$$16.TokenID.EqualsGreaterThan;
                              introspect(JAM.policy.p1) {
                                return v7431[v7432]
                              }
                            }else {
                              this.nextChar();
                              var v7433 = TypeScript$$16.staticTokens;
                              var v7434 = TypeScript$$16.TokenID.Equals;
                              introspect(JAM.policy.p1) {
                                return v7433[v7434]
                              }
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeBNG:
                          if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeEQ) {
                            if(JAM.call(this.peekCharAt, this, [this.pos + 2]) == TypeScript$$16.LexCodeEQ) {
                              JAM.call(this.advanceChar, this, [3]);
                              var v7437 = TypeScript$$16.staticTokens;
                              var v7438 = TypeScript$$16.TokenID.ExclamationEqualsEquals;
                              introspect(JAM.policy.p1) {
                                return v7437[v7438]
                              }
                            }else {
                              JAM.call(this.advanceChar, this, [2]);
                              var v7439 = TypeScript$$16.staticTokens;
                              var v7440 = TypeScript$$16.TokenID.ExclamationEquals;
                              introspect(JAM.policy.p1) {
                                return v7439[v7440]
                              }
                            }
                          }else {
                            this.nextChar();
                            var v7442 = TypeScript$$16.staticTokens;
                            var v7443 = TypeScript$$16.TokenID.Exclamation;
                            introspect(JAM.policy.p1) {
                              return v7442[v7443]
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodePLS:
                          if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeEQ) {
                            JAM.call(this.advanceChar, this, [2]);
                            var v7445 = TypeScript$$16.staticTokens;
                            var v7446 = TypeScript$$16.TokenID.PlusEquals;
                            introspect(JAM.policy.p1) {
                              return v7445[v7446]
                            }
                          }else {
                            if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodePLS) {
                              JAM.call(this.advanceChar, this, [2]);
                              var v7447 = TypeScript$$16.staticTokens;
                              var v7448 = TypeScript$$16.TokenID.PlusPlus;
                              introspect(JAM.policy.p1) {
                                return v7447[v7448]
                              }
                            }else {
                              this.nextChar();
                              var v7449 = TypeScript$$16.staticTokens;
                              var v7450 = TypeScript$$16.TokenID.Plus;
                              introspect(JAM.policy.p1) {
                                return v7449[v7450]
                              }
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeMIN:
                          if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeEQ) {
                            JAM.call(this.advanceChar, this, [2]);
                            var v7453 = TypeScript$$16.staticTokens;
                            var v7454 = TypeScript$$16.TokenID.MinusEquals;
                            introspect(JAM.policy.p1) {
                              return v7453[v7454]
                            }
                          }else {
                            if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeMIN) {
                              JAM.call(this.advanceChar, this, [2]);
                              var v7455 = TypeScript$$16.staticTokens;
                              var v7456 = TypeScript$$16.TokenID.MinusMinus;
                              introspect(JAM.policy.p1) {
                                return v7455[v7456]
                              }
                            }else {
                              this.nextChar();
                              var v7457 = TypeScript$$16.staticTokens;
                              var v7458 = TypeScript$$16.TokenID.Minus;
                              introspect(JAM.policy.p1) {
                                return v7457[v7458]
                              }
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeMUL:
                          if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeEQ) {
                            JAM.call(this.advanceChar, this, [2]);
                            var v7461 = TypeScript$$16.staticTokens;
                            var v7462 = TypeScript$$16.TokenID.AsteriskEquals;
                            introspect(JAM.policy.p1) {
                              return v7461[v7462]
                            }
                          }else {
                            this.nextChar();
                            var v7463 = TypeScript$$16.staticTokens;
                            var v7464 = TypeScript$$16.TokenID.Asterisk;
                            introspect(JAM.policy.p1) {
                              return v7463[v7464]
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodePCT:
                          if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeEQ) {
                            JAM.call(this.advanceChar, this, [2]);
                            var v7466 = TypeScript$$16.staticTokens;
                            var v7467 = TypeScript$$16.TokenID.PercentEquals;
                            introspect(JAM.policy.p1) {
                              return v7466[v7467]
                            }
                          }else {
                            this.nextChar();
                            var v7468 = TypeScript$$16.staticTokens;
                            var v7469 = TypeScript$$16.TokenID.Percent;
                            introspect(JAM.policy.p1) {
                              return v7468[v7469]
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeLT:
                          if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeLT) {
                            if(JAM.call(this.peekCharAt, this, [this.pos + 2]) == TypeScript$$16.LexCodeEQ) {
                              JAM.call(this.advanceChar, this, [3]);
                              var v7471 = TypeScript$$16.staticTokens;
                              var v7472 = TypeScript$$16.TokenID.LessThanLessThanEquals;
                              introspect(JAM.policy.p1) {
                                return v7471[v7472]
                              }
                            }else {
                              JAM.call(this.advanceChar, this, [2]);
                              var v7473 = TypeScript$$16.staticTokens;
                              var v7474 = TypeScript$$16.TokenID.LessThanLessThan;
                              introspect(JAM.policy.p1) {
                                return v7473[v7474]
                              }
                            }
                          }else {
                            if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeEQ) {
                              JAM.call(this.advanceChar, this, [2]);
                              var v7476 = TypeScript$$16.staticTokens;
                              var v7477 = TypeScript$$16.TokenID.LessThanEquals;
                              introspect(JAM.policy.p1) {
                                return v7476[v7477]
                              }
                            }else {
                              this.nextChar();
                              var v7478 = TypeScript$$16.staticTokens;
                              var v7479 = TypeScript$$16.TokenID.LessThan;
                              introspect(JAM.policy.p1) {
                                return v7478[v7479]
                              }
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeGT:
                          if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeGT) {
                            if(JAM.call(this.peekCharAt, this, [this.pos + 2]) == TypeScript$$16.LexCodeEQ) {
                              JAM.call(this.advanceChar, this, [3]);
                              var v7482 = TypeScript$$16.staticTokens;
                              var v7483 = TypeScript$$16.TokenID.GreaterThanGreaterThanEquals;
                              introspect(JAM.policy.p1) {
                                return v7482[v7483]
                              }
                            }else {
                              if(JAM.call(this.peekCharAt, this, [this.pos + 2]) == TypeScript$$16.LexCodeGT) {
                                if(JAM.call(this.peekCharAt, this, [this.pos + 3]) == TypeScript$$16.LexCodeEQ) {
                                  JAM.call(this.advanceChar, this, [4]);
                                  var v7484 = TypeScript$$16.staticTokens;
                                  var v7485 = TypeScript$$16.TokenID.GreaterThanGreaterThanGreaterThanEquals;
                                  introspect(JAM.policy.p1) {
                                    return v7484[v7485]
                                  }
                                }else {
                                  JAM.call(this.advanceChar, this, [3]);
                                  var v7486 = TypeScript$$16.staticTokens;
                                  var v7487 = TypeScript$$16.TokenID.GreaterThanGreaterThanGreaterThan;
                                  introspect(JAM.policy.p1) {
                                    return v7486[v7487]
                                  }
                                }
                              }else {
                                JAM.call(this.advanceChar, this, [2]);
                                var v7489 = TypeScript$$16.staticTokens;
                                var v7490 = TypeScript$$16.TokenID.GreaterThanGreaterThan;
                                introspect(JAM.policy.p1) {
                                  return v7489[v7490]
                                }
                              }
                            }
                          }else {
                            if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeEQ) {
                              JAM.call(this.advanceChar, this, [2]);
                              var v7493 = TypeScript$$16.staticTokens;
                              var v7494 = TypeScript$$16.TokenID.GreaterThanEquals;
                              introspect(JAM.policy.p1) {
                                return v7493[v7494]
                              }
                            }else {
                              this.nextChar();
                              var v7495 = TypeScript$$16.staticTokens;
                              var v7496 = TypeScript$$16.TokenID.GreaterThan;
                              introspect(JAM.policy.p1) {
                                return v7495[v7496]
                              }
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeXOR:
                          if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeEQ) {
                            JAM.call(this.advanceChar, this, [2]);
                            var v7499 = TypeScript$$16.staticTokens;
                            var v7500 = TypeScript$$16.TokenID.CaretEquals;
                            introspect(JAM.policy.p1) {
                              return v7499[v7500]
                            }
                          }else {
                            this.nextChar();
                            var v7501 = TypeScript$$16.staticTokens;
                            var v7502 = TypeScript$$16.TokenID.Caret;
                            introspect(JAM.policy.p1) {
                              return v7501[v7502]
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeBAR:
                          if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeEQ) {
                            JAM.call(this.advanceChar, this, [2]);
                            var v7504 = TypeScript$$16.staticTokens;
                            var v7505 = TypeScript$$16.TokenID.BarEquals;
                            introspect(JAM.policy.p1) {
                              return v7504[v7505]
                            }
                          }else {
                            if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeBAR) {
                              JAM.call(this.advanceChar, this, [2]);
                              var v7506 = TypeScript$$16.staticTokens;
                              var v7507 = TypeScript$$16.TokenID.BarBar;
                              introspect(JAM.policy.p1) {
                                return v7506[v7507]
                              }
                            }else {
                              this.nextChar();
                              var v7508 = TypeScript$$16.staticTokens;
                              var v7509 = TypeScript$$16.TokenID.Bar;
                              introspect(JAM.policy.p1) {
                                return v7508[v7509]
                              }
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeAMP:
                          if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeEQ) {
                            JAM.call(this.advanceChar, this, [2]);
                            var v7512 = TypeScript$$16.staticTokens;
                            var v7513 = TypeScript$$16.TokenID.AmpersandEquals;
                            introspect(JAM.policy.p1) {
                              return v7512[v7513]
                            }
                          }else {
                            if(JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeAMP) {
                              JAM.call(this.advanceChar, this, [2]);
                              var v7514 = TypeScript$$16.staticTokens;
                              var v7515 = TypeScript$$16.TokenID.AmpersandAmpersand;
                              introspect(JAM.policy.p1) {
                                return v7514[v7515]
                              }
                            }else {
                              this.nextChar();
                              var v7516 = TypeScript$$16.staticTokens;
                              var v7517 = TypeScript$$16.TokenID.And;
                              introspect(JAM.policy.p1) {
                                return v7516[v7517]
                              }
                            }
                          }
                        ;
                        default:
                          JAM.call(this.reportScannerError, this, ["Invalid character"]);
                          this.nextChar()
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v7528 = this.pos < this.len
      }
      var v7529 = TypeScript$$16.staticTokens;
      var v7530 = TypeScript$$16.TokenID.EndOfFile;
      introspect(JAM.policy.p1) {
        return v7529[v7530]
      }
    }
    function v671() {
      var hasEscape = false;
      var isFirstChar = this.ch == TypeScript$$16.LexCodeBSL;
      var hasUnicode = false;
      for(;;) {
        var v20704 = this.ch;
        introspect(JAM.policy.p1) {
          var v15787 = lexIdStartTable[v20704]
        }
        if(!v15787) {
          var v20705 = LexIsDigit(this.ch);
          if(!v20705) {
            var v23707 = this.ch >= TypeScript$$16.LexCodeASCIIChars;
            if(v23707) {
              v23707 = this.isValidUnicodeIdentifierChar()
            }
            v20705 = v23707
          }
          v15787 = v20705
        }
        var v7533 = v15787;
        for(;v7533;) {
          this.nextChar();
          var v20707 = this.ch;
          introspect(JAM.policy.p1) {
            var v15788 = lexIdStartTable[v20707]
          }
          if(!v15788) {
            var v20708 = LexIsDigit(this.ch);
            if(!v20708) {
              var v23710 = this.ch >= TypeScript$$16.LexCodeASCIIChars;
              if(v23710) {
                v23710 = this.isValidUnicodeIdentifierChar()
              }
              v20708 = v23710
            }
            v15788 = v20708
          }
          v7533 = v15788
        }
        if(this.ch == TypeScript$$16.LexCodeBSL) {
          this.nextChar();
          if(this.ch == TypeScript$$16.LexCode_u) {
            this.nextChar();
            var h$$4 = 0;
            var v7537 = h$$4 < 4;
            for(;v7537;) {
              if(JAM.call(this.IsHexDigit, this, [this.ch])) {
                this.nextChar()
              }else {
                JAM.call(this.reportScannerError, this, ["Invalid Unicode escape sequence"]);
                var v7534 = TypeScript$$16.staticTokens;
                var v7535 = TypeScript$$16.TokenID.Error;
                introspect(JAM.policy.p1) {
                  return v7534[v7535]
                }
              }
              h$$4 = h$$4 + 1;
              v7537 = h$$4 < 4
            }
            var v15795 = this.src;
            var hexChar = parseInt(JAM.call(v15795.substring, v15795, [this.pos - 4, this.pos]), 16);
            introspect(JAM.policy.p1) {
              var v15798 = lexIdStartTable[hexChar]
            }
            if(!v15798) {
              var v23712 = !isFirstChar;
              if(v23712) {
                v23712 = LexIsDigit(hexChar)
              }
              var v20711 = v23712;
              if(!v20711) {
                var v23713 = hexChar >= TypeScript$$16.LexCodeASCIIChars;
                if(v23713) {
                  var v25185 = LexIsUnicodeIdStart(hexChar);
                  if(!v25185) {
                    var v25959 = !isFirstChar;
                    if(v25959) {
                      v25959 = LexIsUnicodeDigit(hexChar)
                    }
                    v25185 = v25959
                  }
                  v23713 = v25185
                }
                v20711 = v23713
              }
              v15798 = v20711
            }
            if(v15798) {
            }else {
              JAM.call(this.reportScannerError, this, ["Invalid identifier character"]);
              var v7539 = TypeScript$$16.staticTokens;
              var v7540 = TypeScript$$16.TokenID.Error;
              introspect(JAM.policy.p1) {
                return v7539[v7540]
              }
            }
            hasEscape = true;
            isFirstChar = false;
            continue
          }
          JAM.call(this.reportScannerError, this, ["Invalid Unicode escape sequence"]);
          var v7543 = TypeScript$$16.staticTokens;
          var v7544 = TypeScript$$16.TokenID.Error;
          introspect(JAM.policy.p1) {
            return v7543[v7544]
          }
        }
        break
      }
      var id$$16;
      var v7546 = this.src;
      var text$$18 = JAM.call(v7546.substring, v7546, [this.startPos, this.pos]);
      var v15801 = !hasEscape;
      if(v15801) {
        var v23715 = TypeScript$$16.LexKeywordTable;
        v15801 = (id$$16 = JAM.call(v23715.lookup, v23715, [text$$18])) != null
      }
      if(v15801) {
        var v7549 = TypeScript$$16.staticTokens;
        introspect(JAM.policy.p1) {
          return v7549[id$$16]
        }
      }else {
        return JAM.new(TypeScript$$16.IdentifierToken, [text$$18, hasEscape])
      }
      return
    }
    function v670() {
      var endCode = this.ch;
      this.nextChar();
      scanStringConstantLoop:for(;;) {
        switch(this.ch) {
          case TypeScript$$16.LexEOF:
            JAM.call(this.reportScannerError, this, ["Unterminated string constant"]);
            break scanStringConstantLoop;
          case TypeScript$$16.LexCodeLS:
          ;
          case TypeScript$$16.LexCodePS:
            this.seenUnicodeChar = true;
          case TypeScript$$16.LexCodeRET:
          ;
          case TypeScript$$16.LexCodeNWL:
            JAM.call(this.reportScannerError, this, ["Unterminated string constant"]);
            break scanStringConstantLoop;
          case TypeScript$$16.LexCodeAPO:
          ;
          case TypeScript$$16.LexCodeQUO:
            if(this.ch == endCode) {
              this.nextChar();
              break scanStringConstantLoop
            }
            break;
          case TypeScript$$16.LexCodeBSL:
            this.nextChar();
            switch(this.ch) {
              case TypeScript$$16.LexCodeAPO:
              ;
              case TypeScript$$16.LexCodeQUO:
              ;
              case TypeScript$$16.LexCodeBSL:
                this.nextChar();
                continue scanStringConstantLoop;
              case TypeScript$$16.LexCodeLS:
              ;
              case TypeScript$$16.LexCodePS:
                this.seenUnicodeChar = true;
              case TypeScript$$16.LexCodeRET:
              ;
              case TypeScript$$16.LexCodeNWL:
                var v15803 = this.ch == TypeScript$$16.LexCodeRET;
                if(v15803) {
                  v15803 = JAM.call(this.peekCharAt, this, [this.pos + 1]) == TypeScript$$16.LexCodeNWL
                }
                if(v15803) {
                  this.nextChar()
                }
                this.nextChar();
                this.newLine();
                if(this.mode == LexMode.Line) {
                  var v7554;
                  if(endCode == TypeScript$$16.LexCodeAPO) {
                    v7554 = LexState.InMultilineSingleQuoteString
                  }else {
                    v7554 = LexState.InMultilineDoubleQuoteString
                  }
                  this.lexState = v7554;
                  break scanStringConstantLoop
                }
                break;
              case TypeScript$$16.LexCode_x:
              ;
              case TypeScript$$16.LexCode_u:
                var v7556;
                if(this.ch == TypeScript$$16.LexCode_x) {
                  v7556 = 2
                }else {
                  v7556 = 4
                }
                var expectedHexDigits = v7556;
                this.nextChar();
                var i$$54 = 0;
                var v7558 = i$$54 < expectedHexDigits;
                for(;v7558;) {
                  if(JAM.call(this.IsHexDigit, this, [this.ch])) {
                    this.nextChar()
                  }else {
                    JAM.call(this.reportScannerError, this, ["Invalid Unicode escape sequence"]);
                    break
                  }
                  i$$54 = i$$54 + 1;
                  v7558 = i$$54 < expectedHexDigits
                }
                continue scanStringConstantLoop
            }
        }
        if(this.ch >= TypeScript$$16.LexCodeASCIIChars) {
          this.seenUnicodeChar = true
        }
        this.nextChar()
      }
      var v7562 = TypeScript$$16.StringLiteralToken;
      var v15811 = this.src;
      return JAM.new(v7562, [JAM.call(v15811.substring, v15811, [this.startPos, this.pos])])
    }
    function v669() {
      var v7564 = LexIsUnicodeIdStart(this.ch);
      if(!v7564) {
        v7564 = LexIsUnicodeDigit(this.ch)
      }
      var valid = v7564;
      var v7565 = this.seenUnicodeChar;
      if(!v7565) {
        v7565 = valid
      }
      this.seenUnicodeChar = v7565;
      return valid
    }
    function v668() {
      this.prevLine = this.line;
      var v27020 = this.innerScan();
      this.prevTok = v27020;
      if(this.saveScan) {
        var v7566 = this.saveScan;
        JAM.call(v7566.addToken, v7566, [this.prevTok, this])
      }
      return this.prevTok
    }
    function v667() {
      var v15818 = this.lexState == LexState.InMultilineComment;
      if(v15818) {
        v15818 = this.scanComments
      }
      if(v15818) {
        var v27021 = this.peekChar();
        this.ch = v27021;
        var commentLine = this.line;
        this.finishMultilineComment();
        if(this.startPos < this.pos) {
          var v7569 = this.src;
          var commentText$$1 = JAM.call(v7569.substring, v7569, [this.startPos, this.pos]);
          this.tokenStart();
          return JAM.new(TypeScript$$16.CommentToken, [TypeScript$$16.TokenID.Comment, commentText$$1, true, this.startPos, commentLine, true])
        }else {
          var v7575 = TypeScript$$16.staticTokens;
          var v7576 = TypeScript$$16.TokenID.EndOfFile;
          introspect(JAM.policy.p1) {
            return v7575[v7576]
          }
        }
      }else {
        var v15823 = this.lexState == LexState.InMultilineSingleQuoteString;
        if(v15823) {
          v15823 = this.pos < this.len
        }
        if(v15823) {
          this.ch = TypeScript$$16.LexCodeAPO;
          this.lexState = LexState.Start;
          return this.scanStringConstant()
        }else {
          var v15824 = this.lexState == LexState.InMultilineDoubleQuoteString;
          if(v15824) {
            v15824 = this.pos < this.len
          }
          if(v15824) {
            this.ch = TypeScript$$16.LexCodeQUO;
            this.lexState = LexState.Start;
            return this.scanStringConstant()
          }
        }
      }
      this.prevLine = this.line;
      var prevTok$$1 = this.innerScan();
      if(prevTok$$1.tokenId != TypeScript$$16.TokenID.Whitespace) {
        this.prevTok = prevTok$$1
      }
      return prevTok$$1
    }
    function v666() {
      var prevLine$$1 = this.prevLine;
      var line$$9 = this.line;
      var col = this.col;
      var pos$$2 = this.pos;
      var startPos$$1 = this.startPos;
      var startCol = this.startCol;
      var startLine$$41 = this.startLine;
      var ch = this.ch;
      var prevTok = this.prevTok;
      var lexState = this.lexState;
      var interveningWhitespace = this.interveningWhitespace;
      var interveningWhitespacePos = this.interveningWhitespacePos;
      var leftCurlyCount$$6 = this.leftCurlyCount;
      var rightCurlyCount$$6 = this.rightCurlyCount;
      var seenUnicodeChar = this.seenUnicodeChar;
      var seenUnicodeCharInComment = this.seenUnicodeCharInComment;
      var commentStackLength = this.commentStack.length;
      var lookAheadToken = this.scan();
      this.prevLine = prevLine$$1;
      this.line = line$$9;
      this.col = col;
      this.pos = pos$$2;
      this.startPos = startPos$$1;
      this.startCol = startCol;
      this.startLine = startLine$$41;
      this.ch = ch;
      this.prevTok = prevTok;
      this.lexState = lexState;
      this.interveningWhitespace = interveningWhitespace;
      this.interveningWhitespacePos = interveningWhitespacePos;
      this.leftCurlyCount = leftCurlyCount$$6;
      this.rightCurlyCount = rightCurlyCount$$6;
      this.seenUnicodeChar = seenUnicodeChar;
      this.seenUnicodeCharInComment = seenUnicodeCharInComment;
      this.commentStack.length = commentStackLength;
      return lookAheadToken
    }
    function v665() {
      this.pos = this.pos + 1;
      this.col = this.col + 1;
      var v27022 = this.peekChar();
      this.ch = v27022;
      return
    }
    function v664(amt) {
      this.pos = this.pos + amt;
      this.col = this.col + amt;
      var v27023 = this.peekChar();
      this.ch = v27023;
      return
    }
    function v663() {
      var v7584;
      if(this.interveningWhitespace) {
        v7584 = this.interveningWhitespacePos
      }else {
        v7584 = this.startPos
      }
      return v7584
    }
    function v662() {
      return this.prevLine != this.startLine
    }
    function v661() {
      var v20732 = TypeScript$$16.noRegexTable;
      var v20733 = this.prevTok.tokenId;
      introspect(JAM.policy.p1) {
        var v15832 = v20732[v20733]
      }
      if(v15832 != undefined) {
        return null
      }
      var svPos$$2 = this.pos;
      var svCol$$1 = this.col;
      var index$$49 = this.findClosingSLH();
      if(index$$49 > 0) {
        var v7588 = this.src;
        var pattern$$1 = JAM.call(v7588.substring, v7588, [svPos$$2, index$$49]);
        var flags$$2 = "";
        this.pos = index$$49 + 1;
        var v27024 = this.peekChar();
        this.ch = v27024;
        var flagsStart = this.pos;
        var v15833 = this.ch == TypeScript$$16.LexCode_i;
        if(!v15833) {
          var v20736 = this.ch == TypeScript$$16.LexCode_g;
          if(!v20736) {
            v20736 = this.ch == TypeScript$$16.LexCode_m
          }
          v15833 = v20736
        }
        var v7589 = v15833;
        for(;v7589;) {
          this.nextChar();
          var v15834 = this.ch == TypeScript$$16.LexCode_i;
          if(!v15834) {
            var v20740 = this.ch == TypeScript$$16.LexCode_g;
            if(!v20740) {
              v20740 = this.ch == TypeScript$$16.LexCode_m
            }
            v15834 = v20740
          }
          v7589 = v15834
        }
        if(this.pos - flagsStart > 3) {
          return null
        }else {
          var v7590 = this.src;
          flags$$2 = JAM.call(v7590.substring, v7590, [flagsStart, this.pos])
        }
        var regex$$2 = undefined;
        try {
          regex$$2 = new RegExp(pattern$$1, flags$$2)
        }catch(regexException) {
        }
        if(regex$$2) {
          this.col = svCol$$1 + (this.pos - this.startPos);
          return JAM.new(TypeScript$$16.RegularExpressionLiteralToken, [regex$$2])
        }
      }
      this.pos = svPos$$2;
      this.col = svCol$$1;
      return null
    }
    function v660() {
      var index$$48 = this.pos;
      var v7596 = this.src;
      var ch2$$1 = JAM.call(v7596.charCodeAt, v7596, [index$$48]);
      var prevCh = 0;
      var liveEsc = false;
      var v15838 = !JAM.call(this.endsLine, this, [ch2$$1]);
      if(v15838) {
        v15838 = index$$48 < this.len
      }
      var v7600 = v15838;
      for(;v7600;) {
        var v15839 = ch2$$1 == TypeScript$$16.LexCodeSLH;
        if(v15839) {
          v15839 = !liveEsc
        }
        if(v15839) {
          return index$$48
        }
        prevCh = ch2$$1;
        index$$48 = index$$48 + 1;
        if(liveEsc) {
          liveEsc = false
        }else {
          liveEsc = prevCh == TypeScript$$16.LexCodeBSL
        }
        var v7599 = this.src;
        ch2$$1 = JAM.call(v7599.charCodeAt, v7599, [index$$48]);
        var v15840 = !JAM.call(this.endsLine, this, [ch2$$1]);
        if(v15840) {
          v15840 = index$$48 < this.len
        }
        v7600 = v15840
      }
      return-1
    }
    function v659() {
      var v7601 = this.src;
      return JAM.call(v7601.substring, v7601, [this.startPos, this.pos])
    }
    function v658() {
      var v7606 = this.pos < this.len;
      for(;v7606;) {
        if(JAM.call(this.endsLine, this, [this.ch])) {
          break
        }
        if(this.ch >= TypeScript$$16.LexCodeASCIIChars) {
          this.seenUnicodeCharInComment = true
        }
        this.nextChar();
        v7606 = this.pos < this.len
      }
      if(this.mode == LexMode.File) {
        this.tokenStart()
      }
      return
    }
    function v657(c$$10) {
      var v7608 = c$$10 == TypeScript$$16.LexCodeNWL;
      if(!v7608) {
        var v15851 = c$$10 == TypeScript$$16.LexCodeRET;
        if(!v15851) {
          var v20749 = c$$10 == TypeScript$$16.LexCodeLS;
          if(!v20749) {
            v20749 = c$$10 == TypeScript$$16.LexCodePS
          }
          v15851 = v20749
        }
        v7608 = v15851
      }
      return v7608
    }
    function v656() {
      this.commentStack = [];
      return
    }
    function v655(line$$8) {
      var comments$$9 = null;
      var v15853 = this.commentStack.length > 0;
      if(v15853) {
        v15853 = this.commentStack[0].line == line$$8
      }
      var v7612 = v15853;
      for(;v7612;) {
        if(comments$$9 == null) {
          comments$$9 = [this.commentStack.shift()]
        }else {
          comments$$9 = comments$$9.concat([this.commentStack.shift()])
        }
        var v15856 = this.commentStack.length > 0;
        if(v15856) {
          v15856 = this.commentStack[0].line == line$$8
        }
        v7612 = v15856
      }
      return comments$$9
    }
    function v654() {
      var stack$$2 = this.commentStack;
      this.commentStack = [];
      return stack$$2
    }
    function v653(comment$$4) {
      var v7613 = this.commentStack;
      JAM.call(v7613.push, v7613, [comment$$4]);
      return
    }
    function v652() {
      var ch2;
      this.lexState = LexState.InMultilineComment;
      var v7621 = this.pos < this.len;
      for(;v7621;) {
        if(this.ch == TypeScript$$16.LexCodeMUL) {
          ch2 = JAM.call(this.peekCharAt, this, [this.pos + 1]);
          if(ch2 == TypeScript$$16.LexCodeSLH) {
            JAM.call(this.advanceChar, this, [2]);
            if(this.mode == LexMode.File) {
              this.tokenStart()
            }
            this.lexState = LexState.Start;
            return true
          }
        }else {
          if(this.ch == TypeScript$$16.LexCodeNWL) {
            this.newLine();
            if(this.mode == LexMode.Line) {
              this.nextChar();
              return false
            }
          }else {
            if(this.ch >= TypeScript$$16.LexCodeASCIIChars) {
              this.seenUnicodeCharInComment = true
            }
          }
        }
        this.nextChar();
        v7621 = this.pos < this.len
      }
      return false
    }
    function v651() {
      this.col = 0;
      if(this.mode == LexMode.File) {
        this.line = this.line + 1;
        JAM.set(this.lineMap, this.line, this.pos + 1)
      }
      return
    }
    function v650() {
      return JAM.call(this.scanDecimalNumber, this, [NumberScanState.InFraction])
    }
    function v649() {
      if(this.peekChar() == TypeScript$$16.LexCode_0) {
        switch(JAM.call(this.peekCharAt, this, [this.pos + 1])) {
          case TypeScript$$16.LexCode_x:
          ;
          case TypeScript$$16.LexCode_X:
            JAM.call(this.advanceChar, this, [2]);
            return this.scanHexDigits();
          case TypeScript$$16.LexCode_8:
          ;
          case TypeScript$$16.LexCode_9:
          ;
          case TypeScript$$16.LexCodeDOT:
            return JAM.call(this.scanDecimalNumber, this, [NumberScanState.Start]);
          default:
            return this.scanOctalDigits()
        }
      }else {
        return JAM.call(this.scanDecimalNumber, this, [NumberScanState.Start])
      }
      return
    }
    function v648(state$$4) {
      var atLeastOneDigit$$2 = false;
      var svPos$$1 = this.pos;
      var svCol = this.col;
      for(;;) {
        if(LexIsDigit(this.ch)) {
          atLeastOneDigit$$2 = true;
          var v15881 = this.ch != TypeScript$$16.LexCode_0;
          if(v15881) {
            v15881 = state$$4 == NumberScanState.InEmptyFraction
          }
          if(v15881) {
            state$$4 = NumberScanState.InFraction
          }
          this.nextChar()
        }else {
          if(this.ch == TypeScript$$16.LexCodeDOT) {
            if(state$$4 == NumberScanState.Start) {
              this.nextChar();
              state$$4 = NumberScanState.InEmptyFraction
            }else {
              if(atLeastOneDigit$$2) {
                var v7631 = TypeScript$$16.NumberLiteralToken;
                var v20760 = this.src;
                return JAM.new(v7631, [parseFloat(JAM.call(v20760.substring, v20760, [this.startPos, this.pos])), state$$4 == NumberScanState.InEmptyFraction])
              }else {
                this.pos = svPos$$1;
                this.col = svCol;
                return null
              }
            }
          }else {
            var v15887 = this.ch == TypeScript$$16.LexCode_e;
            if(!v15887) {
              v15887 = this.ch == TypeScript$$16.LexCode_E
            }
            if(v15887) {
              if(state$$4 == NumberScanState.Start) {
                if(atLeastOneDigit$$2) {
                  atLeastOneDigit$$2 = false;
                  this.nextChar();
                  state$$4 = NumberScanState.InExponent
                }else {
                  this.pos = svPos$$1;
                  this.col = svCol;
                  return null
                }
              }else {
                var v15889 = state$$4 == NumberScanState.InFraction;
                if(!v15889) {
                  v15889 = state$$4 == NumberScanState.InEmptyFraction
                }
                if(v15889) {
                  this.nextChar();
                  state$$4 = NumberScanState.InExponent;
                  atLeastOneDigit$$2 = false
                }else {
                  if(atLeastOneDigit$$2) {
                    var v7635 = TypeScript$$16.NumberLiteralToken;
                    var v20771 = this.src;
                    return JAM.new(v7635, [parseFloat(JAM.call(v20771.substring, v20771, [this.startPos, this.pos]))])
                  }else {
                    this.pos = svPos$$1;
                    this.col = svCol;
                    return null
                  }
                }
              }
            }else {
              var v15891 = this.ch == TypeScript$$16.LexCodePLS;
              if(!v15891) {
                v15891 = this.ch == TypeScript$$16.LexCodeMIN
              }
              if(v15891) {
                if(state$$4 == NumberScanState.InExponent) {
                  if(!atLeastOneDigit$$2) {
                    this.nextChar()
                  }else {
                    this.pos = svPos$$1;
                    this.col = svCol;
                    return null
                  }
                }else {
                  var v15893 = state$$4 == NumberScanState.InEmptyFraction;
                  if(!v15893) {
                    v15893 = state$$4 == NumberScanState.InFraction
                  }
                  if(v15893) {
                    var v7640 = TypeScript$$16.NumberLiteralToken;
                    var v20782 = this.src;
                    return JAM.new(v7640, [parseFloat(JAM.call(v20782.substring, v20782, [this.startPos, this.pos])), state$$4 == NumberScanState.InEmptyFraction])
                  }else {
                    if(!atLeastOneDigit$$2) {
                      this.pos = svPos$$1;
                      this.col = svCol;
                      return null
                    }else {
                      var v7643 = TypeScript$$16.NumberLiteralToken;
                      var v20785 = this.src;
                      return JAM.new(v7643, [parseFloat(JAM.call(v20785.substring, v20785, [this.startPos, this.pos]))])
                    }
                  }
                }
              }else {
                if(!atLeastOneDigit$$2) {
                  this.pos = svPos$$1;
                  this.col = svCol;
                  return null
                }else {
                  var v7648 = TypeScript$$16.NumberLiteralToken;
                  var v20788 = this.src;
                  return JAM.new(v7648, [parseFloat(JAM.call(v20788.substring, v20788, [this.startPos, this.pos])), state$$4 == NumberScanState.InEmptyFraction])
                }
              }
            }
          }
        }
      }
      return
    }
    function v647() {
      var atLeastOneDigit$$1 = false;
      for(;;) {
        if(JAM.call(this.IsOctalDigit, this, [this.ch])) {
          this.nextChar();
          atLeastOneDigit$$1 = true
        }else {
          if(atLeastOneDigit$$1) {
            var v7656 = TypeScript$$16.NumberLiteralToken;
            var v20791 = this.src;
            return JAM.new(v7656, [parseInt(JAM.call(v20791.substring, v20791, [this.startPos, this.pos]))])
          }else {
            return null
          }
        }
      }
      return
    }
    function v646() {
      var atLeastOneDigit = false;
      for(;;) {
        if(JAM.call(this.IsHexDigit, this, [this.ch])) {
          this.nextChar();
          atLeastOneDigit = true
        }else {
          if(atLeastOneDigit) {
            var v7659 = TypeScript$$16.NumberLiteralToken;
            var v20794 = this.src;
            return JAM.new(v7659, [parseInt(JAM.call(v20794.substring, v20794, [this.startPos, this.pos]))])
          }else {
            return null
          }
        }
      }
      return
    }
    function v645(c$$9) {
      var v15903 = c$$9 >= TypeScript$$16.LexCode_0;
      if(v15903) {
        v15903 = c$$9 <= TypeScript$$16.LexCode_7
      }
      var v7662 = v15903;
      if(!v7662) {
        var v15904 = c$$9 >= TypeScript$$16.LexCode_a;
        if(v15904) {
          v15904 = c$$9 <= TypeScript$$16.LexCode_f
        }
        v7662 = v15904
      }
      return v7662
    }
    function v644(c$$8) {
      var v15906 = c$$8 >= TypeScript$$16.LexCode_0;
      if(v15906) {
        v15906 = c$$8 <= TypeScript$$16.LexCode_9
      }
      var v7663 = v15906;
      if(!v7663) {
        var v20803 = c$$8 >= TypeScript$$16.LexCode_A;
        if(v20803) {
          v20803 = c$$8 <= TypeScript$$16.LexCode_F
        }
        var v15907 = v20803;
        if(!v15907) {
          var v20804 = c$$8 >= TypeScript$$16.LexCode_a;
          if(v20804) {
            v20804 = c$$8 <= TypeScript$$16.LexCode_f
          }
          v15907 = v20804
        }
        v7663 = v15907
      }
      return v7663
    }
    function v643(index$$47) {
      if(index$$47 < this.len) {
        var v7664 = this.src;
        return JAM.call(v7664.charCodeAt, v7664, [index$$47])
      }else {
        return TypeScript$$16.LexEOF
      }
      return
    }
    function v642() {
      if(this.pos < this.len) {
        var v7666 = this.src;
        return JAM.call(v7666.charCodeAt, v7666, [this.pos])
      }else {
        return TypeScript$$16.LexEOF
      }
      return
    }
    function v641() {
      this.startPos = this.pos;
      this.startLine = this.line;
      this.startCol = this.col;
      this.interveningWhitespace = false;
      return
    }
    function v640() {
      return this.lexState
    }
    function v639(value$$36) {
      this.scanComments = value$$36;
      return
    }
    function v638(newSrc$$2, textMode$$2) {
      JAM.call(this.setSourceText, this, [JAM.new(StringSourceText, [newSrc$$2]), textMode$$2]);
      return
    }
    function v637(savedTokens) {
      this.saveScan = savedTokens;
      return
    }
    function v636(reportError$$1) {
      this.reportError = reportError$$1;
      return
    }
    function v635(newSrc$$1, textMode$$1) {
      this.mode = textMode$$1;
      this.scanComments = this.mode === LexMode.Line;
      this.pos = 0;
      this.interveningWhitespacePos = 0;
      this.startPos = 0;
      this.line = 1;
      this.col = 0;
      this.startCol = this.col;
      this.startLine = this.line;
      this.len = 0;
      var v27025 = JAM.call(newSrc$$1.getText, newSrc$$1, [0, newSrc$$1.getLength()]);
      this.src = v27025;
      this.len = this.src.length;
      this.lineMap = [];
      this.lineMap[1] = 0;
      this.commentStack = [];
      this.leftCurlyCount = 0;
      this.rightCurlyCount = 0;
      this.seenUnicodeChar = false;
      this.seenUnicodeCharInComment = false;
      return
    }
    function v634() {
      return this.prevTok
    }
    function Scanner$$1() {
      this.prevLine = 1;
      this.line = 1;
      this.col = 0;
      this.pos = 0;
      this.startPos = 0;
      this.len = 0;
      this.lineMap = [];
      this.ch = TypeScript$$16.LexEOF;
      this.lexState = LexState.Start;
      this.mode = LexMode.File;
      this.scanComments = true;
      this.interveningWhitespace = false;
      this.interveningWhitespacePos = 0;
      this.leftCurlyCount = 0;
      this.rightCurlyCount = 0;
      var v27026 = new Array;
      this.commentStack = v27026;
      this.saveScan = null;
      this.seenUnicodeChar = false;
      this.seenUnicodeCharInComment = false;
      var v7675 = TypeScript$$16.staticTokens;
      var v7676 = TypeScript$$16.TokenID.EndOfFile;
      introspect(JAM.policy.p1) {
        this.prevTok = v7675[v7676]
      }
      this.startCol = this.col;
      this.startLine = this.line;
      this.lineMap[1] = 0;
      if(!TypeScript$$16.LexKeywordTable) {
        LexInitialize()
      }
      return
    }
    Scanner$$1.prototype.previousToken = v634;
    Scanner$$1.prototype.setSourceText = v635;
    Scanner$$1.prototype.setErrorHandler = v636;
    Scanner$$1.prototype.setSaveScan = v637;
    Scanner$$1.prototype.setText = v638;
    Scanner$$1.prototype.setScanComments = v639;
    Scanner$$1.prototype.getLexState = v640;
    Scanner$$1.prototype.tokenStart = v641;
    Scanner$$1.prototype.peekChar = v642;
    Scanner$$1.prototype.peekCharAt = v643;
    Scanner$$1.prototype.IsHexDigit = v644;
    Scanner$$1.prototype.IsOctalDigit = v645;
    Scanner$$1.prototype.scanHexDigits = v646;
    Scanner$$1.prototype.scanOctalDigits = v647;
    Scanner$$1.prototype.scanDecimalNumber = v648;
    Scanner$$1.prototype.scanNumber = v649;
    Scanner$$1.prototype.scanFraction = v650;
    Scanner$$1.prototype.newLine = v651;
    Scanner$$1.prototype.finishMultilineComment = v652;
    Scanner$$1.prototype.pushComment = v653;
    Scanner$$1.prototype.getComments = v654;
    Scanner$$1.prototype.getCommentsForLine = v655;
    Scanner$$1.prototype.resetComments = v656;
    Scanner$$1.prototype.endsLine = v657;
    Scanner$$1.prototype.finishSinglelineComment = v658;
    Scanner$$1.prototype.tokenText = v659;
    Scanner$$1.prototype.findClosingSLH = v660;
    Scanner$$1.prototype.speculateRegex = v661;
    Scanner$$1.prototype.lastTokenHadNewline = v662;
    Scanner$$1.prototype.lastTokenLimChar = v663;
    Scanner$$1.prototype.advanceChar = v664;
    Scanner$$1.prototype.nextChar = v665;
    Scanner$$1.prototype.getLookAheadToken = v666;
    Scanner$$1.prototype.scanInLine = v667;
    Scanner$$1.prototype.scan = v668;
    Scanner$$1.prototype.isValidUnicodeIdentifierChar = v669;
    Scanner$$1.prototype.scanStringConstant = v670;
    Scanner$$1.prototype.scanIdentifier = v671;
    Scanner$$1.prototype.innerScan = v672;
    Scanner$$1.prototype.reportScannerError = v673;
    return Scanner$$1
  }
  function v633() {
    function v632() {
      throw new Error("Invalid operation.");
    }
    function v631(reportError) {
      return
    }
    function v630(newSrc, textMode) {
      return
    }
    function v629() {
      this.commentStack = [];
      return
    }
    function v628(line$$7) {
      var comments$$8 = null;
      var v15914 = this.commentStack.length > 0;
      if(v15914) {
        v15914 = this.commentStack[0].line == line$$7
      }
      var v7722 = v15914;
      for(;v7722;) {
        if(comments$$8 == null) {
          comments$$8 = [this.commentStack.shift()]
        }else {
          comments$$8 = comments$$8.concat([this.commentStack.shift()])
        }
        var v15917 = this.commentStack.length > 0;
        if(v15917) {
          v15917 = this.commentStack[0].line == line$$7
        }
        v7722 = v15917
      }
      return comments$$8
    }
    function v627() {
      var stack$$1 = this.commentStack;
      this.commentStack = [];
      return stack$$1
    }
    function v626(comment$$3) {
      var v7723 = this.commentStack;
      JAM.call(v7723.push, v7723, [comment$$3]);
      return
    }
    function v625() {
      return this.prevLine != this.startLine
    }
    function v624() {
      if(this.prevSavedToken !== null) {
        return this.prevSavedToken.limChar
      }else {
        return 0
      }
      return
    }
    function v623(offset$$12) {
      var v27027 = getLineNumberFromPosition(this.lineMap, offset$$12);
      this.line = v27027;
      this.currentTokenIndex = 0;
      var v15919 = this.lineMap;
      var v15920 = this.line;
      introspect(JAM.policy.p1) {
        var v7729 = v15919[v15920]
      }
      var tmpCol = offset$$12 - v7729;
      var v23743 = this.lexStateByLine;
      var v23744 = this.line;
      introspect(JAM.policy.p1) {
        var v20811 = v23743[v23744]
      }
      var v15921 = v20811 == LexState.InMultilineComment;
      if(v15921) {
        v15921 = this.line > 0
      }
      var v7730 = v15921;
      for(;v7730;) {
        this.line = this.line - 1;
        tmpCol = 0;
        var v23745 = this.lexStateByLine;
        var v23746 = this.line;
        introspect(JAM.policy.p1) {
          var v20814 = v23745[v23746]
        }
        var v15923 = v20814 == LexState.InMultilineComment;
        if(v15923) {
          v15923 = this.line > 0
        }
        v7730 = v15923
      }
      var lenMin1 = this.lineMap.length - 1;
      var v7732 = this.tokensByLine;
      var v7733 = this.line;
      introspect(JAM.policy.p1) {
        this.currentTokens = v7732[v7733]
      }
      var v15925 = this.currentTokens.length == 0;
      if(v15925) {
        v15925 = this.line < lenMin1
      }
      var v7736 = v15925;
      for(;v7736;) {
        this.line = this.line + 1;
        var v7734 = this.tokensByLine;
        var v7735 = this.line;
        introspect(JAM.policy.p1) {
          this.currentTokens = v7734[v7735]
        }
        tmpCol = 0;
        var v15927 = this.currentTokens.length == 0;
        if(v15927) {
          v15927 = this.line < lenMin1
        }
        v7736 = v15927
      }
      if(this.line <= lenMin1) {
        var v15929 = this.currentTokenIndex < this.currentTokens.length;
        if(v15929) {
          var v25191 = this.currentTokens;
          var v25192 = this.currentTokenIndex;
          introspect(JAM.policy.p1) {
            var v23750 = v25191[v25192]
          }
          v15929 = tmpCol > v23750.limChar
        }
        var v7737 = v15929;
        for(;v7737;) {
          this.currentTokenIndex = this.currentTokenIndex + 1;
          var v15931 = this.currentTokenIndex < this.currentTokens.length;
          if(v15931) {
            var v25193 = this.currentTokens;
            var v25194 = this.currentTokenIndex;
            introspect(JAM.policy.p1) {
              var v23752 = v25193[v25194]
            }
            v15931 = tmpCol > v23752.limChar
          }
          v7737 = v15931
        }
        if(this.currentTokenIndex < this.currentTokens.length) {
          var v15934 = this.currentTokens;
          var v15935 = this.currentTokenIndex;
          introspect(JAM.policy.p1) {
            var v7738 = v15934[v15935]
          }
          this.col = v7738.minChar;
          var v7739 = this.col;
          var v15936 = this.lineMap;
          var v15937 = this.line;
          introspect(JAM.policy.p1) {
            var v7740 = v15936[v15937]
          }
          return v7739 + v7740
        }
      }
      return-1
    }
    function v622() {
      this.startLine = this.line;
      this.startPos = this.col;
      if(this.currentTokenIndex == this.currentTokens.length) {
        if(this.line < this.lineMap.length) {
          this.line = this.line + 1;
          this.col = 0;
          this.currentTokenIndex = 0;
          var v7743 = this.tokensByLine;
          var v7744 = this.line;
          introspect(JAM.policy.p1) {
            this.currentTokens = v7743[v7744]
          }
        }else {
          var v7745 = TypeScript$$16.staticTokens;
          var v7746 = TypeScript$$16.TokenID.EndOfFile;
          introspect(JAM.policy.p1) {
            return v7745[v7746]
          }
        }
      }
      if(this.currentTokenIndex < this.currentTokens.length) {
        this.prevToken = this.curSavedToken.tok;
        this.prevSavedToken = this.curSavedToken;
        var v7750 = this.currentTokens;
        var v7751 = this.currentTokenIndex;
        this.currentTokenIndex = this.currentTokenIndex + 1;
        introspect(JAM.policy.p1) {
          this.curSavedToken = v7750[v7751]
        }
        var curToken = this.curSavedToken.tok;
        this.pos = this.curSavedToken.limChar;
        this.col = this.col + (this.curSavedToken.limChar - this.curSavedToken.minChar);
        this.startPos = this.curSavedToken.minChar;
        this.prevLine = this.line;
        return curToken
      }else {
        var v7755 = TypeScript$$16.staticTokens;
        var v7756 = TypeScript$$16.TokenID.EndOfFile;
        introspect(JAM.policy.p1) {
          return v7755[v7756]
        }
      }
      return
    }
    function v621(tok$$3, scanner) {
      var v7758 = this.tokens;
      var v7759 = this.currentToken;
      this.currentToken = this.currentToken + 1;
      var v27028 = JAM.new(TypeScript$$16.SavedToken, [tok$$3, scanner.startPos, scanner.pos]);
      JAM.set(v7758, v7759, v27028);
      return
    }
    function v620() {
      this.currentToken = 0;
      return
    }
    function v619() {
      return this.prevToken
    }
    function SavedTokens$$1() {
      this.prevToken = null;
      this.curSavedToken = null;
      this.prevSavedToken = null;
      this.prevToken = null;
      this.currentToken = 0;
      var v27029 = new Array;
      this.tokens = v27029;
      this.seenUnicodeChar = false;
      this.seenUnicodeCharInComment = false;
      this.prevLine = 1;
      this.line = 1;
      this.col = 0;
      this.lexState = LexState.Start;
      var v27030 = new Array;
      this.commentStack = v27030;
      this.lineMap = [];
      return
    }
    SavedTokens$$1.prototype.previousToken = v619;
    SavedTokens$$1.prototype.close = v620;
    SavedTokens$$1.prototype.addToken = v621;
    SavedTokens$$1.prototype.scan = v622;
    SavedTokens$$1.prototype.syncToTok = v623;
    SavedTokens$$1.prototype.lastTokenLimChar = v624;
    SavedTokens$$1.prototype.lastTokenHadNewline = v625;
    SavedTokens$$1.prototype.pushComment = v626;
    SavedTokens$$1.prototype.getComments = v627;
    SavedTokens$$1.prototype.getCommentsForLine = v628;
    SavedTokens$$1.prototype.resetComments = v629;
    SavedTokens$$1.prototype.setSourceText = v630;
    SavedTokens$$1.prototype.setErrorHandler = v631;
    SavedTokens$$1.prototype.getLookAheadToken = v632;
    return SavedTokens$$1
  }
  function v618() {
    function v617(start$$11, end$$5) {
      var v7774 = JAM.call(this.fetchSegment, this, [start$$11, end$$5]);
      return JAM.call(v7774.substring, v7774, [start$$11, end$$5])
    }
    function v616(index$$46) {
      var v7775 = JAM.call(this.fetchSegment, this, [index$$46, index$$46 + 1]);
      return JAM.call(v7775.charCodeAt, v7775, [index$$46])
    }
    function v615(start$$10, end$$4) {
      var v15953 = this.agg.seg1.segmentStart <= start$$10;
      if(v15953) {
        v15953 = end$$4 <= this.agg.seg1.segmentEnd
      }
      if(v15953) {
        return this.agg.seg1
      }
      var v15954 = this.agg.seg2.segmentStart <= start$$10;
      if(v15954) {
        v15954 = end$$4 <= this.agg.seg1.segmentEnd
      }
      if(v15954) {
        return this.agg
      }
      var prev = this.agg.seg1;
      var s$$16 = prev.segmentEnd;
      var e$$9 = JAM.call(TypeScript$$16.max, TypeScript$$16, [s$$16 + 512, end$$4]);
      e$$9 = JAM.call(TypeScript$$16.min, TypeScript$$16, [e$$9, this.len]);
      var v7782 = this.sourceText;
      var src$$1 = JAM.call(v7782.getText, v7782, [s$$16, e$$9]);
      var newSeg = JAM.new(SourceTextSegment, [s$$16, e$$9, src$$1]);
      this.agg.seg2 = prev;
      this.agg.seg1 = newSeg;
      return this.agg
    }
    function v614(a$$5, b$$4) {
      var v7785;
      if(a$$5 <= b$$4) {
        v7785 = a$$5
      }else {
        v7785 = b$$4
      }
      return v7785
    }
    function v613(a$$4, b$$3) {
      var v7786;
      if(a$$4 >= b$$3) {
        v7786 = a$$4
      }else {
        v7786 = b$$3
      }
      return v7786
    }
    function ScannerTextStream$$1(sourceText$$3) {
      this.sourceText = sourceText$$3;
      var v27031 = JAM.new(AggerateSourceTextSegment, [ScannerTextStream$$1.emptySegment, ScannerTextStream$$1.emptySegment]);
      this.agg = v27031;
      var v27032 = this.sourceText.getLength();
      this.len = v27032;
      return
    }
    var v7790 = ScannerTextStream$$1;
    var v27033 = JAM.new(SourceTextSegment, [0, 0, ""]);
    v7790.emptySegment = v27033;
    ScannerTextStream$$1.prototype.max = v613;
    ScannerTextStream$$1.prototype.min = v614;
    ScannerTextStream$$1.prototype.fetchSegment = v615;
    ScannerTextStream$$1.prototype.charCodeAt = v616;
    ScannerTextStream$$1.prototype.substring = v617;
    return ScannerTextStream$$1
  }
  function v612() {
    function v611(start$$9, end$$3) {
      var v15957 = this.seg1.segmentStart <= start$$9;
      if(v15957) {
        v15957 = end$$3 <= this.seg1.segmentEnd
      }
      if(v15957) {
        var v7796 = this.seg1.segment;
        return JAM.call(v7796.substring, v7796, [start$$9 - this.seg1.segmentStart, end$$3 - this.seg1.segmentStart])
      }
      var v15961 = this.seg2.segment;
      var v7800 = JAM.call(v15961.substring, v15961, [start$$9 - this.seg2.segmentStart]);
      var v15963 = this.seg1.segment;
      return v7800 + JAM.call(v15963.substring, v15963, [0, end$$3 - this.seg1.segmentStart])
    }
    function v610(index$$45) {
      var v15965 = this.seg1.segmentStart <= index$$45;
      if(v15965) {
        v15965 = index$$45 < this.seg1.segmentEnd
      }
      if(v15965) {
        var v7802 = this.seg1.segment;
        return JAM.call(v7802.charCodeAt, v7802, [index$$45 - this.seg1.segmentStart])
      }
      var v7805 = this.seg2.segment;
      return JAM.call(v7805.charCodeAt, v7805, [index$$45 - this.seg2.segmentStart])
    }
    function AggerateSourceTextSegment$$1(seg1, seg2) {
      this.seg1 = seg1;
      this.seg2 = seg2;
      return
    }
    AggerateSourceTextSegment$$1.prototype.charCodeAt = v610;
    AggerateSourceTextSegment$$1.prototype.substring = v611;
    return AggerateSourceTextSegment$$1
  }
  function v609() {
    function v608(start$$8, end$$2) {
      var v7809 = this.segment;
      return JAM.call(v7809.substring, v7809, [start$$8 - this.segmentStart, end$$2 - this.segmentStart])
    }
    function v607(index$$44) {
      var v7812 = this.segment;
      return JAM.call(v7812.charCodeAt, v7812, [index$$44 - this.segmentStart])
    }
    function SourceTextSegment$$1(segmentStart, segmentEnd, segment) {
      this.segmentStart = segmentStart;
      this.segmentEnd = segmentEnd;
      this.segment = segment;
      return
    }
    SourceTextSegment$$1.prototype.charCodeAt = v607;
    SourceTextSegment$$1.prototype.substring = v608;
    return SourceTextSegment$$1
  }
  function v606() {
    function v605() {
      return this.text.length
    }
    function v604(start$$7, end$$1) {
      var v7817 = this.text;
      return JAM.call(v7817.substring, v7817, [start$$7, end$$1])
    }
    function StringSourceText$$1(text$$17) {
      this.text = text$$17;
      return
    }
    StringSourceText$$1.prototype.getText = v604;
    StringSourceText$$1.prototype.getLength = v605;
    return StringSourceText$$1
  }
  function v603(CommentStyle$$1) {
    CommentStyle$$1._map = [];
    CommentStyle$$1._map[0] = "Line";
    CommentStyle$$1.Line = 0;
    CommentStyle$$1._map[1] = "Block";
    CommentStyle$$1.Block = 1;
    return
  }
  function v602(LexMode$$1) {
    LexMode$$1._map = [];
    LexMode$$1._map[0] = "Line";
    LexMode$$1.Line = 0;
    LexMode$$1._map[1] = "File";
    LexMode$$1.File = 1;
    return
  }
  function v601(LexState$$1) {
    LexState$$1._map = [];
    LexState$$1._map[0] = "Start";
    LexState$$1.Start = 0;
    LexState$$1._map[1] = "InMultilineComment";
    LexState$$1.InMultilineComment = 1;
    LexState$$1._map[2] = "InMultilineSingleQuoteString";
    LexState$$1.InMultilineSingleQuoteString = 2;
    LexState$$1._map[3] = "InMultilineDoubleQuoteString";
    LexState$$1.InMultilineDoubleQuoteString = 3;
    return
  }
  function v600(NumberScanState$$1) {
    NumberScanState$$1._map = [];
    NumberScanState$$1._map[0] = "Start";
    NumberScanState$$1.Start = 0;
    NumberScanState$$1._map[1] = "InFraction";
    NumberScanState$$1.InFraction = 1;
    NumberScanState$$1._map[2] = "InEmptyFraction";
    NumberScanState$$1.InEmptyFraction = 2;
    NumberScanState$$1._map[3] = "InExponent";
    NumberScanState$$1.InExponent = 3;
    return
  }
  function LexLookUpUnicodeMap(code$$2, map$$1) {
    var lo = 0;
    var hi = map$$1.length;
    var mid;
    var v7835 = lo + 1 < hi;
    for(;v7835;) {
      mid = lo + (hi - lo) / 2;
      mid = mid - mid % 2;
      introspect(JAM.policy.p1) {
        var v20851 = map$$1[mid]
      }
      var v15976 = v20851 <= code$$2;
      if(v15976) {
        var v23765 = mid + 1;
        introspect(JAM.policy.p1) {
          var v20852 = map$$1[v23765]
        }
        v15976 = code$$2 <= v20852
      }
      if(v15976) {
        return true
      }
      introspect(JAM.policy.p1) {
        var v15977 = map$$1[mid]
      }
      if(code$$2 < v15977) {
        hi = mid
      }else {
        lo = mid + 2
      }
      v7835 = lo + 1 < hi
    }
    return false
  }
  function LexIsUnicodeDigit(code$$3) {
    if(TypeScript$$16.codeGenTarget == TypeScript$$16.CodeGenTarget.ES3) {
      return LexLookUpUnicodeMap(code$$3, unicodeES3IdCont)
    }else {
      return LexLookUpUnicodeMap(code$$3, unicodeES5IdCont)
    }
    return
  }
  function LexIsUnicodeIdStart(code$$4) {
    if(TypeScript$$16.codeGenTarget == TypeScript$$16.CodeGenTarget.ES3) {
      return LexLookUpUnicodeMap(code$$4, unicodeES3IdStart)
    }else {
      return LexLookUpUnicodeMap(code$$4, unicodeES5IdStart)
    }
    return
  }
  function LexInitialize() {
    TypeScript$$16.initializeStaticTokens();
    JAM.set(autoToken, TypeScript$$16.LexCodeLPR, JAM.get(TypeScript$$16.staticTokens, TypeScript$$16.TokenID.OpenParen, JAM.policy.p1));
    JAM.set(autoToken, TypeScript$$16.LexCodeRPR, JAM.get(TypeScript$$16.staticTokens, TypeScript$$16.TokenID.CloseParen, JAM.policy.p1));
    JAM.set(autoToken, TypeScript$$16.LexCodeCMA, JAM.get(TypeScript$$16.staticTokens, TypeScript$$16.TokenID.Comma, JAM.policy.p1));
    JAM.set(autoToken, TypeScript$$16.LexCodeSMC, JAM.get(TypeScript$$16.staticTokens, TypeScript$$16.TokenID.Semicolon, JAM.policy.p1));
    JAM.set(autoToken, TypeScript$$16.LexCodeLBR, JAM.get(TypeScript$$16.staticTokens, TypeScript$$16.TokenID.OpenBracket, JAM.policy.p1));
    JAM.set(autoToken, TypeScript$$16.LexCodeRBR, JAM.get(TypeScript$$16.staticTokens, TypeScript$$16.TokenID.CloseBracket, JAM.policy.p1));
    JAM.set(autoToken, TypeScript$$16.LexCodeTIL, JAM.get(TypeScript$$16.staticTokens, TypeScript$$16.TokenID.Tilde, JAM.policy.p1));
    JAM.set(autoToken, TypeScript$$16.LexCodeQUE, JAM.get(TypeScript$$16.staticTokens, TypeScript$$16.TokenID.Question, JAM.policy.p1));
    JAM.set(autoToken, TypeScript$$16.LexCodeLC, JAM.get(TypeScript$$16.staticTokens, TypeScript$$16.TokenID.OpenBrace, JAM.policy.p1));
    JAM.set(autoToken, TypeScript$$16.LexCodeRC, JAM.get(TypeScript$$16.staticTokens, TypeScript$$16.TokenID.CloseBrace, JAM.policy.p1));
    JAM.set(autoToken, TypeScript$$16.LexCodeCOL, JAM.get(TypeScript$$16.staticTokens, TypeScript$$16.TokenID.Colon, JAM.policy.p1));
    var v7849 = TypeScript$$16;
    var v27034 = new TypeScript$$16.StringHashTable;
    v7849.LexKeywordTable = v27034;
    var i$$53;
    for(i$$53 in TypeScript$$16.TokenID._map) {
      if(i$$53 <= TypeScript$$16.TokenID.LimKeyword) {
        var v7850 = TypeScript$$16.LexKeywordTable;
        var v20867 = TypeScript$$16.TokenID._map;
        introspect(JAM.policy.p1) {
          var v16008 = v20867[i$$53]
        }
        JAM.call(v7850.add, v7850, [v16008.toLowerCase(), i$$53])
      }
    }
    var j$$6 = 0;
    var v7855 = j$$6 < TypeScript$$16.LexCodeASCIIChars;
    for(;v7855;) {
      if(LexIsIdentifierStartChar(j$$6)) {
        lexIdStartTable[j$$6] = true
      }else {
        lexIdStartTable[j$$6] = false
      }
      j$$6 = j$$6 + 1;
      v7855 = j$$6 < TypeScript$$16.LexCodeASCIIChars
    }
    return
  }
  function LexAdjustIndent(code$$5, indentAmt) {
    var v16011 = code$$5 == TypeScript$$16.LexCodeLBR;
    if(!v16011) {
      var v20869 = code$$5 == TypeScript$$16.LexCodeLC;
      if(!v20869) {
        v20869 = code$$5 == TypeScript$$16.LexCodeLPR
      }
      v16011 = v20869
    }
    if(v16011) {
      return indentAmt + 1
    }else {
      var v16012 = code$$5 == TypeScript$$16.LexCodeRBR;
      if(!v16012) {
        var v20872 = code$$5 == TypeScript$$16.LexCodeRC;
        if(!v20872) {
          v20872 = code$$5 == TypeScript$$16.LexCodeRPR
        }
        v16012 = v20872
      }
      if(v16012) {
        return indentAmt - 1
      }else {
        return indentAmt
      }
    }
    return
  }
  function LexIsIdentifierStartChar(code$$6) {
    var v16013 = code$$6 >= 97;
    if(v16013) {
      v16013 = code$$6 <= 122
    }
    var v7858 = v16013;
    if(!v7858) {
      var v20874 = code$$6 >= 65;
      if(v20874) {
        v20874 = code$$6 <= 90
      }
      var v16014 = v20874;
      if(!v16014) {
        var v20875 = code$$6 == TypeScript$$16.LexCodeDollar;
        if(!v20875) {
          v20875 = code$$6 == TypeScript$$16.LexCodeUnderscore
        }
        v16014 = v20875
      }
      v7858 = v16014
    }
    return v7858
  }
  function LexIsDigit(code$$7) {
    var v7859 = code$$7 >= 48;
    if(v7859) {
      v7859 = code$$7 <= 57
    }
    return v7859
  }
  function LexIsIdentifierChar(code$$8) {
    introspect(JAM.policy.p1) {
      var v7860 = lexIdStartTable[code$$8]
    }
    if(!v7860) {
      v7860 = LexIsDigit(code$$8)
    }
    return v7860
  }
  function LexMatchingOpen(code$$9) {
    if(code$$9 == TypeScript$$16.LexCodeRBR) {
      return TypeScript$$16.LexCodeLBR
    }else {
      if(code$$9 == TypeScript$$16.LexCodeRC) {
        return TypeScript$$16.LexCodeLC
      }else {
        if(code$$9 == TypeScript$$16.LexCodeRPR) {
          return TypeScript$$16.LexCodeLPR
        }else {
          return 0
        }
      }
    }
    return
  }
  function convertTokToIDName(tok) {
    return convertTokToIDBase(tok, true, false)
  }
  function convertTokToID(tok$$1, strictMode) {
    return convertTokToIDBase(tok$$1, false, strictMode)
  }
  function convertTokToIDBase(tok$$2, identifierName, strictMode$$1) {
    if(tok$$2.tokenId <= TypeScript$$16.TokenID.LimKeyword) {
      var tokInfo = JAM.call(TypeScript$$16.lookupToken, TypeScript$$16, [tok$$2.tokenId]);
      if(tokInfo != undefined) {
        var resFlags = TypeScript$$16.Reservation.Javascript | TypeScript$$16.Reservation.JavascriptFuture;
        if(strictMode$$1) {
          resFlags = resFlags | TypeScript$$16.Reservation.JavascriptFutureStrict
        }
        var v16025 = identifierName;
        if(!v16025) {
          v16025 = !JAM.call(TypeScript$$16.hasFlag, TypeScript$$16, [tokInfo.reservation, resFlags])
        }
        if(v16025) {
          return true
        }
      }else {
        return false
      }
    }else {
      return false
    }
    return
  }
  function getLineNumberFromPosition(lineMap$$1, position$$2) {
    if(position$$2 === -1) {
      return 0
    }
    var min$$2 = 0;
    var max$$1 = lineMap$$1.length - 1;
    var v7875 = min$$2 < max$$1;
    for(;v7875;) {
      var med = min$$2 + max$$1 >> 1;
      introspect(JAM.policy.p1) {
        var v16026 = lineMap$$1[med]
      }
      if(position$$2 < v16026) {
        max$$1 = med - 1
      }else {
        var v20881 = med + 1;
        introspect(JAM.policy.p1) {
          var v16027 = lineMap$$1[v20881]
        }
        if(position$$2 < v16027) {
          min$$2 = max$$1 = med
        }else {
          min$$2 = med + 1
        }
      }
      v7875 = min$$2 < max$$1
    }
    return min$$2
  }
  function getSourceLineColFromMap(lineCol$$5, minChar$$29, lineMap$$2) {
    var line$$5 = getLineNumberFromPosition(lineMap$$2, minChar$$29);
    if(line$$5 > 0) {
      lineCol$$5.line = line$$5;
      introspect(JAM.policy.p1) {
        var v7876 = lineMap$$2[line$$5]
      }
      lineCol$$5.col = minChar$$29 - v7876
    }
    return
  }
  function getLineColumnFromPosition(script$$9, position$$3) {
    var result$$10 = {line:-1, col:-1};
    getSourceLineColFromMap(result$$10, position$$3, script$$9.locationInfo.lineMap);
    if(result$$10.col >= 0) {
      result$$10.col = result$$10.col + 1
    }
    return result$$10
  }
  function getPositionFromLineColumn(script$$10, line$$6, column) {
    var v16031 = script$$10.locationInfo.lineMap;
    introspect(JAM.policy.p1) {
      var v7880 = v16031[line$$6]
    }
    return v7880 + (column - 1)
  }
  function isPrimitiveTypeToken(token$$5) {
    switch(token$$5.tokenId) {
      case TypeScript$$16.TokenID.Any:
      ;
      case TypeScript$$16.TokenID.Bool:
      ;
      case TypeScript$$16.TokenID.Number:
      ;
      case TypeScript$$16.TokenID.String:
        return true
    }
    return false
  }
  function isModifier(token$$6) {
    switch(token$$6.tokenId) {
      case TypeScript$$16.TokenID.Public:
      ;
      case TypeScript$$16.TokenID.Private:
      ;
      case TypeScript$$16.TokenID.Static:
        return true
    }
    return false
  }
  TypeScript$$16.LexEOF = -1;
  TypeScript$$16.LexCodeNWL = 10;
  TypeScript$$16.LexCodeRET = 13;
  TypeScript$$16.LexCodeLS = 8232;
  TypeScript$$16.LexCodePS = 8233;
  TypeScript$$16.LexCodeTAB = 9;
  TypeScript$$16.LexCodeVTAB = 11;
  var v7884 = TypeScript$$16;
  var v27035 = JAM.call("e".charCodeAt, "e", [0]);
  v7884.LexCode_e = v27035;
  var v7885 = TypeScript$$16;
  var v27036 = JAM.call("E".charCodeAt, "E", [0]);
  v7885.LexCode_E = v27036;
  var v7886 = TypeScript$$16;
  var v27037 = JAM.call("x".charCodeAt, "x", [0]);
  v7886.LexCode_x = v27037;
  var v7887 = TypeScript$$16;
  var v27038 = JAM.call("X".charCodeAt, "X", [0]);
  v7887.LexCode_X = v27038;
  var v7888 = TypeScript$$16;
  var v27039 = JAM.call("a".charCodeAt, "a", [0]);
  v7888.LexCode_a = v27039;
  var v7889 = TypeScript$$16;
  var v27040 = JAM.call("A".charCodeAt, "A", [0]);
  v7889.LexCode_A = v27040;
  var v7890 = TypeScript$$16;
  var v27041 = JAM.call("f".charCodeAt, "f", [0]);
  v7890.LexCode_f = v27041;
  var v7891 = TypeScript$$16;
  var v27042 = JAM.call("F".charCodeAt, "F", [0]);
  v7891.LexCode_F = v27042;
  var v7892 = TypeScript$$16;
  var v27043 = JAM.call("g".charCodeAt, "g", [0]);
  v7892.LexCode_g = v27043;
  var v7893 = TypeScript$$16;
  var v27044 = JAM.call("m".charCodeAt, "m", [0]);
  v7893.LexCode_m = v27044;
  var v7894 = TypeScript$$16;
  var v27045 = JAM.call("i".charCodeAt, "i", [0]);
  v7894.LexCode_i = v27045;
  var v7895 = TypeScript$$16;
  var v27046 = JAM.call("u".charCodeAt, "u", [0]);
  v7895.LexCode_u = v27046;
  var v7896 = TypeScript$$16;
  var v27047 = JAM.call("0".charCodeAt, "0", [0]);
  v7896.LexCode_0 = v27047;
  var v7897 = TypeScript$$16;
  var v27048 = JAM.call("9".charCodeAt, "9", [0]);
  v7897.LexCode_9 = v27048;
  var v7898 = TypeScript$$16;
  var v27049 = JAM.call("8".charCodeAt, "8", [0]);
  v7898.LexCode_8 = v27049;
  var v7899 = TypeScript$$16;
  var v27050 = JAM.call("7".charCodeAt, "7", [0]);
  v7899.LexCode_7 = v27050;
  var v7900 = TypeScript$$16;
  var v27051 = JAM.call("\\".charCodeAt, "\\", [0]);
  v7900.LexCodeBSL = v27051;
  var v7901 = TypeScript$$16;
  var v27052 = JAM.call("#".charCodeAt, "#", [0]);
  v7901.LexCodeSHP = v27052;
  var v7902 = TypeScript$$16;
  var v27053 = JAM.call("!".charCodeAt, "!", [0]);
  v7902.LexCodeBNG = v27053;
  var v7903 = TypeScript$$16;
  var v27054 = JAM.call('"'.charCodeAt, '"', [0]);
  v7903.LexCodeQUO = v27054;
  var v7904 = TypeScript$$16;
  var v27055 = JAM.call("'".charCodeAt, "'", [0]);
  v7904.LexCodeAPO = v27055;
  var v7905 = TypeScript$$16;
  var v27056 = JAM.call("%".charCodeAt, "%", [0]);
  v7905.LexCodePCT = v27056;
  var v7906 = TypeScript$$16;
  var v27057 = JAM.call("&".charCodeAt, "&", [0]);
  v7906.LexCodeAMP = v27057;
  var v7907 = TypeScript$$16;
  var v27058 = JAM.call("(".charCodeAt, "(", [0]);
  v7907.LexCodeLPR = v27058;
  var v7908 = TypeScript$$16;
  var v27059 = JAM.call(")".charCodeAt, ")", [0]);
  v7908.LexCodeRPR = v27059;
  var v7909 = TypeScript$$16;
  var v27060 = JAM.call("+".charCodeAt, "+", [0]);
  v7909.LexCodePLS = v27060;
  var v7910 = TypeScript$$16;
  var v27061 = JAM.call("-".charCodeAt, "-", [0]);
  v7910.LexCodeMIN = v27061;
  var v7911 = TypeScript$$16;
  var v27062 = JAM.call("*".charCodeAt, "*", [0]);
  v7911.LexCodeMUL = v27062;
  var v7912 = TypeScript$$16;
  var v27063 = JAM.call("/".charCodeAt, "/", [0]);
  v7912.LexCodeSLH = v27063;
  var v7913 = TypeScript$$16;
  var v27064 = JAM.call("^".charCodeAt, "^", [0]);
  v7913.LexCodeXOR = v27064;
  var v7914 = TypeScript$$16;
  var v27065 = JAM.call(",".charCodeAt, ",", [0]);
  v7914.LexCodeCMA = v27065;
  var v7915 = TypeScript$$16;
  var v27066 = JAM.call(".".charCodeAt, ".", [0]);
  v7915.LexCodeDOT = v27066;
  var v7916 = TypeScript$$16;
  var v27067 = JAM.call("<".charCodeAt, "<", [0]);
  v7916.LexCodeLT = v27067;
  var v7917 = TypeScript$$16;
  var v27068 = JAM.call("=".charCodeAt, "=", [0]);
  v7917.LexCodeEQ = v27068;
  var v7918 = TypeScript$$16;
  var v27069 = JAM.call(">".charCodeAt, ">", [0]);
  v7918.LexCodeGT = v27069;
  var v7919 = TypeScript$$16;
  var v27070 = JAM.call("?".charCodeAt, "?", [0]);
  v7919.LexCodeQUE = v27070;
  var v7920 = TypeScript$$16;
  var v27071 = JAM.call("[".charCodeAt, "[", [0]);
  v7920.LexCodeLBR = v27071;
  var v7921 = TypeScript$$16;
  var v27072 = JAM.call("]".charCodeAt, "]", [0]);
  v7921.LexCodeRBR = v27072;
  var v7922 = TypeScript$$16;
  var v27073 = JAM.call("_".charCodeAt, "_", [0]);
  v7922.LexCodeUSC = v27073;
  var v7923 = TypeScript$$16;
  var v27074 = JAM.call("{".charCodeAt, "{", [0]);
  v7923.LexCodeLC = v27074;
  var v7924 = TypeScript$$16;
  var v27075 = JAM.call("}".charCodeAt, "}", [0]);
  v7924.LexCodeRC = v27075;
  var v7925 = TypeScript$$16;
  var v27076 = JAM.call("|".charCodeAt, "|", [0]);
  v7925.LexCodeBAR = v27076;
  var v7926 = TypeScript$$16;
  var v27077 = JAM.call("~".charCodeAt, "~", [0]);
  v7926.LexCodeTIL = v27077;
  var v7927 = TypeScript$$16;
  var v27078 = JAM.call(":".charCodeAt, ":", [0]);
  v7927.LexCodeCOL = v27078;
  var v7928 = TypeScript$$16;
  var v27079 = JAM.call(";".charCodeAt, ";", [0]);
  v7928.LexCodeSMC = v27079;
  var v7929 = TypeScript$$16;
  var v27080 = JAM.call("_".charCodeAt, "_", [0]);
  v7929.LexCodeUnderscore = v27080;
  var v7930 = TypeScript$$16;
  var v27081 = JAM.call("$".charCodeAt, "$", [0]);
  v7930.LexCodeDollar = v27081;
  TypeScript$$16.LexCodeSpace = 32;
  var v7931 = TypeScript$$16;
  var v27082 = JAM.call("@".charCodeAt, "@", [0]);
  v7931.LexCodeAtSign = v27082;
  TypeScript$$16.LexCodeASCIIChars = 128;
  TypeScript$$16.LexKeywordTable = undefined;
  var autoToken = new Array(TypeScript$$16.LexCodeASCIIChars);
  var lexIdStartTable = new Array(TypeScript$$16.LexCodeASCIIChars);
  var v27446 = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 
  2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 
  2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 
  3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 
  4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 
  8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 13312, 19893, 19893, 19968, 19968, 40869, 40869, 40960, 42124, 44032, 44032, 55203, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 
  65019, 65136, 65138];
  var v27447 = [65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
  var unicodeES3IdStart = v27446.concat(v27447);
  var unicodeES3IdCont = [768, 846, 864, 866, 1155, 1158, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1611, 1621, 1632, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 2305, 2307, 2364, 2364, 2366, 2381, 2385, 2388, 2402, 2403, 2406, 2415, 2433, 2435, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2562, 2562, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2662, 2673, 
  2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2790, 2799, 2817, 2819, 2876, 2876, 2878, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2918, 2927, 2946, 2947, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3174, 3183, 3202, 3203, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3302, 3311, 3330, 3331, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 
  3570, 3571, 3633, 3633, 3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903, 3953, 3972, 3974, 3975, 3984, 3991, 3993, 4028, 4038, 4038, 4140, 4146, 4150, 4153, 4160, 4169, 4182, 4185, 4969, 4977, 6068, 6099, 6112, 6121, 6160, 6169, 6313, 6313, 8255, 8256, 8400, 8412, 8417, 8417, 12330, 12335, 12441, 12442, 12539, 12539, 64286, 64286, 65056, 65059, 65075, 65076, 65101, 65103, 65296, 
  65305, 65343, 65343, 65381, 65381];
  var v27448 = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 
  2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 
  2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 
  3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 
  4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6E3, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 
  6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455];
  var v27449 = [8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 
  12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 13312, 19893, 19893, 19968, 19968, 40908, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43E3, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 
  43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 44032, 55203, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 
  64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
  var unicodeES5IdStart = v27448.concat(v27449);
  var unicodeES5IdCont = [768, 879, 1155, 1159, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1552, 1562, 1611, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 1984, 1993, 2027, 2035, 2070, 2073, 2075, 2083, 2085, 2087, 2089, 2093, 2137, 2139, 2276, 2302, 2304, 2307, 2362, 2364, 2366, 2383, 2385, 2391, 2402, 2403, 2406, 2415, 2433, 2435, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 
  2561, 2563, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2662, 2673, 2677, 2677, 2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2786, 2787, 2790, 2799, 2817, 2819, 2876, 2876, 2878, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2914, 2915, 2918, 2927, 2946, 2946, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3046, 3055, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3170, 3171, 3174, 3183, 3202, 3203, 3260, 3260, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 
  3298, 3299, 3302, 3311, 3330, 3331, 3390, 3396, 3398, 3400, 3402, 3405, 3415, 3415, 3426, 3427, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3633, 3633, 3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903, 3953, 3972, 3974, 3975, 3981, 3991, 3993, 4028, 4038, 4038, 4139, 4158, 4160, 4169, 4182, 4185, 4190, 4192, 4194, 4196, 4199, 4205, 4209, 4212, 
  4226, 4237, 4239, 4253, 4957, 4959, 5906, 5908, 5938, 5940, 5970, 5971, 6002, 6003, 6068, 6099, 6109, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6313, 6313, 6432, 6443, 6448, 6459, 6470, 6479, 6576, 6592, 6600, 6601, 6608, 6617, 6679, 6683, 6741, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6912, 6916, 6964, 6980, 6992, 7001, 7019, 7027, 7040, 7042, 7073, 7085, 7088, 7097, 7142, 7155, 7204, 7223, 7232, 7241, 7248, 7257, 7376, 7378, 7380, 7400, 7405, 7405, 7410, 7412, 7616, 7654, 7676, 7679, 8204, 8205, 
  8255, 8256, 8276, 8276, 8400, 8412, 8417, 8417, 8421, 8432, 11503, 11505, 11647, 11647, 11744, 11775, 12330, 12335, 12441, 12442, 42528, 42537, 42607, 42607, 42612, 42621, 42655, 42655, 42736, 42737, 43010, 43010, 43014, 43014, 43019, 43019, 43043, 43047, 43136, 43137, 43188, 43204, 43216, 43225, 43232, 43249, 43264, 43273, 43302, 43309, 43335, 43347, 43392, 43395, 43443, 43456, 43472, 43481, 43561, 43574, 43587, 43587, 43596, 43597, 43600, 43609, 43643, 43643, 43696, 43696, 43698, 43700, 43703, 
  43704, 43710, 43711, 43713, 43713, 43755, 43759, 43765, 43766, 44003, 44010, 44012, 44013, 44016, 44025, 64286, 64286, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65296, 65305, 65343, 65343];
  TypeScript$$16.LexLookUpUnicodeMap = LexLookUpUnicodeMap;
  TypeScript$$16.LexIsUnicodeDigit = LexIsUnicodeDigit;
  TypeScript$$16.LexIsUnicodeIdStart = LexIsUnicodeIdStart;
  TypeScript$$16.LexInitialize = LexInitialize;
  TypeScript$$16.LexAdjustIndent = LexAdjustIndent;
  TypeScript$$16.LexIsIdentifierStartChar = LexIsIdentifierStartChar;
  TypeScript$$16.LexIsDigit = LexIsDigit;
  TypeScript$$16.LexIsIdentifierChar = LexIsIdentifierChar;
  TypeScript$$16.LexMatchingOpen = LexMatchingOpen;
  var v16032 = TypeScript$$16.NumberScanState;
  if(!v16032) {
    v16032 = TypeScript$$16.NumberScanState = {}
  }
  v600(v16032);
  var NumberScanState = TypeScript$$16.NumberScanState;
  var v16033 = TypeScript$$16.LexState;
  if(!v16033) {
    v16033 = TypeScript$$16.LexState = {}
  }
  v601(v16033);
  var LexState = TypeScript$$16.LexState;
  var v16034 = TypeScript$$16.LexMode;
  if(!v16034) {
    v16034 = TypeScript$$16.LexMode = {}
  }
  v602(v16034);
  var LexMode = TypeScript$$16.LexMode;
  var v16035 = TypeScript$$16.CommentStyle;
  if(!v16035) {
    v16035 = TypeScript$$16.CommentStyle = {}
  }
  v603(v16035);
  var CommentStyle = TypeScript$$16.CommentStyle;
  var StringSourceText = v606();
  TypeScript$$16.StringSourceText = StringSourceText;
  var SourceTextSegment = v609();
  TypeScript$$16.SourceTextSegment = SourceTextSegment;
  var AggerateSourceTextSegment = v612();
  TypeScript$$16.AggerateSourceTextSegment = AggerateSourceTextSegment;
  var ScannerTextStream = v618();
  TypeScript$$16.ScannerTextStream = ScannerTextStream;
  var SavedTokens = v633();
  TypeScript$$16.SavedTokens = SavedTokens;
  var Scanner = v674();
  TypeScript$$16.Scanner = Scanner;
  TypeScript$$16.convertTokToIDName = convertTokToIDName;
  TypeScript$$16.convertTokToID = convertTokToID;
  TypeScript$$16.getLineNumberFromPosition = getLineNumberFromPosition;
  TypeScript$$16.getSourceLineColFromMap = getSourceLineColFromMap;
  TypeScript$$16.getLineColumnFromPosition = getLineColumnFromPosition;
  TypeScript$$16.getPositionFromLineColumn = getPositionFromLineColumn;
  TypeScript$$16.isPrimitiveTypeToken = isPrimitiveTypeToken;
  TypeScript$$16.isModifier = isModifier;
  return
}
function v599(TypeScript$$15) {
  function v598() {
    function v597(s$$15) {
      this.builder = this.builder + s$$15;
      var v7938 = this.outfile;
      JAM.call(v7938.WriteLine, v7938, [this.builder]);
      this.builder = "";
      return
    }
    function v596(s$$14) {
      this.builder = this.builder + s$$14;
      return
    }
    function v595() {
      if(this.builder.length > 0) {
        var v7940 = TypeScript$$15.CompilerDiagnostics;
        JAM.call(v7940.Alert, v7940, [this.builder])
      }
      var v7943 = this.indentStrings;
      var v7944 = this.indentAmt;
      introspect(JAM.policy.p1) {
        var indentString$$1 = v7943[v7944]
      }
      if(indentString$$1 === undefined) {
        indentString$$1 = "";
        var i$$52 = 0;
        var v7945 = i$$52 < this.indentAmt;
        for(;v7945;) {
          indentString$$1 = indentString$$1 + this.indent1;
          i$$52 = i$$52 + 1;
          v7945 = i$$52 < this.indentAmt
        }
        JAM.set(this.indentStrings, this.indentAmt, indentString$$1)
      }
      this.builder = this.builder + indentString$$1;
      return
    }
    function v594() {
      this.indentAmt = this.indentAmt - 1;
      return
    }
    function v593() {
      this.indentAmt = this.indentAmt + 1;
      return
    }
    function PrintContext$$1(outfile$$4, parser$$1) {
      this.outfile = outfile$$4;
      this.parser = parser$$1;
      this.builder = "";
      this.indent1 = "  ";
      this.indentStrings = [];
      this.indentAmt = 0;
      return
    }
    PrintContext$$1.prototype.increaseIndent = v593;
    PrintContext$$1.prototype.decreaseIndent = v594;
    PrintContext$$1.prototype.startLine = v595;
    PrintContext$$1.prototype.write = v596;
    PrintContext$$1.prototype.writeLine = v597;
    return PrintContext$$1
  }
  function prePrintAST(ast$$46, parent$$43, walker$$40) {
    var pc = walker$$40.state;
    JAM.call(ast$$46.print, ast$$46, [pc]);
    pc.increaseIndent();
    return ast$$46
  }
  function postPrintAST(ast$$47, parent$$44, walker$$41) {
    var pc$$1 = walker$$41.state;
    pc$$1.decreaseIndent();
    return ast$$47
  }
  var PrintContext = v598();
  TypeScript$$15.PrintContext = PrintContext;
  TypeScript$$15.prePrintAST = prePrintAST;
  TypeScript$$15.postPrintAST = postPrintAST;
  return
}
function v592(TypeScript$$14) {
  function v591() {
    function v590(sourceText$$2, filename$$2, unitIndex$$2, allowedElements$$4) {
      function v589(message$$16) {
        return JAM.call(_this$$2.reportParseError, _this$$2, [message$$16])
      }
      if(typeof allowedElements$$4 === "undefined") {
        allowedElements$$4 = TypeScript$$14.AllowedElements.Global
      }
      var _this$$2 = this;
      this.ambientModule = false;
      this.topLevel = true;
      this.hasTopLevelImportOrExport = false;
      this.requiresExtendsBlock = false;
      this.fname = filename$$2;
      this.currentUnitIndex = unitIndex$$2;
      this.amdDependencies = [];
      this.scanner.resetComments();
      var v7957 = this.scanner;
      JAM.call(v7957.setErrorHandler, v7957, [v589]);
      var v7958 = this.scanner;
      JAM.call(v7958.setSourceText, v7958, [sourceText$$2, TypeScript$$14.LexMode.File]);
      var leftCurlyCount$$5 = this.scanner.leftCurlyCount;
      var rightCurlyCount$$5 = this.scanner.rightCurlyCount;
      var minChar$$28 = this.scanner.pos;
      var v27083 = this.scanner.scan();
      this.currentToken = v27083;
      this.pushDeclLists();
      var bod$$3 = new TypeScript$$14.ASTList;
      bod$$3.minChar = minChar$$28;
      this.state = ParseState.StartScript;
      var v7965 = JAM.call(TypeScript$$14.isDSTRFile, TypeScript$$14, [filename$$2]);
      if(!v7965) {
        v7965 = JAM.call(TypeScript$$14.isDTSFile, TypeScript$$14, [filename$$2])
      }
      this.parsingDeclareFile = v7965;
      for(;true;) {
        JAM.call(this.parseStatementList, this, [TypeScript$$14.ErrorRecoverySet.EOF | TypeScript$$14.ErrorRecoverySet.Func, bod$$3, true, false, allowedElements$$4, TypeScript$$14.Modifiers.None]);
        if(this.currentToken.tokenId === TypeScript$$14.TokenID.EndOfFile) {
          break
        }
        var v7969 = TypeScript$$14.tokenTable;
        var v7970 = this.currentToken.tokenId;
        introspect(JAM.policy.p1) {
          var badToken = v7969[v7970]
        }
        JAM.call(this.reportParseError, this, ["Unexpected statement block terminator '" + badToken.text + "'"]);
        var v27084 = this.scanner.scan();
        this.currentToken = v27084
      }
      this.state = ParseState.EndScript;
      bod$$3.limChar = this.scanner.pos;
      var topLevelMod = null;
      var v16055 = TypeScript$$14.moduleGenTarget != TypeScript$$14.ModuleGenTarget.Local;
      if(v16055) {
        v16055 = this.hasTopLevelImportOrExport
      }
      if(v16055) {
        var correctedFileName = JAM.call(TypeScript$$14.switchToForwardSlashes, TypeScript$$14, [filename$$2]);
        var id$$15 = JAM.new(TypeScript$$14.Identifier, [correctedFileName]);
        topLevelMod = JAM.new(TypeScript$$14.ModuleDeclaration, [id$$15, bod$$3, this.topVarList(), this.topScopeList(), null]);
        topLevelMod.modFlags = topLevelMod.modFlags | TypeScript$$14.ModuleFlags.IsDynamic;
        topLevelMod.modFlags = topLevelMod.modFlags | TypeScript$$14.ModuleFlags.IsWholeFile;
        topLevelMod.modFlags = topLevelMod.modFlags | TypeScript$$14.ModuleFlags.Exported;
        if(this.parsingDeclareFile) {
          topLevelMod.modFlags = topLevelMod.modFlags | TypeScript$$14.ModuleFlags.Ambient
        }
        topLevelMod.minChar = minChar$$28;
        topLevelMod.limChar = this.scanner.pos;
        var v7980 = topLevelMod;
        var v27085 = JAM.call(TypeScript$$14.getPrettyName, TypeScript$$14, [correctedFileName]);
        v7980.prettyName = v27085;
        topLevelMod.containsUnicodeChar = this.scanner.seenUnicodeChar;
        topLevelMod.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;
        topLevelMod.amdDependencies = this.amdDependencies;
        bod$$3 = new TypeScript$$14.ASTList;
        bod$$3.minChar = topLevelMod.minChar;
        bod$$3.limChar = topLevelMod.limChar;
        JAM.call(bod$$3.append, bod$$3, [topLevelMod])
      }
      var script$$8 = JAM.new(TypeScript$$14.Script, [this.topVarList(), this.topScopeList()]);
      script$$8.bod = bod$$3;
      this.popDeclLists();
      script$$8.minChar = minChar$$28;
      script$$8.limChar = this.scanner.pos;
      var v7989 = script$$8;
      var v27086 = JAM.new(TypeScript$$14.LocationInfo, [filename$$2, this.scanner.lineMap, unitIndex$$2]);
      v7989.locationInfo = v27086;
      script$$8.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount$$5;
      script$$8.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount$$5;
      script$$8.isDeclareFile = this.parsingDeclareFile;
      script$$8.topLevelMod = topLevelMod;
      script$$8.containsUnicodeChar = this.scanner.seenUnicodeChar;
      script$$8.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;
      script$$8.requiresExtendsBlock = this.requiresExtendsBlock;
      return script$$8
    }
    function v588(sourceText$$1, filename$$1, unitIndex$$1) {
      var svGenTarget = TypeScript$$14.moduleGenTarget;
      try {
        TypeScript$$14.moduleGenTarget = TypeScript$$14.ModuleGenTarget.Local;
        var script$$7 = JAM.call(this.parse, this, [sourceText$$1, filename$$1, unitIndex$$1, TypeScript$$14.AllowedElements.QuickParse]);
        return JAM.new(QuickParseResult, [script$$7, this.scanner.lexState])
      }finally {
        TypeScript$$14.moduleGenTarget = svGenTarget
      }
      return
    }
    function v587(errorRecoverySet$$38, statements$$1, sourceElms, noLeadingCase, allowedElements$$3, parentModifiers$$8) {
      var directivePrologue = sourceElms;
      statements$$1.minChar = this.scanner.startPos;
      var limChar$$8 = this.scanner.pos;
      var innerStmts = (allowedElements$$3 & TypeScript$$14.AllowedElements.ModuleDeclarations) == TypeScript$$14.AllowedElements.None;
      var classNope = (allowedElements$$3 & TypeScript$$14.AllowedElements.ClassDeclarations) == TypeScript$$14.AllowedElements.None;
      errorRecoverySet$$38 = errorRecoverySet$$38 | TypeScript$$14.ErrorRecoverySet.TypeScriptS | TypeScript$$14.ErrorRecoverySet.RCurly;
      this.state = ParseState.StartStatementList;
      var oldStrictMode = this.strictMode;
      this.nestingLevel = this.nestingLevel + 1;
      for(;;) {
        var v16076 = this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBrace;
        if(!v16076) {
          var v23782 = noLeadingCase;
          if(v23782) {
            var v25199 = this.currentToken.tokenId == TypeScript$$14.TokenID.Case;
            if(!v25199) {
              v25199 = this.currentToken.tokenId == TypeScript$$14.TokenID.Default
            }
            v23782 = v25199
          }
          var v20906 = v23782;
          if(!v20906) {
            var v25200 = innerStmts;
            if(v25200) {
              v25200 = this.currentToken.tokenId == TypeScript$$14.TokenID.Export
            }
            var v23783 = v25200;
            if(!v23783) {
              var v25968 = classNope;
              if(v25968) {
                v25968 = this.currentToken.tokenId == TypeScript$$14.TokenID.Class
              }
              var v25201 = v25968;
              if(!v25201) {
                v25201 = this.currentToken.tokenId == TypeScript$$14.TokenID.EndOfFile
              }
              v23783 = v25201
            }
            v20906 = v23783
          }
          v16076 = v20906
        }
        if(v16076) {
          this.state = ParseState.EndStmtList;
          statements$$1.limChar = limChar$$8;
          if(statements$$1.members.length == 0) {
            var v8003 = statements$$1;
            var v27087 = this.parseComments();
            v8003.preComments = v27087
          }else {
            var v8004 = statements$$1;
            var v27088 = this.parseComments();
            v8004.postComments = v27088
          }
          this.strictMode = oldStrictMode;
          this.nestingLevel = this.nestingLevel - 1;
          return
        }
        var stmt$$4 = JAM.call(this.parseStatement, this, [errorRecoverySet$$38 & ~(TypeScript$$14.ErrorRecoverySet.Else | TypeScript$$14.ErrorRecoverySet.RParen | TypeScript$$14.ErrorRecoverySet.Catch | TypeScript$$14.ErrorRecoverySet.Colon), allowedElements$$3, parentModifiers$$8]);
        if(stmt$$4) {
          var v8008 = stmt$$4;
          var v27089 = JAM.call(this.combineComments, this, [stmt$$4.postComments, JAM.call(this.parseCommentsForLine, this, [this.scanner.prevLine])]);
          v8008.postComments = v27089;
          JAM.call(statements$$1.append, statements$$1, [stmt$$4]);
          limChar$$8 = stmt$$4.limChar;
          if(directivePrologue) {
            if(stmt$$4.nodeType == TypeScript$$14.NodeType.QString) {
              var qstring = stmt$$4;
              if(qstring.text == '"use strict"') {
                statements$$1.flags = statements$$1.flags | TypeScript$$14.ASTFlags.StrictMode;
                this.strictMode = true
              }else {
                directivePrologue = false
              }
            }else {
              directivePrologue = false
            }
          }
        }
      }
      return
    }
    function v586(ast$$45) {
      var nt = ast$$45.nodeType;
      var v8011 = nt == TypeScript$$14.NodeType.ClassDeclaration;
      if(!v8011) {
        var v16088 = nt == TypeScript$$14.NodeType.ImportDeclaration;
        if(!v16088) {
          var v20915 = nt == TypeScript$$14.NodeType.InterfaceDeclaration;
          if(!v20915) {
            var v23790 = nt == TypeScript$$14.NodeType.ModuleDeclaration;
            if(!v23790) {
              var v25208 = nt == TypeScript$$14.NodeType.Empty;
              if(!v25208) {
                var v25977 = nt == TypeScript$$14.NodeType.VarDecl;
                if(!v25977) {
                  var v26563 = nt == TypeScript$$14.NodeType.Block;
                  if(v26563) {
                    v26563 = !ast$$45.isStatementBlock
                  }
                  var v26392 = v26563;
                  if(!v26392) {
                    var v26564 = nt == TypeScript$$14.NodeType.FuncDecl;
                    if(v26564) {
                      v26564 = ast$$45.isMethod()
                    }
                    v26392 = v26564
                  }
                  v25977 = v26392
                }
                v25208 = v25977
              }
              v23790 = v25208
            }
            v20915 = v23790
          }
          v16088 = v20915
        }
        v8011 = v16088
      }
      return v8011
    }
    function v585(errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7) {
      function isAmbient$$3() {
        var v8012 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$12, TypeScript$$14.Modifiers.Ambient]);
        if(!v8012) {
          v8012 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [parentModifiers$$7, TypeScript$$14.Modifiers.Ambient])
        }
        return v8012
      }
      function mayNotBeExported() {
        if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$12, TypeScript$$14.Modifiers.Exported])) {
          JAM.call(this.reportError, this, ["Statement may not be exported"])
        }
        return
      }
      var ast$$44 = null;
      var labelList$$1 = null;
      var astList = null;
      var temp$$15;
      var modifiers$$12 = TypeScript$$14.Modifiers.None;
      var minChar$$27 = this.scanner.startPos;
      var forInOk = false;
      var needTerminator = false;
      var fnOrVar = null;
      var preComments$$8 = this.parseComments();
      this.state = ParseState.StartStatement;
      for(;;) {
        switch(this.currentToken.tokenId) {
          case TypeScript$$14.TokenID.EndOfFile:
            ast$$44 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Error]);
            ast$$44.minChar = minChar$$27;
            ast$$44.limChar = this.scanner.pos;
            break;
          case TypeScript$$14.TokenID.Function:
            var v16096 = this.parsingDeclareFile;
            if(!v16096) {
              var v20920 = isAmbient$$3();
              if(!v20920) {
                v20920 = this.ambientModule
              }
              v16096 = v20920
            }
            if(v16096) {
              var v27090 = this.scanner.scan();
              this.currentToken = v27090;
              fnOrVar = JAM.call(this.parsePropertyDeclaration, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.SColon, modifiers$$12, true, false]);
              if(fnOrVar.nodeType == TypeScript$$14.NodeType.VarDecl) {
                JAM.call(this.reportParseError, this, ["function keyword can only introduce function declaration"])
              }else {
                var v16100 = fnOrVar.nodeType == TypeScript$$14.NodeType.FuncDecl;
                if(v16100) {
                  fnOrVar.fncFlags;
                  v16100 = TypeScript$$14.FncFlags.IsFatArrowFunction
                }
                if(v16100) {
                  needTerminator = true
                }
              }
              ast$$44 = fnOrVar;
              var v16101 = this.parsingDeclareFile;
              if(!v16101) {
                var v20926 = this.ambientModule;
                if(v20926) {
                  v20926 = ast$$44.nodeType == TypeScript$$14.NodeType.FuncDecl
                }
                v16101 = v20926
              }
              if(v16101) {
                ast$$44.fncFlags = ast$$44.fncFlags | TypeScript$$14.FncFlags.Exported
              }
            }else {
              ast$$44 = JAM.call(this.parseFncDecl, this, [errorRecoverySet$$37, true, false, false, null, false, false, isAmbient$$3(), modifiers$$12, null, true]);
              if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [ast$$44.fncFlags, TypeScript$$14.FncFlags.IsFatArrowFunction])) {
                needTerminator = true
              }
              if(this.ambientModule) {
                JAM.call(this.reportParseError, this, ["function declaration not permitted within ambient module"])
              }
              if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$12, TypeScript$$14.Modifiers.Exported])) {
                ast$$44.fncFlags = ast$$44.fncFlags | TypeScript$$14.FncFlags.Exported
              }
            }
            break;
          case TypeScript$$14.TokenID.Module:
            if((allowedElements$$2 & TypeScript$$14.AllowedElements.ModuleDeclarations) == TypeScript$$14.AllowedElements.None) {
              JAM.call(this.reportParseError, this, ["module not allowed in this context"]);
              var v27091 = this.scanner.scan();
              this.currentToken = v27091;
              ast$$44 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Error]);
              ast$$44.minChar = minChar$$27;
              var v8032 = ast$$44;
              var v27092 = this.scanner.lastTokenLimChar();
              v8032.limChar = v27092
            }else {
              ast$$44 = JAM.call(this.parseModuleDecl, this, [errorRecoverySet$$37, modifiers$$12, preComments$$8]);
              preComments$$8 = null
            }
            break;
          case TypeScript$$14.TokenID.Import:
            if((allowedElements$$2 & TypeScript$$14.AllowedElements.ModuleDeclarations) == TypeScript$$14.AllowedElements.None) {
              JAM.call(this.reportParseError, this, ["module not allowed in this context"]);
              var v27093 = this.scanner.scan();
              this.currentToken = v27093;
              ast$$44 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Error]);
              ast$$44.minChar = minChar$$27;
              var v8037 = ast$$44;
              var v27094 = this.scanner.lastTokenLimChar();
              v8037.limChar = v27094
            }else {
              if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$12, TypeScript$$14.Modifiers.Exported])) {
                JAM.call(this.reportParseError, this, ["export keyword not permitted on import declaration"])
              }
              ast$$44 = JAM.call(this.parseImportDeclaration, this, [errorRecoverySet$$37, modifiers$$12]);
              needTerminator = true
            }
            break;
          case TypeScript$$14.TokenID.Export:
            if((allowedElements$$2 & TypeScript$$14.AllowedElements.ModuleDeclarations) == TypeScript$$14.AllowedElements.None) {
              JAM.call(this.reportParseError, this, ["'export' statements are only allowed at the global and module levels"]);
              var v27095 = this.scanner.scan();
              this.currentToken = v27095;
              ast$$44 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Error]);
              ast$$44.minChar = minChar$$27;
              var v8043 = ast$$44;
              var v27096 = this.scanner.lastTokenLimChar();
              v8043.limChar = v27096
            }
            if(this.topLevel) {
              this.hasTopLevelImportOrExport = true
            }
            modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Exported;
            var v27097 = this.scanner.scan();
            this.currentToken = v27097;
            break;
          case TypeScript$$14.TokenID.Private:
            modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Private;
            var v27098 = this.scanner.scan();
            this.currentToken = v27098;
            if(this.parsingClassConstructorDefinition) {
              if(!this.inferPropertiesFromThisAssignment) {
                JAM.call(this.reportParseError, this, ["Property declarations are not permitted within constructor bodies"])
              }
              minChar$$27 = this.scanner.pos;
              var v16125 = this.inferPropertiesFromThisAssignment;
              if(v16125) {
                var v20941 = this.currentToken.tokenId != TypeScript$$14.TokenID.This;
                if(!v20941) {
                  var v27099 = this.scanner.scan();
                  v20941 = (this.currentToken = v27099).tokenId != TypeScript$$14.TokenID.Dot
                }
                v16125 = v20941
              }
              if(v16125) {
                JAM.call(this.reportParseError, this, ["Expected 'this.' for property declaration"]);
                var v27100 = this.scanner.scan();
                this.currentToken = v27100;
                ast$$44 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Error]);
                ast$$44.minChar = minChar$$27;
                var v8053 = ast$$44;
                var v27101 = this.scanner.lastTokenLimChar();
                v8053.limChar = v27101
              }else {
                var v27102 = this.scanner.scan();
                this.currentToken = v27102;
                var v8055 = TypeScript$$14.Identifier;
                var id$$14 = JAM.call(v8055.fromToken, v8055, [this.currentToken]);
                id$$14.minChar = this.scanner.startPos;
                id$$14.limChar = this.scanner.pos;
                var v27103 = this.scanner.scan();
                this.currentToken = v27103;
                ast$$44 = JAM.call(this.parseClassMemberVariableDeclaration, this, [id$$14, minChar$$27, this.parsingClassConstructorDefinition, errorRecoverySet$$37, modifiers$$12])
              }
            }else {
              if(this.currentToken.tokenId != TypeScript$$14.TokenID.Interface) {
                if(this.currentToken.tokenId == TypeScript$$14.TokenID.Get) {
                  this.prevIDTok = this.currentToken;
                  var v27104 = this.scanner.scan();
                  this.currentToken = v27104;
                  if(TypeScript$$14.codeGenTarget < TypeScript$$14.CodeGenTarget.ES5) {
                    JAM.call(this.reportParseError, this, ["Property accessors are only available when targeting ES5 or greater"])
                  }
                  var v16134 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
                  if(!v16134) {
                    v16134 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
                  }
                  if(v16134) {
                    modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Getter;
                    this.prevIDTok = null
                  }
                }else {
                  if(this.currentToken.tokenId == TypeScript$$14.TokenID.Set) {
                    this.prevIDTok = this.currentToken;
                    var v27105 = this.scanner.scan();
                    this.currentToken = v27105;
                    if(TypeScript$$14.codeGenTarget < TypeScript$$14.CodeGenTarget.ES5) {
                      JAM.call(this.reportParseError, this, ["Property accessors are only available when targeting ES5 or greater"])
                    }
                    var v16140 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
                    if(!v16140) {
                      v16140 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
                    }
                    if(v16140) {
                      modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Setter;
                      this.prevIDTok = null
                    }
                  }
                }
                fnOrVar = JAM.call(this.parsePropertyDeclaration, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.SColon, modifiers$$12, isAmbient$$3(), false]);
                var v16143 = fnOrVar.nodeType == TypeScript$$14.NodeType.VarDecl;
                if(!v16143) {
                  var v20965 = fnOrVar.nodeType == TypeScript$$14.NodeType.FuncDecl;
                  if(v20965) {
                    v20965 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [fnOrVar.fncFlags, TypeScript$$14.FncFlags.IsFatArrowFunction])
                  }
                  v16143 = v20965
                }
                if(v16143) {
                  needTerminator = true
                }
                ast$$44 = fnOrVar
              }
            }
            break;
          case TypeScript$$14.TokenID.Public:
            if(this.parsingClassConstructorDefinition) {
              if(!this.inferPropertiesFromThisAssignment) {
                JAM.call(this.reportParseError, this, ["Property declarations are not permitted within constructor bodies"])
              }
              var v27106 = this.scanner.scan();
              this.currentToken = v27106;
              minChar$$27 = this.scanner.pos;
              modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Public;
              var v16146 = this.inferPropertiesFromThisAssignment;
              if(v16146) {
                var v20968 = this.currentToken.tokenId != TypeScript$$14.TokenID.This;
                if(!v20968) {
                  var v27107 = this.scanner.scan();
                  v20968 = (this.currentToken = v27107).tokenId != TypeScript$$14.TokenID.Dot
                }
                v16146 = v20968
              }
              if(v16146) {
                JAM.call(this.reportParseError, this, ["Expected 'this.' for property declaration"]);
                var v27108 = this.scanner.scan();
                this.currentToken = v27108;
                ast$$44 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Error]);
                ast$$44.minChar = minChar$$27;
                var v8081 = ast$$44;
                var v27109 = this.scanner.lastTokenLimChar();
                v8081.limChar = v27109
              }else {
                var v27110 = this.scanner.scan();
                this.currentToken = v27110;
                var v8083 = TypeScript$$14.Identifier;
                id$$14 = JAM.call(v8083.fromToken, v8083, [this.currentToken]);
                id$$14.minChar = this.scanner.startPos;
                id$$14.limChar = this.scanner.pos;
                var v27111 = this.scanner.scan();
                this.currentToken = v27111;
                ast$$44 = JAM.call(this.parseClassMemberVariableDeclaration, this, [id$$14, minChar$$27, this.parsingClassConstructorDefinition, errorRecoverySet$$37, modifiers$$12])
              }
            }else {
              if((allowedElements$$2 & TypeScript$$14.AllowedElements.Properties) == TypeScript$$14.AllowedElements.None) {
                JAM.call(this.reportParseError, this, ["'property' statements are only allowed within classes"]);
                var v27112 = this.scanner.scan();
                this.currentToken = v27112;
                ast$$44 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Error]);
                ast$$44.minChar = minChar$$27;
                var v8093 = ast$$44;
                var v27113 = this.scanner.lastTokenLimChar();
                v8093.limChar = v27113
              }else {
                modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Public;
                var v27114 = this.scanner.scan();
                this.currentToken = v27114;
                if(this.currentToken.tokenId == TypeScript$$14.TokenID.Get) {
                  this.prevIDTok = this.currentToken;
                  var v27115 = this.scanner.scan();
                  this.currentToken = v27115;
                  if(TypeScript$$14.codeGenTarget < TypeScript$$14.CodeGenTarget.ES5) {
                    JAM.call(this.reportParseError, this, ["Property accessors are only available when targeting ES5 or greater"])
                  }
                  var v16158 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
                  if(!v16158) {
                    v16158 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
                  }
                  if(v16158) {
                    modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Getter;
                    this.prevIDTok = null
                  }
                }else {
                  if(this.currentToken.tokenId == TypeScript$$14.TokenID.Set) {
                    this.prevIDTok = this.currentToken;
                    var v27116 = this.scanner.scan();
                    this.currentToken = v27116;
                    if(TypeScript$$14.codeGenTarget < TypeScript$$14.CodeGenTarget.ES5) {
                      JAM.call(this.reportParseError, this, ["Property accessors are only available when targeting ES5 or greater"])
                    }
                    var v16164 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
                    if(!v16164) {
                      v16164 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
                    }
                    if(v16164) {
                      modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Setter;
                      this.prevIDTok = null
                    }
                  }
                }
                fnOrVar = JAM.call(this.parsePropertyDeclaration, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.SColon, modifiers$$12, isAmbient$$3(), false]);
                var v16167 = fnOrVar.nodeType == TypeScript$$14.NodeType.VarDecl;
                if(!v16167) {
                  var v20993 = fnOrVar.nodeType == TypeScript$$14.NodeType.FuncDecl;
                  if(v20993) {
                    v20993 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [fnOrVar.fncFlags, TypeScript$$14.FncFlags.IsFatArrowFunction])
                  }
                  v16167 = v20993
                }
                if(v16167) {
                  needTerminator = true
                }
                ast$$44 = fnOrVar
              }
            }
            break;
          case TypeScript$$14.TokenID.Declare:
            if(!(allowedElements$$2 & TypeScript$$14.AllowedElements.AmbientDeclarations)) {
              JAM.call(this.reportParseError, this, ["Ambient declarations are only allowed at the top-level or module scopes"])
            }
            var v16169 = !this.parsingDeclareFile;
            if(v16169) {
              v16169 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [parentModifiers$$7, TypeScript$$14.Modifiers.Ambient])
            }
            if(v16169) {
              JAM.call(this.reportParseError, this, ["Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)"])
            }
            modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Ambient;
            var v27117 = this.scanner.scan();
            this.currentToken = v27117;
            break;
          case TypeScript$$14.TokenID.Class:
            if((allowedElements$$2 & TypeScript$$14.AllowedElements.ClassDeclarations) == TypeScript$$14.AllowedElements.None) {
              JAM.call(this.reportParseError, this, ["class not allowed in this context"]);
              var v27118 = this.scanner.scan();
              this.currentToken = v27118;
              ast$$44 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Error]);
              ast$$44.minChar = minChar$$27;
              var v8114 = ast$$44;
              var v27119 = this.scanner.lastTokenLimChar();
              v8114.limChar = v27119
            }else {
              ast$$44 = JAM.call(this.parseClassDecl, this, [errorRecoverySet$$37, minChar$$27, modifiers$$12])
            }
            break;
          case TypeScript$$14.TokenID.Interface:
            if((allowedElements$$2 & TypeScript$$14.AllowedElements.InterfaceDeclarations) == TypeScript$$14.AllowedElements.None) {
              JAM.call(this.reportParseError, this, ["interface not allowed in this context"]);
              var v27120 = this.scanner.scan();
              this.currentToken = v27120;
              ast$$44 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Error]);
              ast$$44.minChar = minChar$$27;
              var v8119 = ast$$44;
              var v27121 = this.scanner.lastTokenLimChar();
              v8119.limChar = v27121
            }else {
              ast$$44 = JAM.call(this.parseInterfaceDecl, this, [errorRecoverySet$$37, modifiers$$12])
            }
            break;
          case TypeScript$$14.TokenID.Var:
            var declAst = JAM.call(this.parseVariableDeclaration, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.StmtStart, modifiers$$12, true, false]);
            if(declAst.nodeType == TypeScript$$14.NodeType.VarDecl) {
              ast$$44 = declAst
            }else {
              ast$$44 = JAM.new(TypeScript$$14.Block, [declAst, false])
            }
            needTerminator = true;
            break;
          case TypeScript$$14.TokenID.Static:
            if(this.currentClassDecl == null) {
              JAM.call(this.reportParseError, this, ["Statics may only be class members"])
            }
            mayNotBeExported();
            modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Public;
            var v27122 = this.scanner.scan();
            this.currentToken = v27122;
            if(this.currentToken.tokenId == TypeScript$$14.TokenID.Get) {
              this.prevIDTok = this.currentToken;
              var v27123 = this.scanner.scan();
              this.currentToken = v27123;
              if(TypeScript$$14.codeGenTarget < TypeScript$$14.CodeGenTarget.ES5) {
                JAM.call(this.reportParseError, this, ["Property accessors are only available when targeting ES5 or greater"])
              }
              var v16188 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
              if(!v16188) {
                v16188 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
              }
              if(v16188) {
                modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Getter;
                this.prevIDTok = null
              }
            }else {
              if(this.currentToken.tokenId == TypeScript$$14.TokenID.Set) {
                var v27124 = this.scanner.scan();
                this.currentToken = v27124;
                if(TypeScript$$14.codeGenTarget < TypeScript$$14.CodeGenTarget.ES5) {
                  JAM.call(this.reportParseError, this, ["Property accessors are only available when targeting ES5 or greater"])
                }
                var v16194 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
                if(!v16194) {
                  v16194 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
                }
                if(v16194) {
                  modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Setter
                }
              }
            }
            if(isAmbient$$3()) {
              modifiers$$12 = modifiers$$12 | TypeScript$$14.Modifiers.Ambient
            }
            var v8135 = errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.SColon;
            var v16198 = this.parsingDeclareFile;
            if(!v16198) {
              v16198 = (modifiers$$12 & TypeScript$$14.Modifiers.Ambient) != TypeScript$$14.Modifiers.None
            }
            fnOrVar = JAM.call(this.parsePropertyDeclaration, this, [v8135, modifiers$$12, v16198, true]);
            var staticsList = this.topStaticsList();
            var v16199 = staticsList;
            if(v16199) {
              v16199 = fnOrVar.nodeType == TypeScript$$14.NodeType.VarDecl
            }
            if(v16199) {
              JAM.call(staticsList.append, staticsList, [fnOrVar])
            }
            var v16200 = fnOrVar.nodeType == TypeScript$$14.NodeType.VarDecl;
            if(!v16200) {
              var v21033 = fnOrVar.nodeType == TypeScript$$14.NodeType.FuncDecl;
              if(v21033) {
                v21033 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [fnOrVar.fncFlags, TypeScript$$14.FncFlags.IsFatArrowFunction])
              }
              v16200 = v21033
            }
            if(v16200) {
              needTerminator = true
            }
            ast$$44 = fnOrVar;
            break;
          case TypeScript$$14.TokenID.For:
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["syntax error: for statement does not take modifiers"])
            }
            minChar$$27 = this.scanner.startPos;
            JAM.call(this.checkNextToken, this, [TypeScript$$14.TokenID.OpenParen, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.ExprStart | TypeScript$$14.ErrorRecoverySet.Var]);
            this.state = ParseState.ForInit;
            forInOk = true;
            switch(this.currentToken.tokenId) {
              case TypeScript$$14.TokenID.Var:
                temp$$15 = JAM.call(this.parseVariableDeclaration, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.SColon | TypeScript$$14.ErrorRecoverySet.In, TypeScript$$14.Modifiers.None, false, false]);
                break;
              case TypeScript$$14.TokenID.Semicolon:
                temp$$15 = null;
                this.state = ParseState.ForCondStart;
                break;
              default:
                temp$$15 = JAM.call(this.parseExpr, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.SColon | TypeScript$$14.ErrorRecoverySet.In, TypeScript$$14.OperatorPrecedence.None, false, TypeContext.NoTypes])
            }
            this.state = ParseState.ForInitAfterVar;
            if(this.currentToken.tokenId == TypeScript$$14.TokenID.In) {
              var v16214 = temp$$15 == null;
              if(!v16214) {
                v16214 = !forInOk
              }
              if(v16214) {
                JAM.call(this.reportParseError, this, ["malformed for statement"]);
                if(this.errorRecovery) {
                  JAM.call(this.skip, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.StmtStart]);
                  ast$$44 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Empty]);
                  ast$$44.flags = ast$$44.flags | TypeScript$$14.ASTFlags.Error
                }
              }else {
                var v27125 = this.scanner.scan();
                this.currentToken = v27125;
                var forInStmt = JAM.new(TypeScript$$14.ForInStatement, [temp$$15, JAM.call(this.parseExpr, this, [TypeScript$$14.ErrorRecoverySet.RParen | errorRecoverySet$$37, TypeScript$$14.OperatorPrecedence.Comma, false, TypeContext.NoTypes])]);
                forInStmt.limChar = this.scanner.pos;
                forInStmt.statement.minChar = minChar$$27;
                forInStmt.statement.limChar = this.scanner.pos;
                JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseParen, TypeScript$$14.ErrorRecoverySet.StmtStart | errorRecoverySet$$37]);
                JAM.call(this.pushStmt, this, [forInStmt, labelList$$1]);
                var v8161 = forInStmt;
                var v27126 = JAM.call(this.parseStatement, this, [errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7]);
                v8161.body = v27126;
                this.popStmt();
                forInStmt.minChar = minChar$$27;
                ast$$44 = forInStmt
              }
            }else {
              var forStmt = JAM.new(TypeScript$$14.ForStatement, [temp$$15]);
              forStmt.minChar = minChar$$27;
              JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.Semicolon, errorRecoverySet$$37]);
              if(this.currentToken.tokenId == TypeScript$$14.TokenID.Semicolon) {
                forStmt.cond = null
              }else {
                var v8165 = forStmt;
                var v27127 = JAM.call(this.parseExpr, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.SColon | TypeScript$$14.ErrorRecoverySet.RParen, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes]);
                v8165.cond = v27127;
                if(this.currentToken.tokenId != TypeScript$$14.TokenID.Semicolon) {
                  JAM.call(this.skip, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.StmtStart]);
                  ast$$44 = forStmt;
                  ast$$44.flags = ast$$44.flags | TypeScript$$14.ASTFlags.Error
                }
              }
              var v27128 = this.scanner.scan();
              this.currentToken = v27128;
              if(this.currentToken.tokenId == TypeScript$$14.TokenID.CloseParen) {
                forStmt.incr = null
              }else {
                var v8170 = forStmt;
                var v27129 = JAM.call(this.parseExpr, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.SColon | TypeScript$$14.ErrorRecoverySet.RParen, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes]);
                v8170.incr = v27129
              }
              JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseParen, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.LCurly]);
              JAM.call(this.pushStmt, this, [forStmt, labelList$$1]);
              var v8174 = forStmt;
              var v27130 = JAM.call(this.parseStatement, this, [errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7]);
              v8174.body = v27130;
              this.popStmt();
              forStmt.limChar = forStmt.body.limChar;
              ast$$44 = forStmt
            }
            break;
          case TypeScript$$14.TokenID.With:
            if(TypeScript$$14.codeGenTarget < TypeScript$$14.CodeGenTarget.ES5) {
              JAM.call(this.reportParseError, this, ["'with' statements are only available in ES5 codegen mode or better"])
            }
            if(this.strictMode) {
              JAM.call(this.reportParseError, this, ["'with' statements are not available in strict mode"])
            }
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["'with' statement does not take modifiers"])
            }
            minChar$$27 = this.scanner.startPos;
            JAM.call(this.checkNextToken, this, [TypeScript$$14.TokenID.OpenParen, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.ExprStart | TypeScript$$14.ErrorRecoverySet.Var]);
            var expr$$5 = JAM.call(this.parseExpr, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.Colon, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes]);
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseParen, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.LCurly]);
            var withStmt = JAM.new(TypeScript$$14.WithStatement, [expr$$5]);
            var v8189 = withStmt;
            var v27131 = JAM.call(this.parseStatement, this, [errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7]);
            v8189.body = v27131;
            withStmt.minChar = minChar$$27;
            withStmt.limChar = withStmt.body.limChar;
            ast$$44 = withStmt;
            break;
          case TypeScript$$14.TokenID.Switch:
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["'switch' statement does not take modifiers"])
            }
            JAM.call(this.checkNextToken, this, [TypeScript$$14.TokenID.OpenParen, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.ExprStart]);
            var switchStmt = JAM.new(TypeScript$$14.SwitchStatement, [JAM.call(this.parseExpr, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.RParen, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes])]);
            switchStmt.statement.minChar = minChar$$27;
            switchStmt.statement.limChar = this.scanner.pos;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseParen, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.LCurly]);
            var caseListMinChar = this.scanner.startPos;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.OpenBrace, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.SCase]);
            switchStmt.defaultCase = null;
            var v8203 = switchStmt;
            var v27132 = new TypeScript$$14.ASTList;
            v8203.caseList = v27132;
            var caseStmt = null;
            JAM.call(this.pushStmt, this, [switchStmt, labelList$$1]);
            for(;;) {
              var v16265 = this.currentToken.tokenId == TypeScript$$14.TokenID.Case;
              if(!v16265) {
                v16265 = this.currentToken.tokenId == TypeScript$$14.TokenID.Default
              }
              if(v16265) {
                var isDefault = this.currentToken.tokenId == TypeScript$$14.TokenID.Default;
                caseStmt = new TypeScript$$14.CaseStatement;
                caseStmt.minChar = this.scanner.startPos;
                var v27133 = this.scanner.scan();
                this.currentToken = v27133;
                if(isDefault) {
                  switchStmt.defaultCase = caseStmt
                }else {
                  var v8209 = caseStmt;
                  var v27134 = JAM.call(this.parseExpr, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.Colon, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes]);
                  v8209.expr = v27134
                }
                JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.Colon, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.StmtStart]);
                var v8212 = caseStmt;
                var v27135 = new TypeScript$$14.ASTList;
                v8212.body = v27135;
                JAM.call(this.parseStatementList, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.RCurly, caseStmt.body, false, true, allowedElements$$2, modifiers$$12]);
                caseStmt.limChar = caseStmt.body.limChar;
                var v8216 = switchStmt.caseList;
                JAM.call(v8216.append, v8216, [caseStmt])
              }else {
                break
              }
            }
            switchStmt.caseList.minChar = caseListMinChar;
            switchStmt.caseList.limChar = this.scanner.pos;
            switchStmt.limChar = switchStmt.caseList.limChar;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBrace, errorRecoverySet$$37]);
            this.popStmt();
            ast$$44 = switchStmt;
            break;
          case TypeScript$$14.TokenID.While:
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["'while' statement does not take modifiers"])
            }
            minChar$$27 = this.scanner.startPos;
            JAM.call(this.checkNextToken, this, [TypeScript$$14.TokenID.OpenParen, TypeScript$$14.ErrorRecoverySet.ExprStart | errorRecoverySet$$37]);
            var whileStmt = JAM.new(TypeScript$$14.WhileStatement, [JAM.call(this.parseExpr, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.RParen, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes])]);
            whileStmt.minChar = minChar$$27;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseParen, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.StmtStart]);
            JAM.call(this.pushStmt, this, [whileStmt, labelList$$1]);
            var v8230 = whileStmt;
            var v27136 = JAM.call(this.parseStatement, this, [errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7]);
            v8230.body = v27136;
            whileStmt.limChar = whileStmt.body.limChar;
            this.popStmt();
            ast$$44 = whileStmt;
            break;
          case TypeScript$$14.TokenID.Do:
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["'do' statement does not take modifiers"])
            }
            minChar$$27 = this.scanner.startPos;
            var v27137 = this.scanner.scan();
            this.currentToken = v27137;
            var doStmt = new TypeScript$$14.DoWhileStatement;
            doStmt.minChar = minChar$$27;
            JAM.call(this.pushStmt, this, [doStmt, labelList$$1]);
            var v8236 = doStmt;
            var v27138 = JAM.call(this.parseStatement, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.While, allowedElements$$2, parentModifiers$$7]);
            v8236.body = v27138;
            this.popStmt();
            var v8237 = doStmt;
            var v27139 = JAM.new(TypeScript$$14.Identifier, ["while"]);
            v8237.whileAST = v27139;
            doStmt.whileAST.minChar = this.scanner.startPos;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.While, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.LParen]);
            doStmt.whileAST.limChar = doStmt.whileAST.minChar + 5;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.OpenParen, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.ExprStart]);
            var v8244 = doStmt;
            var v27140 = JAM.call(this.parseExpr, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.RParen, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes]);
            v8244.cond = v27140;
            doStmt.limChar = this.scanner.pos;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseParen, errorRecoverySet$$37]);
            ast$$44 = doStmt;
            if(this.currentToken.tokenId == TypeScript$$14.TokenID.Semicolon) {
              var v27141 = this.scanner.scan();
              this.currentToken = v27141
            }
            break;
          case TypeScript$$14.TokenID.If:
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["if statement does not take modifiers"])
            }
            minChar$$27 = this.scanner.startPos;
            JAM.call(this.checkNextToken, this, [TypeScript$$14.TokenID.OpenParen, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.ExprStart]);
            var ifStmt = JAM.new(TypeScript$$14.IfStatement, [JAM.call(this.parseExpr, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.LParen, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes])]);
            ifStmt.minChar = minChar$$27;
            ifStmt.statement.minChar = minChar$$27;
            ifStmt.statement.limChar = this.scanner.pos;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseParen, errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.StmtStart]);
            JAM.call(this.pushStmt, this, [ifStmt, labelList$$1]);
            var v8259 = ifStmt;
            var v27142 = JAM.call(this.parseStatement, this, [TypeScript$$14.ErrorRecoverySet.Else | errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7]);
            v8259.thenBod = v27142;
            ifStmt.limChar = ifStmt.thenBod.limChar;
            if(this.currentToken.tokenId == TypeScript$$14.TokenID.Else) {
              var v27143 = this.scanner.scan();
              this.currentToken = v27143;
              var v8262 = ifStmt;
              var v27144 = JAM.call(this.parseStatement, this, [errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7]);
              v8262.elseBod = v27144;
              ifStmt.limChar = ifStmt.elseBod.limChar
            }
            this.popStmt();
            ast$$44 = ifStmt;
            break;
          case TypeScript$$14.TokenID.Try:
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["try statement does not take modifiers"])
            }
            minChar$$27 = this.scanner.startPos;
            ast$$44 = JAM.call(this.parseTryCatchFinally, this, [errorRecoverySet$$37, parentModifiers$$7, labelList$$1]);
            break;
          case TypeScript$$14.TokenID.OpenBrace:
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["block does not take modifiers"])
            }
            minChar$$27 = this.scanner.startPos;
            var v27145 = this.scanner.scan();
            this.currentToken = v27145;
            var block$$1 = JAM.new(TypeScript$$14.Block, [new TypeScript$$14.ASTList, true]);
            JAM.call(this.pushStmt, this, [block$$1, labelList$$1]);
            JAM.call(this.parseStatementList, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.RCurly, block$$1.statements, false, false, TypeScript$$14.AllowedElements.None, modifiers$$12]);
            this.popStmt();
            block$$1.statements.minChar = minChar$$27;
            block$$1.statements.limChar = this.scanner.pos;
            block$$1.minChar = block$$1.statements.minChar;
            block$$1.limChar = block$$1.statements.limChar;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBrace, errorRecoverySet$$37]);
            ast$$44 = block$$1;
            break;
          case TypeScript$$14.TokenID.Semicolon:
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["modifier can not appear here"])
            }
            ast$$44 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Empty]);
            var v27146 = this.scanner.scan();
            this.currentToken = v27146;
            break;
          case TypeScript$$14.TokenID.Break:
          ;
          case TypeScript$$14.TokenID.Continue:
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["modifiers can not appear before jump statement"])
            }
            var v8285 = TypeScript$$14.Jump;
            var v16322;
            if(this.currentToken.tokenId == TypeScript$$14.TokenID.Break) {
              v16322 = TypeScript$$14.NodeType.Break
            }else {
              v16322 = TypeScript$$14.NodeType.Continue
            }
            var jump$$1 = JAM.new(v8285, [v16322]);
            var v27147 = this.scanner.scan();
            this.currentToken = v27147;
            var v16323 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
            if(v16323) {
              v16323 = !this.scanner.lastTokenHadNewline()
            }
            if(v16323) {
              var v8288 = jump$$1;
              var v27148 = this.currentToken.getText();
              v8288.target = v27148;
              var v27149 = this.scanner.scan();
              this.currentToken = v27149
            }
            JAM.call(this.resolveJumpTarget, this, [jump$$1]);
            ast$$44 = jump$$1;
            needTerminator = true;
            break;
          case TypeScript$$14.TokenID.Return:
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["modifiers can not appear before return statement"])
            }
            if(!this.inFunction) {
              JAM.call(this.reportParseError, this, ["return statement outside of function body"])
            }
            minChar$$27 = this.scanner.startPos;
            var v27150 = this.scanner.scan();
            this.currentToken = v27150;
            var retStmt$$1 = new TypeScript$$14.ReturnStatement;
            retStmt$$1.minChar = minChar$$27;
            var v16327 = this.currentToken.tokenId != TypeScript$$14.TokenID.Semicolon;
            if(v16327) {
              var v21122 = this.currentToken.tokenId != TypeScript$$14.TokenID.CloseBrace;
              if(v21122) {
                v21122 = !this.scanner.lastTokenHadNewline()
              }
              v16327 = v21122
            }
            if(v16327) {
              var v8296 = retStmt$$1;
              var v27151 = JAM.call(this.parseExpr, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.SColon, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes]);
              v8296.returnExpression = v27151
            }
            needTerminator = true;
            var v8298 = retStmt$$1;
            var v27152 = this.scanner.lastTokenLimChar();
            v8298.limChar = v27152;
            ast$$44 = retStmt$$1;
            break;
          case TypeScript$$14.TokenID.Throw:
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["modifiers can not appear before a throw statement"])
            }
            minChar$$27 = this.scanner.startPos;
            var v27153 = this.scanner.scan();
            this.currentToken = v27153;
            var v16333 = this.currentToken.tokenId != TypeScript$$14.TokenID.Semicolon;
            if(v16333) {
              var v21128 = this.currentToken.tokenId != TypeScript$$14.TokenID.CloseBrace;
              if(v21128) {
                v21128 = !this.scanner.lastTokenHadNewline()
              }
              v16333 = v21128
            }
            if(v16333) {
              temp$$15 = JAM.call(this.parseExpr, this, [errorRecoverySet$$37 | TypeScript$$14.ErrorRecoverySet.SColon, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes])
            }else {
              JAM.call(this.reportParseError, this, ["throw with no target"]);
              temp$$15 = null
            }
            ast$$44 = JAM.new(TypeScript$$14.UnaryExpression, [TypeScript$$14.NodeType.Throw, temp$$15]);
            var v8308 = ast$$44;
            var v27154 = this.scanner.lastTokenLimChar();
            v8308.limChar = v27154;
            needTerminator = true;
            break;
          case TypeScript$$14.TokenID.Enum:
            var v27155 = this.scanner.scan();
            this.currentToken = v27155;
            ast$$44 = JAM.call(this.parseEnumDecl, this, [errorRecoverySet$$37, modifiers$$12]);
            ast$$44.minChar = minChar$$27;
            var v8310 = ast$$44;
            var v27156 = this.scanner.lastTokenLimChar();
            v8310.limChar = v27156;
            var v16339 = this.parsingDeclareFile;
            if(!v16339) {
              var v21130 = this.ambientModule;
              if(!v21130) {
                v21130 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$12, TypeScript$$14.Modifiers.Ambient])
              }
              v16339 = v21130
            }
            if(v16339) {
              ast$$44.modFlags = ast$$44.modFlags | TypeScript$$14.ModuleFlags.Ambient
            }
            var v16342 = this.parsingDeclareFile;
            if(!v16342) {
              var v21133 = this.ambientModule;
              if(!v21133) {
                v21133 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$12, TypeScript$$14.Modifiers.Exported])
              }
              v16342 = v21133
            }
            if(v16342) {
              ast$$44.modFlags = ast$$44.modFlags | TypeScript$$14.ModuleFlags.Exported
            }
            break;
          case TypeScript$$14.TokenID.Debugger:
            mayNotBeExported();
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["modifiers can not appear before debugger statement"])
            }
            minChar$$27 = this.scanner.startPos;
            var v27157 = this.scanner.scan();
            this.currentToken = v27157;
            var debuggerStmt = new TypeScript$$14.DebuggerStatement;
            debuggerStmt.minChar = minChar$$27;
            needTerminator = true;
            var v8317 = debuggerStmt;
            var v27158 = this.scanner.lastTokenLimChar();
            v8317.limChar = v27158;
            ast$$44 = debuggerStmt;
            break;
          default:
            if(modifiers$$12 != TypeScript$$14.Modifiers.None) {
              JAM.call(this.reportParseError, this, ["modifiers can not appear before an expression statement or label"])
            }
            minChar$$27 = this.scanner.startPos;
            var svPos = this.scanner.pos;
            temp$$15 = JAM.call(this.parseExpr, this, [TypeScript$$14.ErrorRecoverySet.Colon | TypeScript$$14.ErrorRecoverySet.StmtStart | errorRecoverySet$$37, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes]);
            if(this.scanner.pos == svPos) {
              var v27159 = this.scanner.scan();
              this.currentToken = v27159;
              ast$$44 = temp$$15
            }else {
              var v16351 = this.currentToken.tokenId == TypeScript$$14.TokenID.Colon;
              if(v16351) {
                var v21143 = !this.scanner.lastTokenHadNewline();
                if(v21143) {
                  var v23890 = temp$$15;
                  if(v23890) {
                    v23890 = temp$$15.nodeType == TypeScript$$14.NodeType.Name
                  }
                  v21143 = v23890
                }
                v16351 = v21143
              }
              if(v16351) {
                if(labelList$$1 == null) {
                  labelList$$1 = new TypeScript$$14.ASTList
                }
                JAM.call(labelList$$1.append, labelList$$1, [JAM.new(TypeScript$$14.Label, [temp$$15])]);
                var v27160 = this.scanner.scan();
                this.currentToken = v27160
              }else {
                ast$$44 = temp$$15;
                needTerminator = true
              }
            }
        }
        if(ast$$44) {
          break
        }
      }
      if(needTerminator) {
        switch(this.currentToken.tokenId) {
          case TypeScript$$14.TokenID.Semicolon:
            var v27161 = this.scanner.scan();
            this.currentToken = v27161;
            ast$$44.flags = ast$$44.flags | TypeScript$$14.ASTFlags.ExplicitSemicolon;
            break;
          case TypeScript$$14.TokenID.EndOfFile:
            ast$$44.limChar = this.scanner.pos;
          case TypeScript$$14.TokenID.CloseBrace:
            ast$$44.flags = ast$$44.flags | TypeScript$$14.ASTFlags.AutomaticSemicolon;
            if(this.style_requireSemi) {
              JAM.call(this.reportParseStyleError, this, ["no automatic semicolon"])
            }
            break;
          default:
            if(!this.scanner.lastTokenHadNewline()) {
              JAM.call(this.reportParseError, this, ["Expected ';'"])
            }else {
              ast$$44.flags = ast$$44.flags | TypeScript$$14.ASTFlags.AutomaticSemicolon;
              if(this.style_requireSemi) {
                JAM.call(this.reportParseStyleError, this, ["no automatic semicolon"])
              }
            }
        }
      }
      if(labelList$$1) {
        ast$$44 = JAM.new(TypeScript$$14.LabeledStatement, [labelList$$1, ast$$44])
      }
      ast$$44.minChar = minChar$$27;
      var v8339 = ast$$44;
      var v27162 = JAM.call(TypeScript$$14.max, TypeScript$$14, [ast$$44.limChar, this.scanner.lastTokenLimChar()]);
      v8339.limChar = v27162;
      if(preComments$$8) {
        ast$$44.preComments = preComments$$8
      }
      var v16363 = this.ambientModule;
      if(v16363) {
        v16363 = !JAM.call(this.okAmbientModuleMember, this, [ast$$44])
      }
      if(v16363) {
        JAM.call(this.reportParseError, this, ["statement not permitted within ambient module"])
      }
      ast$$44.flags = ast$$44.flags | TypeScript$$14.ASTFlags.IsStatement;
      return ast$$44
    }
    function v584(errorRecoverySet$$36, parentModifiers$$6, labelList) {
      var tryPart = JAM.new(TypeScript$$14.Try, [null]);
      var tryMinChar = this.scanner.startPos;
      JAM.call(this.pushStmt, this, [tryPart, labelList]);
      JAM.call(this.parseTry, this, [tryPart, errorRecoverySet$$36 | TypeScript$$14.ErrorRecoverySet.Catch, parentModifiers$$6]);
      this.popStmt();
      var tc$$1 = null;
      var tf = null;
      if(this.currentToken.tokenId == TypeScript$$14.TokenID.Catch) {
        var catchPart = JAM.call(this.parseCatch, this, [errorRecoverySet$$36 | TypeScript$$14.ErrorRecoverySet.Catch, parentModifiers$$6]);
        tc$$1 = JAM.new(TypeScript$$14.TryCatch, [tryPart, catchPart]);
        tc$$1.minChar = tryPart.minChar;
        tc$$1.limChar = catchPart.limChar
      }
      if(this.currentToken.tokenId != TypeScript$$14.TokenID.Finally) {
        if(tc$$1 == null) {
          JAM.call(this.reportParseError, this, ["try with neither catch nor finally"]);
          if(this.errorRecovery) {
            var etf = JAM.new(TypeScript$$14.TryFinally, [tryPart, JAM.new(TypeScript$$14.Finally, [JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Empty])])]);
            etf.flags = etf.flags | TypeScript$$14.ASTFlags.Error;
            etf.minChar = this.scanner.startPos;
            etf.limChar = this.scanner.pos;
            return etf
          }
          return JAM.new(TypeScript$$14.TryFinally, [tryPart, JAM.new(TypeScript$$14.Finally, [JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Empty])])])
        }else {
          return tc$$1
        }
      }else {
        if(tc$$1) {
          tryPart = tc$$1
        }
        var finallyPart = JAM.call(this.parseFinally, this, [errorRecoverySet$$36, parentModifiers$$6]);
        tf = JAM.new(TypeScript$$14.TryFinally, [tryPart, finallyPart]);
        tf.minChar = tryMinChar;
        tf.limChar = finallyPart.limChar;
        return tf
      }
      return
    }
    function v583(errorRecoverySet$$35, parentModifiers$$5) {
      var finMinChar = this.scanner.startPos;
      var preComments$$7 = this.parseComments();
      var v27163 = this.scanner.scan();
      this.currentToken = v27163;
      if(this.currentToken.tokenId != TypeScript$$14.TokenID.OpenBrace) {
        JAM.call(this.reportParseError, this, ["Expected '{' to start body of finally statement"]);
        if(this.errorRecovery) {
          JAM.call(this.skip, this, [errorRecoverySet$$35]);
          var efin = JAM.new(TypeScript$$14.Finally, [JAM.new(TypeScript$$14.Statement, [TypeScript$$14.NodeType.Empty])]);
          efin.flags = efin.flags | TypeScript$$14.ASTFlags.Error;
          efin.minChar = this.scanner.startPos;
          efin.limChar = this.scanner.pos;
          return efin
        }
      }
      var finBody = JAM.call(this.parseStatement, this, [errorRecoverySet$$35, TypeScript$$14.AllowedElements.None, parentModifiers$$5]);
      var fin = JAM.new(TypeScript$$14.Finally, [finBody]);
      fin.minChar = finMinChar;
      fin.limChar = fin.body.limChar;
      fin.preComments = preComments$$7;
      var v8368 = fin;
      var v27164 = this.parseComments();
      v8368.postComments = v27164;
      return fin
    }
    function v582(errorRecoverySet$$34, parentModifiers$$4) {
      var catchMinChar = this.scanner.startPos;
      var preComments$$6 = this.parseComments();
      var v27165 = this.scanner.scan();
      this.currentToken = v27165;
      JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.OpenParen, errorRecoverySet$$34 | TypeScript$$14.ErrorRecoverySet.ExprStart]);
      var v16387 = this.currentToken.tokenId != TypeScript$$14.TokenID.Identifier;
      if(!v16387) {
        v16387 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
      }
      if(v16387) {
        JAM.call(this.reportParseError, this, ["Expected identifier in catch header"]);
        if(this.errorRecovery) {
          JAM.call(this.skip, this, [errorRecoverySet$$34]);
          var ecatch = JAM.new(TypeScript$$14.Catch, [JAM.new(TypeScript$$14.VarDecl, [new TypeScript$$14.MissingIdentifier, this.nestingLevel]), JAM.new(TypeScript$$14.Statement, [TypeScript$$14.NodeType.Empty])]);
          ecatch.statement.minChar = catchMinChar;
          ecatch.statement.limChar = this.scanner.pos;
          ecatch.minChar = this.scanner.startPos;
          ecatch.limChar = this.scanner.pos;
          ecatch.flags = ecatch.flags | TypeScript$$14.ASTFlags.Error;
          return ecatch
        }
      }
      var v8382 = TypeScript$$14.VarDecl;
      var v16396 = TypeScript$$14.Identifier;
      var param$$5 = JAM.new(v8382, [JAM.call(v16396.fromToken, v16396, [this.currentToken]), this.nestingLevel]);
      param$$5.id.minChar = this.scanner.startPos;
      param$$5.id.limChar = this.scanner.pos;
      param$$5.minChar = param$$5.id.minChar;
      param$$5.limChar = param$$5.id.limChar;
      var v27166 = this.scanner.scan();
      this.currentToken = v27166;
      var statementPos = this.scanner.pos;
      JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseParen, errorRecoverySet$$34 | TypeScript$$14.ErrorRecoverySet.StmtStart]);
      if(this.currentToken.tokenId != TypeScript$$14.TokenID.OpenBrace) {
        JAM.call(this.reportParseError, this, ["Expected '{' to start catch body"]);
        if(this.errorRecovery) {
          JAM.call(this.skip, this, [errorRecoverySet$$34]);
          ecatch = JAM.new(TypeScript$$14.Catch, [JAM.new(TypeScript$$14.VarDecl, [new TypeScript$$14.MissingIdentifier, this.nestingLevel]), JAM.new(TypeScript$$14.Statement, [TypeScript$$14.NodeType.Empty])]);
          ecatch.statement.minChar = catchMinChar;
          ecatch.statement.limChar = statementPos;
          ecatch.minChar = this.scanner.startPos;
          ecatch.limChar = this.scanner.pos;
          ecatch.flags = ecatch.flags | TypeScript$$14.ASTFlags.Error;
          return ecatch
        }
      }
      var catchStmt = JAM.call(this.parseStatement, this, [errorRecoverySet$$34, TypeScript$$14.AllowedElements.None, parentModifiers$$4]);
      var catchNode$$1 = JAM.new(TypeScript$$14.Catch, [param$$5, catchStmt]);
      catchNode$$1.statement.minChar = catchMinChar;
      catchNode$$1.statement.limChar = statementPos;
      catchNode$$1.minChar = catchMinChar;
      catchNode$$1.limChar = catchStmt.limChar;
      catchNode$$1.preComments = preComments$$6;
      var v8406 = catchNode$$1;
      var v27167 = this.parseComments();
      v8406.postComments = v27167;
      return catchNode$$1
    }
    function v581(tryNode$$2, errorRecoverySet$$33, parentModifiers$$3) {
      var minChar$$26 = this.scanner.startPos;
      var preComments$$5 = this.parseComments();
      var v27168 = this.scanner.scan();
      this.currentToken = v27168;
      if(this.currentToken.tokenId != TypeScript$$14.TokenID.OpenBrace) {
        JAM.call(this.reportParseError, this, ["Expected '{'"]);
        if(this.errorRecovery) {
          var etryNode = tryNode$$2;
          etryNode.minChar = minChar$$26;
          var v8409 = etryNode;
          var v27169 = this.scanner.lastTokenLimChar();
          v8409.limChar = v27169;
          etryNode.flags = etryNode.flags | TypeScript$$14.ASTFlags.Error;
          return etryNode
        }
      }
      var v8412 = tryNode$$2;
      var v27170 = JAM.call(this.parseStatement, this, [errorRecoverySet$$33, TypeScript$$14.AllowedElements.None, parentModifiers$$3]);
      v8412.body = v27170;
      tryNode$$2.minChar = minChar$$26;
      tryNode$$2.limChar = tryNode$$2.body.limChar;
      tryNode$$2.preComments = preComments$$5;
      var v8414 = tryNode$$2;
      var v27171 = this.parseComments();
      v8414.postComments = v27171;
      return tryNode$$2
    }
    function v580(errorRecoverySet$$32, ast$$43, allowCall$$1, inNew$$1, typeContext$$2, lhsMinChar, lhsLimChar) {
      var count$$7 = 0;
      if(!ast$$43) {
        ast$$43 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.EmptyExpr]);
        ast$$43.isParenthesized = true
      }
      ast$$43.minChar = lhsMinChar;
      ast$$43.limChar = lhsLimChar;
      for(;;) {
        switch(this.currentToken.tokenId) {
          case TypeScript$$14.TokenID.OpenParen:
            if(inNew$$1) {
              var callExpr = ast$$43;
              var v8418 = callExpr;
              var v27172 = JAM.call(this.parseArgList, this, [errorRecoverySet$$32]);
              v8418.arguments = v27172;
              inNew$$1 = false
            }else {
              if(!allowCall$$1) {
                return ast$$43
              }
              ast$$43 = JAM.new(TypeScript$$14.CallExpression, [TypeScript$$14.NodeType.Call, ast$$43, JAM.call(this.parseArgList, this, [errorRecoverySet$$32])]);
              ast$$43.minChar = lhsMinChar
            }
            ast$$43.limChar = this.scanner.pos;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseParen, errorRecoverySet$$32]);
            break;
          case TypeScript$$14.TokenID.OpenBracket:
            var v27173 = this.scanner.scan();
            this.currentToken = v27173;
            if(this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBracket) {
              if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [typeContext$$2, TypeContext.ArraySuffix])) {
                var v27174 = this.scanner.scan();
                this.currentToken = v27174;
                if(ast$$43.nodeType == TypeScript$$14.NodeType.TypeRef) {
                  var typeRef$$1 = ast$$43;
                  typeRef$$1.arrayCount = typeRef$$1.arrayCount + 1
                }else {
                  ast$$43 = JAM.new(TypeScript$$14.BinaryExpression, [TypeScript$$14.NodeType.Index, ast$$43, null])
                }
                ast$$43.limChar = this.scanner.pos;
                break
              }
            }
            ast$$43 = JAM.new(TypeScript$$14.BinaryExpression, [TypeScript$$14.NodeType.Index, ast$$43, JAM.call(this.parseExpr, this, [errorRecoverySet$$32 | TypeScript$$14.ErrorRecoverySet.RBrack, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes])]);
            ast$$43.minChar = lhsMinChar;
            ast$$43.limChar = this.scanner.pos;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBracket, errorRecoverySet$$32]);
            break;
          case TypeScript$$14.TokenID.Dot:
            var name$$52 = null;
            var curpos$$2 = this.scanner.pos;
            var v27175 = this.scanner.scan();
            this.currentToken = v27175;
            if(this.currentToken === undefined) {
              var v27176 = this.scanner.scan();
              this.currentToken = v27176;
              continue
            }
            var v16435 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
            if(!v16435) {
              var v23898 = !this.errorRecovery;
              if(!v23898) {
                v23898 = !this.scanner.lastTokenHadNewline()
              }
              var v21192 = v23898;
              if(v21192) {
                v21192 = JAM.call(TypeScript$$14.convertTokToIDName, TypeScript$$14, [this.currentToken])
              }
              v16435 = v21192
            }
            if(v16435) {
              ast$$43.flags = ast$$43.flags | TypeScript$$14.ASTFlags.DotLHS;
              name$$52 = JAM.call(this.createRef, this, [this.currentToken.getText(), this.currentToken.hasEscapeSequence, this.scanner.startPos]);
              name$$52.limChar = this.scanner.pos;
              var v27177 = this.scanner.scan();
              this.currentToken = v27177
            }else {
              JAM.call(this.reportParseError, this, ["Expected identifier following dot"]);
              if(this.errorRecovery) {
                JAM.call(this.skip, this, [errorRecoverySet$$32]);
                ast$$43.flags = ast$$43.flags | TypeScript$$14.ASTFlags.Error | TypeScript$$14.ASTFlags.DotLHS;
                return ast$$43
              }else {
                name$$52 = new TypeScript$$14.MissingIdentifier
              }
            }
            ast$$43 = JAM.new(TypeScript$$14.BinaryExpression, [TypeScript$$14.NodeType.Dot, ast$$43, name$$52]);
            ast$$43.minChar = lhsMinChar;
            var v8452 = ast$$43;
            var v27178 = this.scanner.lastTokenLimChar();
            v8452.limChar = v27178;
            break;
          case TypeScript$$14.TokenID.EqualsGreaterThan:
            ast$$43 = JAM.call(this.parseFncDecl, this, [errorRecoverySet$$32, false, false, false, null, false, false, false, TypeScript$$14.Modifiers.None, {preProcessedLambdaArgs:ast$$43}, false]);
            ast$$43.fncFlags = ast$$43.fncFlags | TypeScript$$14.FncFlags.IsFunctionExpression;
            ast$$43.minChar = lhsMinChar;
            var v8455 = ast$$43;
            var v27179 = this.scanner.lastTokenLimChar();
            v8455.limChar = v27179;
            break;
          default:
            return ast$$43
        }
      }
      return
    }
    function v579(errorRecoverySet$$31, minPrecedence, allowIn$$1, typeContext$$1, possiblyInLambda) {
      if(typeof possiblyInLambda === "undefined") {
        possiblyInLambda = false
      }
      var ast$$42 = null;
      var tokenInfo$$1 = JAM.call(TypeScript$$14.lookupToken, TypeScript$$14, [this.currentToken.tokenId]);
      var canAssign = true;
      var idHint$$1 = null;
      var minChar$$25 = this.scanner.startPos;
      var preComments$$4 = this.parseComments();
      var exprIsAnonLambda = false;
      var v16451 = tokenInfo$$1 != undefined;
      if(v16451) {
        v16451 = tokenInfo$$1.unopNodeType != TypeScript$$14.NodeType.None
      }
      if(v16451) {
        canAssign = false;
        var v27180 = this.scanner.scan();
        this.currentToken = v27180;
        var tempExpr = JAM.call(this.parseExpr, this, [TypeScript$$14.ErrorRecoverySet.BinOp | errorRecoverySet$$31, tokenInfo$$1.unopPrecedence, allowIn$$1, TypeContext.NoTypes]);
        var v16453 = tokenInfo$$1.unopNodeType == TypeScript$$14.NodeType.Pos;
        if(v16453) {
          v16453 = tempExpr.nodeType == TypeScript$$14.NodeType.NumberLit
        }
        if(v16453) {
          ast$$42 = tempExpr
        }else {
          var v16454 = tokenInfo$$1.unopNodeType == TypeScript$$14.NodeType.Neg;
          if(v16454) {
            v16454 = tempExpr.nodeType == TypeScript$$14.NodeType.NumberLit
          }
          if(v16454) {
            var numLit$$1 = tempExpr;
            numLit$$1.value = -numLit$$1.value;
            if(numLit$$1.value == 0) {
              numLit$$1.isNegativeZero = true
            }
            ast$$42 = tempExpr
          }else {
            ast$$42 = JAM.new(TypeScript$$14.UnaryExpression, [tokenInfo$$1.unopNodeType, tempExpr]);
            ast$$42.limChar = tempExpr.limChar
          }
        }
        ast$$42.minChar = minChar$$25
      }else {
        ast$$42 = JAM.call(this.parseTerm, this, [TypeScript$$14.ErrorRecoverySet.BinOp | TypeScript$$14.ErrorRecoverySet.AddOp | errorRecoverySet$$31, true, typeContext$$1, false]);
        var id$$13;
        var temp$$14;
        if(ast$$42.nodeType == TypeScript$$14.NodeType.Name) {
          id$$13 = ast$$42;
          idHint$$1 = id$$13.actualText
        }else {
          if(ast$$42.nodeType == TypeScript$$14.NodeType.Dot) {
            var subsumedExpr = false;
            var v16461 = this.inferPropertiesFromThisAssignment;
            if(v16461) {
              var v23909 = this.currentToken.tokenId == TypeScript$$14.TokenID.Colon;
              if(!v23909) {
                v23909 = this.currentToken.tokenId == TypeScript$$14.TokenID.Equals
              }
              var v21213 = v23909;
              if(v21213) {
                var v23910 = this.parsingClassConstructorDefinition;
                if(v23910) {
                  var v25249 = this.nestingLevel == this.currentClassDefinition.constructorNestingLevel;
                  if(v25249) {
                    v25249 = ast$$42.operand1.nodeType == TypeScript$$14.NodeType.This
                  }
                  v23910 = v25249
                }
                v21213 = v23910
              }
              v16461 = v21213
            }
            if(v16461) {
              if(ast$$42.operand2.nodeType == TypeScript$$14.NodeType.Name) {
                var op2ID = ast$$42.operand2;
                var v21216 = this.currentClassDefinition.knownMemberNames;
                var v21217 = op2ID.actualText;
                introspect(JAM.policy.p1) {
                  var v16464 = v21216[v21217]
                }
                if(!v16464) {
                  ast$$42 = JAM.call(this.parseClassMemberVariableDeclaration, this, [op2ID, ast$$42.minChar, true, errorRecoverySet$$31, TypeScript$$14.Modifiers.Public]);
                  subsumedExpr = true
                }
              }
            }
            if(!subsumedExpr) {
              temp$$14 = ast$$42;
              var v8476 = temp$$14.nodeType == TypeScript$$14.NodeType.Dot;
              for(;v8476;) {
                var binExpr$$1 = temp$$14;
                temp$$14 = binExpr$$1.operand2;
                v8476 = temp$$14.nodeType == TypeScript$$14.NodeType.Dot
              }
              if(temp$$14.nodeType == TypeScript$$14.NodeType.Name) {
                id$$13 = temp$$14;
                idHint$$1 = id$$13.actualText
              }
            }
          }
        }
        var v16472 = !this.scanner.lastTokenHadNewline();
        if(v16472) {
          var v21222 = this.currentToken.tokenId == TypeScript$$14.TokenID.PlusPlus;
          if(!v21222) {
            v21222 = this.currentToken.tokenId == TypeScript$$14.TokenID.MinusMinus
          }
          v16472 = v21222
        }
        if(v16472) {
          canAssign = false;
          var operand$$2 = ast$$42;
          var v8481 = TypeScript$$14.UnaryExpression;
          var v16473;
          if(this.currentToken.tokenId == TypeScript$$14.TokenID.PlusPlus) {
            v16473 = TypeScript$$14.NodeType.IncPost
          }else {
            v16473 = TypeScript$$14.NodeType.DecPost
          }
          ast$$42 = JAM.new(v8481, [v16473, operand$$2]);
          ast$$42.limChar = this.scanner.pos;
          ast$$42.minChar = operand$$2.minChar;
          var v27181 = this.scanner.scan();
          this.currentToken = v27181
        }
      }
      for(;;) {
        tokenInfo$$1 = JAM.call(TypeScript$$14.lookupToken, TypeScript$$14, [this.currentToken.tokenId]);
        var v16475 = tokenInfo$$1 == undefined;
        if(!v16475) {
          v16475 = tokenInfo$$1.binopNodeType == TypeScript$$14.NodeType.None
        }
        if(v16475) {
          break
        }
        var v16476 = !allowIn$$1;
        if(v16476) {
          v16476 = tokenInfo$$1.binopNodeType == TypeScript$$14.NodeType.In
        }
        if(v16476) {
          break
        }
        if(tokenInfo$$1.binopPrecedence == TypeScript$$14.OperatorPrecedence.Assignment) {
          if(tokenInfo$$1.binopPrecedence < minPrecedence) {
            break
          }
          if(!canAssign) {
            JAM.call(this.reportParseError, this, ["illegal assignment"])
          }
        }else {
          if(tokenInfo$$1.binopPrecedence <= minPrecedence) {
            break
          }
        }
        var v16481 = possiblyInLambda;
        if(v16481) {
          var v21232 = this.currentToken.tokenId == TypeScript$$14.TokenID.Comma;
          if(v21232) {
            v21232 = this.scanner.getLookAheadToken().tokenId == TypeScript$$14.TokenID.DotDotDot
          }
          v16481 = v21232
        }
        if(v16481) {
          exprIsAnonLambda = true;
          canAssign = false;
          ast$$42 = JAM.call(this.parseLambdaExpr, this, [errorRecoverySet$$31, ast$$42, false, true]);
          break
        }
        var v27182 = this.scanner.scan();
        this.currentToken = v27182;
        canAssign = false;
        if(tokenInfo$$1.binopNodeType == TypeScript$$14.NodeType.ConditionalExpression) {
          var v16484 = possiblyInLambda;
          if(v16484) {
            var v21234 = this.currentToken.tokenId == TypeScript$$14.TokenID.Equals;
            if(!v21234) {
              var v23928 = this.currentToken.tokenId == TypeScript$$14.TokenID.Colon;
              if(!v23928) {
                var v25264 = this.currentToken.tokenId == TypeScript$$14.TokenID.CloseParen;
                if(!v25264) {
                  v25264 = this.currentToken.tokenId == TypeScript$$14.TokenID.Comma
                }
                v23928 = v25264
              }
              v21234 = v23928
            }
            v16484 = v21234
          }
          if(v16484) {
            exprIsAnonLambda = true;
            canAssign = true
          }else {
            this.prevExpr = ast$$42;
            var whenTrue = JAM.call(this.parseExpr, this, [errorRecoverySet$$31 | TypeScript$$14.ErrorRecoverySet.Colon, TypeScript$$14.OperatorPrecedence.Assignment, allowIn$$1, TypeContext.NoTypes]);
            this.prevExpr = null;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.Colon, errorRecoverySet$$31 | TypeScript$$14.ErrorRecoverySet.ExprStart]);
            var whenFalse = JAM.call(this.parseExpr, this, [errorRecoverySet$$31 | TypeScript$$14.ErrorRecoverySet.BinOp, TypeScript$$14.OperatorPrecedence.Assignment, allowIn$$1, TypeContext.NoTypes]);
            ast$$42 = JAM.new(TypeScript$$14.ConditionalExpression, [ast$$42, whenTrue, whenFalse])
          }
        }else {
          var tc = TypeContext.NoTypes;
          var binExpr2;
          binExpr2 = JAM.new(TypeScript$$14.BinaryExpression, [tokenInfo$$1.binopNodeType, ast$$42, JAM.call(this.parseExpr, this, [errorRecoverySet$$31 | TypeScript$$14.ErrorRecoverySet.BinOp, tokenInfo$$1.binopPrecedence, allowIn$$1, TypeContext.NoTypes, possiblyInLambda])]);
          if(binExpr2.operand2.nodeType == TypeScript$$14.NodeType.FuncDecl) {
            var funcDecl$$12 = binExpr2.operand2;
            funcDecl$$12.hint = idHint$$1
          }
          binExpr2.minChar = ast$$42.minChar;
          var v8510 = binExpr2;
          var v27183 = this.scanner.lastTokenLimChar();
          v8510.limChar = v27183;
          idHint$$1 = null;
          ast$$42 = binExpr2
        }
      }
      if(canAssign) {
        ast$$42.flags = ast$$42.flags | TypeScript$$14.ASTFlags.Writeable
      }
      if(!exprIsAnonLambda) {
        ast$$42.minChar = minChar$$25;
        var v8512 = ast$$42;
        var v27184 = JAM.call(TypeScript$$14.max, TypeScript$$14, [ast$$42.limChar, this.scanner.lastTokenLimChar()]);
        v8512.limChar = v27184;
        ast$$42.preComments = preComments$$4;
        var v8513 = ast$$42;
        var v27185 = JAM.call(this.parseCommentsForLine, this, [this.scanner.line]);
        v8513.postComments = v27185
      }
      return ast$$42
    }
    function v578(errorRecoverySet$$30, lambdaArgs, skipNextRParen, expectClosingRParen$$2) {
      var ast$$41 = JAM.call(this.parseFncDecl, this, [errorRecoverySet$$30, false, false, false, null, false, false, false, TypeScript$$14.Modifiers.None, {preProcessedLambdaArgs:lambdaArgs}, expectClosingRParen$$2]);
      ast$$41.fncFlags = ast$$41.fncFlags | TypeScript$$14.FncFlags.IsFunctionExpression;
      ast$$41.fncFlags = ast$$41.fncFlags | TypeScript$$14.FncFlags.IsFatArrowFunction;
      if(!skipNextRParen) {
        ast$$41.flags = ast$$41.flags | TypeScript$$14.ASTFlags.SkipNextRParen
      }
      var v8518 = ast$$41;
      var v27186 = this.scanner.lastTokenLimChar();
      v8518.limChar = v27186;
      return ast$$41
    }
    function v577(errorRecoverySet$$29, allowCall, typeContext, inCast) {
      var ast$$40 = null;
      var sawId = false;
      var inNew = false;
      var minChar$$24 = this.scanner.startPos;
      var limChar$$7 = this.scanner.pos;
      var parseAsLambda = false;
      var expectlambdaRParen = false;
      switch(this.currentToken.tokenId) {
        case TypeScript$$14.TokenID.Number:
        ;
        case TypeScript$$14.TokenID.Bool:
        ;
        case TypeScript$$14.TokenID.Any:
        ;
        case TypeScript$$14.TokenID.String:
          var v8521 = TypeScript$$14.Identifier;
          var v21247 = TypeScript$$14.tokenTable;
          var v21248 = this.currentToken.tokenId;
          introspect(JAM.policy.p1) {
            var v16511 = v21247[v21248]
          }
          var tid = JAM.new(v8521, [v16511.text]);
          if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [typeContext, TypeContext.Primitive])) {
            ast$$40 = JAM.new(TypeScript$$14.TypeReference, [tid, 0]);
            sawId = true
          }else {
            ast$$40 = tid;
            sawId = true
          }
          ast$$40.minChar = minChar$$24;
          var v27187 = this.scanner.scan();
          this.currentToken = v27187;
          limChar$$7 = this.scanner.lastTokenLimChar();
          break;
        case TypeScript$$14.TokenID.This:
          ast$$40 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.This]);
          ast$$40.minChar = minChar$$24;
          var v27188 = this.scanner.scan();
          this.currentToken = v27188;
          limChar$$7 = this.scanner.lastTokenLimChar();
          break;
        case TypeScript$$14.TokenID.Super:
          ast$$40 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Super]);
          ast$$40.minChar = minChar$$24;
          var v27189 = this.scanner.scan();
          this.currentToken = v27189;
          limChar$$7 = this.scanner.lastTokenLimChar();
          break;
        case TypeScript$$14.TokenID.True:
          ast$$40 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.True]);
          var v27190 = this.scanner.scan();
          this.currentToken = v27190;
          ast$$40.minChar = minChar$$24;
          break;
        case TypeScript$$14.TokenID.False:
          ast$$40 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.False]);
          var v27191 = this.scanner.scan();
          this.currentToken = v27191;
          ast$$40.minChar = minChar$$24;
          break;
        case TypeScript$$14.TokenID.Null:
          ast$$40 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Null]);
          var v27192 = this.scanner.scan();
          this.currentToken = v27192;
          ast$$40.minChar = minChar$$24;
          break;
        case TypeScript$$14.TokenID.New:
          minChar$$24 = this.scanner.pos;
          var v27193 = this.scanner.scan();
          this.currentToken = v27193;
          var target$$41 = JAM.call(this.parseTerm, this, [errorRecoverySet$$29, false, TypeContext.AllSimpleTypes, inCast]);
          var v16518 = target$$41.nodeType == TypeScript$$14.NodeType.Error;
          if(!v16518) {
            var v21251 = target$$41.nodeType == TypeScript$$14.NodeType.Index;
            if(v21251) {
              v21251 = target$$41.operand1.nodeType == TypeScript$$14.NodeType.TypeRef
            }
            v16518 = v21251
          }
          if(v16518) {
            JAM.call(this.reportParseError, this, ["Cannot invoke 'new' on this expression"])
          }else {
            ast$$40 = JAM.new(TypeScript$$14.CallExpression, [TypeScript$$14.NodeType.New, target$$41, null]);
            ast$$40.minChar = minChar$$24;
            limChar$$7 = this.scanner.lastTokenLimChar();
            inNew = true
          }
          break;
        case TypeScript$$14.TokenID.Function:
          minChar$$24 = this.scanner.pos;
          ast$$40 = JAM.call(this.parseFncDecl, this, [errorRecoverySet$$29, false, false, false, null, false, false, false, TypeScript$$14.Modifiers.None, null, true]);
          ast$$40.fncFlags = ast$$40.fncFlags | TypeScript$$14.FncFlags.IsFunctionExpression;
          ast$$40.minChar = minChar$$24;
          limChar$$7 = this.scanner.lastTokenLimChar();
          ast$$40.limChar = limChar$$7
      }
      if(ast$$40 == null) {
        var v16523 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
        if(!v16523) {
          v16523 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
        }
        if(v16523) {
          var idText$$1 = this.currentToken.getText();
          ast$$40 = JAM.call(this.createRef, this, [idText$$1, this.currentToken.hasEscapeSequence, minChar$$24]);
          sawId = true;
          ast$$40.minChar = minChar$$24;
          var v27194 = this.scanner.scan();
          this.currentToken = v27194;
          if(this.currentToken.tokenId == TypeScript$$14.TokenID.Question) {
            ast$$40.flags = ast$$40.flags | TypeScript$$14.ASTFlags.PossibleOptionalParameter
          }
          limChar$$7 = this.scanner.lastTokenLimChar()
        }
      }
      if(inCast) {
        JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.GreaterThan, errorRecoverySet$$29])
      }
      if(ast$$40 == null) {
        switch(this.currentToken.tokenId) {
          case TypeScript$$14.TokenID.OpenParen:
            minChar$$24 = this.scanner.pos;
            var prevTokId = this.scanner.previousToken().tokenId;
            var v27195 = this.scanner.scan();
            this.currentToken = v27195;
            var v8566 = prevTokId == TypeScript$$14.TokenID.OpenParen;
            if(!v8566) {
              var v16533 = prevTokId == TypeScript$$14.TokenID.Comma;
              if(!v16533) {
                var v21264 = prevTokId == TypeScript$$14.TokenID.EqualsEquals;
                if(!v21264) {
                  v21264 = prevTokId == TypeScript$$14.TokenID.Colon
                }
                v16533 = v21264
              }
              v8566 = v16533
            }
            var couldBeLambda = v8566;
            var v16535 = couldBeLambda;
            if(v16535) {
              v16535 = this.currentToken.tokenId == TypeScript$$14.TokenID.CloseParen
            }
            if(v16535) {
              parseAsLambda = true;
              expectlambdaRParen = false;
              var v27196 = this.scanner.scan();
              this.currentToken = v27196
            }else {
              var v16536 = couldBeLambda;
              if(v16536) {
                v16536 = this.currentToken.tokenId == TypeScript$$14.TokenID.DotDotDot
              }
              if(v16536) {
                parseAsLambda = true;
                expectlambdaRParen = true
              }else {
                ast$$40 = JAM.call(this.parseExpr, this, [errorRecoverySet$$29 | TypeScript$$14.ErrorRecoverySet.RParen, TypeScript$$14.OperatorPrecedence.None, true, TypeContext.NoTypes, couldBeLambda]);
                limChar$$7 = this.scanner.lastTokenLimChar();
                var v8572 = couldBeLambda;
                if(v8572) {
                  var v21271 = ast$$40.nodeType == TypeScript$$14.NodeType.Name;
                  if(!v21271) {
                    v21271 = ast$$40.nodeType == TypeScript$$14.NodeType.Comma
                  }
                  var v16539 = v21271;
                  if(v16539) {
                    var v21272 = this.currentToken.tokenId == TypeScript$$14.TokenID.Colon;
                    if(!v21272) {
                      v21272 = this.currentToken.tokenId == TypeScript$$14.TokenID.Question
                    }
                    v16539 = v21272
                  }
                  v8572 = v16539
                }
                parseAsLambda = v8572;
                expectlambdaRParen = true
              }
            }
            var v16540 = ast$$40;
            if(v16540) {
              v16540 = !parseAsLambda
            }
            if(v16540) {
              if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [ast$$40.flags, TypeScript$$14.ASTFlags.SkipNextRParen])) {
                ast$$40.flags = ast$$40.flags & ~TypeScript$$14.ASTFlags.SkipNextRParen;
                break
              }
              JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseParen, errorRecoverySet$$29]);
              ast$$40.isParenthesized = true
            }
            break;
          case TypeScript$$14.TokenID.NumberLiteral:
            var numTok = this.currentToken;
            var v27197 = this.scanner.scan();
            this.currentToken = v27197;
            ast$$40 = JAM.new(TypeScript$$14.NumberLiteral, [numTok.value, numTok.hasEmptyFraction]);
            ast$$40.minChar = minChar$$24;
            limChar$$7 = this.scanner.lastTokenLimChar();
            break;
          case TypeScript$$14.TokenID.StringLiteral:
            ast$$40 = JAM.new(TypeScript$$14.StringLiteral, [this.currentToken.getText()]);
            var v27198 = this.scanner.scan();
            this.currentToken = v27198;
            ast$$40.minChar = minChar$$24;
            limChar$$7 = this.scanner.lastTokenLimChar();
            break;
          case TypeScript$$14.TokenID.RegularExpressionLiteral:
            var rtok = this.currentToken;
            ast$$40 = JAM.new(TypeScript$$14.RegexLiteral, [rtok.regex]);
            var v27199 = this.scanner.scan();
            this.currentToken = v27199;
            ast$$40.minChar = minChar$$24;
            limChar$$7 = this.scanner.lastTokenLimChar();
            break;
          case TypeScript$$14.TokenID.OpenBracket:
            minChar$$24 = this.scanner.startPos;
            var v27200 = this.scanner.scan();
            this.currentToken = v27200;
            ast$$40 = JAM.call(this.parseArrayLiteral, this, [TypeScript$$14.ErrorRecoverySet.RBrack | errorRecoverySet$$29]);
            ast$$40.minChar = minChar$$24;
            limChar$$7 = this.scanner.pos;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBracket, errorRecoverySet$$29]);
            break;
          case TypeScript$$14.TokenID.OpenBrace:
            minChar$$24 = this.scanner.startPos;
            var v27201 = this.scanner.scan();
            this.currentToken = v27201;
            var members$$11 = JAM.call(this.parseMemberList, this, [TypeScript$$14.ErrorRecoverySet.RCurly | errorRecoverySet$$29]);
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBrace, errorRecoverySet$$29]);
            ast$$40 = JAM.new(TypeScript$$14.UnaryExpression, [TypeScript$$14.NodeType.ObjectLit, members$$11]);
            ast$$40.minChar = minChar$$24;
            limChar$$7 = this.scanner.lastTokenLimChar();
            members$$11.minChar = minChar$$24;
            members$$11.limChar = limChar$$7;
            break;
          case TypeScript$$14.TokenID.LessThan:
            minChar$$24 = this.scanner.startPos;
            var v27202 = this.scanner.scan();
            this.currentToken = v27202;
            var term$$3 = JAM.call(this.parseTypeReference, this, [TypeScript$$14.ErrorRecoverySet.BinOp, false]);
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.GreaterThan, errorRecoverySet$$29]);
            ast$$40 = JAM.new(TypeScript$$14.UnaryExpression, [TypeScript$$14.NodeType.TypeAssertion, JAM.call(this.parseExpr, this, [errorRecoverySet$$29, TypeScript$$14.OperatorPrecedence.Unary, false, TypeContext.NoTypes])]);
            ast$$40.castTerm = term$$3;
            break;
          default:
            var v16556 = this.prevExpr;
            if(v16556) {
              v16556 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [this.prevExpr.flags, TypeScript$$14.ASTFlags.PossibleOptionalParameter])
            }
            if(v16556) {
              parseAsLambda = true;
              ast$$40 = this.prevExpr
            }else {
              JAM.call(this.reportParseError, this, ["Check format of expression term"]);
              if(this.errorRecovery) {
                var ident$$1 = new TypeScript$$14.MissingIdentifier;
                ident$$1.minChar = minChar$$24;
                ident$$1.flags = ident$$1.flags | TypeScript$$14.ASTFlags.Error;
                JAM.call(this.skip, this, [errorRecoverySet$$29 | TypeScript$$14.ErrorRecoverySet.Postfix]);
                var v16560 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
                if(!v16560) {
                  v16560 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
                }
                if(v16560) {
                  JAM.call(ident$$1.setText, ident$$1, [this.currentToken.getText(), this.currentToken.hasEscapeSequence]);
                  var v27203 = this.scanner.scan();
                  this.currentToken = v27203;
                  limChar$$7 = this.scanner.lastTokenLimChar()
                }else {
                  limChar$$7 = this.scanner.lastTokenLimChar()
                }
                ast$$40 = ident$$1
              }
            }
        }
      }
      if(parseAsLambda) {
        var v16563 = this.currentToken.tokenId == TypeScript$$14.TokenID.Colon;
        if(!v16563) {
          var v21289 = this.currentToken.tokenId == TypeScript$$14.TokenID.Comma;
          if(!v21289) {
            var v23965 = this.currentToken.tokenId == TypeScript$$14.TokenID.CloseParen;
            if(!v23965) {
              v23965 = this.currentToken.tokenId == TypeScript$$14.TokenID.DotDotDot
            }
            v21289 = v23965
          }
          v16563 = v21289
        }
        if(v16563) {
          ast$$40 = JAM.call(this.parseLambdaExpr, this, [errorRecoverySet$$29, ast$$40, true, expectlambdaRParen]);
          ast$$40.minChar = minChar$$24;
          limChar$$7 = this.scanner.lastTokenLimChar();
          ast$$40.limChar = limChar$$7
        }else {
          if(ast$$40) {
            ast$$40.isParenthesized = true
          }
        }
      }
      var v16564 = sawId;
      if(v16564) {
        v16564 = typeContext != TypeContext.NoTypes
      }
      if(v16564) {
        typeContext = typeContext | TypeContext.ArraySuffix
      }
      var postFix = JAM.call(this.parsePostfixOperators, this, [errorRecoverySet$$29, ast$$40, allowCall, inNew, typeContext, minChar$$24, limChar$$7]);
      if(postFix) {
        var v16566 = sawId;
        if(v16566) {
          v16566 = postFix.nodeType == TypeScript$$14.NodeType.Index
        }
        if(v16566) {
          var binExpr = postFix;
          if(binExpr.operand2 == null) {
            postFix = JAM.call(this.convertToTypeReference, this, [postFix])
          }
        }
        postFix.minChar = minChar$$24;
        var v8629 = postFix;
        var v27204 = JAM.call(TypeScript$$14.max, TypeScript$$14, [postFix.limChar, this.scanner.lastTokenLimChar()]);
        v8629.limChar = v27204;
        return postFix
      }else {
        return JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Error])
      }
      return
    }
    function v576(errorRecoverySet$$28) {
      var arrayLiteral = null;
      arrayLiteral = JAM.new(TypeScript$$14.UnaryExpression, [TypeScript$$14.NodeType.ArrayLit, JAM.call(this.parseArrayList, this, [errorRecoverySet$$28])]);
      return arrayLiteral
    }
    function v575(errorRecoverySet$$27) {
      var elements$$1 = null;
      if(this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBracket) {
        return elements$$1
      }else {
        elements$$1 = new TypeScript$$14.ASTList;
        elements$$1.minChar = this.scanner.startPos
      }
      var arg$$12;
      for(;;) {
        var v16574 = this.currentToken.tokenId == TypeScript$$14.TokenID.Comma;
        if(!v16574) {
          v16574 = this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBracket
        }
        if(v16574) {
          arg$$12 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.EmptyExpr])
        }else {
          arg$$12 = JAM.call(this.parseExpr, this, [TypeScript$$14.ErrorRecoverySet.Comma | errorRecoverySet$$27, TypeScript$$14.OperatorPrecedence.Comma, true, TypeContext.NoTypes])
        }
        JAM.call(elements$$1.append, elements$$1, [arg$$12]);
        if(this.currentToken.tokenId != TypeScript$$14.TokenID.Comma) {
          break
        }
        var v27205 = this.scanner.scan();
        this.currentToken = v27205
      }
      var v8646 = elements$$1;
      var v27206 = this.scanner.lastTokenLimChar();
      v8646.limChar = v27206;
      return elements$$1
    }
    function v574(errorRecoverySet$$26) {
      var elements = new TypeScript$$14.ASTList;
      if(this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBrace) {
        return elements
      }
      var idHint = null;
      var memberName$$1 = null;
      var memberExpr = null;
      var member$$2 = null;
      var minChar$$23 = this.scanner.startPos;
      var isSet = false;
      var skippedTokenForGetSetId = false;
      var getSetTok = null;
      var getSetStartPos = 0;
      var getSetPos = 0;
      for(;;) {
        var accessorPattern = false;
        var v16583 = this.currentToken.tokenId == TypeScript$$14.TokenID.Get;
        if(!v16583) {
          v16583 = this.currentToken.tokenId == TypeScript$$14.TokenID.Set
        }
        if(v16583) {
          isSet = this.currentToken.tokenId == TypeScript$$14.TokenID.Set;
          getSetTok = this.currentToken;
          getSetStartPos = this.scanner.startPos;
          getSetPos = this.scanner.pos;
          var v27207 = this.scanner.scan();
          this.currentToken = v27207;
          var v16586 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
          if(!v16586) {
            v16586 = JAM.call(TypeScript$$14.convertTokToIDName, TypeScript$$14, [this.currentToken])
          }
          if(v16586) {
            var v8655;
            if(isSet) {
              v8655 = "set"
            }else {
              v8655 = "get"
            }
            idHint = v8655;
            idHint = idHint + this.currentToken.getText();
            var v8658 = TypeScript$$14.Identifier;
            memberName$$1 = JAM.call(v8658.fromToken, v8658, [this.currentToken]);
            memberName$$1.minChar = this.scanner.startPos;
            accessorPattern = true;
            if(TypeScript$$14.codeGenTarget < TypeScript$$14.CodeGenTarget.ES5) {
              JAM.call(this.reportParseError, this, ["Property accessors are only available when targeting ES5 or greater"])
            }
          }else {
            if(this.currentToken.tokenId != TypeScript$$14.TokenID.Colon) {
              JAM.call(this.reportParseError, this, ["Expected identifier, string or number as accessor name"])
            }else {
              skippedTokenForGetSetId = true;
              var v8662 = TypeScript$$14.Identifier;
              memberName$$1 = JAM.call(v8662.fromToken, v8662, [getSetTok]);
              memberName$$1.minChar = getSetStartPos;
              memberName$$1.limChar = getSetPos
            }
          }
        }else {
          var v16592 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
          if(!v16592) {
            v16592 = JAM.call(TypeScript$$14.convertTokToIDName, TypeScript$$14, [this.currentToken])
          }
          if(v16592) {
            idHint = this.currentToken.getText();
            var v8666 = TypeScript$$14.Identifier;
            memberName$$1 = JAM.call(v8666.fromToken, v8666, [this.currentToken]);
            memberName$$1.minChar = this.scanner.startPos;
            memberName$$1.limChar = this.scanner.pos
          }else {
            if(this.currentToken.tokenId == TypeScript$$14.TokenID.StringLiteral) {
              idHint = this.currentToken.getText();
              memberName$$1 = JAM.new(TypeScript$$14.StringLiteral, [idHint]);
              memberName$$1.minChar = this.scanner.startPos;
              memberName$$1.limChar = this.scanner.pos
            }else {
              if(this.currentToken.tokenId == TypeScript$$14.TokenID.NumberLiteral) {
                var ntok = this.currentToken;
                idHint = ntok.value.toString();
                memberName$$1 = JAM.new(TypeScript$$14.StringLiteral, [idHint]);
                memberName$$1.minChar = this.scanner.startPos;
                memberName$$1.limChar = this.scanner.pos
              }else {
                JAM.call(this.reportParseError, this, ["Expected identifier, string or number as member name"]);
                if(this.errorRecovery) {
                  memberName$$1 = new TypeScript$$14.MissingIdentifier;
                  memberName$$1.minChar = this.scanner.startPos;
                  memberName$$1.flags = memberName$$1.flags | TypeScript$$14.ASTFlags.Error;
                  JAM.call(this.skip, this, [errorRecoverySet$$26 | TypeScript$$14.ErrorRecoverySet.Comma]);
                  var v8681 = memberName$$1;
                  var v27208 = this.scanner.lastTokenLimChar();
                  v8681.limChar = v27208
                }
              }
            }
          }
        }
        if(!skippedTokenForGetSetId) {
          var v27209 = this.scanner.scan();
          this.currentToken = v27209
        }else {
          skippedTokenForGetSetId = false
        }
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Question) {
          memberName$$1.flags = memberName$$1.flags | TypeScript$$14.ASTFlags.OptionalName;
          var v27210 = this.scanner.scan();
          this.currentToken = v27210
        }
        if(accessorPattern) {
          var args$$10 = new TypeScript$$14.ASTList;
          JAM.call(this.parseFormalParameterList, this, [errorRecoverySet$$26 | TypeScript$$14.ErrorRecoverySet.RParen, args$$10, false, true, false, !isSet, isSet, false, null, true]);
          var funcDecl$$11 = JAM.call(this.parseFunctionStatements, this, [errorRecoverySet$$26 | TypeScript$$14.ErrorRecoverySet.RCurly, memberName$$1, false, true, args$$10, TypeScript$$14.AllowedElements.None, this.scanner.startPos, false, TypeScript$$14.Modifiers.None]);
          var v16610 = isSet;
          if(v16610) {
            v16610 = funcDecl$$11.returnTypeAnnotation
          }
          if(v16610) {
            JAM.call(this.reportParseError, this, ["Property setters may not declare a return type"])
          }
          var v16611 = funcDecl$$11.fncFlags;
          var v21334;
          if(isSet) {
            v21334 = TypeScript$$14.FncFlags.SetAccessor
          }else {
            v21334 = TypeScript$$14.FncFlags.GetAccessor
          }
          funcDecl$$11.fncFlags = v16611 | v21334;
          funcDecl$$11.fncFlags = funcDecl$$11.fncFlags | TypeScript$$14.FncFlags.IsFunctionExpression;
          funcDecl$$11.hint = idHint;
          memberExpr = funcDecl$$11;
          member$$2 = JAM.new(TypeScript$$14.BinaryExpression, [TypeScript$$14.NodeType.Member, memberName$$1, memberExpr]);
          member$$2.minChar = memberName$$1.minChar;
          if(memberExpr.nodeType == TypeScript$$14.NodeType.FuncDecl) {
            funcDecl$$11 = memberExpr;
            funcDecl$$11.hint = idHint
          }
        }else {
          if(this.currentToken.tokenId == TypeScript$$14.TokenID.Colon) {
            var v27211 = this.scanner.scan();
            this.currentToken = v27211;
            memberExpr = JAM.call(this.parseExpr, this, [TypeScript$$14.ErrorRecoverySet.Comma | errorRecoverySet$$26, TypeScript$$14.OperatorPrecedence.Comma, true, TypeContext.NoTypes]);
            if(memberExpr.nodeType == TypeScript$$14.NodeType.TypeRef) {
              JAM.call(this.reportParseError, this, ["Expected 'new' on array declaration in member definition"])
            }
            member$$2 = JAM.new(TypeScript$$14.BinaryExpression, [TypeScript$$14.NodeType.Member, memberName$$1, memberExpr]);
            member$$2.minChar = memberName$$1.minChar;
            if(memberExpr.nodeType == TypeScript$$14.NodeType.FuncDecl) {
              funcDecl$$11 = memberExpr;
              funcDecl$$11.hint = idHint
            }
          }else {
            JAM.call(this.reportParseError, this, ["Expected ':' in member definition"]);
            if(this.errorRecovery) {
              JAM.call(this.skip, this, [errorRecoverySet$$26]);
              elements.flags = elements.flags | TypeScript$$14.ASTFlags.Error;
              elements.minChar = minChar$$23;
              var v8710 = elements;
              var v27212 = this.scanner.lastTokenLimChar();
              v8710.limChar = v27212;
              return elements
            }
          }
        }
        idHint = null;
        JAM.call(elements.append, elements, [member$$2]);
        var v8713 = member$$2;
        var v27213 = this.scanner.lastTokenLimChar();
        v8713.limChar = v27213;
        if(this.currentToken.tokenId != TypeScript$$14.TokenID.Comma) {
          break
        }else {
          var v27214 = this.scanner.scan();
          this.currentToken = v27214
        }
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBrace) {
          break
        }
      }
      if(member$$2) {
        elements.limChar = member$$2.limChar
      }
      elements.minChar = minChar$$23;
      return elements
    }
    function v573(errorRecoverySet$$25, modifiers$$11, allowIn, isStatic$$4) {
      var isConst = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$11, TypeScript$$14.Modifiers.Readonly]);
      var minChar$$22 = this.scanner.startPos;
      var varDecl$$10 = null;
      var declList = null;
      var multivar = false;
      var v27215 = this.scanner.scan();
      this.currentToken = v27215;
      var varDeclPreComments = this.parseComments();
      for(;true;) {
        var v16636 = this.currentToken.tokenId != TypeScript$$14.TokenID.Identifier;
        if(v16636) {
          v16636 = !JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
        }
        if(v16636) {
          JAM.call(this.reportParseError, this, ["Expected identifier in variable declaration"]);
          if(this.errorRecovery) {
            varDecl$$10 = JAM.new(TypeScript$$14.VarDecl, [new TypeScript$$14.MissingIdentifier, this.nestingLevel]);
            varDecl$$10.minChar = minChar$$22;
            JAM.call(this.skip, this, [errorRecoverySet$$25]);
            varDecl$$10.flags = varDecl$$10.flags | TypeScript$$14.ASTFlags.Error;
            var v8723 = varDecl$$10;
            var v27216 = this.scanner.lastTokenLimChar();
            v8723.limChar = v27216;
            return varDecl$$10
          }
        }
        var v8726 = TypeScript$$14.Identifier;
        var varDeclName = JAM.call(v8726.fromToken, v8726, [this.currentToken]);
        var v16641 = this.strictMode;
        if(v16641) {
          v16641 = varDeclName.text == "eval"
        }
        if(v16641) {
          JAM.call(this.reportParseError, this, ["'eval' may not name a variable in strict mode"])
        }
        varDecl$$10 = JAM.call(this.makeVarDecl, this, [varDeclName, this.nestingLevel]);
        varDecl$$10.id.minChar = this.scanner.startPos;
        varDecl$$10.id.limChar = this.scanner.pos;
        varDecl$$10.preComments = varDeclPreComments;
        if(isStatic$$4) {
          varDecl$$10.varFlags = varDecl$$10.varFlags | TypeScript$$14.VarFlags.Static
        }
        if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$11, TypeScript$$14.Modifiers.Readonly])) {
          varDecl$$10.varFlags = varDecl$$10.varFlags | TypeScript$$14.VarFlags.Readonly
        }
        var v16649 = this.parsingDeclareFile;
        if(!v16649) {
          var v21355 = this.ambientModule;
          if(!v21355) {
            v21355 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$11, TypeScript$$14.Modifiers.Ambient])
          }
          v16649 = v21355
        }
        if(v16649) {
          varDecl$$10.varFlags = varDecl$$10.varFlags | TypeScript$$14.VarFlags.Ambient
        }
        var v16652 = this.parsingDeclareFile;
        if(!v16652) {
          var v21358 = this.ambientModule;
          if(!v21358) {
            v21358 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$11, TypeScript$$14.Modifiers.Exported])
          }
          v16652 = v21358
        }
        if(v16652) {
          varDecl$$10.varFlags = varDecl$$10.varFlags | TypeScript$$14.VarFlags.Exported
        }
        varDecl$$10.minChar = minChar$$22;
        if(declList) {
          JAM.call(declList.append, declList, [varDecl$$10])
        }
        var v27217 = this.scanner.scan();
        this.currentToken = v27217;
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Colon) {
          var v27218 = this.scanner.scan();
          this.currentToken = v27218;
          var prevInFncDecl = this.inFncDecl;
          this.inFncDecl = false;
          var v8737 = varDecl$$10;
          var v27219 = JAM.call(this.parseTypeReference, this, [errorRecoverySet$$25 | TypeScript$$14.ErrorRecoverySet.Asg | TypeScript$$14.ErrorRecoverySet.Comma, false]);
          v8737.typeExpr = v27219;
          this.inFncDecl = prevInFncDecl
        }
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Equals) {
          if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [varDecl$$10.varFlags, TypeScript$$14.VarFlags.Ambient])) {
            JAM.call(this.reportParseError, this, ["Ambient variable can not have an initializer"])
          }
          var v27220 = this.scanner.scan();
          this.currentToken = v27220;
          var v8741 = varDecl$$10;
          var v27221 = JAM.call(this.parseExpr, this, [TypeScript$$14.ErrorRecoverySet.Comma | errorRecoverySet$$25, TypeScript$$14.OperatorPrecedence.Comma, allowIn, TypeContext.NoTypes]);
          v8741.init = v27221;
          varDecl$$10.limChar = varDecl$$10.init.limChar;
          if(varDecl$$10.init.nodeType == TypeScript$$14.NodeType.FuncDecl) {
            var funcDecl$$10 = varDecl$$10.init;
            funcDecl$$10.hint = varDecl$$10.id.actualText
          }
        }else {
          if(isConst) {
            JAM.call(this.reportParseError, this, ["const declaration requires initializer"])
          }
          varDecl$$10.limChar = this.scanner.pos
        }
        var v8747 = varDecl$$10;
        var v27222 = JAM.call(this.parseCommentsForLine, this, [this.scanner.line]);
        v8747.postComments = v27222;
        if(this.currentToken.tokenId != TypeScript$$14.TokenID.Comma) {
          if(declList) {
            declList.limChar = varDecl$$10.limChar;
            return declList
          }else {
            return varDecl$$10
          }
        }
        if(!multivar) {
          declList = new TypeScript$$14.ASTList;
          declList.minChar = varDecl$$10.minChar;
          JAM.call(declList.append, declList, [varDecl$$10]);
          multivar = true
        }
        var v27223 = this.scanner.scan();
        this.currentToken = v27223;
        minChar$$22 = this.scanner.startPos
      }
      return
    }
    function v572(errorRecoverySet$$24, modifiers$$10, requireSignature, isStatic$$3) {
      var text$$16 = null;
      var minChar$$21 = this.scanner.startPos;
      var nameLimChar = minChar$$21;
      var isNew = false;
      var isIndexer$$1 = false;
      var wasAccessorID$$1 = this.prevIDTok != null;
      var v8755 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$10, TypeScript$$14.Modifiers.Getter]);
      if(!v8755) {
        v8755 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$10, TypeScript$$14.Modifiers.Setter])
      }
      var isAccessor$$1 = v8755;
      var v16673 = this.parsingDeclareFile;
      if(!v16673) {
        var v21377 = this.ambientModule;
        if(!v21377) {
          v21377 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$10, TypeScript$$14.Modifiers.Ambient])
        }
        v16673 = v21377
      }
      if(v16673) {
        requireSignature = true
      }
      var v16674 = this.currentToken.tokenId == TypeScript$$14.TokenID.OpenParen;
      if(v16674) {
        v16674 = !wasAccessorID$$1
      }
      if(v16674) {
        var v16675 = !requireSignature;
        if(v16675) {
          v16675 = !isStatic$$3
        }
        if(v16675) {
          JAM.call(this.reportParseError, this, ["Expected identifier in property declaration"]);
          if(this.errorRecovery) {
            JAM.call(this.skip, this, [errorRecoverySet$$24]);
            text$$16 = new TypeScript$$14.MissingIdentifier
          }
        }
      }else {
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.New) {
          if(requireSignature) {
            var v27224 = this.scanner.scan();
            this.currentToken = v27224;
            if(this.currentToken.tokenId == TypeScript$$14.TokenID.OpenParen) {
              isNew = true
            }
          }
          if(!isNew) {
            if(!requireSignature) {
              var v27225 = this.scanner.scan();
              this.currentToken = v27225
            }
            text$$16 = JAM.new(TypeScript$$14.Identifier, ["new"]);
            text$$16.minChar = this.scanner.pos - 3;
            text$$16.limChar = this.scanner.pos;
            nameLimChar = this.scanner.pos
          }
        }else {
          var v16681 = this.currentToken.tokenId == TypeScript$$14.TokenID.OpenBracket;
          if(v16681) {
            v16681 = requireSignature
          }
          if(v16681) {
            isIndexer$$1 = true;
            text$$16 = JAM.new(TypeScript$$14.Identifier, ["__item"])
          }else {
            var v16682 = this.currentToken.tokenId != TypeScript$$14.TokenID.Identifier;
            if(v16682) {
              var v21389 = !JAM.call(TypeScript$$14.convertTokToIDName, TypeScript$$14, [this.currentToken]);
              if(v21389) {
                v21389 = !wasAccessorID$$1
              }
              v16682 = v21389
            }
            if(v16682) {
              JAM.call(this.reportParseError, this, ["Expected identifier in property declaration"]);
              if(this.errorRecovery) {
                var eminChar = this.scanner.startPos;
                var curpos$$1 = this.scanner.pos;
                JAM.call(this.skip, this, [errorRecoverySet$$24 & ~TypeScript$$14.ErrorRecoverySet.Comma]);
                if(this.scanner.pos == curpos$$1) {
                  var v27226 = this.scanner.scan();
                  this.currentToken = v27226
                }
                var epd = JAM.new(TypeScript$$14.VarDecl, [new TypeScript$$14.MissingIdentifier, this.nestingLevel]);
                epd.flags = epd.flags | TypeScript$$14.ASTFlags.Error;
                epd.minChar = eminChar;
                var v8778 = epd;
                var v27227 = this.scanner.lastTokenLimChar();
                v8778.limChar = v27227;
                return epd
              }
            }else {
              if(wasAccessorID$$1) {
                var v8780 = TypeScript$$14.Identifier;
                text$$16 = JAM.call(v8780.fromToken, v8780, [this.prevIDTok]);
                text$$16.minChar = this.scanner.lastTokenLimChar() - 3;
                var v8783 = text$$16;
                var v27228 = this.scanner.lastTokenLimChar();
                v8783.limChar = v27228;
                nameLimChar = text$$16.limChar;
                if(TypeScript$$14.codeGenTarget < TypeScript$$14.CodeGenTarget.ES5) {
                  JAM.call(this.reportParseError, this, ["Property accessors are only available when targeting ES5 or greater"])
                }
                var v16693 = this.currentToken.getText() == text$$16.actualText;
                if(v16693) {
                  v16693 = this.currentToken != this.prevIDTok
                }
                if(v16693) {
                  var v27229 = this.scanner.scan();
                  this.currentToken = v27229
                }
                this.prevIDTok = null
              }else {
                var v8787 = TypeScript$$14.Identifier;
                text$$16 = JAM.call(v8787.fromToken, v8787, [this.currentToken]);
                text$$16.minChar = this.scanner.startPos;
                text$$16.limChar = this.scanner.pos;
                nameLimChar = this.scanner.pos;
                var v27230 = this.scanner.scan();
                this.currentToken = v27230
              }
            }
          }
        }
      }
      if(this.currentToken.tokenId == TypeScript$$14.TokenID.Question) {
        var v16696 = this.inInterfaceDecl;
        if(v16696) {
          v16696 = text$$16
        }
        if(v16696) {
          text$$16.flags = text$$16.flags | TypeScript$$14.ASTFlags.OptionalName
        }else {
          JAM.call(this.reportParseError, this, ["Optional properties may only be declared on interface or object types"])
        }
        var v27231 = this.scanner.scan();
        this.currentToken = v27231
      }
      var v16699 = this.currentToken.tokenId == TypeScript$$14.TokenID.OpenParen;
      if(!v16699) {
        var v21404 = isIndexer$$1;
        if(v21404) {
          v21404 = this.currentToken.tokenId == TypeScript$$14.TokenID.OpenBracket
        }
        v16699 = v21404
      }
      if(v16699) {
        var ers = errorRecoverySet$$24 | TypeScript$$14.ErrorRecoverySet.RParen;
        if(isIndexer$$1) {
          ers = errorRecoverySet$$24 | TypeScript$$14.ErrorRecoverySet.RBrack
        }
        var v8802 = !this.inFncDecl;
        var v16703 = this.parsingDeclareFile;
        if(!v16703) {
          v16703 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$10, TypeScript$$14.Modifiers.Ambient])
        }
        var ast$$39 = JAM.call(this.parseFncDecl, this, [ers, true, requireSignature, v8802, text$$16, isIndexer$$1, isStatic$$3, v16703, modifiers$$10, null, true]);
        var funcDecl$$9;
        if(ast$$39.nodeType == TypeScript$$14.NodeType.Error) {
          return ast$$39
        }else {
          funcDecl$$9 = ast$$39
        }
        if(funcDecl$$9.name) {
          funcDecl$$9.name.minChar = minChar$$21;
          funcDecl$$9.name.limChar = nameLimChar
        }
        if((modifiers$$10 & TypeScript$$14.Modifiers.Public) != TypeScript$$14.Modifiers.None) {
          funcDecl$$9.fncFlags = funcDecl$$9.fncFlags | TypeScript$$14.FncFlags.Public
        }
        if((modifiers$$10 & TypeScript$$14.Modifiers.Private) != TypeScript$$14.Modifiers.None) {
          funcDecl$$9.fncFlags = funcDecl$$9.fncFlags | TypeScript$$14.FncFlags.Private
        }
        if(isStatic$$3) {
          funcDecl$$9.fncFlags = funcDecl$$9.fncFlags | TypeScript$$14.FncFlags.Static
        }
        var v16716 = this.parsingDeclareFile;
        if(!v16716) {
          v16716 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$10, TypeScript$$14.Modifiers.Ambient])
        }
        if(v16716) {
          funcDecl$$9.fncFlags = funcDecl$$9.fncFlags | TypeScript$$14.FncFlags.Ambient
        }
        if(isAccessor$$1) {
          if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$10, TypeScript$$14.Modifiers.Getter])) {
            funcDecl$$9.fncFlags = funcDecl$$9.fncFlags | TypeScript$$14.FncFlags.GetAccessor;
            funcDecl$$9.hint = "get" + funcDecl$$9.name.actualText
          }else {
            funcDecl$$9.fncFlags = funcDecl$$9.fncFlags | TypeScript$$14.FncFlags.SetAccessor;
            funcDecl$$9.hint = "set" + funcDecl$$9.name.actualText
          }
          funcDecl$$9.fncFlags = funcDecl$$9.fncFlags | TypeScript$$14.FncFlags.IsFunctionExpression;
          if(modifiers$$10 & TypeScript$$14.Modifiers.Ambient) {
            JAM.call(this.reportParseError, this, ["Property accessors may not be declared in ambient types"])
          }
        }
        if(text$$16 == null) {
          if(isNew) {
            funcDecl$$9.fncFlags = funcDecl$$9.fncFlags | TypeScript$$14.FncFlags.ConstructMember;
            funcDecl$$9.hint = "_construct";
            funcDecl$$9.classDecl = this.currentClassDecl
          }else {
            funcDecl$$9.hint = "_call";
            funcDecl$$9.fncFlags = funcDecl$$9.fncFlags | TypeScript$$14.FncFlags.CallMember
          }
        }
        return funcDecl$$9
      }else {
        var varDecl$$9 = JAM.new(TypeScript$$14.VarDecl, [text$$16, this.nestingLevel]);
        var v8818 = varDecl$$9;
        var v27232 = this.parseComments();
        v8818.preComments = v27232;
        varDecl$$9.minChar = minChar$$21;
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Colon) {
          var v27233 = this.scanner.scan();
          this.currentToken = v27233;
          var v8820 = varDecl$$9;
          var v27234 = JAM.call(this.parseTypeReference, this, [errorRecoverySet$$24 | TypeScript$$14.ErrorRecoverySet.Asg | TypeScript$$14.ErrorRecoverySet.Comma, false]);
          v8820.typeExpr = v27234;
          var v16736 = varDecl$$9.typeExpr;
          if(v16736) {
            v16736 = varDecl$$9.typeExpr.nodeType == TypeScript$$14.NodeType.TypeRef
          }
          if(v16736) {
            var typeExpr$$1 = varDecl$$9.typeExpr;
            var v16737 = typeExpr$$1.term;
            if(v16737) {
              v16737 = typeExpr$$1.term.nodeType == TypeScript$$14.NodeType.FuncDecl
            }
            if(v16737) {
              typeExpr$$1.term.preComments = varDecl$$9.preComments
            }
          }
        }
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Equals) {
          if(requireSignature) {
            JAM.call(this.reportParseError, this, ["context does not permit variable initializer"]);
            if(this.errorRecovery) {
              JAM.call(this.skip, this, [errorRecoverySet$$24]);
              varDecl$$9.flags = varDecl$$9.flags | TypeScript$$14.ASTFlags.Error;
              var v8825 = varDecl$$9;
              var v27235 = this.scanner.lastTokenLimChar();
              v8825.limChar = v27235;
              return varDecl$$9
            }
          }
          var v27236 = this.scanner.scan();
          this.currentToken = v27236;
          var v8828 = varDecl$$9;
          var v27237 = JAM.call(this.parseExpr, this, [TypeScript$$14.ErrorRecoverySet.Comma | errorRecoverySet$$24, TypeScript$$14.OperatorPrecedence.Comma, true, TypeContext.NoTypes]);
          v8828.init = v27237;
          varDecl$$9.limChar = varDecl$$9.init.limChar;
          if(varDecl$$9.init.nodeType == TypeScript$$14.NodeType.FuncDecl) {
            funcDecl$$9 = varDecl$$9.init;
            funcDecl$$9.hint = varDecl$$9.id.text;
            funcDecl$$9.boundToProperty = varDecl$$9
          }else {
            if(isAccessor$$1) {
              JAM.call(this.reportParseError, this, ["Accessors may only be functions"])
            }
          }
        }else {
          varDecl$$9.limChar = this.scanner.pos
        }
        if((modifiers$$10 & TypeScript$$14.Modifiers.Readonly) != TypeScript$$14.Modifiers.None) {
          varDecl$$9.varFlags = varDecl$$9.varFlags | TypeScript$$14.VarFlags.Readonly
        }
        if(isStatic$$3) {
          varDecl$$9.varFlags = varDecl$$9.varFlags | TypeScript$$14.VarFlags.Static
        }
        if((modifiers$$10 & TypeScript$$14.Modifiers.Public) != TypeScript$$14.Modifiers.None) {
          varDecl$$9.varFlags = varDecl$$9.varFlags | TypeScript$$14.VarFlags.Public
        }
        if((modifiers$$10 & TypeScript$$14.Modifiers.Private) != TypeScript$$14.Modifiers.None) {
          varDecl$$9.varFlags = varDecl$$9.varFlags | TypeScript$$14.VarFlags.Private
        }
        varDecl$$9.varFlags = varDecl$$9.varFlags | TypeScript$$14.VarFlags.Property;
        return varDecl$$9
      }
      return
    }
    function v571(id$$12, nest$$1) {
      var varDecl$$8 = JAM.new(TypeScript$$14.VarDecl, [id$$12, nest$$1]);
      var currentVarList = this.topVarList();
      if(currentVarList) {
        JAM.call(currentVarList.append, currentVarList, [varDecl$$8])
      }
      return varDecl$$8
    }
    function v570(errorRecoverySet$$23, modifiers$$9) {
      var leftCurlyCount$$4 = this.scanner.leftCurlyCount;
      var rightCurlyCount$$4 = this.scanner.rightCurlyCount;
      var v27238 = this.scanner.scan();
      this.currentToken = v27238;
      var minChar$$20 = this.scanner.pos;
      var name$$51 = null;
      var v16764 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
      if(!v16764) {
        var v21454 = !JAM.call(TypeScript$$14.isPrimitiveTypeToken, TypeScript$$14, [this.currentToken]);
        if(v21454) {
          v21454 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
        }
        v16764 = v21454
      }
      if(v16764) {
        var v8843 = TypeScript$$14.Identifier;
        name$$51 = JAM.call(v8843.fromToken, v8843, [this.currentToken]);
        name$$51.minChar = this.scanner.startPos;
        name$$51.limChar = this.scanner.pos;
        var v27239 = this.scanner.scan();
        this.currentToken = v27239
      }else {
        JAM.call(this.reportParseError, this, ["interface missing name"]);
        if(this.errorRecovery) {
          name$$51 = new TypeScript$$14.MissingIdentifier;
          name$$51.minChar = this.scanner.pos;
          name$$51.limChar = this.scanner.pos;
          name$$51.flags = name$$51.flags | TypeScript$$14.ASTFlags.Error
        }
      }
      var extendsList$$6 = null;
      var implementsList$$5 = null;
      var v16767 = this.currentToken.tokenId === TypeScript$$14.TokenID.Extends;
      if(!v16767) {
        v16767 = this.currentToken.tokenId === TypeScript$$14.TokenID.Implements
      }
      if(v16767) {
        if(this.currentToken.tokenId === TypeScript$$14.TokenID.Implements) {
          JAM.call(this.reportParseError, this, ["Expected 'extends'"])
        }
        extendsList$$6 = new TypeScript$$14.ASTList;
        implementsList$$5 = new TypeScript$$14.ASTList;
        extendsList$$6.minChar = this.scanner.startPos;
        JAM.call(this.parseBaseList, this, [extendsList$$6, implementsList$$5, errorRecoverySet$$23, false])
      }
      var membersMinChar$$2 = this.scanner.startPos;
      JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.OpenBrace, errorRecoverySet$$23 | TypeScript$$14.ErrorRecoverySet.TypeScriptS]);
      var members$$10 = new TypeScript$$14.ASTList;
      members$$10.minChar = membersMinChar$$2;
      var prevInInterfaceDecl$$1 = this.inInterfaceDecl;
      this.inInterfaceDecl = true;
      JAM.call(this.parseTypeMemberList, this, [errorRecoverySet$$23 | TypeScript$$14.ErrorRecoverySet.RCurly, members$$10]);
      this.inInterfaceDecl = prevInInterfaceDecl$$1;
      JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBrace, errorRecoverySet$$23]);
      var interfaceDecl$$1 = JAM.new(TypeScript$$14.InterfaceDeclaration, [name$$51, members$$10, extendsList$$6, null]);
      if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$9, TypeScript$$14.Modifiers.Private])) {
        interfaceDecl$$1.varFlags = interfaceDecl$$1.varFlags | TypeScript$$14.VarFlags.Private
      }
      if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$9, TypeScript$$14.Modifiers.Public])) {
        interfaceDecl$$1.varFlags = interfaceDecl$$1.varFlags | TypeScript$$14.VarFlags.Public
      }
      var v16780 = this.parsingDeclareFile;
      if(!v16780) {
        var v21470 = this.ambientModule;
        if(!v21470) {
          v21470 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$9, TypeScript$$14.Modifiers.Exported])
        }
        v16780 = v21470
      }
      if(v16780) {
        interfaceDecl$$1.varFlags = interfaceDecl$$1.varFlags | TypeScript$$14.VarFlags.Exported
      }
      interfaceDecl$$1.limChar = members$$10.limChar;
      interfaceDecl$$1.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount$$4;
      interfaceDecl$$1.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount$$4;
      return interfaceDecl$$1
    }
    function v569(errorRecoverySet$$22, members$$9) {
      errorRecoverySet$$22 = errorRecoverySet$$22 | TypeScript$$14.ErrorRecoverySet.TypeScriptS;
      for(;true;) {
        switch(this.currentToken.tokenId) {
          case TypeScript$$14.TokenID.CloseBrace:
          ;
          case TypeScript$$14.TokenID.EndOfFile:
            members$$9.limChar = this.scanner.pos;
            return
        }
        var element$$3 = JAM.call(this.parseTypeMember, this, [errorRecoverySet$$22]);
        if(element$$3) {
          JAM.call(members$$9.append, members$$9, [element$$3])
        }
      }
      return
    }
    function v568(errorRecoverySet$$21) {
      var minChar$$19 = this.scanner.startPos;
      var propertyDecl = JAM.call(this.parsePropertyDeclaration, this, [errorRecoverySet$$21, TypeScript$$14.Modifiers.Public, true, false]);
      if(propertyDecl) {
        propertyDecl.minChar = minChar$$19;
        if(propertyDecl.nodeType == TypeScript$$14.NodeType.VarDecl) {
          JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.Semicolon, errorRecoverySet$$21])
        }
      }
      return propertyDecl
    }
    function v567(methodName$$1, minChar$$18, errorRecoverySet$$20, modifiers$$8) {
      var wasAccessorID = this.prevIDTok != null;
      var v8877 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$8, TypeScript$$14.Modifiers.Getter]);
      if(!v8877) {
        v8877 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$8, TypeScript$$14.Modifiers.Setter])
      }
      var isAccessor = v8877;
      var isStatic$$2 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$8, TypeScript$$14.Modifiers.Static]);
      var v8879 = this.ambientModule;
      if(!v8879) {
        v8879 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$8, TypeScript$$14.Modifiers.Ambient])
      }
      var isAmbient$$2 = v8879;
      errorRecoverySet$$20 = errorRecoverySet$$20 | TypeScript$$14.ErrorRecoverySet.RParen;
      var v16798 = isAccessor;
      if(v16798) {
        v16798 = modifiers$$8 & TypeScript$$14.Modifiers.Ambient
      }
      if(v16798) {
        JAM.call(this.reportParseError, this, ["Property accessors may not be declared in ambient classes"])
      }
      var ast$$38 = JAM.call(this.parseFncDecl, this, [errorRecoverySet$$20, true, isAmbient$$2, true, methodName$$1, false, isStatic$$2, isAmbient$$2, modifiers$$8, null, true]);
      if(ast$$38.nodeType == TypeScript$$14.NodeType.Error) {
        return ast$$38
      }
      var funcDecl$$8 = ast$$38;
      funcDecl$$8.minChar = minChar$$18;
      if(funcDecl$$8.bod !== null) {
        funcDecl$$8.limChar = funcDecl$$8.bod.limChar
      }
      if(modifiers$$8 & TypeScript$$14.Modifiers.Private) {
        funcDecl$$8.fncFlags = funcDecl$$8.fncFlags | TypeScript$$14.FncFlags.Private
      }else {
        funcDecl$$8.fncFlags = funcDecl$$8.fncFlags | TypeScript$$14.FncFlags.Public
      }
      if(isStatic$$2) {
        funcDecl$$8.fncFlags = funcDecl$$8.fncFlags | TypeScript$$14.FncFlags.Static
      }
      if(isAccessor) {
        if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$8, TypeScript$$14.Modifiers.Getter])) {
          funcDecl$$8.fncFlags = funcDecl$$8.fncFlags | TypeScript$$14.FncFlags.GetAccessor;
          funcDecl$$8.hint = "get" + funcDecl$$8.name.actualText
        }else {
          funcDecl$$8.fncFlags = funcDecl$$8.fncFlags | TypeScript$$14.FncFlags.SetAccessor;
          funcDecl$$8.hint = "set" + funcDecl$$8.name.actualText
        }
        funcDecl$$8.fncFlags = funcDecl$$8.fncFlags | TypeScript$$14.FncFlags.IsFunctionExpression;
        if(TypeScript$$14.codeGenTarget < TypeScript$$14.CodeGenTarget.ES5) {
          JAM.call(this.reportParseError, this, ["Property accessors are only available when targeting ES5 or greater", funcDecl$$8.minChar, funcDecl$$8.limChar])
        }
      }
      funcDecl$$8.fncFlags = funcDecl$$8.fncFlags | TypeScript$$14.FncFlags.ClassMethod;
      JAM.set(this.currentClassDefinition.knownMemberNames, methodName$$1.actualText, true);
      JAM.set(this.currentClassDefinition.members.members, this.currentClassDefinition.members.members.length, funcDecl$$8);
      return funcDecl$$8
    }
    function v566(text$$15, minChar$$17, isDeclaredInConstructor, errorRecoverySet$$19, modifiers$$7) {
      var varDecl$$7 = JAM.new(TypeScript$$14.VarDecl, [text$$15, this.nestingLevel]);
      varDecl$$7.minChar = minChar$$17;
      var isStatic$$1 = false;
      var v8897 = varDecl$$7;
      var v27240 = this.parseComments();
      v8897.preComments = v27240;
      if(this.currentToken.tokenId == TypeScript$$14.TokenID.Colon) {
        var v27241 = this.scanner.scan();
        this.currentToken = v27241;
        var v8899 = varDecl$$7;
        var v27242 = JAM.call(this.parseTypeReference, this, [errorRecoverySet$$19 | TypeScript$$14.ErrorRecoverySet.Asg | TypeScript$$14.ErrorRecoverySet.Comma, false]);
        v8899.typeExpr = v27242;
        var v16828 = varDecl$$7.typeExpr;
        if(v16828) {
          v16828 = varDecl$$7.typeExpr.nodeType == TypeScript$$14.NodeType.TypeRef
        }
        if(v16828) {
          var typeExpr = varDecl$$7.typeExpr;
          var v16829 = typeExpr.term;
          if(v16829) {
            v16829 = typeExpr.term.nodeType == TypeScript$$14.NodeType.FuncDecl
          }
          if(v16829) {
            typeExpr.term.preComments = varDecl$$7.preComments
          }
        }
      }
      if(this.currentToken.tokenId == TypeScript$$14.TokenID.Equals) {
        var v16832 = this.parsingDeclareFile;
        if(!v16832) {
          v16832 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$7, TypeScript$$14.Modifiers.Ambient])
        }
        if(v16832) {
          JAM.call(this.reportParseError, this, ["context does not permit variable initializer"]);
          if(this.errorRecovery) {
            JAM.call(this.skip, this, [errorRecoverySet$$19]);
            varDecl$$7.flags = varDecl$$7.flags | TypeScript$$14.ASTFlags.Error;
            var v8904 = varDecl$$7;
            var v27243 = this.scanner.lastTokenLimChar();
            v8904.limChar = v27243;
            return varDecl$$7
          }
        }
        var v27244 = this.scanner.scan();
        this.currentToken = v27244;
        var v8908 = varDecl$$7;
        var v27245 = JAM.call(this.parseExpr, this, [TypeScript$$14.ErrorRecoverySet.Comma | errorRecoverySet$$19, TypeScript$$14.OperatorPrecedence.Comma, true, TypeContext.NoTypes]);
        v8908.init = v27245;
        varDecl$$7.limChar = varDecl$$7.init.limChar;
        if(!(modifiers$$7 & TypeScript$$14.Modifiers.Static)) {
          var v8910 = this.currentClassDefinition;
          v8910.varFlags = v8910.varFlags | TypeScript$$14.VarFlags.ClassSuperMustBeFirstCallInConstructor
        }
      }else {
        varDecl$$7.limChar = this.scanner.pos
      }
      if(modifiers$$7 & TypeScript$$14.Modifiers.Static) {
        varDecl$$7.varFlags = varDecl$$7.varFlags | TypeScript$$14.VarFlags.Static;
        isStatic$$1 = true
      }
      if((modifiers$$7 & TypeScript$$14.Modifiers.Private) != TypeScript$$14.Modifiers.None) {
        varDecl$$7.varFlags = varDecl$$7.varFlags | TypeScript$$14.VarFlags.Private
      }else {
        varDecl$$7.varFlags = varDecl$$7.varFlags | TypeScript$$14.VarFlags.Public
      }
      varDecl$$7.varFlags = varDecl$$7.varFlags | TypeScript$$14.VarFlags.Property;
      if(isDeclaredInConstructor) {
        varDecl$$7.varFlags = varDecl$$7.varFlags | TypeScript$$14.VarFlags.ClassConstructorProperty
      }
      var v16853 = !isDeclaredInConstructor;
      if(v16853) {
        v16853 = !isStatic$$1
      }
      if(v16853) {
        varDecl$$7.varFlags = varDecl$$7.varFlags | TypeScript$$14.VarFlags.ClassBodyProperty
      }
      JAM.set(this.currentClassDefinition.knownMemberNames, text$$15.actualText, true);
      if(!isDeclaredInConstructor) {
        JAM.set(this.currentClassDefinition.members.members, this.currentClassDefinition.members.members.length, varDecl$$7)
      }
      var v8922 = varDecl$$7;
      var v27246 = this.parseComments();
      v8922.postComments = v27246;
      return varDecl$$7
    }
    function v565(minChar$$16, errorRecoverySet$$18, modifiers$$6) {
      this.parsingClassConstructorDefinition = true;
      var v8923 = this.parsingDeclareFile;
      if(!v8923) {
        v8923 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$6, TypeScript$$14.Modifiers.Ambient])
      }
      var isAmbient$$1 = v8923;
      var args$$9 = new TypeScript$$14.ASTList;
      var variableArgList$$2 = false;
      var preComments$$3 = this.parseComments();
      var v27247 = this.scanner.scan();
      this.currentToken = v27247;
      if(this.currentToken.tokenId == TypeScript$$14.TokenID.OpenParen) {
        variableArgList$$2 = JAM.call(this.parseFormalParameterList, this, [errorRecoverySet$$18, args$$9, true, isAmbient$$1, false, false, false, false, null, true]);
        if(args$$9.members.length > 0) {
          var v8926 = args$$9.members;
          var v8927 = args$$9.members.length - 1;
          introspect(JAM.policy.p1) {
            var lastArg$$1 = v8926[v8927]
          }
        }
      }
      var v8930 = isAmbient$$1;
      if(!v8930) {
        v8930 = this.currentToken.tokenId == TypeScript$$14.TokenID.Semicolon
      }
      var requiresSignature$$3 = v8930;
      if(requiresSignature$$3) {
        var i$$51 = 0;
        var v8935 = i$$51 < args$$9.members.length;
        for(;v8935;) {
          var v8931 = args$$9.members;
          introspect(JAM.policy.p1) {
            var arg$$11 = v8931[i$$51]
          }
          if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [arg$$11.varFlags, TypeScript$$14.VarFlags.Property])) {
            JAM.call(this.reportParseError, this, ["Overload or ambient signatures may not specify parameter properties", arg$$11.minChar, arg$$11.limChar])
          }
          i$$51 = i$$51 + 1;
          v8935 = i$$51 < args$$9.members.length
        }
      }
      if(!requiresSignature$$3) {
        this.currentClassDefinition.constructorNestingLevel = this.nestingLevel + 1
      }
      var constructorFuncDecl = JAM.call(this.parseFunctionStatements, this, [errorRecoverySet$$18 | TypeScript$$14.ErrorRecoverySet.RCurly, this.currentClassDefinition.name, true, false, args$$9, TypeScript$$14.AllowedElements.Properties, minChar$$16, requiresSignature$$3, modifiers$$6]);
      constructorFuncDecl.preComments = preComments$$3;
      var v16876 = requiresSignature$$3;
      if(v16876) {
        v16876 = !isAmbient$$1
      }
      if(v16876) {
        constructorFuncDecl.isOverload = true
      }
      constructorFuncDecl.variableArgList = variableArgList$$2;
      this.currentClassDecl = null;
      var v8942 = constructorFuncDecl;
      var v27248 = JAM.call(this.convertToTypeReference, this, [this.currentClassDefinition.name]);
      v8942.returnTypeAnnotation = v27248;
      constructorFuncDecl.classDecl = this.currentClassDefinition;
      if(isAmbient$$1) {
        constructorFuncDecl.fncFlags = constructorFuncDecl.fncFlags | TypeScript$$14.FncFlags.Ambient
      }
      if(requiresSignature$$3) {
        constructorFuncDecl.fncFlags = constructorFuncDecl.fncFlags | TypeScript$$14.FncFlags.Signature
      }
      var v16882 = this.ambientModule;
      if(!v16882) {
        v16882 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$6, TypeScript$$14.Modifiers.Exported])
      }
      if(v16882) {
        constructorFuncDecl.fncFlags = constructorFuncDecl.fncFlags | TypeScript$$14.FncFlags.Exported
      }
      if(this.currentClassDefinition.constructorDecl) {
        var v16886 = !isAmbient$$1;
        if(v16886) {
          var v21539 = !this.currentClassDefinition.constructorDecl.isSignature();
          if(v21539) {
            v21539 = !constructorFuncDecl.isSignature()
          }
          v16886 = v21539
        }
        if(v16886) {
          JAM.call(this.reportParseError, this, ["Duplicate constructor definition"])
        }
      }
      var v16887 = isAmbient$$1;
      if(!v16887) {
        v16887 = !constructorFuncDecl.isSignature()
      }
      if(v16887) {
        this.currentClassDefinition.constructorDecl = constructorFuncDecl
      }
      constructorFuncDecl.fncFlags = constructorFuncDecl.fncFlags | TypeScript$$14.FncFlags.ClassMethod;
      JAM.set(this.currentClassDefinition.members.members, this.currentClassDefinition.members.members.length, constructorFuncDecl);
      this.parsingClassConstructorDefinition = false;
      return constructorFuncDecl
    }
    function v564(classDecl$$5, errorRecoverySet$$17, parentModifiers$$2) {
      var modifiers$$5 = parentModifiers$$2;
      var resetModifiers = false;
      var membersMinChar$$1 = this.scanner.startPos;
      JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.OpenBrace, errorRecoverySet$$17]);
      this.nestingLevel = this.nestingLevel + 1;
      var currentMemberMinChar = this.scanner.startPos;
      var wasGetOrSetId = false;
      var v21545 = this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBrace;
      if(!v21545) {
        v21545 = this.currentToken.tokenId == TypeScript$$14.TokenID.EndOfFile
      }
      var v8991 = !v21545;
      for(;v8991;) {
        var scanNext = true;
        var publicOrPrivateFlags = TypeScript$$14.Modifiers.Public | TypeScript$$14.Modifiers.Private;
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Get) {
          if(modifiers$$5 & TypeScript$$14.Modifiers.Getter) {
            JAM.call(this.reportParseError, this, ["Duplicate 'get' declaration in class body"])
          }
          if(modifiers$$5 & TypeScript$$14.Modifiers.Setter) {
            JAM.call(this.reportParseError, this, ["Getter already marked as a setter"])
          }
          modifiers$$5 = modifiers$$5 | TypeScript$$14.Modifiers.Getter
        }else {
          if(this.currentToken.tokenId == TypeScript$$14.TokenID.Set) {
            if(modifiers$$5 & TypeScript$$14.Modifiers.Setter) {
              JAM.call(this.reportParseError, this, ["Duplicate 'set' declaration in class body"])
            }
            if(modifiers$$5 & TypeScript$$14.Modifiers.Getter) {
              JAM.call(this.reportParseError, this, ["Setter already marked as a getter"])
            }
            modifiers$$5 = modifiers$$5 | TypeScript$$14.Modifiers.Setter
          }else {
            if(this.currentToken.tokenId == TypeScript$$14.TokenID.Private) {
              if(modifiers$$5 & publicOrPrivateFlags) {
                JAM.call(this.reportParseError, this, ["Multiple modifiers may not be applied to class members"])
              }
              modifiers$$5 = modifiers$$5 | TypeScript$$14.Modifiers.Private
            }else {
              if(this.currentToken.tokenId == TypeScript$$14.TokenID.Public) {
                if(modifiers$$5 & publicOrPrivateFlags) {
                  JAM.call(this.reportParseError, this, ["Multiple modifiers may not be applied to class members"])
                }
                modifiers$$5 = modifiers$$5 | TypeScript$$14.Modifiers.Public
              }else {
                if(this.currentToken.tokenId == TypeScript$$14.TokenID.Static) {
                  if(modifiers$$5 & TypeScript$$14.Modifiers.Static) {
                    JAM.call(this.reportParseError, this, ["Multiple modifiers may not be applied to class members"])
                  }
                  modifiers$$5 = modifiers$$5 | TypeScript$$14.Modifiers.Static
                }else {
                  if(this.currentToken.tokenId == TypeScript$$14.TokenID.Constructor) {
                    if(modifiers$$5 != parentModifiers$$2) {
                      JAM.call(this.reportParseError, this, ["Constructors may not have modifiers"])
                    }
                    JAM.call(this.parseClassConstructorDeclaration, this, [currentMemberMinChar, errorRecoverySet$$17, modifiers$$5]);
                    scanNext = false;
                    resetModifiers = true
                  }else {
                    var v16919 = wasGetOrSetId;
                    if(!v16919) {
                      var v21568 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
                      if(!v21568) {
                        v21568 = JAM.call(TypeScript$$14.convertTokToIDName, TypeScript$$14, [this.currentToken])
                      }
                      v16919 = v21568
                    }
                    if(v16919) {
                      var v8963;
                      if(wasGetOrSetId) {
                        var v16920;
                        if(modifiers$$5 & TypeScript$$14.Modifiers.Getter) {
                          v16920 = "get"
                        }else {
                          v16920 = "set"
                        }
                        v8963 = v16920
                      }else {
                        v8963 = this.currentToken.getText()
                      }
                      var idText = v8963;
                      var v8964;
                      if(wasGetOrSetId) {
                        v8964 = JAM.new(TypeScript$$14.Identifier, [idText])
                      }else {
                        var v16923 = TypeScript$$14.Identifier;
                        v8964 = JAM.call(v16923.fromToken, v16923, [this.currentToken])
                      }
                      var id$$11 = v8964;
                      id$$11.minChar = this.scanner.startPos;
                      id$$11.limChar = this.scanner.pos;
                      if(wasGetOrSetId) {
                        var v16925;
                        if(modifiers$$5 & TypeScript$$14.Modifiers.Getter) {
                          v16925 = TypeScript$$14.Modifiers.Getter
                        }else {
                          v16925 = TypeScript$$14.Modifiers.Setter
                        }
                        modifiers$$5 = modifiers$$5 ^ v16925;
                        wasGetOrSetId = false
                      }else {
                        var v27249 = this.scanner.scan();
                        this.currentToken = v27249
                      }
                      if(this.currentToken.tokenId == TypeScript$$14.TokenID.OpenParen) {
                        JAM.call(this.parseClassMemberFunctionDeclaration, this, [id$$11, currentMemberMinChar, errorRecoverySet$$17, modifiers$$5]);
                        scanNext = false
                      }else {
                        var v16928 = modifiers$$5 & TypeScript$$14.Modifiers.Getter;
                        if(!v16928) {
                          v16928 = modifiers$$5 & TypeScript$$14.Modifiers.Setter
                        }
                        if(v16928) {
                          JAM.call(this.reportParseError, this, ["Property accessors must be functions"])
                        }
                        var varDecl$$6 = JAM.call(this.parseClassMemberVariableDeclaration, this, [id$$11, currentMemberMinChar, false, errorRecoverySet$$17, modifiers$$5]);
                        var v16929 = varDecl$$6.init;
                        if(v16929) {
                          v16929 = varDecl$$6.init.nodeType == TypeScript$$14.NodeType.FuncDecl
                        }
                        if(v16929) {
                          if(this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBrace) {
                            scanNext = false
                          }
                        }else {
                          var v16932 = varDecl$$6.init;
                          if(v16932) {
                            var v21583 = varDecl$$6.init.nodeType == TypeScript$$14.NodeType.ObjectLit;
                            if(v21583) {
                              v21583 = this.currentToken.tokenId != TypeScript$$14.TokenID.Semicolon
                            }
                            v16932 = v21583
                          }
                          if(v16932) {
                            scanNext = false;
                            var v8971 = varDecl$$6.init;
                            v8971.flags = v8971.flags | TypeScript$$14.ASTFlags.AutomaticSemicolon
                          }else {
                            if(this.currentToken.tokenId != TypeScript$$14.TokenID.Semicolon) {
                              JAM.call(this.reportParseError, this, ["Expected ';'"]);
                              scanNext = false
                            }
                          }
                        }
                      }
                      resetModifiers = true
                    }else {
                      if(this.currentToken.tokenId == TypeScript$$14.TokenID.Super) {
                        JAM.call(this.reportParseError, this, ["Base class initializers must be the first statement in a class definition"])
                      }else {
                        var v16937 = !wasGetOrSetId;
                        if(v16937) {
                          var v24071 = modifiers$$5 & TypeScript$$14.Modifiers.Getter;
                          if(!v24071) {
                            v24071 = modifiers$$5 & TypeScript$$14.Modifiers.Setter
                          }
                          var v21590 = v24071;
                          if(v21590) {
                            var v24072 = this.currentToken.tokenId == TypeScript$$14.TokenID.OpenParen;
                            if(!v24072) {
                              var v25313 = this.currentToken.tokenId == TypeScript$$14.TokenID.Equals;
                              if(!v25313) {
                                var v26010 = this.currentToken.tokenId == TypeScript$$14.TokenID.Colon;
                                if(!v26010) {
                                  v26010 = this.currentToken.tokenId == TypeScript$$14.TokenID.Semicolon
                                }
                                v25313 = v26010
                              }
                              v24072 = v25313
                            }
                            v21590 = v24072
                          }
                          v16937 = v21590
                        }
                        if(v16937) {
                          wasGetOrSetId = true;
                          scanNext = false
                        }else {
                          if(this.currentToken.tokenId != TypeScript$$14.TokenID.Semicolon) {
                            JAM.call(this.reportParseError, this, ["Unexpected '" + this.currentToken.getText() + "' in class definition"]);
                            resetModifiers = true
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if(scanNext) {
          var v27250 = this.scanner.scan();
          this.currentToken = v27250;
          if(this.currentToken === undefined) {
            var v27251 = this.scanner.scan();
            this.currentToken = v27251
          }
        }
        if(resetModifiers) {
          modifiers$$5 = parentModifiers$$2;
          currentMemberMinChar = this.scanner.startPos;
          resetModifiers = false
        }
        var v21594 = this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBrace;
        if(!v21594) {
          v21594 = this.currentToken.tokenId == TypeScript$$14.TokenID.EndOfFile
        }
        v8991 = !v21594
      }
      var membersLimChar = this.scanner.pos;
      if(this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBrace) {
        var v8993 = classDecl$$5;
        var v27252 = new TypeScript$$14.ASTSpan;
        v8993.endingToken = v27252;
        classDecl$$5.endingToken.minChar = this.scanner.startPos;
        classDecl$$5.endingToken.limChar = this.scanner.pos;
        if(!this.currentClassDefinition.members.members.length) {
          var v8996 = this.currentClassDefinition;
          var v27253 = this.parseComments();
          v8996.preComments = v27253
        }
        var v27254 = this.scanner.scan();
        this.currentToken = v27254
      }
      this.nestingLevel = this.nestingLevel - 1;
      this.currentClassDefinition.members.minChar = membersMinChar$$1;
      this.currentClassDefinition.members.limChar = membersLimChar;
      this.currentClassDefinition.limChar = membersLimChar;
      this.currentClassDefinition = null;
      return
    }
    function v563(errorRecoverySet$$16, minChar$$15, modifiers$$4) {
      var leftCurlyCount$$3 = this.scanner.leftCurlyCount;
      var rightCurlyCount$$3 = this.scanner.rightCurlyCount;
      if((modifiers$$4 & TypeScript$$14.Modifiers.Readonly) != TypeScript$$14.Modifiers.None) {
        JAM.call(this.reportParseError, this, ["const modifier is implicit for class"])
      }
      var v16954 = this.parsingDeclareFile;
      if(!v16954) {
        v16954 = this.ambientModule
      }
      if(v16954) {
        modifiers$$4 = modifiers$$4 | TypeScript$$14.Modifiers.Ambient;
        modifiers$$4 = modifiers$$4 | TypeScript$$14.Modifiers.Exported
      }
      var v9007 = this.parsingDeclareFile;
      if(!v9007) {
        v9007 = (modifiers$$4 & TypeScript$$14.Modifiers.Ambient) != TypeScript$$14.Modifiers.None
      }
      var classIsMarkedAsAmbient = v9007;
      var svAmbientClass = this.ambientClass;
      this.ambientClass = classIsMarkedAsAmbient;
      var v27255 = this.scanner.scan();
      this.currentToken = v27255;
      var name$$50 = null;
      var v16960 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
      if(!v16960) {
        var v21607 = !JAM.call(TypeScript$$14.isPrimitiveTypeToken, TypeScript$$14, [this.currentToken]);
        if(v21607) {
          v21607 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
        }
        v16960 = v21607
      }
      if(v16960) {
        var v9009 = TypeScript$$14.Identifier;
        name$$50 = JAM.call(v9009.fromToken, v9009, [this.currentToken]);
        name$$50.minChar = this.scanner.startPos;
        name$$50.limChar = this.scanner.pos;
        var v27256 = this.scanner.scan();
        this.currentToken = v27256
      }else {
        JAM.call(this.reportParseError, this, ["class missing name"]);
        if(this.errorRecovery) {
          name$$50 = new TypeScript$$14.MissingIdentifier;
          name$$50.minChar = this.scanner.pos;
          name$$50.limChar = this.scanner.pos;
          name$$50.flags = name$$50.flags | TypeScript$$14.ASTFlags.Error
        }
      }
      var extendsList$$5 = null;
      var implementsList$$4 = null;
      var requiresSignature$$2 = false;
      var v16963 = this.currentToken.tokenId == TypeScript$$14.TokenID.Extends;
      if(!v16963) {
        v16963 = this.currentToken.tokenId == TypeScript$$14.TokenID.Implements
      }
      if(v16963) {
        extendsList$$5 = new TypeScript$$14.ASTList;
        implementsList$$4 = new TypeScript$$14.ASTList;
        JAM.call(this.parseBaseList, this, [extendsList$$5, implementsList$$4, errorRecoverySet$$16, true])
      }
      var classDecl$$4 = JAM.new(TypeScript$$14.ClassDeclaration, [name$$50, new TypeScript$$14.ASTList, extendsList$$5, implementsList$$4]);
      this.currentClassDefinition = classDecl$$4;
      JAM.call(this.parseClassElements, this, [classDecl$$4, errorRecoverySet$$16, modifiers$$4]);
      var v16965 = this.ambientModule;
      if(!v16965) {
        var v21615 = this.parsingDeclareFile;
        if(!v21615) {
          v21615 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$4, TypeScript$$14.Modifiers.Exported])
        }
        v16965 = v21615
      }
      if(v16965) {
        classDecl$$4.varFlags = classDecl$$4.varFlags | TypeScript$$14.VarFlags.Exported
      }
      var v16968 = this.ambientModule;
      if(!v16968) {
        v16968 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$4, TypeScript$$14.Modifiers.Ambient])
      }
      if(v16968) {
        classDecl$$4.varFlags = classDecl$$4.varFlags | TypeScript$$14.VarFlags.Ambient
      }
      classDecl$$4.varFlags = classDecl$$4.varFlags | TypeScript$$14.VarFlags.Class;
      this.ambientClass = svAmbientClass;
      classDecl$$4.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount$$3;
      classDecl$$4.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount$$3;
      return classDecl$$4
    }
    function v562(extendsList$$4, implementsList$$3, errorRecoverySet$$15, isClass) {
      var keyword = true;
      var currentList = extendsList$$4;
      for(;;) {
        if(keyword) {
          if(this.currentToken.tokenId === TypeScript$$14.TokenID.Implements) {
            currentList = implementsList$$3
          }else {
            var v16977 = this.currentToken.tokenId == TypeScript$$14.TokenID.Extends;
            if(v16977) {
              v16977 = !this.requiresExtendsBlock
            }
            if(v16977) {
              this.requiresExtendsBlock = isClass
            }
          }
          var v27257 = this.scanner.scan();
          this.currentToken = v27257;
          keyword = false
        }
        var baseName$$3 = null;
        var v16978 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
        if(!v16978) {
          v16978 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
        }
        if(v16978) {
          var minChar$$14 = this.scanner.startPos;
          var v9032 = TypeScript$$14.Identifier;
          baseName$$3 = JAM.call(v9032.fromToken, v9032, [this.currentToken]);
          baseName$$3.minChar = minChar$$14;
          baseName$$3.limChar = this.scanner.pos;
          baseName$$3 = JAM.call(this.parseNamedType, this, [errorRecoverySet$$15 | TypeScript$$14.ErrorRecoverySet.LCurly, minChar$$14, baseName$$3, false])
        }else {
          JAM.call(this.reportParseError, this, ["Expected base name"]);
          if(this.errorRecovery) {
            baseName$$3 = new TypeScript$$14.MissingIdentifier;
            baseName$$3.minChar = this.scanner.pos;
            baseName$$3.limChar = this.scanner.pos;
            baseName$$3.flags = baseName$$3.flags | TypeScript$$14.ASTFlags.Error
          }
        }
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.OpenParen) {
          if(isClass) {
            JAM.call(this.reportParseError, this, ["Base classes may only be initialized via a 'super' call within the constructor body"])
          }else {
            JAM.call(this.reportParseError, this, ["Interfaces may not be extended with a call expression"])
          }
        }else {
          JAM.call(currentList.append, currentList, [baseName$$3])
        }
        var v16984 = isClass;
        if(v16984) {
          var v21636 = currentList == extendsList$$4;
          if(v21636) {
            v21636 = extendsList$$4.members.length > 1
          }
          v16984 = v21636
        }
        if(v16984) {
          JAM.call(this.reportParseError, this, ["A class may only extend one other class"])
        }
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Comma) {
          var v27258 = this.scanner.scan();
          this.currentToken = v27258;
          continue
        }else {
          var v16987 = this.currentToken.tokenId == TypeScript$$14.TokenID.Extends;
          if(!v16987) {
            v16987 = this.currentToken.tokenId == TypeScript$$14.TokenID.Implements
          }
          if(v16987) {
            var v16988 = this.currentToken.tokenId == TypeScript$$14.TokenID.Extends;
            if(v16988) {
              v16988 = !this.requiresExtendsBlock
            }
            if(v16988) {
              this.requiresExtendsBlock = isClass
            }
            currentList = extendsList$$4;
            keyword = true;
            continue
          }
        }
        break
      }
      return
    }
    function v561(errorRecoverySet$$14) {
      var args$$8 = new TypeScript$$14.ASTList;
      args$$8.minChar = this.scanner.startPos;
      var v27259 = this.scanner.scan();
      this.currentToken = v27259;
      if(this.currentToken.tokenId !== TypeScript$$14.TokenID.CloseParen) {
        for(;true;) {
          if(args$$8.members.length > 65535) {
            JAM.call(this.reportParseError, this, ["max number of args exceeded"]);
            break
          }
          var arg$$10 = JAM.call(this.parseExpr, this, [TypeScript$$14.ErrorRecoverySet.Comma | errorRecoverySet$$14, TypeScript$$14.OperatorPrecedence.Comma, true, TypeContext.NoTypes]);
          JAM.call(args$$8.append, args$$8, [arg$$10]);
          if(this.currentToken.tokenId != TypeScript$$14.TokenID.Comma) {
            break
          }
          var v27260 = this.scanner.scan();
          this.currentToken = v27260
        }
      }
      args$$8.limChar = this.scanner.pos;
      return args$$8
    }
    function v560(ast$$37) {
      var result$$9;
      switch(ast$$37.nodeType) {
        case TypeScript$$14.NodeType.TypeRef:
          return ast$$37;
        case TypeScript$$14.NodeType.Name:
          result$$9 = JAM.new(TypeScript$$14.TypeReference, [ast$$37, 0]);
          result$$9.minChar = ast$$37.minChar;
          result$$9.limChar = ast$$37.limChar;
          return result$$9;
        case TypeScript$$14.NodeType.Index:
          var expr$$4 = ast$$37;
          result$$9 = JAM.call(this.convertToTypeReference, this, [expr$$4.operand1]);
          if(result$$9) {
            result$$9.arrayCount = result$$9.arrayCount + 1;
            result$$9.minChar = expr$$4.minChar;
            result$$9.limChar = expr$$4.limChar;
            return result$$9
          }else {
            var etr$$1 = JAM.new(TypeScript$$14.AST, [TypeScript$$14.NodeType.Error]);
            return etr$$1
          }
      }
      return null
    }
    function v559(errorRecoverySet$$13, isDecl, requiresSignature$$1, isMethod$$1, methodName, indexer, isStatic, markedAsAmbient, modifiers$$3, lambdaArgContext, expectClosingRParen$$1) {
      var leftCurlyCount$$2 = this.scanner.leftCurlyCount;
      var rightCurlyCount$$2 = this.scanner.rightCurlyCount;
      var prevInConstr = this.parsingClassConstructorDefinition;
      this.parsingClassConstructorDefinition = false;
      var name$$49 = null;
      var fnMin = this.scanner.startPos;
      var minChar$$13 = this.scanner.pos;
      var prevNestingLevel = this.nestingLevel;
      var preComments$$2 = this.parseComments();
      var isLambda$$1 = !!lambdaArgContext;
      this.nestingLevel = 0;
      var v16998 = !this.style_funcInLoop;
      if(v16998) {
        v16998 = this.inLoop()
      }
      if(v16998) {
        JAM.call(this.reportParseStyleError, this, ["function declaration in loop"])
      }
      var v16999 = !isMethod$$1;
      if(v16999) {
        var v21654 = !isStatic;
        if(v21654) {
          var v24105 = !indexer;
          if(v24105) {
            v24105 = !lambdaArgContext
          }
          v21654 = v24105
        }
        v16999 = v21654
      }
      if(v16999) {
        var v27261 = this.scanner.scan();
        this.currentToken = v27261;
        this.state = ParseState.StartFncDecl;
        var v17000 = this.currentToken.tokenId != TypeScript$$14.TokenID.Identifier;
        if(v17000) {
          v17000 = !JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
        }
        if(v17000) {
          if(isDecl) {
            JAM.call(this.reportParseError, this, ["Function declaration must include identifier"]);
            this.nestingLevel = prevNestingLevel;
            return JAM.new(TypeScript$$14.IncompleteAST, [fnMin, this.scanner.pos])
          }
        }else {
          var v9072 = TypeScript$$14.Identifier;
          name$$49 = JAM.call(v9072.fromToken, v9072, [this.currentToken]);
          name$$49.minChar = this.scanner.startPos;
          name$$49.limChar = this.scanner.pos;
          var v27262 = this.scanner.scan();
          this.currentToken = v27262
        }
      }else {
        if(methodName) {
          name$$49 = methodName
        }
      }
      this.state = ParseState.FncDeclName;
      var args$$7 = new TypeScript$$14.ASTList;
      var variableArgList$$1 = false;
      var isOverload = false;
      var isGetter$$1 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$3, TypeScript$$14.Modifiers.Getter]);
      var isSetter$$1 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$3, TypeScript$$14.Modifiers.Setter]);
      var v17004 = this.currentToken.tokenId == TypeScript$$14.TokenID.OpenParen;
      if(!v17004) {
        var v24112 = indexer;
        if(v24112) {
          v24112 = this.currentToken.tokenId == TypeScript$$14.TokenID.OpenBracket
        }
        var v21660 = v24112;
        if(!v21660) {
          var v24113 = lambdaArgContext;
          if(v24113) {
            var v25325 = lambdaArgContext.preProcessedLambdaArgs;
            if(!v25325) {
              v25325 = this.currentToken.tokenId == TypeScript$$14.TokenID.DotDotDot
            }
            v24113 = v25325
          }
          v21660 = v24113
        }
        v17004 = v21660
      }
      if(v17004) {
        var v17005;
        if(lambdaArgContext) {
          v17005 = lambdaArgContext.preProcessedLambdaArgs
        }else {
          v17005 = null
        }
        variableArgList$$1 = JAM.call(this.parseFormalParameterList, this, [errorRecoverySet$$13, args$$7, false, requiresSignature$$1, indexer, isGetter$$1, isSetter$$1, isLambda$$1, v17005, expectClosingRParen$$1])
      }
      this.state = ParseState.FncDeclArgs;
      var returnType$$1 = null;
      if(this.currentToken.tokenId == TypeScript$$14.TokenID.Colon) {
        var v27263 = this.scanner.scan();
        this.currentToken = v27263;
        if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$3, TypeScript$$14.Modifiers.Setter])) {
          JAM.call(this.reportParseError, this, ["Property setters may not declare a return type"])
        }
        returnType$$1 = JAM.call(this.parseTypeReference, this, [errorRecoverySet$$13, true])
      }
      var v17009 = indexer;
      if(v17009) {
        v17009 = args$$7.members.length == 0
      }
      if(v17009) {
        JAM.call(this.reportParseError, this, ["Index signatures require a parameter type to be specified"])
      }
      this.state = ParseState.FncDeclReturnType;
      var v17010 = isLambda$$1;
      if(v17010) {
        v17010 = this.currentToken.tokenId != TypeScript$$14.TokenID.EqualsGreaterThan
      }
      if(v17010) {
        JAM.call(this.reportParseError, this, ["Expected '=>'"])
      }
      var v17011 = isDecl;
      if(v17011) {
        var v25326 = this.parsingDeclareFile;
        if(!v25326) {
          v25326 = markedAsAmbient
        }
        var v21668 = !v25326;
        if(v21668) {
          var v25327 = !isMethod$$1;
          if(!v25327) {
            var v26410 = this.ambientModule;
            if(!v26410) {
              var v26570 = this.ambientClass;
              if(!v26570) {
                v26570 = this.inInterfaceDecl
              }
              v26410 = v26570
            }
            v25327 = !v26410
          }
          var v24119 = v25327;
          if(v24119) {
            v24119 = this.currentToken.tokenId == TypeScript$$14.TokenID.Semicolon
          }
          v21668 = v24119
        }
        v17011 = v21668
      }
      if(v17011) {
        isOverload = true;
        isDecl = false;
        requiresSignature$$1 = true
      }
      var svInFncDecl = this.inFncDecl;
      this.inFncDecl = true;
      var funcDecl$$7 = JAM.call(this.parseFunctionStatements, this, [errorRecoverySet$$13 | TypeScript$$14.ErrorRecoverySet.RCurly, name$$49, false, isMethod$$1, args$$7, TypeScript$$14.AllowedElements.None, minChar$$13, requiresSignature$$1, TypeScript$$14.Modifiers.None]);
      this.inFncDecl = svInFncDecl;
      funcDecl$$7.variableArgList = variableArgList$$1;
      funcDecl$$7.isOverload = isOverload;
      if(!requiresSignature$$1) {
        funcDecl$$7.fncFlags = funcDecl$$7.fncFlags | TypeScript$$14.FncFlags.Definition
      }
      if(isStatic) {
        funcDecl$$7.fncFlags = funcDecl$$7.fncFlags | TypeScript$$14.FncFlags.Static
      }
      if(requiresSignature$$1) {
        funcDecl$$7.fncFlags = funcDecl$$7.fncFlags | TypeScript$$14.FncFlags.Signature
      }
      if(indexer) {
        funcDecl$$7.fncFlags = funcDecl$$7.fncFlags | TypeScript$$14.FncFlags.IndexerMember
      }
      funcDecl$$7.returnTypeAnnotation = returnType$$1;
      if(isMethod$$1) {
        funcDecl$$7.fncFlags = funcDecl$$7.fncFlags | TypeScript$$14.FncFlags.Method;
        funcDecl$$7.fncFlags = funcDecl$$7.fncFlags | TypeScript$$14.FncFlags.ClassPropertyMethodExported
      }
      funcDecl$$7.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount$$2;
      funcDecl$$7.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount$$2;
      this.nestingLevel = prevNestingLevel;
      this.parsingClassConstructorDefinition = prevInConstr;
      funcDecl$$7.preComments = preComments$$2;
      return funcDecl$$7
    }
    function v558(errorRecoverySet$$12, formals$$2, isClassConstr, isSig, isIndexer, isGetter, isSetter, isLambda, preProcessedLambdaArgs, expectClosingRParen) {
      formals$$2.minChar = this.scanner.startPos;
      if(isIndexer) {
        var v27264 = this.scanner.scan();
        this.currentToken = v27264
      }else {
        if(!isLambda) {
          JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.OpenParen, errorRecoverySet$$12 | TypeScript$$14.ErrorRecoverySet.RParen])
        }
      }
      var sawEllipsis = false;
      var firstArg = true;
      var hasOptional = false;
      var haveFirstArgID = false;
      var v17031 = isLambda;
      if(v17031) {
        var v21677 = preProcessedLambdaArgs;
        if(v21677) {
          v21677 = preProcessedLambdaArgs.nodeType != TypeScript$$14.NodeType.EmptyExpr
        }
        v17031 = v21677
      }
      if(v17031) {
        hasOptional = JAM.call(this.transformAnonymousArgsIntoFormals, this, [formals$$2, preProcessedLambdaArgs]);
        haveFirstArgID = true
      }
      for(;true;) {
        var munchedArg = false;
        var argFlags = TypeScript$$14.VarFlags.None;
        var argMinChar = this.scanner.startPos;
        var v17032 = this.inferPropertiesFromThisAssignment;
        if(v17032) {
          v17032 = this.currentToken.tokenId == TypeScript$$14.TokenID.This
        }
        if(v17032) {
          if(!isClassConstr) {
            JAM.call(this.reportParseError, this, ["Instance property declarations using 'this' may only be used in class constructors"])
          }
          var v27265 = this.scanner.scan();
          this.currentToken = v27265;
          argFlags = argFlags | TypeScript$$14.VarFlags.Public | TypeScript$$14.VarFlags.Property;
          if(this.currentClassDefinition) {
            var v9106 = this.currentClassDefinition;
            v9106.varFlags = v9106.varFlags | TypeScript$$14.VarFlags.ClassSuperMustBeFirstCallInConstructor
          }
        }
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Public) {
          argFlags = argFlags | TypeScript$$14.VarFlags.Public | TypeScript$$14.VarFlags.Property;
          if(this.currentClassDefinition) {
            var v9109 = this.currentClassDefinition;
            v9109.varFlags = v9109.varFlags | TypeScript$$14.VarFlags.ClassSuperMustBeFirstCallInConstructor
          }
        }else {
          if(this.currentToken.tokenId == TypeScript$$14.TokenID.Private) {
            argFlags = argFlags | TypeScript$$14.VarFlags.Private | TypeScript$$14.VarFlags.Property;
            if(this.currentClassDefinition) {
              var v9111 = this.currentClassDefinition;
              v9111.varFlags = v9111.varFlags | TypeScript$$14.VarFlags.ClassSuperMustBeFirstCallInConstructor
            }
          }else {
            var v17040 = this.currentToken.tokenId == TypeScript$$14.TokenID.Static;
            if(v17040) {
              v17040 = isClassConstr
            }
            if(v17040) {
              JAM.call(this.reportParseError, this, ["Static properties can not be declared as parameter properties"]);
              var v27266 = this.scanner.scan();
              this.currentToken = v27266
            }
          }
        }
        if(argFlags != TypeScript$$14.VarFlags.None) {
          if(!isClassConstr) {
            JAM.call(this.reportParseError, this, ["only constructor parameters can be properties"])
          }
          var v27267 = this.scanner.scan();
          this.currentToken = v27267;
          if(JAM.call(TypeScript$$14.isModifier, TypeScript$$14, [this.currentToken])) {
            JAM.call(this.reportParseError, this, ["Multiple modifiers may not be applied to parameters"]);
            var v27268 = this.scanner.scan();
            this.currentToken = v27268
          }
          var v17043 = this.inferPropertiesFromThisAssignment;
          if(v17043) {
            v17043 = this.currentToken.tokenId == TypeScript$$14.TokenID.This
          }
          if(v17043) {
            if(!isClassConstr) {
              JAM.call(this.reportParseError, this, ["Instance property declarations using 'this' may only be used in class constructors"])
            }
            var v27269 = this.scanner.scan();
            this.currentToken = v27269;
            var v27270 = this.scanner.scan();
            this.currentToken = v27270
          }
        }else {
          if(this.currentToken.tokenId == TypeScript$$14.TokenID.DotDotDot) {
            sawEllipsis = true;
            var v27271 = this.scanner.scan();
            this.currentToken = v27271;
            var v17046 = !(this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier);
            if(!v17046) {
              v17046 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
            }
            if(v17046) {
              JAM.call(this.reportParseError, this, ["'...' parameters require both a parameter name and an array type annotation to be specified"]);
              sawEllipsis = false
            }
          }
        }
        var argId = null;
        var v21707 = !haveFirstArgID;
        if(v21707) {
          v21707 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier
        }
        var v17047 = v21707;
        if(!v17047) {
          v17047 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
        }
        if(v17047) {
          var v9129 = TypeScript$$14.Identifier;
          argId = JAM.call(v9129.fromToken, v9129, [this.currentToken]);
          argId.minChar = this.scanner.startPos;
          argId.limChar = this.scanner.pos
        }
        if(haveFirstArgID || argId) {
          munchedArg = true;
          var type$$30 = null;
          var arg$$9 = null;
          var v17048 = haveFirstArgID;
          if(v17048) {
            v17048 = formals$$2.members.length
          }
          if(v17048) {
            arg$$9 = formals$$2.members[formals$$2.members.length - 1];
            if(arg$$9.isOptional) {
              hasOptional = true
            }
          }else {
            arg$$9 = JAM.new(TypeScript$$14.ArgDecl, [argId]);
            if(isGetter) {
              JAM.call(this.reportParseError, this, ["Property getters may not take any arguments"])
            }
            var v17050 = isSetter;
            if(v17050) {
              v17050 = !firstArg
            }
            if(v17050) {
              JAM.call(this.reportParseError, this, ["Property setters may only take one argument"])
            }
            arg$$9.minChar = argMinChar;
            var v9139 = arg$$9;
            var v27272 = this.parseComments();
            v9139.preComments = v27272;
            var v27273 = this.scanner.scan();
            this.currentToken = v27273
          }
          if(this.currentToken.tokenId == TypeScript$$14.TokenID.Question) {
            arg$$9.isOptional = true;
            hasOptional = true;
            var v27274 = this.scanner.scan();
            this.currentToken = v27274
          }
          if(this.currentToken.tokenId == TypeScript$$14.TokenID.Colon) {
            var v27275 = this.scanner.scan();
            this.currentToken = v27275;
            type$$30 = JAM.call(this.parseTypeReference, this, [errorRecoverySet$$12, false])
          }
          if(this.currentToken.tokenId == TypeScript$$14.TokenID.Equals) {
            if(isSig) {
              JAM.call(this.reportParseError, this, ["Arguments in signatures may not have default values"])
            }
            hasOptional = true;
            var v27276 = this.scanner.scan();
            this.currentToken = v27276;
            var v9147 = arg$$9;
            var v27277 = JAM.call(this.parseExpr, this, [TypeScript$$14.ErrorRecoverySet.Comma | errorRecoverySet$$12, TypeScript$$14.OperatorPrecedence.Comma, false, TypeContext.NoTypes]);
            v9147.init = v27277
          }
          var v17060 = hasOptional;
          if(v17060) {
            var v21721 = !arg$$9.isOptionalArg();
            if(v21721) {
              v21721 = !sawEllipsis
            }
            v17060 = v21721
          }
          if(v17060) {
            JAM.call(this.reportParseError, this, ["Optional parameters may only be followed by other optional parameters"])
          }
          var v17061 = sawEllipsis;
          if(v17061) {
            v17061 = arg$$9.isOptionalArg()
          }
          if(v17061) {
            JAM.call(this.reportParseError, this, ["Varargs may not be optional or have default parameters"])
          }
          var v17062 = sawEllipsis;
          if(v17062) {
            v17062 = !type$$30
          }
          if(v17062) {
            JAM.call(this.reportParseError, this, ["'...' parameters require both a parameter name and an array type annotation to be specified"])
          }
          var v9152 = arg$$9;
          var v27278 = this.parseComments();
          v9152.postComments = v27278;
          arg$$9.typeExpr = type$$30;
          var v9153 = arg$$9;
          var v27279 = this.scanner.lastTokenLimChar();
          v9153.limChar = v27279;
          arg$$9.varFlags = arg$$9.varFlags | argFlags;
          if(!haveFirstArgID) {
            JAM.call(formals$$2.append, formals$$2, [arg$$9])
          }else {
            haveFirstArgID = false
          }
        }
        firstArg = false;
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Comma) {
          var v17067 = munchedArg;
          if(v17067) {
            v17067 = !sawEllipsis
          }
          if(v17067) {
            var v27280 = this.scanner.scan();
            this.currentToken = v27280
          }else {
            JAM.call(this.reportParseError, this, ["Unexpected ',' in argument list"]);
            if(this.errorRecovery) {
              var v27281 = this.scanner.scan();
              this.currentToken = v27281
            }
          }
        }else {
          break
        }
      }
      if(isIndexer) {
        JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBracket, errorRecoverySet$$12 | TypeScript$$14.ErrorRecoverySet.LCurly | TypeScript$$14.ErrorRecoverySet.SColon])
      }else {
        if(expectClosingRParen) {
          JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseParen, errorRecoverySet$$12 | TypeScript$$14.ErrorRecoverySet.LCurly | TypeScript$$14.ErrorRecoverySet.SColon])
        }
      }
      var v9165 = formals$$2;
      var v27282 = this.scanner.lastTokenLimChar();
      v9165.limChar = v27282;
      return sawEllipsis
    }
    function v557(formals$$1, argList) {
      function translateBinExOperand(operand$$1) {
        if(operand$$1.nodeType == TypeScript$$14.NodeType.Comma) {
          return JAM.call(_this$$1.transformAnonymousArgsIntoFormals, _this$$1, [formals$$1, operand$$1])
        }else {
          var v17077 = operand$$1.nodeType == TypeScript$$14.NodeType.Name;
          if(!v17077) {
            v17077 = operand$$1.nodeType == TypeScript$$14.NodeType.Asg
          }
          if(v17077) {
            var v9166;
            if(operand$$1.nodeType == TypeScript$$14.NodeType.Asg) {
              v9166 = operand$$1.operand1
            }else {
              v9166 = operand$$1
            }
            var opArg = v9166;
            var arg$$8 = JAM.new(TypeScript$$14.ArgDecl, [opArg]);
            arg$$8.preComments = opArg.preComments;
            arg$$8.postComments = opArg.postComments;
            arg$$8.minChar = operand$$1.minChar;
            arg$$8.limChar = operand$$1.limChar;
            if(JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [opArg.flags, TypeScript$$14.ASTFlags.PossibleOptionalParameter])) {
              arg$$8.isOptional = true
            }
            if(operand$$1.nodeType == TypeScript$$14.NodeType.Asg) {
              arg$$8.init = operand$$1.operand2
            }
            JAM.call(formals$$1.append, formals$$1, [arg$$8]);
            var v9170 = arg$$8.isOptional;
            if(!v9170) {
              v9170 = arg$$8.init
            }
            return v9170
          }else {
            JAM.call(_this$$1.reportParseError, _this$$1, ["Invalid lambda argument"])
          }
        }
        return false
      }
      var _this$$1 = this;
      if(argList) {
        if(argList.nodeType == TypeScript$$14.NodeType.Comma) {
          var commaList = argList;
          if(commaList.operand1.isParenthesized) {
            JAM.call(this.reportParseError, this, ["Invalid lambda argument", commaList.operand1.minChar, commaList.operand1.limChar])
          }
          if(commaList.operand2.isParenthesized) {
            JAM.call(this.reportParseError, this, ["Invalid lambda argument", commaList.operand2.minChar, commaList.operand2.limChar])
          }
          var isOptional = translateBinExOperand(commaList.operand1);
          var v9180 = translateBinExOperand(commaList.operand2);
          if(!v9180) {
            v9180 = isOptional
          }
          isOptional = v9180;
          return isOptional
        }else {
          return translateBinExOperand(argList)
        }
      }
      return
    }
    function v556(errorRecoverySet$$11, name$$48, isConstructor$$1, isMethod, args$$6, allowedElements$$1, minChar$$12, requiresSignature, parentModifiers$$1) {
      this.pushDeclLists();
      var svStmtStack = this.statementInfoStack;
      this.resetStmtStack();
      var bod$$2 = null;
      var wasShorthand = false;
      var isAnonLambda = false;
      var limChar$$6;
      if(requiresSignature) {
        limChar$$6 = this.scanner.pos;
        if(this.currentToken.tokenId === TypeScript$$14.TokenID.OpenBrace) {
          JAM.call(this.reportParseError, this, ["Function declarations are not permitted within interfaces, ambient modules or classes"]);
          bod$$2 = new TypeScript$$14.ASTList;
          var bodMinChar$$1 = this.scanner.startPos;
          JAM.call(this.parseFunctionBlock, this, [errorRecoverySet$$11, allowedElements$$1, parentModifiers$$1, bod$$2, bodMinChar$$1]);
          JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBrace, errorRecoverySet$$11]);
          if(this.currentToken.tokenId === TypeScript$$14.TokenID.Semicolon) {
            var v27283 = this.scanner.scan();
            this.currentToken = v27283
          }
        }else {
          JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.Semicolon, errorRecoverySet$$11, "Expected ';'"])
        }
      }else {
        bod$$2 = new TypeScript$$14.ASTList;
        bodMinChar$$1 = this.scanner.startPos;
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.EqualsGreaterThan) {
          if(isMethod) {
            JAM.call(this.reportParseError, this, ["'=>' may not be used for class methods"])
          }
          wasShorthand = true;
          var v27284 = this.scanner.scan();
          this.currentToken = v27284
        }
        var v17102 = wasShorthand;
        if(v17102) {
          v17102 = this.currentToken.tokenId != TypeScript$$14.TokenID.OpenBrace
        }
        if(v17102) {
          var retExpr = JAM.call(this.parseExpr, this, [errorRecoverySet$$11 | TypeScript$$14.ErrorRecoverySet.SColon, TypeScript$$14.OperatorPrecedence.Assignment, true, TypeContext.NoTypes]);
          var retStmt = new TypeScript$$14.ReturnStatement;
          retStmt.returnExpression = retExpr;
          retStmt.minChar = retExpr.minChar;
          retStmt.limChar = retExpr.limChar;
          bod$$2.minChar = bodMinChar$$1;
          JAM.call(bod$$2.append, bod$$2, [retStmt])
        }else {
          isAnonLambda = wasShorthand;
          JAM.call(this.parseFunctionBlock, this, [errorRecoverySet$$11, allowedElements$$1, parentModifiers$$1, bod$$2, bodMinChar$$1])
        }
        limChar$$6 = this.scanner.pos
      }
      var funcDecl$$6 = JAM.new(TypeScript$$14.FuncDecl, [name$$48, bod$$2, isConstructor$$1, args$$6, this.topVarList(), this.topScopeList(), this.topStaticsList(), TypeScript$$14.NodeType.FuncDecl]);
      this.popDeclLists();
      var scopeList = this.topScopeList();
      JAM.call(scopeList.append, scopeList, [funcDecl$$6]);
      var staticFuncDecl = false;
      if(!requiresSignature) {
        var v17106 = !wasShorthand;
        if(!v17106) {
          v17106 = isAnonLambda
        }
        if(v17106) {
          var v9205 = funcDecl$$6;
          var v27285 = new TypeScript$$14.ASTSpan;
          v9205.endingToken = v27285;
          funcDecl$$6.endingToken.minChar = this.scanner.startPos;
          funcDecl$$6.endingToken.limChar = this.scanner.pos;
          JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBrace, errorRecoverySet$$11]);
          if(isAnonLambda) {
            funcDecl$$6.fncFlags = funcDecl$$6.fncFlags | TypeScript$$14.FncFlags.IsFatArrowFunction
          }
        }else {
          funcDecl$$6.fncFlags = funcDecl$$6.fncFlags | TypeScript$$14.FncFlags.IsFatArrowFunction;
          var v9209 = funcDecl$$6;
          var v27286 = new TypeScript$$14.ASTSpan;
          v9209.endingToken = v27286;
          funcDecl$$6.endingToken.minChar = bod$$2.members[0].minChar;
          funcDecl$$6.endingToken.limChar = bod$$2.members[0].limChar
        }
      }
      funcDecl$$6.minChar = minChar$$12;
      funcDecl$$6.limChar = limChar$$6;
      if(!requiresSignature) {
        funcDecl$$6.fncFlags = funcDecl$$6.fncFlags | TypeScript$$14.FncFlags.Definition
      }
      this.statementInfoStack = svStmtStack;
      return funcDecl$$6
    }
    function v555(errorRecoverySet$$10, allowedElements, parentModifiers, bod$$1, bodMinChar) {
      this.state = ParseState.StartStatementList;
      JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.OpenBrace, errorRecoverySet$$10 | TypeScript$$14.ErrorRecoverySet.StmtStart]);
      var savedInFunction = this.inFunction;
      this.inFunction = true;
      JAM.call(this.parseStatementList, this, [errorRecoverySet$$10 | TypeScript$$14.ErrorRecoverySet.RCurly | TypeScript$$14.ErrorRecoverySet.StmtStart, bod$$1, true, false, allowedElements, parentModifiers]);
      bod$$1.minChar = bodMinChar;
      bod$$1.limChar = this.scanner.pos;
      this.inFunction = savedInFunction;
      var ec = new TypeScript$$14.EndCode;
      ec.minChar = bod$$1.limChar;
      ec.limChar = ec.minChar;
      JAM.call(bod$$1.append, bod$$1, [ec]);
      return
    }
    function v554(minChar$$11, errorRecoverySet$$9) {
      var v27287 = this.scanner.scan();
      this.currentToken = v27287;
      var members$$8 = new TypeScript$$14.ASTList;
      members$$8.minChar = minChar$$11;
      var prevInInterfaceDecl = this.inInterfaceDecl;
      this.inInterfaceDecl = true;
      JAM.call(this.parseTypeMemberList, this, [errorRecoverySet$$9 | TypeScript$$14.ErrorRecoverySet.RCurly, members$$8]);
      this.inInterfaceDecl = prevInInterfaceDecl;
      JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBrace, errorRecoverySet$$9]);
      var interfaceDecl = JAM.new(TypeScript$$14.InterfaceDeclaration, [this.anonId, members$$8, null, null]);
      interfaceDecl.minChar = minChar$$11;
      interfaceDecl.limChar = members$$8.limChar;
      return JAM.call(this.parseTypeReferenceTail, this, [errorRecoverySet$$9, minChar$$11, interfaceDecl])
    }
    function v553(errorRecoverySet$$8, allowVoid) {
      var minChar$$10 = this.scanner.startPos;
      var isConstructorMember = false;
      switch(this.currentToken.tokenId) {
        case TypeScript$$14.TokenID.Void:
          if(!allowVoid) {
            JAM.call(this.reportParseError, this, ["void not a valid type in this context"])
          }
        ;
        case TypeScript$$14.TokenID.Any:
        ;
        case TypeScript$$14.TokenID.Number:
        ;
        case TypeScript$$14.TokenID.Bool:
        ;
        case TypeScript$$14.TokenID.String:
          var v17127 = TypeScript$$14.tokenTable;
          var v17128 = this.currentToken.tokenId;
          introspect(JAM.policy.p1) {
            var v9228 = v17127[v17128]
          }
          var text$$14 = v9228.text;
          var predefinedIdentifier = JAM.new(TypeScript$$14.Identifier, [text$$14]);
          predefinedIdentifier.minChar = minChar$$10;
          predefinedIdentifier.limChar = this.scanner.pos;
          var v27288 = this.scanner.scan();
          this.currentToken = v27288;
          return JAM.call(this.parseTypeReferenceTail, this, [errorRecoverySet$$8, minChar$$10, predefinedIdentifier]);
        case TypeScript$$14.TokenID.Identifier:
          var ident = JAM.call(this.createRef, this, [this.currentToken.getText(), this.currentToken.hasEscapeSequence, minChar$$10]);
          ident.limChar = this.scanner.pos;
          return JAM.call(this.parseNamedType, this, [errorRecoverySet$$8, minChar$$10, ident, true]);
        case TypeScript$$14.TokenID.OpenBrace:
          return JAM.call(this.parseObjectType, this, [minChar$$10, errorRecoverySet$$8]);
        case TypeScript$$14.TokenID.New:
          var v27289 = this.scanner.scan();
          this.currentToken = v27289;
          if(this.currentToken.tokenId != TypeScript$$14.TokenID.OpenParen) {
            JAM.call(this.reportParseError, this, ["Expected '('"])
          }else {
            isConstructorMember = true
          }
        ;
        case TypeScript$$14.TokenID.OpenParen:
          var formals = new TypeScript$$14.ASTList;
          var variableArgList = JAM.call(this.parseFormalParameterList, this, [errorRecoverySet$$8 | TypeScript$$14.ErrorRecoverySet.RParen, formals, false, true, false, false, false, false, null, true]);
          JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.EqualsGreaterThan, errorRecoverySet$$8]);
          var returnType = JAM.call(this.parseTypeReference, this, [errorRecoverySet$$8, true]);
          var funcDecl$$5 = JAM.new(TypeScript$$14.FuncDecl, [null, null, false, formals, null, null, null, TypeScript$$14.NodeType.FuncDecl]);
          funcDecl$$5.returnTypeAnnotation = returnType;
          funcDecl$$5.variableArgList = variableArgList;
          funcDecl$$5.fncFlags = funcDecl$$5.fncFlags | TypeScript$$14.FncFlags.Signature;
          if(isConstructorMember) {
            funcDecl$$5.fncFlags = funcDecl$$5.fncFlags | TypeScript$$14.FncFlags.ConstructMember;
            funcDecl$$5.hint = "_construct";
            funcDecl$$5.classDecl = null
          }
          funcDecl$$5.minChar = minChar$$10;
          return JAM.call(this.parseTypeReferenceTail, this, [errorRecoverySet$$8, minChar$$10, funcDecl$$5]);
        default:
          JAM.call(this.reportParseError, this, ["Expected type name"]);
          var etr = JAM.new(TypeScript$$14.TypeReference, [null, 0]);
          etr.flags = etr.flags | TypeScript$$14.ASTFlags.Error;
          etr.minChar = this.scanner.pos;
          etr.limChar = this.scanner.pos;
          return etr
      }
      return
    }
    function v552(errorRecoverySet$$7, minChar$$9, term$$2, tail) {
      var v27290 = this.scanner.scan();
      this.currentToken = v27290;
      if(this.currentToken.tokenId == TypeScript$$14.TokenID.Dot) {
        var curpos = this.scanner.pos;
        var v27291 = this.scanner.scan();
        this.currentToken = v27291;
        var v17144 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
        if(!v17144) {
          var v24153 = !this.errorRecovery;
          if(!v24153) {
            v24153 = !this.scanner.lastTokenHadNewline()
          }
          var v21769 = v24153;
          if(v21769) {
            v21769 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
          }
          v17144 = v21769
        }
        if(v17144) {
          var v9249 = TypeScript$$14.Identifier;
          var op2 = JAM.call(v9249.fromToken, v9249, [this.currentToken]);
          op2.minChar = this.scanner.startPos;
          op2.limChar = this.scanner.pos;
          var dotNode$$1 = JAM.new(TypeScript$$14.BinaryExpression, [TypeScript$$14.NodeType.Dot, term$$2, op2]);
          dotNode$$1.minChar = term$$2.minChar;
          dotNode$$1.limChar = op2.limChar;
          return JAM.call(this.parseNamedType, this, [errorRecoverySet$$7, minChar$$9, dotNode$$1, tail])
        }else {
          JAM.call(this.reportParseError, this, ["need identifier after '.'"]);
          if(this.errorRecovery) {
            term$$2.flags = term$$2.flags | TypeScript$$14.ASTFlags.DotLHS;
            var v9255 = term$$2;
            var v27292 = this.scanner.lastTokenLimChar();
            v9255.limChar = v27292;
            return term$$2
          }else {
            var eop2 = new TypeScript$$14.MissingIdentifier;
            eop2.minChar = this.scanner.pos;
            eop2.limChar = this.scanner.pos;
            var edotNode = JAM.new(TypeScript$$14.BinaryExpression, [TypeScript$$14.NodeType.Dot, term$$2, eop2]);
            edotNode.flags = edotNode.flags | TypeScript$$14.ASTFlags.Error;
            edotNode.minChar = term$$2.minChar;
            edotNode.limChar = eop2.limChar;
            return JAM.call(this.parseNamedType, this, [errorRecoverySet$$7, minChar$$9, edotNode, tail])
          }
        }
      }else {
        if(tail) {
          return JAM.call(this.parseTypeReferenceTail, this, [errorRecoverySet$$7, minChar$$9, term$$2])
        }else {
          return term$$2
        }
      }
      return
    }
    function v551(errorRecoverySet$$6, minChar$$8, term$$1) {
      var result$$8 = JAM.new(TypeScript$$14.TypeReference, [term$$1, 0]);
      result$$8.minChar = minChar$$8;
      var v9268 = this.currentToken.tokenId == TypeScript$$14.TokenID.OpenBracket;
      for(;v9268;) {
        var v27293 = this.scanner.scan();
        this.currentToken = v27293;
        result$$8.arrayCount = result$$8.arrayCount + 1;
        JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBracket, errorRecoverySet$$6 | TypeScript$$14.ErrorRecoverySet.LBrack]);
        v9268 = this.currentToken.tokenId == TypeScript$$14.TokenID.OpenBracket
      }
      var v9269 = result$$8;
      var v27294 = this.scanner.lastTokenLimChar();
      v9269.limChar = v27294;
      return result$$8
    }
    function v550(errorRecoverySet$$5, modifiers$$2, preComments$$1) {
      var leftCurlyCount$$1 = this.scanner.leftCurlyCount;
      var rightCurlyCount$$1 = this.scanner.rightCurlyCount;
      var svAmbient = this.ambientModule;
      var svTopLevel = this.topLevel;
      this.topLevel = false;
      var v17160 = this.parsingDeclareFile;
      if(!v17160) {
        var v21778 = svAmbient;
        if(!v21778) {
          v21778 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$2, TypeScript$$14.Modifiers.Ambient])
        }
        v17160 = v21778
      }
      if(v17160) {
        this.ambientModule = true
      }
      var v27295 = this.scanner.scan();
      this.currentToken = v27295;
      var name$$47 = null;
      var enclosedList$$1 = null;
      this.pushDeclLists();
      var minChar$$7 = this.scanner.startPos;
      var isDynamicMod$$1 = false;
      var v17161 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
      if(!v17161) {
        var v21782 = this.currentToken.tokenId == TypeScript$$14.TokenID.StringLiteral;
        if(!v21782) {
          var v24162 = !JAM.call(TypeScript$$14.isPrimitiveTypeToken, TypeScript$$14, [this.currentToken]);
          if(v24162) {
            v24162 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
          }
          v21782 = v24162
        }
        v17161 = v21782
      }
      if(v17161) {
        var nameText = this.currentToken.getText();
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.StringLiteral) {
          isDynamicMod$$1 = true;
          if(!this.ambientModule) {
            JAM.call(this.reportParseError, this, ["Only ambient dynamic modules may have string literal names"])
          }
          if(!svTopLevel) {
            JAM.call(this.reportParseError, this, ["Dynamic modules may not be nested within other modules"])
          }
        }
        var v9279 = TypeScript$$14.Identifier;
        name$$47 = JAM.call(v9279.fromToken, v9279, [this.currentToken]);
        name$$47.minChar = this.scanner.startPos;
        name$$47.limChar = this.scanner.pos;
        var v27296 = this.scanner.scan();
        this.currentToken = v27296
      }else {
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.OpenBrace) {
          JAM.call(this.reportParseError, this, ["Module name missing"]);
          name$$47 = JAM.new(TypeScript$$14.Identifier, [""]);
          name$$47.minChar = minChar$$7;
          name$$47.limChar = minChar$$7
        }
      }
      if(this.currentToken.tokenId == TypeScript$$14.TokenID.Dot) {
        enclosedList$$1 = new Array;
        JAM.call(this.parseDottedName, this, [enclosedList$$1])
      }
      if(name$$47 == null) {
        name$$47 = new TypeScript$$14.MissingIdentifier
      }
      var moduleBody = new TypeScript$$14.ASTList;
      var bodyMinChar = this.scanner.startPos;
      JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.OpenBrace, errorRecoverySet$$5 | TypeScript$$14.ErrorRecoverySet.ID]);
      if(svTopLevel && isDynamicMod$$1) {
        this.allowImportDeclaration = true
      }else {
        this.allowImportDeclaration = false
      }
      JAM.call(this.parseStatementList, this, [errorRecoverySet$$5 | TypeScript$$14.ErrorRecoverySet.RCurly, moduleBody, true, true, TypeScript$$14.AllowedElements.Global, modifiers$$2]);
      moduleBody.minChar = bodyMinChar;
      moduleBody.limChar = this.scanner.pos;
      var endingToken$$2 = new TypeScript$$14.ASTSpan;
      endingToken$$2.minChar = this.scanner.startPos;
      endingToken$$2.limChar = this.scanner.pos;
      JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBrace, errorRecoverySet$$5]);
      var limChar$$5 = this.scanner.lastTokenLimChar();
      var moduleDecl$$3;
      this.allowImportDeclaration = svTopLevel;
      var v17174 = enclosedList$$1;
      if(v17174) {
        v17174 = enclosedList$$1.length > 0
      }
      if(v17174) {
        var len$$16 = enclosedList$$1.length;
        var v9303 = len$$16 - 1;
        introspect(JAM.policy.p1) {
          var innerName = enclosedList$$1[v9303]
        }
        var innerDecl = JAM.new(TypeScript$$14.ModuleDeclaration, [innerName, moduleBody, this.topVarList(), this.topScopeList(), endingToken$$2]);
        innerDecl.preComments = preComments$$1;
        var v17175 = this.parsingDeclareFile;
        if(!v17175) {
          v17175 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$2, TypeScript$$14.Modifiers.Ambient])
        }
        if(v17175) {
          innerDecl.modFlags = innerDecl.modFlags | TypeScript$$14.ModuleFlags.Ambient
        }
        innerDecl.modFlags = innerDecl.modFlags | TypeScript$$14.ModuleFlags.Exported;
        innerDecl.minChar = minChar$$7;
        innerDecl.limChar = limChar$$5;
        this.popDeclLists();
        var outerModBod;
        var i$$50 = len$$16 - 2;
        var v9313 = i$$50 >= 0;
        for(;v9313;) {
          outerModBod = new TypeScript$$14.ASTList;
          JAM.call(outerModBod.append, outerModBod, [innerDecl]);
          innerName = enclosedList$$1[i$$50];
          innerDecl = JAM.new(TypeScript$$14.ModuleDeclaration, [innerName, outerModBod, new TypeScript$$14.ASTList, new TypeScript$$14.ASTList, endingToken$$2]);
          outerModBod.minChar = innerDecl.minChar = minChar$$7;
          outerModBod.limChar = innerDecl.limChar = limChar$$5;
          var v17182 = this.parsingDeclareFile;
          if(!v17182) {
            v17182 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$2, TypeScript$$14.Modifiers.Ambient])
          }
          if(v17182) {
            innerDecl.modFlags = innerDecl.modFlags | TypeScript$$14.ModuleFlags.Ambient
          }
          innerDecl.modFlags = innerDecl.modFlags | TypeScript$$14.ModuleFlags.Exported;
          i$$50 = i$$50 - 1;
          v9313 = i$$50 >= 0
        }
        outerModBod = new TypeScript$$14.ASTList;
        JAM.call(outerModBod.append, outerModBod, [innerDecl]);
        outerModBod.minChar = minChar$$7;
        outerModBod.limChar = limChar$$5;
        moduleDecl$$3 = JAM.new(TypeScript$$14.ModuleDeclaration, [name$$47, outerModBod, new TypeScript$$14.ASTList, new TypeScript$$14.ASTList, endingToken$$2])
      }else {
        moduleDecl$$3 = JAM.new(TypeScript$$14.ModuleDeclaration, [name$$47, moduleBody, this.topVarList(), this.topScopeList(), endingToken$$2]);
        moduleDecl$$3.preComments = preComments$$1;
        this.popDeclLists()
      }
      var v17189 = this.parsingDeclareFile;
      if(!v17189) {
        var v21801 = svAmbient;
        if(!v21801) {
          v21801 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$2, TypeScript$$14.Modifiers.Ambient])
        }
        v17189 = v21801
      }
      if(v17189) {
        moduleDecl$$3.modFlags = moduleDecl$$3.modFlags | TypeScript$$14.ModuleFlags.Ambient
      }
      var v17192 = svAmbient;
      if(!v17192) {
        v17192 = JAM.call(TypeScript$$14.hasFlag, TypeScript$$14, [modifiers$$2, TypeScript$$14.Modifiers.Exported])
      }
      if(v17192) {
        moduleDecl$$3.modFlags = moduleDecl$$3.modFlags | TypeScript$$14.ModuleFlags.Exported
      }
      if(isDynamicMod$$1) {
        moduleDecl$$3.modFlags = moduleDecl$$3.modFlags | TypeScript$$14.ModuleFlags.IsDynamic
      }
      this.ambientModule = svAmbient;
      this.topLevel = svTopLevel;
      moduleDecl$$3.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount$$1;
      moduleDecl$$3.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount$$1;
      moduleDecl$$3.limChar = moduleBody.limChar;
      return moduleDecl$$3
    }
    function v549(errorRecoverySet$$4, modifiers$$1) {
      var name$$46 = null;
      var alias$$1 = null;
      var importDecl = null;
      var minChar$$6 = this.scanner.startPos;
      var isDynamicImport = false;
      var v27297 = this.scanner.scan();
      this.currentToken = v27297;
      var v17199 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
      if(!v17199) {
        v17199 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
      }
      if(v17199) {
        var v9328 = TypeScript$$14.Identifier;
        name$$46 = JAM.call(v9328.fromToken, v9328, [this.currentToken])
      }else {
        JAM.call(this.reportParseError, this, ["Expected identifer after 'import'"]);
        name$$46 = new TypeScript$$14.MissingIdentifier
      }
      name$$46.minChar = this.scanner.startPos;
      name$$46.limChar = this.scanner.pos;
      var v27298 = this.scanner.scan();
      this.currentToken = v27298;
      JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.Equals, errorRecoverySet$$4 | TypeScript$$14.ErrorRecoverySet.ID]);
      var aliasPreComments = this.parseComments();
      var limChar$$4;
      var v17202 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
      if(!v17202) {
        v17202 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
      }
      if(v17202) {
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Module) {
          limChar$$4 = this.scanner.pos;
          var v27299 = this.scanner.scan();
          this.currentToken = v27299;
          if(this.currentToken.tokenId == TypeScript$$14.TokenID.OpenParen) {
            var v27300 = this.scanner.scan();
            this.currentToken = v27300;
            var v17207 = this.currentToken.tokenId == TypeScript$$14.TokenID.StringLiteral;
            if(!v17207) {
              var v21825 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
              if(!v21825) {
                v21825 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
              }
              v17207 = v21825
            }
            if(v17207) {
              if(this.currentToken.tokenId == TypeScript$$14.TokenID.StringLiteral) {
                if(this.topLevel) {
                  this.hasTopLevelImportOrExport = true
                }else {
                  if(!this.allowImportDeclaration) {
                    JAM.call(this.reportParseError, this, ["Import declaration of external module is permitted only in global or top level dynamic modules"])
                  }
                }
                var aliasText = this.currentToken.getText();
                var v9343 = TypeScript$$14.Identifier;
                alias$$1 = JAM.call(v9343.fromToken, v9343, [this.currentToken]);
                alias$$1.minChar = this.scanner.startPos;
                alias$$1.limChar = this.scanner.pos;
                if(!JAM.call(this.isValidImportPath, this, [alias$$1.text])) {
                  JAM.call(this.reportParseError, this, ["Invalid import path"])
                }
                isDynamicImport = true;
                var v27301 = this.scanner.scan();
                this.currentToken = v27301;
                alias$$1.preComments = aliasPreComments
              }else {
                alias$$1 = JAM.call(this.parseExpr, this, [errorRecoverySet$$4 | TypeScript$$14.ErrorRecoverySet.SColon, TypeScript$$14.OperatorPrecedence.Assignment, true, TypeContext.NoTypes]);
                alias$$1.preComments = aliasPreComments
              }
            }
            limChar$$4 = this.scanner.pos;
            JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseParen, errorRecoverySet$$4 | TypeScript$$14.ErrorRecoverySet.ID]);
            if(alias$$1) {
              var v9357 = alias$$1;
              var v27302 = this.parseComments();
              v9357.postComments = v27302
            }
          }
        }else {
          alias$$1 = JAM.call(this.parseExpr, this, [errorRecoverySet$$4 | TypeScript$$14.ErrorRecoverySet.SColon, TypeScript$$14.OperatorPrecedence.Assignment, true, TypeContext.NoTypes]);
          limChar$$4 = this.scanner.pos
        }
      }else {
        JAM.call(this.reportParseError, this, ["Expected module name"]);
        alias$$1 = new TypeScript$$14.MissingIdentifier;
        alias$$1.minChar = this.scanner.startPos;
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Semicolon) {
          alias$$1.limChar = this.scanner.startPos
        }else {
          alias$$1.limChar = this.scanner.pos;
          var v27303 = this.scanner.scan();
          this.currentToken = v27303
        }
        alias$$1.flags = alias$$1.flags | TypeScript$$14.ASTFlags.Error;
        limChar$$4 = alias$$1.limChar
      }
      importDecl = JAM.new(TypeScript$$14.ImportDeclaration, [name$$46, alias$$1]);
      importDecl.isDynamicImport = isDynamicImport;
      importDecl.minChar = minChar$$6;
      importDecl.limChar = limChar$$4;
      return importDecl
    }
    function v548(importPath) {
      importPath = JAM.call(TypeScript$$14.stripQuotes, TypeScript$$14, [importPath]);
      var v17222 = !importPath;
      if(!v17222) {
        var v21836 = importPath.indexOf(":") != -1;
        if(!v21836) {
          var v24181 = importPath.indexOf("\\") != -1;
          if(!v24181) {
            v24181 = importPath.charAt(0) == "/"
          }
          v21836 = v24181
        }
        v17222 = v21836
      }
      if(v17222) {
        return false
      }
      return true
    }
    function v547(enclosedList) {
      var v27304 = this.scanner.scan();
      this.currentToken = v27304;
      var v17223 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
      if(!v17223) {
        v17223 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
      }
      if(v17223) {
        var v9374 = TypeScript$$14.Identifier;
        var id$$10 = JAM.call(v9374.fromToken, v9374, [this.currentToken]);
        var v9376 = id$$10;
        var v27305 = this.parseComments();
        v9376.preComments = v27305;
        JAM.set(enclosedList, enclosedList.length, id$$10);
        id$$10.minChar = this.scanner.startPos;
        id$$10.limChar = this.scanner.pos;
        var v27306 = this.scanner.scan();
        this.currentToken = v27306;
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Dot) {
          JAM.call(this.parseDottedName, this, [enclosedList])
        }
      }else {
        JAM.call(this.reportParseError, this, ["need identifier after '.'"])
      }
      return
    }
    function v546(errorRecoverySet$$3, modifiers) {
      var leftCurlyCount = this.scanner.leftCurlyCount;
      var rightCurlyCount = this.scanner.rightCurlyCount;
      var name$$45 = null;
      var v17226 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
      if(!v17226) {
        v17226 = JAM.call(TypeScript$$14.convertTokToID, TypeScript$$14, [this.currentToken, this.strictMode])
      }
      if(v17226) {
        var v9385 = TypeScript$$14.Identifier;
        name$$45 = JAM.call(v9385.fromToken, v9385, [this.currentToken]);
        name$$45.minChar = this.scanner.startPos;
        name$$45.limChar = this.scanner.pos;
        var v27307 = this.scanner.scan();
        this.currentToken = v27307
      }else {
        JAM.call(this.reportParseError, this, ["Enum declaration requires identifier"]);
        if(this.errorRecovery) {
          name$$45 = new TypeScript$$14.MissingIdentifier;
          name$$45.minChar = this.scanner.startPos;
          name$$45.limChar = this.scanner.startPos;
          name$$45.flags = name$$45.flags | TypeScript$$14.ASTFlags.Error
        }
      }
      var membersMinChar = this.scanner.startPos;
      JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.OpenBrace, errorRecoverySet$$3 | TypeScript$$14.ErrorRecoverySet.ID]);
      this.pushDeclLists();
      var members$$7 = new TypeScript$$14.ASTList;
      members$$7.minChar = membersMinChar;
      var mapDecl = JAM.new(TypeScript$$14.VarDecl, [JAM.new(TypeScript$$14.Identifier, ["_map"]), 0]);
      mapDecl.varFlags = mapDecl.varFlags | TypeScript$$14.VarFlags.Exported;
      mapDecl.varFlags = mapDecl.varFlags | TypeScript$$14.VarFlags.Private;
      mapDecl.varFlags = mapDecl.varFlags | TypeScript$$14.VarFlags.Property | TypeScript$$14.VarFlags.Public;
      var v9401 = mapDecl;
      var v27308 = JAM.new(TypeScript$$14.UnaryExpression, [TypeScript$$14.NodeType.ArrayLit, null]);
      v9401.init = v27308;
      JAM.call(members$$7.append, members$$7, [mapDecl]);
      var lastValue = null;
      for(;;) {
        var minChar$$5 = this.scanner.startPos;
        var limChar$$3;
        var memberName = null;
        var memberValue = null;
        var preComments = null;
        var postComments = null;
        var v17240 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
        if(!v17240) {
          v17240 = JAM.call(TypeScript$$14.convertTokToIDName, TypeScript$$14, [this.currentToken])
        }
        if(v17240) {
          var v9403 = TypeScript$$14.Identifier;
          memberName = JAM.call(v9403.fromToken, v9403, [this.currentToken]);
          memberName.minChar = this.scanner.startPos;
          memberName.limChar = this.scanner.pos
        }else {
          if(this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBrace) {
            break
          }else {
            JAM.call(this.reportParseError, this, ["Expected identifer of enum member"]);
            if(this.errorRecovery) {
              memberName = new TypeScript$$14.MissingIdentifier;
              memberName.minChar = this.scanner.startPos;
              memberName.limChar = this.scanner.startPos;
              memberName.flags = memberName.flags | TypeScript$$14.ASTFlags.Error
            }
          }
        }
        limChar$$3 = this.scanner.pos;
        preComments = this.parseComments();
        var v27309 = this.scanner.scan();
        this.currentToken = v27309;
        postComments = this.parseComments();
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Equals) {
          var v27310 = this.scanner.scan();
          this.currentToken = v27310;
          memberValue = JAM.call(this.parseExpr, this, [errorRecoverySet$$3, TypeScript$$14.OperatorPrecedence.Comma, true, TypeContext.NoTypes]);
          lastValue = memberValue;
          limChar$$3 = memberValue.limChar
        }else {
          if(lastValue == null) {
            memberValue = JAM.new(TypeScript$$14.NumberLiteral, [0]);
            lastValue = memberValue
          }else {
            memberValue = JAM.new(TypeScript$$14.NumberLiteral, [lastValue.value + 1]);
            lastValue = memberValue
          }
          var map = JAM.new(TypeScript$$14.BinaryExpression, [TypeScript$$14.NodeType.Asg, JAM.new(TypeScript$$14.BinaryExpression, [TypeScript$$14.NodeType.Index, JAM.new(TypeScript$$14.Identifier, ["_map"]), memberValue]), JAM.new(TypeScript$$14.StringLiteral, ['"' + memberName.actualText + '"'])]);
          JAM.call(members$$7.append, members$$7, [map])
        }
        var member$$1 = JAM.new(TypeScript$$14.VarDecl, [memberName, this.nestingLevel]);
        member$$1.minChar = minChar$$5;
        member$$1.limChar = limChar$$3;
        member$$1.init = memberValue;
        var v9429 = member$$1;
        var v27311 = JAM.new(TypeScript$$14.TypeReference, [JAM.call(this.createRef, this, [name$$45.actualText, name$$45.hasEscapeSequence, -1]), 0]);
        v9429.typeExpr = v27311;
        member$$1.varFlags = member$$1.varFlags | TypeScript$$14.VarFlags.Readonly | TypeScript$$14.VarFlags.Property;
        if(memberValue.nodeType == TypeScript$$14.NodeType.NumberLit) {
          member$$1.varFlags = member$$1.varFlags | TypeScript$$14.VarFlags.Constant
        }
        member$$1.preComments = preComments;
        JAM.call(members$$7.append, members$$7, [member$$1]);
        member$$1.postComments = postComments;
        member$$1.varFlags = member$$1.varFlags | TypeScript$$14.VarFlags.Exported;
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.Comma) {
          var v27312 = this.scanner.scan();
          this.currentToken = v27312;
          var v9432 = member$$1;
          var v27313 = JAM.call(this.combineComments, this, [member$$1.postComments, JAM.call(this.parseCommentsForLine, this, [this.scanner.prevLine])]);
          v9432.postComments = v27313;
          var v17269 = this.currentToken.tokenId == TypeScript$$14.TokenID.Identifier;
          if(!v17269) {
            v17269 = JAM.call(TypeScript$$14.convertTokToIDName, TypeScript$$14, [this.currentToken])
          }
          if(v17269) {
            continue
          }
        }
        break
      }
      var endingToken$$1 = new TypeScript$$14.ASTSpan;
      endingToken$$1.minChar = this.scanner.startPos;
      endingToken$$1.limChar = this.scanner.pos;
      JAM.call(this.checkCurrentToken, this, [TypeScript$$14.TokenID.CloseBrace, errorRecoverySet$$3]);
      var v9439 = members$$7;
      var v27314 = this.scanner.lastTokenLimChar();
      v9439.limChar = v27314;
      var modDecl = JAM.new(TypeScript$$14.ModuleDeclaration, [name$$45, members$$7, this.topVarList(), this.topScopeList(), endingToken$$1]);
      modDecl.modFlags = modDecl.modFlags | TypeScript$$14.ModuleFlags.IsEnum;
      this.popDeclLists();
      modDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
      modDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
      return modDecl
    }
    function v545(comment1, comment2) {
      if(comment1 == null) {
        return comment2
      }else {
        if(comment2 == null) {
          return comment1
        }else {
          return comment1.concat(comment2)
        }
      }
      return
    }
    function v544(line$$4) {
      var v9447 = this.scanner;
      var comments$$7 = JAM.call(v9447.getCommentsForLine, v9447, [line$$4]);
      return JAM.call(this.parseCommentsInner, this, [comments$$7])
    }
    function v543() {
      var comments$$6 = this.scanner.getComments();
      return JAM.call(this.parseCommentsInner, this, [comments$$6])
    }
    function v542(comments$$5) {
      if(comments$$5) {
        var commentASTs = new Array;
        var i$$49 = 0;
        var v9450 = i$$49 < comments$$5.length;
        for(;v9450;) {
          introspect(JAM.policy.p1) {
            var v17277 = comments$$5[i$$49]
          }
          JAM.call(commentASTs.push, commentASTs, [JAM.call(this.parseComment, this, [v17277])]);
          i$$49 = i$$49 + 1;
          v9450 = i$$49 < comments$$5.length
        }
        return commentASTs
      }else {
        return null
      }
      return
    }
    function v541(comment$$2) {
      if(comment$$2) {
        var c$$7 = JAM.new(TypeScript$$14.Comment, [comment$$2.value, comment$$2.isBlock, comment$$2.endsLine]);
        c$$7.minChar = comment$$2.startPos;
        c$$7.limChar = comment$$2.startPos + comment$$2.value.length;
        var lineCol$$4 = {line:-1, col:-1};
        JAM.call(this.getSourceLineCol, this, [lineCol$$4, c$$7.minChar]);
        c$$7.minLine = lineCol$$4.line;
        JAM.call(this.getSourceLineCol, this, [lineCol$$4, c$$7.limChar]);
        c$$7.limLine = lineCol$$4.line;
        var v17280 = !comment$$2.isBlock;
        if(v17280) {
          var v21885 = comment$$2.value.length > 3;
          if(v21885) {
            var v25351 = comment$$2.value;
            v21885 = JAM.call(v25351.substring, v25351, [0, 3]) == "///"
          }
          v17280 = v21885
        }
        if(v17280) {
          var dependencyPath = JAM.call(TypeScript$$14.getAdditionalDependencyPath, TypeScript$$14, [comment$$2.value]);
          if(dependencyPath) {
            var v9460 = this.amdDependencies;
            JAM.call(v9460.push, v9460, [dependencyPath])
          }
          if(JAM.call(TypeScript$$14.getImplicitImport, TypeScript$$14, [comment$$2.value])) {
            this.hasTopLevelImportOrExport = true
          }
        }
        return c$$7
      }else {
        return null
      }
      return
    }
    function v540() {
      var v9463 = this.staticsLists;
      var v9464 = this.staticsLists.length - 1;
      introspect(JAM.policy.p1) {
        return v9463[v9464]
      }
    }
    function v539() {
      var v9465 = this.scopeLists;
      var v9466 = this.scopeLists.length - 1;
      introspect(JAM.policy.p1) {
        return v9465[v9466]
      }
    }
    function v538() {
      var v9467 = this.varLists;
      var v9468 = this.varLists.length - 1;
      introspect(JAM.policy.p1) {
        return v9467[v9468]
      }
    }
    function v537() {
      this.staticsLists.pop();
      this.varLists.pop();
      this.scopeLists.pop();
      return
    }
    function v536() {
      var v9472 = this.staticsLists;
      JAM.call(v9472.push, v9472, [new TypeScript$$14.ASTList]);
      var v9474 = this.varLists;
      JAM.call(v9474.push, v9474, [new TypeScript$$14.ASTList]);
      var v9476 = this.scopeLists;
      JAM.call(v9476.push, v9476, [new TypeScript$$14.ASTList]);
      return
    }
    function v535(tokenId$$43, errorRecoverySet$$2, errorText$$1) {
      if(typeof errorText$$1 === "undefined") {
        errorText$$1 = null
      }
      if(this.currentToken.tokenId != tokenId$$43) {
        var v9479;
        if(errorText$$1 == null) {
          var v25352 = TypeScript$$14.tokenTable;
          introspect(JAM.policy.p1) {
            var v24199 = v25352[tokenId$$43]
          }
          v9479 = "Expected '" + v24199.text + "'"
        }else {
          v9479 = errorText$$1
        }
        errorText$$1 = v9479;
        JAM.call(this.reportParseError, this, [errorText$$1]);
        if(this.errorRecovery) {
          JAM.call(this.skip, this, [errorRecoverySet$$2])
        }
      }else {
        var v27315 = this.scanner.scan();
        this.currentToken = v27315
      }
      return
    }
    function v534(errorRecoverySet$$1) {
      errorRecoverySet$$1 = errorRecoverySet$$1 | TypeScript$$14.ErrorRecoverySet.EOF;
      var ersTok = TypeScript$$14.ErrorRecoverySet.None;
      var tokenInfo = JAM.call(TypeScript$$14.lookupToken, TypeScript$$14, [this.currentToken.tokenId]);
      if(tokenInfo != undefined) {
        ersTok = tokenInfo.ers
      }
      var pendingRightCurlies = 0;
      var v17294 = (ersTok & errorRecoverySet$$1) == TypeScript$$14.ErrorRecoverySet.None;
      if(!v17294) {
        var v21894 = this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBrace;
        if(v21894) {
          v21894 = pendingRightCurlies > 0
        }
        v17294 = v21894
      }
      var v9492 = v17294;
      for(;v9492;) {
        if(this.currentToken.tokenId == TypeScript$$14.TokenID.OpenBrace) {
          pendingRightCurlies = pendingRightCurlies + 1
        }else {
          if(this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBrace) {
            pendingRightCurlies = pendingRightCurlies - 1
          }
        }
        var v27316 = this.scanner.scan();
        this.currentToken = v27316;
        ersTok = TypeScript$$14.ErrorRecoverySet.None;
        tokenInfo = JAM.call(TypeScript$$14.lookupToken, TypeScript$$14, [this.currentToken.tokenId]);
        if(tokenInfo != undefined) {
          ersTok = tokenInfo.ers
        }
        var v17300 = (ersTok & errorRecoverySet$$1) == TypeScript$$14.ErrorRecoverySet.None;
        if(!v17300) {
          var v21902 = this.currentToken.tokenId == TypeScript$$14.TokenID.CloseBrace;
          if(v21902) {
            v21902 = pendingRightCurlies > 0
          }
          v17300 = v21902
        }
        v9492 = v17300
      }
      return
    }
    function v533(tokenId$$42, errorRecoverySet, errorText) {
      if(typeof errorText === "undefined") {
        errorText = null
      }
      var v27317 = this.scanner.scan();
      this.currentToken = v27317;
      JAM.call(this.checkCurrentToken, this, [tokenId$$42, errorRecoverySet, errorText]);
      return
    }
    function v532(message$$15, startPos, pos$$1) {
      if(typeof startPos === "undefined") {
        startPos = this.scanner.startPos
      }
      if(typeof pos$$1 === "undefined") {
        pos$$1 = this.scanner.pos
      }
      var len$$15 = JAM.call(Math.max, Math, [1, pos$$1 - startPos]);
      if(this.errorCallback) {
        JAM.call(this.errorCallback, this, [startPos, len$$15, message$$15, this.currentUnitIndex])
      }else {
        if(this.errorRecovery) {
          var lineCol$$3 = {line:-1, col:-1};
          JAM.call(this.getSourceLineCol, this, [lineCol$$3, startPos]);
          if(this.outfile) {
            var v9501 = this.outfile;
            JAM.call(v9501.WriteLine, v9501, ["// " + this.fname + " (" + lineCol$$3.line + "," + lineCol$$3.col + "): " + message$$15])
          }
        }else {
          throw new SyntaxError(this.fname + " (" + this.scanner.line + "," + this.scanner.col + "): " + message$$15);
        }
      }
      return
    }
    function v531(message$$14) {
      JAM.call(this.reportParseError, this, ["STYLE: " + message$$14]);
      return
    }
    function v530(text$$13, hasEscapeSequence$$2, minChar$$4) {
      var id$$9 = JAM.new(TypeScript$$14.Identifier, [text$$13, hasEscapeSequence$$2]);
      id$$9.minChar = minChar$$4;
      return id$$9
    }
    function v529(lineCol$$2, minChar$$3) {
      JAM.call(TypeScript$$14.getSourceLineColFromMap, TypeScript$$14, [lineCol$$2, minChar$$3, this.scanner.lineMap]);
      return
    }
    function v528(outfile$$3) {
      this.outfile = outfile$$3;
      this.errorRecovery = true;
      return
    }
    function v527(jump) {
      var v9510 = TypeScript$$14.AST;
      var resolvedTarget = JAM.call(v9510.getResolvedIdentifierName, v9510, [jump.target]);
      var len$$14 = this.statementInfoStack.length;
      var i$$48 = len$$14 - 1;
      var v9525 = i$$48 >= 0;
      for(;v9525;) {
        var v9513 = this.statementInfoStack;
        introspect(JAM.policy.p1) {
          var info$$1 = v9513[i$$48]
        }
        if(jump.target) {
          var v17307 = info$$1.labels;
          if(v17307) {
            v17307 = info$$1.labels.members.length > 0
          }
          if(v17307) {
            var j$$5 = 0;
            var labLen = info$$1.labels.members.length;
            var v9518 = j$$5 < labLen;
            for(;v9518;) {
              var v9515 = info$$1.labels.members;
              introspect(JAM.policy.p1) {
                var label$$2 = v9515[j$$5]
              }
              if(label$$2.id.text == resolvedTarget) {
                JAM.call(jump.setResolvedTarget, jump, [this, info$$1.stmt]);
                return
              }
              j$$5 = j$$5 + 1;
              v9518 = j$$5 < labLen
            }
          }
        }else {
          if(info$$1.stmt.isLoop()) {
            JAM.call(jump.setResolvedTarget, jump, [this, info$$1.stmt]);
            return
          }else {
            var v17312 = info$$1.stmt.nodeType == TypeScript$$14.NodeType.Switch;
            if(v17312) {
              v17312 = jump.nodeType == TypeScript$$14.NodeType.Break
            }
            if(v17312) {
              JAM.call(jump.setResolvedTarget, jump, [this, info$$1.stmt]);
              return
            }
          }
        }
        i$$48 = i$$48 - 1;
        v9525 = i$$48 >= 0
      }
      if(jump.target) {
        JAM.call(this.reportParseError, this, ["could not find enclosing statement with label " + jump.target])
      }else {
        if(jump.nodeType == TypeScript$$14.NodeType.Break) {
          JAM.call(this.reportParseError, this, ["break statement requires enclosing loop or switch"])
        }else {
          JAM.call(this.reportParseError, this, ["continue statement requires enclosing loop"])
        }
      }
      return
    }
    function v526() {
      return this.statementInfoStack.pop()
    }
    function v525(stmt$$3, labels$$1) {
      var info = {stmt:stmt$$3, labels:labels$$1};
      var v9530 = this.statementInfoStack;
      JAM.call(v9530.push, v9530, [info]);
      return
    }
    function v524() {
      var j$$4 = this.statementInfoStack.length - 1;
      var v9533 = j$$4 >= 0;
      for(;v9533;) {
        var v24214 = this.statementInfoStack;
        introspect(JAM.policy.p1) {
          var v21913 = v24214[j$$4]
        }
        if(v21913.stmt.isLoop()) {
          return true
        }
        j$$4 = j$$4 - 1;
        v9533 = j$$4 >= 0
      }
      return false
    }
    function v523() {
      var v27318 = new Array;
      this.statementInfoStack = v27318;
      return
    }
    function Parser$$1() {
      this.varLists = [];
      this.scopeLists = [];
      this.staticsLists = [];
      var v27319 = new TypeScript$$14.Scanner;
      this.scanner = v27319;
      this.currentToken = null;
      this.needTerminator = false;
      this.inFunction = false;
      this.inInterfaceDecl = false;
      this.currentClassDecl = null;
      this.inFncDecl = false;
      var v27320 = JAM.new(TypeScript$$14.Identifier, ["_anonymous"]);
      this.anonId = v27320;
      this.style_requireSemi = false;
      this.style_funcInLoop = true;
      this.incremental = false;
      this.errorRecovery = false;
      this.outfile = undefined;
      this.errorCallback = null;
      this.state = ParseState.StartStatementList;
      this.ambientModule = false;
      this.ambientClass = false;
      this.topLevel = true;
      this.allowImportDeclaration = true;
      this.currentUnitIndex = -1;
      this.prevIDTok = null;
      var v27321 = new Array;
      this.statementInfoStack = v27321;
      this.hasTopLevelImportOrExport = false;
      this.strictMode = false;
      this.nestingLevel = 0;
      this.prevExpr = null;
      this.currentClassDefinition = null;
      this.parsingClassConstructorDefinition = false;
      this.parsingDeclareFile = false;
      this.amdDependencies = [];
      this.inferPropertiesFromThisAssignment = false;
      this.requiresExtendsBlock = false;
      this.fname = "";
      return
    }
    Parser$$1.prototype.resetStmtStack = v523;
    Parser$$1.prototype.inLoop = v524;
    Parser$$1.prototype.pushStmt = v525;
    Parser$$1.prototype.popStmt = v526;
    Parser$$1.prototype.resolveJumpTarget = v527;
    Parser$$1.prototype.setErrorRecovery = v528;
    Parser$$1.prototype.getSourceLineCol = v529;
    Parser$$1.prototype.createRef = v530;
    Parser$$1.prototype.reportParseStyleError = v531;
    Parser$$1.prototype.reportParseError = v532;
    Parser$$1.prototype.checkNextToken = v533;
    Parser$$1.prototype.skip = v534;
    Parser$$1.prototype.checkCurrentToken = v535;
    Parser$$1.prototype.pushDeclLists = v536;
    Parser$$1.prototype.popDeclLists = v537;
    Parser$$1.prototype.topVarList = v538;
    Parser$$1.prototype.topScopeList = v539;
    Parser$$1.prototype.topStaticsList = v540;
    Parser$$1.prototype.parseComment = v541;
    Parser$$1.prototype.parseCommentsInner = v542;
    Parser$$1.prototype.parseComments = v543;
    Parser$$1.prototype.parseCommentsForLine = v544;
    Parser$$1.prototype.combineComments = v545;
    Parser$$1.prototype.parseEnumDecl = v546;
    Parser$$1.prototype.parseDottedName = v547;
    Parser$$1.prototype.isValidImportPath = v548;
    Parser$$1.prototype.parseImportDeclaration = v549;
    Parser$$1.prototype.parseModuleDecl = v550;
    Parser$$1.prototype.parseTypeReferenceTail = v551;
    Parser$$1.prototype.parseNamedType = v552;
    Parser$$1.prototype.parseTypeReference = v553;
    Parser$$1.prototype.parseObjectType = v554;
    Parser$$1.prototype.parseFunctionBlock = v555;
    Parser$$1.prototype.parseFunctionStatements = v556;
    Parser$$1.prototype.transformAnonymousArgsIntoFormals = v557;
    Parser$$1.prototype.parseFormalParameterList = v558;
    Parser$$1.prototype.parseFncDecl = v559;
    Parser$$1.prototype.convertToTypeReference = v560;
    Parser$$1.prototype.parseArgList = v561;
    Parser$$1.prototype.parseBaseList = v562;
    Parser$$1.prototype.parseClassDecl = v563;
    Parser$$1.prototype.parseClassElements = v564;
    Parser$$1.prototype.parseClassConstructorDeclaration = v565;
    Parser$$1.prototype.parseClassMemberVariableDeclaration = v566;
    Parser$$1.prototype.parseClassMemberFunctionDeclaration = v567;
    Parser$$1.prototype.parseTypeMember = v568;
    Parser$$1.prototype.parseTypeMemberList = v569;
    Parser$$1.prototype.parseInterfaceDecl = v570;
    Parser$$1.prototype.makeVarDecl = v571;
    Parser$$1.prototype.parsePropertyDeclaration = v572;
    Parser$$1.prototype.parseVariableDeclaration = v573;
    Parser$$1.prototype.parseMemberList = v574;
    Parser$$1.prototype.parseArrayList = v575;
    Parser$$1.prototype.parseArrayLiteral = v576;
    Parser$$1.prototype.parseTerm = v577;
    Parser$$1.prototype.parseLambdaExpr = v578;
    Parser$$1.prototype.parseExpr = v579;
    Parser$$1.prototype.parsePostfixOperators = v580;
    Parser$$1.prototype.parseTry = v581;
    Parser$$1.prototype.parseCatch = v582;
    Parser$$1.prototype.parseFinally = v583;
    Parser$$1.prototype.parseTryCatchFinally = v584;
    Parser$$1.prototype.parseStatement = v585;
    Parser$$1.prototype.okAmbientModuleMember = v586;
    Parser$$1.prototype.parseStatementList = v587;
    Parser$$1.prototype.quickParse = v588;
    Parser$$1.prototype.parse = v590;
    return Parser$$1
  }
  function v522() {
    function QuickParseResult$$1(Script$$2, endLexState) {
      this.Script = Script$$2;
      this.endLexState = endLexState;
      return
    }
    return QuickParseResult$$1
  }
  function v521(ParseState$$1) {
    ParseState$$1._map = [];
    ParseState$$1._map[0] = "None";
    ParseState$$1.None = 0;
    ParseState$$1._map[1] = "StartScript";
    ParseState$$1.StartScript = 1;
    ParseState$$1._map[2] = "StartStatementList";
    ParseState$$1.StartStatementList = 2;
    ParseState$$1._map[3] = "StartStatement";
    ParseState$$1.StartStatement = 3;
    ParseState$$1._map[4] = "StartFncDecl";
    ParseState$$1.StartFncDecl = 4;
    ParseState$$1._map[5] = "FncDeclName";
    ParseState$$1.FncDeclName = 5;
    ParseState$$1._map[6] = "FncDeclArgs";
    ParseState$$1.FncDeclArgs = 6;
    ParseState$$1._map[7] = "FncDeclReturnType";
    ParseState$$1.FncDeclReturnType = 7;
    ParseState$$1._map[8] = "ForInit";
    ParseState$$1.ForInit = 8;
    ParseState$$1._map[9] = "ForInitAfterVar";
    ParseState$$1.ForInitAfterVar = 9;
    ParseState$$1._map[10] = "ForCondStart";
    ParseState$$1.ForCondStart = 10;
    ParseState$$1._map[11] = "EndStmtList";
    ParseState$$1.EndStmtList = 11;
    ParseState$$1._map[12] = "EndScript";
    ParseState$$1.EndScript = 12;
    return
  }
  function v520(TypeContext$$1) {
    TypeContext$$1._map = [];
    TypeContext$$1.NoTypes = 0;
    TypeContext$$1.ArraySuffix = 1;
    TypeContext$$1.Primitive = 2;
    TypeContext$$1.Named = 4;
    TypeContext$$1.AllSimpleTypes = TypeContext$$1.Primitive | TypeContext$$1.Named;
    TypeContext$$1.AllTypes = TypeContext$$1.Primitive | TypeContext$$1.Named | TypeContext$$1.ArraySuffix;
    return
  }
  function quickParse(logger$$1, scopeStartAST, sourceText, minChar$$2, limChar$$2, errorCapture) {
    var fragment = JAM.call(sourceText.getText, sourceText, [minChar$$2, limChar$$2]);
    JAM.call(logger$$1.log, logger$$1, ["Quick parse range (" + minChar$$2 + "," + limChar$$2 + '): "' + JAM.call(TypeScript$$14.stringToLiteral, TypeScript$$14, [fragment, 100]) + '"']);
    var quickParser = new Parser;
    JAM.call(quickParser.setErrorRecovery, quickParser, [null]);
    quickParser.errorCallback = errorCapture;
    var quickClassDecl = JAM.new(TypeScript$$14.ClassDeclaration, [null, null, null, null]);
    quickParser.currentClassDecl = quickClassDecl;
    var result$$7 = JAM.call(quickParser.quickParse, quickParser, [JAM.new(TypeScript$$14.StringSourceText, [fragment]), "", 0]);
    return result$$7
  }
  var v17322 = TypeScript$$14.TypeContext;
  if(!v17322) {
    v17322 = TypeScript$$14.TypeContext = {}
  }
  v520(v17322);
  var TypeContext = TypeScript$$14.TypeContext;
  var v17323 = TypeScript$$14.ParseState;
  if(!v17323) {
    v17323 = TypeScript$$14.ParseState = {}
  }
  v521(v17323);
  var ParseState = TypeScript$$14.ParseState;
  var QuickParseResult = v522();
  TypeScript$$14.QuickParseResult = QuickParseResult;
  var Parser = v591();
  TypeScript$$14.Parser = Parser;
  TypeScript$$14.quickParse = quickParse;
  return
}
function v519(TypeScript$$13) {
  function v518() {
    function v517(ast$$36, op$$1, type$$29) {
      JAM.call(this.reportError, this, [ast$$36, "Operator '" + op$$1 + "' cannot be applied to type '" + type$$29.getTypeName() + "'"]);
      return
    }
    function v516(ast$$35) {
      JAM.call(this.simpleError, this, [ast$$35, "Expected var, class, interface, or module"]);
      return
    }
    function v515(ast$$34, t1, t2, op, scope$$8, comparisonInfo) {
      if(!t1) {
        t1 = this.checker.anyType
      }
      if(!t2) {
        t2 = this.checker.anyType
      }
      var v9630;
      if(comparisonInfo) {
        v9630 = comparisonInfo.message
      }else {
        v9630 = ""
      }
      var reason = v9630;
      if(op) {
        var v17325 = "Operator '" + op + "' cannot be applied to types '" + JAM.call(t1.getScopedTypeName, t1, [scope$$8]) + "' and '" + JAM.call(t2.getScopedTypeName, t2, [scope$$8]) + "'";
        var v21921;
        if(reason) {
          v21921 = ": " + reason
        }else {
          v21921 = ""
        }
        JAM.call(this.reportError, this, [ast$$34, v17325 + v21921])
      }else {
        var v17327 = "Cannot convert '" + JAM.call(t1.getScopedTypeName, t1, [scope$$8]) + "' to '" + JAM.call(t2.getScopedTypeName, t2, [scope$$8]) + "'";
        var v21923;
        if(reason) {
          v21923 = ": " + reason
        }else {
          v21923 = ""
        }
        JAM.call(this.reportError, this, [ast$$34, v17327 + v21923])
      }
      return
    }
    function v514(ast$$33, scope$$7) {
      var v9633 = ast$$33.operand1.type;
      var targetType$$2 = JAM.call(v9633.getScopedTypeName, v9633, [scope$$7]);
      var v9634 = ast$$33.operand2.type;
      var indexType = JAM.call(v9634.getScopedTypeName, v9634, [scope$$7]);
      JAM.call(this.simpleError, this, [ast$$33, "Value of type '" + targetType$$2 + "' is not indexable by type '" + indexType + "'"]);
      return
    }
    function v513(ast$$32, nodeType$$13, scope$$6) {
      var targetType$$1 = ast$$32.target.type;
      var typeName = JAM.call(targetType$$1.getScopedTypeName, targetType$$1, [scope$$6]);
      var v17332 = targetType$$1.construct;
      if(v17332) {
        v17332 = nodeType$$13 == TypeScript$$13.NodeType.Call
      }
      if(v17332) {
        JAM.call(this.reportError, this, [ast$$32, "Value of type '" + typeName + "' is not callable.  Did you mean to include 'new'?"])
      }else {
        var v9638;
        if(nodeType$$13 == TypeScript$$13.NodeType.Call) {
          v9638 = "callable"
        }else {
          v9638 = "newable"
        }
        var catString = v9638;
        JAM.call(this.reportError, this, [ast$$32, "Value of type '" + typeName + "' is not " + catString])
      }
      return
    }
    function v512(ast$$31) {
      JAM.call(this.simpleError, this, [ast$$31, "The left-hand side of an assignment expression must be a variable, property or indexer"]);
      return
    }
    function v511(ast$$30) {
      JAM.call(this.simpleError, this, [ast$$30, "Keyword 'super' can only be used inside a class instance method"]);
      return
    }
    function v510(sym$$6, msg$$3) {
      JAM.call(this.reportErrorFromSym, this, [sym$$6, msg$$3]);
      return
    }
    function v509(ast$$29, msg$$2) {
      JAM.call(this.reportError, this, [ast$$29, msg$$2]);
      return
    }
    function v508(ast$$28, msg$$1) {
      var bkThrow = this.pushToErrorSink;
      this.pushToErrorSink = false;
      JAM.call(this.reportError, this, [ast$$28, "STYLE: " + msg$$1]);
      this.pushToErrorSink = bkThrow;
      return
    }
    function v507(ast$$27, name$$44) {
      JAM.call(this.reportError, this, [ast$$27, "The name '" + name$$44 + "' does not refer to a value"]);
      return
    }
    function v506(ast$$26, name$$43) {
      JAM.call(this.reportError, this, [ast$$26, "The name '" + name$$43 + "' does not exist in the current scope"]);
      return
    }
    function v505(ast$$25, text$$12, symbol$$5) {
      var defLineCol = {line:-1, col:-1};
      var v9644 = this.parser;
      JAM.call(v9644.getSourceLineCol, v9644, [defLineCol, symbol$$5.location]);
      JAM.call(this.reportError, this, [ast$$25, "symbol " + text$$12 + " defined at (" + defLineCol.line + "," + defLineCol.col + ")"]);
      return
    }
    function v504(ast$$24, name$$42) {
      JAM.call(this.reportError, this, [ast$$24, "Duplicate identifier '" + name$$42 + "'"]);
      return
    }
    function v503(ast$$23, message$$13) {
      JAM.call(this.reportError, this, [ast$$23, message$$13]);
      throw Error("EmitError");
    }
    function v502(symbol$$4, message$$12) {
      if(this.pushToErrorSink) {
        JAM.call(this.captureError, this, [message$$12]);
        return
      }
      this.hasErrors = true;
      var v17340 = this.parser.errorRecovery;
      if(v17340) {
        v17340 = this.parser.errorCallback
      }
      if(v17340) {
        var v9649 = this.parser;
        JAM.call(v9649.errorCallback, v9649, [symbol$$4.location, symbol$$4.length, message$$12, this.checker.locationInfo.unitIndex])
      }else {
        JAM.call(this.writePrefixFromSym, this, [symbol$$4]);
        var v9653 = this.outfile;
        JAM.call(v9653.WriteLine, v9653, [message$$12])
      }
      return
    }
    function v501(ast$$22, message$$11) {
      if(this.pushToErrorSink) {
        JAM.call(this.captureError, this, [message$$11]);
        return
      }
      this.hasErrors = true;
      var v17342 = ast$$22;
      if(v17342) {
        var v21933 = this.parser.errorRecovery;
        if(v21933) {
          v21933 = this.parser.errorCallback
        }
        v17342 = v21933
      }
      if(v17342) {
        var len$$13 = ast$$22.limChar - ast$$22.minChar;
        var v9658 = this.parser;
        JAM.call(v9658.errorCallback, v9658, [ast$$22.minChar, len$$13, message$$11, this.checker.locationInfo.unitIndex])
      }else {
        JAM.call(this.writePrefix, this, [ast$$22]);
        var v9661 = this.outfile;
        JAM.call(v9661.WriteLine, v9661, [message$$11])
      }
      return
    }
    function v500(ast$$21) {
      if(ast$$21) {
        ast$$21.flags = ast$$21.flags | TypeScript$$13.ASTFlags.Error;
        if(this.checker.locationInfo.lineMap) {
          JAM.call(TypeScript$$13.getSourceLineColFromMap, TypeScript$$13, [this.lineCol, ast$$21.minChar, this.checker.locationInfo.lineMap])
        }
      }
      return
    }
    function v499(symbol$$3) {
      var v17348 = symbol$$3;
      if(v17348) {
        v17348 = this.checker.locationInfo.lineMap
      }
      if(v17348) {
        JAM.call(TypeScript$$13.getSourceLineColFromMap, TypeScript$$13, [this.lineCol, symbol$$3.location, this.checker.locationInfo.lineMap])
      }else {
        this.lineCol.line = -1;
        this.lineCol.col = -1
      }
      this.emitPrefix();
      return
    }
    function v498(ast$$20) {
      if(ast$$20) {
        JAM.call(this.setError, this, [ast$$20])
      }else {
        this.lineCol.line = 0;
        this.lineCol.col = 0
      }
      this.emitPrefix();
      return
    }
    function v497() {
      if(this.emitAsComments) {
        var v9675 = this.outfile;
        JAM.call(v9675.Write, v9675, ["// "])
      }
      var v9677 = this.outfile;
      JAM.call(v9677.Write, v9677, [this.checker.locationInfo.filename + "(" + this.lineCol.line + "," + this.lineCol.col + "): "]);
      return
    }
    function v496(outerr$$1) {
      this.outfile = outerr$$1;
      this.emitAsComments = false;
      return
    }
    function v495(emsg) {
      JAM.set(this.errorSink, this.errorSink.length, emsg);
      return
    }
    function v494() {
      this.errorSink = [];
      return
    }
    function v493() {
      return this.errorSink
    }
    function ErrorReporter$$1(outfile$$2) {
      this.outfile = outfile$$2;
      this.parser = null;
      this.checker = null;
      this.lineCol = {line:0, col:0};
      this.emitAsComments = true;
      this.hasErrors = false;
      this.pushToErrorSink = false;
      this.errorSink = [];
      return
    }
    ErrorReporter$$1.prototype.getCapturedErrors = v493;
    ErrorReporter$$1.prototype.freeCapturedErrors = v494;
    ErrorReporter$$1.prototype.captureError = v495;
    ErrorReporter$$1.prototype.setErrOut = v496;
    ErrorReporter$$1.prototype.emitPrefix = v497;
    ErrorReporter$$1.prototype.writePrefix = v498;
    ErrorReporter$$1.prototype.writePrefixFromSym = v499;
    ErrorReporter$$1.prototype.setError = v500;
    ErrorReporter$$1.prototype.reportError = v501;
    ErrorReporter$$1.prototype.reportErrorFromSym = v502;
    ErrorReporter$$1.prototype.emitterError = v503;
    ErrorReporter$$1.prototype.duplicateIdentifier = v504;
    ErrorReporter$$1.prototype.showRef = v505;
    ErrorReporter$$1.prototype.unresolvedSymbol = v506;
    ErrorReporter$$1.prototype.symbolDoesNotReferToAValue = v507;
    ErrorReporter$$1.prototype.styleError = v508;
    ErrorReporter$$1.prototype.simpleError = v509;
    ErrorReporter$$1.prototype.simpleErrorFromSym = v510;
    ErrorReporter$$1.prototype.invalidSuperReference = v511;
    ErrorReporter$$1.prototype.valueCannotBeModified = v512;
    ErrorReporter$$1.prototype.invalidCall = v513;
    ErrorReporter$$1.prototype.indexLHS = v514;
    ErrorReporter$$1.prototype.incompatibleTypes = v515;
    ErrorReporter$$1.prototype.expectedClassOrInterface = v516;
    ErrorReporter$$1.prototype.unaryOperatorTypeError = v517;
    return ErrorReporter$$1
  }
  var ErrorReporter = v518();
  TypeScript$$13.ErrorReporter = ErrorReporter;
  return
}
function v492(TypeScript$$12) {
  function v491() {
    function v490(fileName$$2, useUTF8) {
      try {
        var v9706 = this.emitOptions.ioHost;
        return JAM.call(v9706.createFile, v9706, [fileName$$2, useUTF8])
      }catch(ex$$2) {
        var v9707 = this.errorReporter;
        JAM.call(v9707.emitterError, v9707, [null, ex$$2.message])
      }
      return
    }
    function shouldCaptureThis(func$$3) {
      var v9709 = func$$3.hasSelfReference();
      if(!v9709) {
        v9709 = func$$3.hasSuperReferenceInFatArrowFunction()
      }
      return v9709
    }
    function v489() {
      var v17354 = this.thisFnc;
      if(v17354) {
        var v21942 = !this.thisFnc.isMethod();
        if(v21942) {
          v21942 = !this.thisFnc.isConstructor
        }
        v17354 = v21942
      }
      if(v17354) {
        JAM.call(this.writeToOutput, this, ["_this"])
      }else {
        JAM.call(this.writeToOutput, this, ["this"])
      }
      return
    }
    function v488(callEx) {
      if(callEx.target.nodeType == TypeScript$$12.NodeType.Dot) {
        var dotNode = callEx.target;
        if(dotNode.operand1.nodeType == TypeScript$$12.NodeType.Super) {
          JAM.call(this.emitJavascript, this, [dotNode, TypeScript$$12.TokenID.OpenParen, false]);
          JAM.call(this.writeToOutput, this, [".call("]);
          this.emitThis();
          var v17360 = callEx.arguments;
          if(v17360) {
            v17360 = callEx.arguments.members.length > 0
          }
          if(v17360) {
            JAM.call(this.writeToOutput, this, [", "]);
            JAM.call(this.emitJavascriptList, this, [callEx.arguments, ", ", TypeScript$$12.TokenID.Comma, false, false, false])
          }
          JAM.call(this.writeToOutput, this, [")"]);
          return true
        }
      }
      return false
    }
    function v487() {
      JAM.call(this.writeToOutput, this, ["_super.prototype"]);
      return
    }
    function v486(reqInherits) {
      if(!this.prologueEmitted) {
        if(reqInherits) {
          this.prologueEmitted = true;
          JAM.call(this.writeLineToOutput, this, ["var __extends = this.__extends || function (d, b) {"]);
          JAM.call(this.writeLineToOutput, this, ["    function __() { this.constructor = d; }"]);
          JAM.call(this.writeLineToOutput, this, ["    __.prototype = b.prototype;"]);
          JAM.call(this.writeLineToOutput, this, ["    d.prototype = new __();"]);
          JAM.call(this.writeLineToOutput, this, ["};"])
        }
        if(this.checker.mustCaptureGlobalThis) {
          this.prologueEmitted = true;
          JAM.call(this.writeLineToOutput, this, [this.captureThisStmtString])
        }
      }
      return
    }
    function v485(classDecl$$3) {
      if(!JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [classDecl$$3.varFlags, TypeScript$$12.VarFlags.Ambient])) {
        var svClassNode = this.thisClassNode;
        var i$$47 = 0;
        this.thisClassNode = classDecl$$3;
        var className$$3 = classDecl$$3.name.actualText;
        JAM.call(this.emitParensAndCommentsInPlace, this, [classDecl$$3, true]);
        var temp$$13 = JAM.call(this.setContainer, this, [EmitContainer.Class]);
        JAM.call(this.recordSourceMappingStart, this, [classDecl$$3]);
        var v17365 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [classDecl$$3.varFlags, TypeScript$$12.VarFlags.Exported]);
        if(v17365) {
          v17365 = classDecl$$3.type.symbol.container == this.checker.gloMod
        }
        if(v17365) {
          JAM.call(this.writeToOutput, this, ["this." + className$$3])
        }else {
          JAM.call(this.writeToOutput, this, ["var " + className$$3])
        }
        var v9725 = classDecl$$3.extendsList;
        if(v9725) {
          v9725 = classDecl$$3.extendsList.members.length
        }
        var hasBaseClass = v9725;
        var baseNameDecl = null;
        var baseName$$2 = null;
        if(hasBaseClass) {
          JAM.call(this.writeLineToOutput, this, [" = (function (_super) {"])
        }else {
          JAM.call(this.writeLineToOutput, this, [" = (function () {"])
        }
        JAM.call(this.recordSourceMappingNameStart, this, [className$$3]);
        this.indenter.increaseIndent();
        if(hasBaseClass) {
          baseNameDecl = classDecl$$3.extendsList.members[0];
          var v9728;
          if(baseNameDecl.nodeType == TypeScript$$12.NodeType.Call) {
            v9728 = baseNameDecl.target
          }else {
            v9728 = baseNameDecl
          }
          baseName$$2 = v9728;
          this.emitIndent();
          JAM.call(this.writeLineToOutput, this, ["__extends(" + className$$3 + ", _super);"])
        }
        this.emitIndent();
        var constrDecl = classDecl$$3.constructorDecl;
        if(constrDecl) {
          JAM.call(this.emitJavascript, this, [classDecl$$3.constructorDecl, TypeScript$$12.TokenID.OpenParen, false])
        }else {
          var wroteProps = 0;
          JAM.call(this.recordSourceMappingStart, this, [classDecl$$3]);
          this.indenter.increaseIndent();
          JAM.call(this.writeToOutput, this, ["function " + classDecl$$3.name.actualText + "() {"]);
          JAM.call(this.recordSourceMappingNameStart, this, ["constructor"]);
          if(hasBaseClass) {
            JAM.call(this.writeLineToOutput, this, [""]);
            this.emitIndent();
            JAM.call(this.writeLineToOutput, this, ["_super.apply(this, arguments);"]);
            wroteProps = wroteProps + 1
          }
          if(classDecl$$3.varFlags & TypeScript$$12.VarFlags.MustCaptureThis) {
            JAM.call(this.writeCaptureThisStatement, this, [classDecl$$3])
          }
          var members$$6 = this.thisClassNode.members.members;
          i$$47 = 0;
          var v9739 = i$$47 < members$$6.length;
          for(;v9739;) {
            introspect(JAM.policy.p1) {
              var v21959 = members$$6[i$$47]
            }
            if(v21959.nodeType == TypeScript$$12.NodeType.VarDecl) {
              introspect(JAM.policy.p1) {
                var varDecl$$5 = members$$6[i$$47]
              }
              var v17378 = !JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [varDecl$$5.varFlags, TypeScript$$12.VarFlags.Static]);
              if(v17378) {
                v17378 = varDecl$$5.init
              }
              if(v17378) {
                JAM.call(this.writeLineToOutput, this, [""]);
                this.emitIndent();
                JAM.call(this.emitJavascriptVarDecl, this, [varDecl$$5, TypeScript$$12.TokenID.Tilde]);
                wroteProps = wroteProps + 1
              }
            }
            i$$47 = i$$47 + 1;
            v9739 = i$$47 < members$$6.length
          }
          if(wroteProps) {
            JAM.call(this.writeLineToOutput, this, [""]);
            this.indenter.decreaseIndent();
            this.emitIndent();
            JAM.call(this.writeLineToOutput, this, ["}"])
          }else {
            JAM.call(this.writeLineToOutput, this, [" }"]);
            this.indenter.decreaseIndent()
          }
          this.recordSourceMappingNameEnd();
          JAM.call(this.recordSourceMappingEnd, this, [classDecl$$3])
        }
        var membersLen = classDecl$$3.members.members.length;
        var j$$3 = 0;
        var v9758 = j$$3 < membersLen;
        for(;v9758;) {
          var v9743 = classDecl$$3.members.members;
          introspect(JAM.policy.p1) {
            var memberDecl = v9743[j$$3]
          }
          if(memberDecl.nodeType == TypeScript$$12.NodeType.FuncDecl) {
            var fn$$6 = memberDecl;
            var v17385 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [fn$$6.fncFlags, TypeScript$$12.FncFlags.Method]);
            if(v17385) {
              v17385 = !fn$$6.isSignature()
            }
            if(v17385) {
              if(!JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [fn$$6.fncFlags, TypeScript$$12.FncFlags.Static])) {
                JAM.call(this.emitPrototypeMember, this, [fn$$6, className$$3])
              }else {
                if(fn$$6.isAccessor()) {
                  JAM.call(this.emitPropertyAccessor, this, [fn$$6, this.thisClassNode.name.actualText, false])
                }else {
                  this.emitIndent();
                  JAM.call(this.recordSourceMappingStart, this, [fn$$6]);
                  JAM.call(this.writeToOutput, this, [classDecl$$3.name.actualText + "." + fn$$6.name.actualText + " = "]);
                  var v17389 = fn$$6.name;
                  if(v17389) {
                    v17389 = !fn$$6.name.isMissing()
                  }
                  JAM.call(this.emitInnerFunction, this, [fn$$6, v17389, true, null, JAM.call(Emitter$$1.shouldCaptureThis, Emitter$$1, [fn$$6]), null]);
                  JAM.call(this.writeLineToOutput, this, [";"])
                }
              }
            }
          }else {
            if(memberDecl.nodeType == TypeScript$$12.NodeType.VarDecl) {
              varDecl$$5 = memberDecl;
              if(JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [varDecl$$5.varFlags, TypeScript$$12.VarFlags.Static])) {
                if(varDecl$$5.init) {
                  this.emitIndent();
                  JAM.call(this.recordSourceMappingStart, this, [varDecl$$5]);
                  JAM.call(this.writeToOutput, this, [classDecl$$3.name.actualText + "." + varDecl$$5.id.actualText + " = "]);
                  JAM.call(this.emitJavascript, this, [varDecl$$5.init, TypeScript$$12.TokenID.Equals, false]);
                  JAM.call(this.writeLineToOutput, this, [";"]);
                  JAM.call(this.recordSourceMappingEnd, this, [varDecl$$5])
                }
              }
            }else {
              throw Error("We want to catch this");
            }
          }
          j$$3 = j$$3 + 1;
          v9758 = j$$3 < membersLen
        }
        this.emitIndent();
        JAM.call(this.recordSourceMappingStart, this, [classDecl$$3.endingToken]);
        JAM.call(this.writeLineToOutput, this, ["return " + className$$3 + ";"]);
        JAM.call(this.recordSourceMappingEnd, this, [classDecl$$3.endingToken]);
        this.indenter.decreaseIndent();
        this.emitIndent();
        JAM.call(this.recordSourceMappingStart, this, [classDecl$$3.endingToken]);
        JAM.call(this.writeToOutput, this, ["}"]);
        this.recordSourceMappingNameEnd();
        JAM.call(this.recordSourceMappingEnd, this, [classDecl$$3.endingToken]);
        JAM.call(this.recordSourceMappingStart, this, [classDecl$$3]);
        JAM.call(this.writeToOutput, this, [")("]);
        if(hasBaseClass) {
          JAM.call(this.emitJavascript, this, [baseName$$2, TypeScript$$12.TokenID.Tilde, false])
        }
        JAM.call(this.writeToOutput, this, [");"]);
        JAM.call(this.recordSourceMappingEnd, this, [classDecl$$3]);
        var v21976 = temp$$13 == EmitContainer.Module;
        if(!v21976) {
          v21976 = temp$$13 == EmitContainer.DynamicModule
        }
        var v17398 = v21976;
        if(v17398) {
          v17398 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [classDecl$$3.varFlags, TypeScript$$12.VarFlags.Exported])
        }
        if(v17398) {
          JAM.call(this.writeLineToOutput, this, [""]);
          this.emitIndent();
          var v9766;
          if(temp$$13 == EmitContainer.Module) {
            v9766 = this.moduleName
          }else {
            v9766 = "exports"
          }
          var modName$$2 = v9766;
          JAM.call(this.recordSourceMappingStart, this, [classDecl$$3]);
          JAM.call(this.writeToOutput, this, [modName$$2 + "." + className$$3 + " = " + className$$3 + ";"]);
          JAM.call(this.recordSourceMappingEnd, this, [classDecl$$3])
        }
        this.emitIndent();
        JAM.call(this.recordSourceMappingEnd, this, [classDecl$$3]);
        JAM.call(this.emitParensAndCommentsInPlace, this, [classDecl$$3, false]);
        JAM.call(this.setContainer, this, [temp$$13]);
        this.thisClassNode = svClassNode
      }
      return
    }
    function v484(className$$2, base$$1, classDecl$$2) {
      function v483(key$$32, s$$13, c$$6) {
        var sym$$5 = s$$13;
        var v17401 = sym$$5.kind() == TypeScript$$12.SymbolKind.Type;
        if(v17401) {
          v17401 = sym$$5.type.call
        }
        if(v17401) {
          JAM.call(this.recordSourceMappingStart, this, [sym$$5.declAST]);
          JAM.call(this.writeLineToOutput, this, [className$$2 + ".prototype." + sym$$5.name + " = " + baseName$$1 + ".prototype." + sym$$5.name + ";"]);
          JAM.call(this.recordSourceMappingEnd, this, [sym$$5.declAST])
        }
        return
      }
      if(base$$1.members) {
        var baseSymbol$$1 = base$$1.symbol;
        var baseName$$1 = baseSymbol$$1.name;
        if(baseSymbol$$1.declModule != classDecl$$2.type.symbol.declModule) {
          baseName$$1 = baseSymbol$$1.fullName()
        }
        var v9775 = base$$1.members.allMembers;
        JAM.call(v9775.map, v9775, [v483, null])
      }
      if(base$$1.extendsList) {
        var i$$46 = 0;
        var len$$12 = base$$1.extendsList.length;
        var v9779 = i$$46 < len$$12;
        for(;v9779;) {
          var v17406 = base$$1.extendsList;
          introspect(JAM.policy.p1) {
            var v9778 = v17406[i$$46]
          }
          JAM.call(this.emitAddBaseMethods, this, [className$$2, v9778, classDecl$$2]);
          i$$46 = i$$46 + 1;
          v9779 = i$$46 < len$$12
        }
      }
      return
    }
    function v482(member, className$$1) {
      if(member.nodeType == TypeScript$$12.NodeType.FuncDecl) {
        var funcDecl$$4 = member;
        if(funcDecl$$4.isAccessor()) {
          JAM.call(this.emitPropertyAccessor, this, [funcDecl$$4, className$$1, true])
        }else {
          this.emitIndent();
          JAM.call(this.recordSourceMappingStart, this, [funcDecl$$4]);
          JAM.call(this.writeToOutput, this, [className$$1 + ".prototype." + funcDecl$$4.getNameText() + " = "]);
          JAM.call(this.emitInnerFunction, this, [funcDecl$$4, false, true, null, JAM.call(Emitter$$1.shouldCaptureThis, Emitter$$1, [funcDecl$$4]), null]);
          JAM.call(this.writeLineToOutput, this, [";"])
        }
      }else {
        if(member.nodeType == TypeScript$$12.NodeType.VarDecl) {
          var varDecl$$4 = member;
          if(varDecl$$4.init) {
            this.emitIndent();
            JAM.call(this.recordSourceMappingStart, this, [varDecl$$4]);
            JAM.call(this.recordSourceMappingStart, this, [varDecl$$4.id]);
            JAM.call(this.writeToOutput, this, [className$$1 + ".prototype." + varDecl$$4.id.actualText]);
            JAM.call(this.recordSourceMappingEnd, this, [varDecl$$4.id]);
            JAM.call(this.writeToOutput, this, [" = "]);
            JAM.call(this.emitJavascript, this, [varDecl$$4.init, TypeScript$$12.TokenID.Equals, false]);
            JAM.call(this.recordSourceMappingEnd, this, [varDecl$$4]);
            JAM.call(this.writeLineToOutput, this, [";"])
          }
        }
      }
      return
    }
    function v481(funcDecl$$3, className, isProto) {
      if(!funcDecl$$3.accessorSymbol.hasBeenEmitted) {
        var accessorSymbol = funcDecl$$3.accessorSymbol;
        this.emitIndent();
        JAM.call(this.recordSourceMappingStart, this, [funcDecl$$3]);
        var v25377 = "Object.defineProperty(" + className;
        var v26036;
        if(isProto) {
          v26036 = '.prototype, "'
        }else {
          v26036 = ', "'
        }
        JAM.call(this.writeLineToOutput, this, [v25377 + v26036 + funcDecl$$3.name.actualText + '"' + ", {"]);
        this.indenter.increaseIndent();
        if(accessorSymbol.getter) {
          var getter = accessorSymbol.getter.declAST;
          this.emitIndent();
          JAM.call(this.recordSourceMappingStart, this, [getter]);
          JAM.call(this.writeToOutput, this, ["get: "]);
          JAM.call(this.emitInnerFunction, this, [getter, false, isProto, null, JAM.call(Emitter$$1.shouldCaptureThis, Emitter$$1, [getter]), null]);
          JAM.call(this.writeLineToOutput, this, [","])
        }
        if(accessorSymbol.setter) {
          var setter = accessorSymbol.setter.declAST;
          this.emitIndent();
          JAM.call(this.recordSourceMappingStart, this, [setter]);
          JAM.call(this.writeToOutput, this, ["set: "]);
          JAM.call(this.emitInnerFunction, this, [setter, false, isProto, null, JAM.call(Emitter$$1.shouldCaptureThis, Emitter$$1, [setter]), null]);
          JAM.call(this.writeLineToOutput, this, [","])
        }
        this.emitIndent();
        JAM.call(this.writeLineToOutput, this, ["enumerable: true,"]);
        this.emitIndent();
        JAM.call(this.writeLineToOutput, this, ["configurable: true"]);
        this.indenter.decreaseIndent();
        this.emitIndent();
        JAM.call(this.writeLineToOutput, this, ["});"]);
        JAM.call(this.recordSourceMappingEnd, this, [funcDecl$$3]);
        accessorSymbol.hasBeenEmitted = true
      }
      return
    }
    function v480(ast$$19, tokenId$$41, startLine$$40) {
      if(ast$$19 == null) {
        return
      }
      var v17417 = startLine$$40;
      if(v17417) {
        var v21994 = this.indenter.indentAmt > 0;
        if(v21994) {
          var v24259 = ast$$19.nodeType != TypeScript$$12.NodeType.List;
          if(v24259) {
            v24259 = ast$$19.nodeType != TypeScript$$12.NodeType.Block
          }
          v21994 = v24259
        }
        v17417 = v21994
      }
      if(v17417) {
        var v17418 = ast$$19.nodeType != TypeScript$$12.NodeType.InterfaceDeclaration;
        if(v17418) {
          var v26039 = ast$$19.nodeType == TypeScript$$12.NodeType.VarDecl;
          if(v26039) {
            var v26420 = (ast$$19.varFlags & TypeScript$$12.VarFlags.Ambient) == TypeScript$$12.VarFlags.Ambient;
            if(v26420) {
              v26420 = ast$$19.init == null
            }
            v26039 = v26420
          }
          var v24261 = !v26039;
          if(v24261) {
            v24261 = this.varListCount() >= 0
          }
          var v21997 = v24261;
          if(v21997) {
            var v24262 = ast$$19.nodeType != TypeScript$$12.NodeType.EndCode;
            if(v24262) {
              var v25389 = ast$$19.nodeType != TypeScript$$12.NodeType.FuncDecl;
              if(!v25389) {
                v25389 = this.emitState.container != EmitContainer.Constructor
              }
              v24262 = v25389
            }
            v21997 = v24262
          }
          v17418 = v21997
        }
        if(v17418) {
          this.emitIndent()
        }
      }
      JAM.call(ast$$19.emit, ast$$19, [this, tokenId$$41, startLine$$40]);
      var v17419 = tokenId$$41 == TypeScript$$12.TokenID.Semicolon;
      if(v17419) {
        v17419 = ast$$19.nodeType < TypeScript$$12.NodeType.GeneralNode
      }
      if(v17419) {
        JAM.call(this.writeToOutput, this, [";"])
      }
      return
    }
    function v479(ast$$18, delimiter, tokenId$$40, startLine$$39, onlyStatics, emitClassPropertiesAfterSuperCall$$1, emitPrologue, requiresExtendsBlock) {
      if(typeof emitClassPropertiesAfterSuperCall$$1 === "undefined") {
        emitClassPropertiesAfterSuperCall$$1 = false
      }
      if(typeof emitPrologue === "undefined") {
        emitPrologue = false
      }
      if(ast$$18 == null) {
      }else {
        if(ast$$18.nodeType != TypeScript$$12.NodeType.List) {
          JAM.call(this.emitPrologue, this, [emitPrologue]);
          JAM.call(this.emitJavascript, this, [ast$$18, tokenId$$40, startLine$$39])
        }else {
          var list$$1 = ast$$18;
          if(list$$1.members.length == 0) {
            return
          }
          JAM.call(this.emitParensAndCommentsInPlace, this, [ast$$18, true]);
          var len$$11 = list$$1.members.length;
          var i$$45 = 0;
          var v9835 = i$$45 < len$$11;
          for(;v9835;) {
            if(emitPrologue) {
              var v17425 = i$$45 == 1;
              if(!v17425) {
                v17425 = !JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [list$$1.flags, TypeScript$$12.ASTFlags.StrictMode])
              }
              if(v17425) {
                JAM.call(this.emitPrologue, this, [requiresExtendsBlock]);
                emitPrologue = false
              }
            }
            var v17426 = i$$45 == 1;
            if(v17426) {
              v17426 = emitClassPropertiesAfterSuperCall$$1
            }
            if(v17426) {
              var constructorDecl = this.thisClassNode.constructorDecl;
              var v17427 = constructorDecl;
              if(v17427) {
                v17427 = constructorDecl.arguments
              }
              if(v17427) {
                var argsLen$$1 = constructorDecl.arguments.members.length;
                var iArg = 0;
                var v9821 = iArg < argsLen$$1;
                for(;v9821;) {
                  var v9813 = constructorDecl.arguments.members;
                  introspect(JAM.policy.p1) {
                    var arg$$7 = v9813[iArg]
                  }
                  if((arg$$7.varFlags & TypeScript$$12.VarFlags.Property) != TypeScript$$12.VarFlags.None) {
                    this.emitIndent();
                    JAM.call(this.recordSourceMappingStart, this, [arg$$7]);
                    JAM.call(this.recordSourceMappingStart, this, [arg$$7.id]);
                    JAM.call(this.writeToOutput, this, ["this." + arg$$7.id.actualText]);
                    JAM.call(this.recordSourceMappingEnd, this, [arg$$7.id]);
                    JAM.call(this.writeToOutput, this, [" = "]);
                    JAM.call(this.recordSourceMappingStart, this, [arg$$7.id]);
                    JAM.call(this.writeToOutput, this, [arg$$7.id.actualText]);
                    JAM.call(this.recordSourceMappingEnd, this, [arg$$7.id]);
                    JAM.call(this.writeLineToOutput, this, [";"]);
                    JAM.call(this.recordSourceMappingEnd, this, [arg$$7])
                  }
                  iArg = iArg + 1;
                  v9821 = iArg < argsLen$$1
                }
              }
              var nProps$$1 = this.thisClassNode.members.members.length;
              var iMember = 0;
              var v9828 = iMember < nProps$$1;
              for(;v9828;) {
                var v24268 = this.thisClassNode.members.members;
                introspect(JAM.policy.p1) {
                  var v22010 = v24268[iMember]
                }
                if(v22010.nodeType == TypeScript$$12.NodeType.VarDecl) {
                  var v9824 = this.thisClassNode.members.members;
                  introspect(JAM.policy.p1) {
                    var varDecl$$3 = v9824[iMember]
                  }
                  var v17438 = !JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [varDecl$$3.varFlags, TypeScript$$12.VarFlags.Static]);
                  if(v17438) {
                    v17438 = varDecl$$3.init
                  }
                  if(v17438) {
                    this.emitIndent();
                    JAM.call(this.emitJavascriptVarDecl, this, [varDecl$$3, TypeScript$$12.TokenID.Tilde]);
                    JAM.call(this.writeLineToOutput, this, [""])
                  }
                }
                iMember = iMember + 1;
                v9828 = iMember < nProps$$1
              }
            }
            var v9830 = list$$1.members;
            introspect(JAM.policy.p1) {
              var emitNode = v9830[i$$45]
            }
            var v17440 = emitNode.nodeType == TypeScript$$12.NodeType.FuncDecl;
            if(v17440) {
              v17440 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [emitNode.fncFlags, TypeScript$$12.FncFlags.Static])
            }
            var v9831 = v17440;
            if(!v9831) {
              var v17441 = emitNode.nodeType == TypeScript$$12.NodeType.VarDecl;
              if(v17441) {
                v17441 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [emitNode.varFlags, TypeScript$$12.VarFlags.Static])
              }
              v9831 = v17441
            }
            var isStaticDecl = v9831;
            var v17443;
            if(onlyStatics) {
              v17443 = !isStaticDecl
            }else {
              v17443 = isStaticDecl
            }
            if(v17443) {
              i$$45 = i$$45 + 1;
              v9835 = i$$45 < len$$11;
              continue
            }
            JAM.call(this.emitJavascript, this, [emitNode, tokenId$$40, startLine$$39]);
            var v17444 = delimiter;
            if(v17444) {
              v17444 = i$$45 < len$$11 - 1
            }
            if(v17444) {
              if(startLine$$39) {
                JAM.call(this.writeLineToOutput, this, [delimiter])
              }else {
                JAM.call(this.writeToOutput, this, [delimiter])
              }
            }else {
              var v17445 = startLine$$39;
              if(v17445) {
                var v22023 = emitNode.nodeType != TypeScript$$12.NodeType.ModuleDeclaration;
                if(v22023) {
                  var v24277 = emitNode.nodeType != TypeScript$$12.NodeType.InterfaceDeclaration;
                  if(v24277) {
                    var v26578 = emitNode.nodeType == TypeScript$$12.NodeType.VarDecl;
                    if(v26578) {
                      var v26663 = (emitNode.varFlags & TypeScript$$12.VarFlags.Ambient) == TypeScript$$12.VarFlags.Ambient;
                      if(v26663) {
                        v26663 = emitNode.init == null
                      }
                      v26578 = v26663
                    }
                    var v26048 = !v26578;
                    if(v26048) {
                      v26048 = this.varListCount() >= 0
                    }
                    var v25396 = v26048;
                    if(v25396) {
                      var v26425 = emitNode.nodeType != TypeScript$$12.NodeType.Block;
                      if(!v26425) {
                        v26425 = emitNode.isStatementBlock
                      }
                      var v26049 = v26425;
                      if(v26049) {
                        var v26426 = emitNode.nodeType != TypeScript$$12.NodeType.EndCode;
                        if(v26426) {
                          v26426 = emitNode.nodeType != TypeScript$$12.NodeType.FuncDecl
                        }
                        v26049 = v26426
                      }
                      v25396 = v26049
                    }
                    v24277 = v25396
                  }
                  v22023 = v24277
                }
                v17445 = v22023
              }
              if(v17445) {
                JAM.call(this.writeLineToOutput, this, [""])
              }
            }
            i$$45 = i$$45 + 1;
            v9835 = i$$45 < len$$11
          }
          JAM.call(this.emitParensAndCommentsInPlace, this, [ast$$18, false])
        }
      }
      return
    }
    function v478() {
      if(this.sourceMapper != null) {
        var v9838 = TypeScript$$12.SourceMapper;
        JAM.call(v9838.EmitSourceMapping, v9838, [this.allSourceMappers])
      }
      try {
        this.outfile.Close()
      }catch(ex$$1) {
        var v9842 = this.errorReporter;
        JAM.call(v9842.emitterError, v9842, [null, ex$$1.message])
      }
      return
    }
    function v477(ast$$17) {
      var v17447 = this.sourceMapper;
      if(v17447) {
        v17447 = JAM.call(TypeScript$$12.isValidAstNode, TypeScript$$12, [ast$$17])
      }
      if(v17447) {
        this.sourceMapper.currentMappings.pop();
        var v9845 = this.sourceMapper.currentMappings;
        var v9846 = this.sourceMapper.currentMappings.length - 1;
        introspect(JAM.policy.p1) {
          var siblings$$1 = v9845[v9846]
        }
        var v9847 = siblings$$1.length - 1;
        introspect(JAM.policy.p1) {
          var sourceMapping$$2 = siblings$$1[v9847]
        }
        sourceMapping$$2.end.emittedColumn = this.emitState.column;
        sourceMapping$$2.end.emittedLine = this.emitState.line
      }
      return
    }
    function v476(ast$$16) {
      var v17454 = this.sourceMapper;
      if(v17454) {
        v17454 = JAM.call(TypeScript$$12.isValidAstNode, TypeScript$$12, [ast$$16])
      }
      if(v17454) {
        var lineCol$$1 = {line:-1, col:-1};
        var sourceMapping$$1 = new TypeScript$$12.SourceMapping;
        sourceMapping$$1.start.emittedColumn = this.emitState.column;
        sourceMapping$$1.start.emittedLine = this.emitState.line;
        JAM.call(TypeScript$$12.getSourceLineColFromMap, TypeScript$$12, [lineCol$$1, ast$$16.minChar, this.checker.locationInfo.lineMap]);
        sourceMapping$$1.start.sourceColumn = lineCol$$1.col;
        sourceMapping$$1.start.sourceLine = lineCol$$1.line;
        JAM.call(TypeScript$$12.getSourceLineColFromMap, TypeScript$$12, [lineCol$$1, ast$$16.limChar, this.checker.locationInfo.lineMap]);
        sourceMapping$$1.end.sourceColumn = lineCol$$1.col;
        sourceMapping$$1.end.sourceLine = lineCol$$1.line;
        if(this.sourceMapper.currentNameIndex.length > 0) {
          sourceMapping$$1.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1]
        }
        var v9865 = this.sourceMapper.currentMappings;
        var v9866 = this.sourceMapper.currentMappings.length - 1;
        introspect(JAM.policy.p1) {
          var siblings = v9865[v9866]
        }
        JAM.call(siblings.push, siblings, [sourceMapping$$1]);
        var v9867 = this.sourceMapper.currentMappings;
        JAM.call(v9867.push, v9867, [sourceMapping$$1.childMappings])
      }
      return
    }
    function v475() {
      if(this.sourceMapper) {
        this.sourceMapper.currentNameIndex.pop()
      }
      return
    }
    function v474(name$$41) {
      if(this.sourceMapper) {
        var finalName = name$$41;
        if(!name$$41) {
          finalName = ""
        }else {
          if(this.sourceMapper.currentNameIndex.length > 0) {
            var v22031 = this.sourceMapper.names;
            var v22032 = this.sourceMapper.currentNameIndex.length - 1;
            introspect(JAM.policy.p1) {
              var v17467 = v22031[v22032]
            }
            finalName = v17467 + "." + name$$41
          }
        }
        var v9875 = this.sourceMapper.names;
        JAM.call(v9875.push, v9875, [finalName]);
        var v9876 = this.sourceMapper.currentNameIndex;
        JAM.call(v9876.push, v9876, [this.sourceMapper.names.length - 1])
      }
      return
    }
    function v473(stmts$$2, emitClassPropertiesAfterSuperCall) {
      if(typeof emitClassPropertiesAfterSuperCall === "undefined") {
        emitClassPropertiesAfterSuperCall = false
      }
      if(stmts$$2.nodeType != TypeScript$$12.NodeType.Block) {
        if(stmts$$2.nodeType == TypeScript$$12.NodeType.List) {
          var stmtList = stmts$$2;
          var v17476 = stmtList.members.length == 2;
          if(v17476) {
            var v22037 = stmtList.members[0].nodeType == TypeScript$$12.NodeType.Block;
            if(v22037) {
              v22037 = stmtList.members[1].nodeType == TypeScript$$12.NodeType.EndCode
            }
            v17476 = v22037
          }
          if(v17476) {
            JAM.call(this.emitJavascript, this, [stmtList.members[0], TypeScript$$12.TokenID.Semicolon, true]);
            JAM.call(this.writeLineToOutput, this, [""])
          }else {
            JAM.call(this.emitJavascriptList, this, [stmts$$2, null, TypeScript$$12.TokenID.Semicolon, true, false, emitClassPropertiesAfterSuperCall])
          }
        }else {
          JAM.call(this.emitJavascript, this, [stmts$$2, TypeScript$$12.TokenID.Semicolon, true])
        }
      }else {
        JAM.call(this.emitJavascript, this, [stmts$$2, TypeScript$$12.TokenID.Semicolon, true])
      }
      return
    }
    function v472(stmts$$1, emitEmptyBod) {
      if(stmts$$1) {
        if(stmts$$1.nodeType != TypeScript$$12.NodeType.Block) {
          var v9888 = stmts$$1;
          if(v9888) {
            var v17484 = stmts$$1.nodeType != TypeScript$$12.NodeType.List;
            if(!v17484) {
              v17484 = stmts$$1.members.length > 0
            }
            v9888 = v17484
          }
          var hasContents = v9888;
          if(emitEmptyBod || hasContents) {
            var v9889 = stmts$$1.nodeType == TypeScript$$12.NodeType.Block;
            if(!v9889) {
              var v17487 = stmts$$1.nodeType == TypeScript$$12.NodeType.List;
              if(v17487) {
                var v22046 = stmts$$1.members.length == 1;
                if(v22046) {
                  v22046 = stmts$$1.members[0].nodeType == TypeScript$$12.NodeType.Block
                }
                v17487 = v22046
              }
              v9889 = v17487
            }
            var hasOnlyBlockStatement = v9889;
            JAM.call(this.recordSourceMappingStart, this, [stmts$$1]);
            if(!hasOnlyBlockStatement) {
              JAM.call(this.writeLineToOutput, this, [" {"]);
              this.indenter.increaseIndent()
            }
            JAM.call(this.emitJavascriptList, this, [stmts$$1, null, TypeScript$$12.TokenID.Semicolon, true, false, false]);
            if(!hasOnlyBlockStatement) {
              JAM.call(this.writeLineToOutput, this, [""]);
              this.indenter.decreaseIndent();
              this.emitIndent();
              JAM.call(this.writeToOutput, this, ["}"])
            }
            JAM.call(this.recordSourceMappingEnd, this, [stmts$$1])
          }
        }else {
          JAM.call(this.emitJavascript, this, [stmts$$1, TypeScript$$12.TokenID.Semicolon, true])
        }
      }else {
        if(emitEmptyBod) {
          JAM.call(this.writeToOutput, this, ["{ }"])
        }
      }
      return
    }
    function v471(name$$40, addThis) {
      var sym$$4 = name$$40.sym;
      JAM.call(this.emitParensAndCommentsInPlace, this, [name$$40, true]);
      JAM.call(this.recordSourceMappingStart, this, [name$$40]);
      if(!name$$40.isMissing()) {
        var v17492 = addThis;
        if(v17492) {
          var v22047 = this.emitState.container != EmitContainer.Args;
          if(v22047) {
            v22047 = sym$$4
          }
          v17492 = v22047
        }
        if(v17492) {
          var v17493 = sym$$4.container;
          if(v17493) {
            v17493 = sym$$4.container.name != TypeScript$$12.globalId
          }
          if(v17493) {
            var v17494 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$4.flags, TypeScript$$12.SymbolFlags.Static]);
            if(v17494) {
              v17494 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$4.flags, TypeScript$$12.SymbolFlags.Property])
            }
            if(v17494) {
              var v17495 = sym$$4.declModule;
              if(v17495) {
                v17495 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$4.declModule.modFlags, TypeScript$$12.ModuleFlags.IsDynamic])
              }
              if(v17495) {
                JAM.call(this.writeToOutput, this, ["exports."])
              }else {
                JAM.call(this.writeToOutput, this, [sym$$4.container.name + "."])
              }
            }else {
              if(sym$$4.kind() == TypeScript$$12.SymbolKind.Field) {
                var fieldSym = sym$$4;
                if(JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [fieldSym.flags, TypeScript$$12.SymbolFlags.ModuleMember])) {
                  var v17501 = sym$$4.container != this.checker.gloMod;
                  if(v17501) {
                    var v22061 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$4.flags, TypeScript$$12.SymbolFlags.Property]);
                    if(!v22061) {
                      v22061 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$4.flags, TypeScript$$12.SymbolFlags.Exported])
                    }
                    v17501 = v22061
                  }
                  if(v17501) {
                    if(JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$4.declModule.modFlags, TypeScript$$12.ModuleFlags.IsDynamic])) {
                      JAM.call(this.writeToOutput, this, ["exports."])
                    }else {
                      JAM.call(this.writeToOutput, this, [sym$$4.container.name + "."])
                    }
                  }
                }else {
                  if(sym$$4.isInstanceProperty()) {
                    this.emitThis();
                    JAM.call(this.writeToOutput, this, ["."])
                  }
                }
              }else {
                if(sym$$4.kind() == TypeScript$$12.SymbolKind.Type) {
                  if(sym$$4.isInstanceProperty()) {
                    var typeSym = sym$$4;
                    var type$$28 = typeSym.type;
                    var v17507 = type$$28.call;
                    if(v17507) {
                      v17507 = !JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$4.flags, TypeScript$$12.SymbolFlags.ModuleMember])
                    }
                    if(v17507) {
                      this.emitThis();
                      JAM.call(this.writeToOutput, this, ["."])
                    }
                  }else {
                    var v17508 = sym$$4.unitIndex != this.checker.locationInfo.unitIndex;
                    if(!v17508) {
                      v17508 = !JAM.call(this.declEnclosed, this, [sym$$4.declModule])
                    }
                    if(v17508) {
                      JAM.call(this.writeToOutput, this, [sym$$4.container.name + "."])
                    }
                  }
                }
              }
            }
          }else {
            var v17510 = sym$$4.container == this.checker.gloMod;
            if(v17510) {
              var v22074 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$4.flags, TypeScript$$12.SymbolFlags.Exported]);
              if(v22074) {
                var v24317 = !JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$4.flags, TypeScript$$12.SymbolFlags.Ambient]);
                if(v24317) {
                  var v26586 = sym$$4.isType();
                  if(!v26586) {
                    v26586 = sym$$4.isMember()
                  }
                  var v26428 = v26586;
                  if(v26428) {
                    var v26587 = sym$$4.declModule;
                    if(v26587) {
                      v26587 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$4.declModule.modFlags, TypeScript$$12.ModuleFlags.Ambient])
                    }
                    v26428 = v26587
                  }
                  var v25412 = !v26428;
                  if(v25412) {
                    var v26057 = this.emitState.container == EmitContainer.Prog;
                    if(v26057) {
                      v26057 = sym$$4.declAST.nodeType != TypeScript$$12.NodeType.FuncDecl
                    }
                    v25412 = v26057
                  }
                  v24317 = v25412
                }
                v22074 = v24317
              }
              v17510 = v22074
            }
            if(v17510) {
              JAM.call(this.writeToOutput, this, ["this."])
            }
          }
        }
        var v17511 = sym$$4;
        if(v17511) {
          var v22075 = sym$$4.declAST;
          if(v22075) {
            var v24318 = sym$$4.declAST.nodeType == TypeScript$$12.NodeType.ModuleDeclaration;
            if(v24318) {
              v24318 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$4.declAST.modFlags, TypeScript$$12.ModuleFlags.IsDynamic])
            }
            v22075 = v24318
          }
          v17511 = v22075
        }
        if(v17511) {
          var moduleDecl$$2 = sym$$4.declAST;
          if(TypeScript$$12.moduleGenTarget == TypeScript$$12.ModuleGenTarget.Asynchronous) {
            JAM.call(this.writeLineToOutput, this, ["__" + this.modAliasId + "__;"])
          }else {
            var modPath$$1 = name$$40.actualText;
            var v9916 = moduleDecl$$2.mod.symbol.declAST;
            if(v9916) {
              v9916 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [moduleDecl$$2.mod.symbol.declAST.modFlags, TypeScript$$12.ModuleFlags.Ambient])
            }
            var isAmbient = v9916;
            var v9917;
            if(isAmbient) {
              v9917 = modPath$$1
            }else {
              var v17518;
              if(this.firstModAlias) {
                v17518 = this.firstModAlias
              }else {
                v17518 = JAM.call(TypeScript$$12.quoteBaseName, TypeScript$$12, [modPath$$1])
              }
              v9917 = v17518
            }
            modPath$$1 = v9917;
            var v9918;
            if(isAmbient) {
              v9918 = modPath$$1
            }else {
              var v17519;
              if(!JAM.call(TypeScript$$12.isRelative, TypeScript$$12, [JAM.call(TypeScript$$12.stripQuotes, TypeScript$$12, [modPath$$1])])) {
                v17519 = JAM.call(TypeScript$$12.quoteStr, TypeScript$$12, ["./" + JAM.call(TypeScript$$12.stripQuotes, TypeScript$$12, [modPath$$1])])
              }else {
                v17519 = modPath$$1
              }
              v9918 = v17519
            }
            modPath$$1 = v9918;
            JAM.call(this.writeToOutput, this, ["require(" + modPath$$1 + ")"])
          }
        }else {
          JAM.call(this.writeToOutput, this, [name$$40.actualText])
        }
      }
      JAM.call(this.recordSourceMappingEnd, this, [name$$40]);
      JAM.call(this.emitParensAndCommentsInPlace, this, [name$$40, false]);
      return
    }
    function v470(moduleDecl$$1) {
      if(moduleDecl$$1 == null) {
        return true
      }
      var i$$44 = 0;
      var len$$10 = this.moduleDeclList.length;
      var v9927 = i$$44 < len$$10;
      for(;v9927;) {
        var v22084 = this.moduleDeclList;
        introspect(JAM.policy.p1) {
          var v17521 = v22084[i$$44]
        }
        if(v17521 == moduleDecl$$1) {
          return true
        }
        i$$44 = i$$44 + 1;
        v9927 = i$$44 < len$$10
      }
      return false
    }
    function v469(varDecl$$2, tokenId$$39) {
      if((varDecl$$2.varFlags & TypeScript$$12.VarFlags.Ambient) == TypeScript$$12.VarFlags.Ambient) {
        JAM.call(this.emitAmbientVarDecl, this, [varDecl$$2]);
        this.onEmitVar()
      }else {
        var sym$$3 = varDecl$$2.sym;
        var hasInitializer = varDecl$$2.init != null;
        JAM.call(this.emitParensAndCommentsInPlace, this, [varDecl$$2, true]);
        JAM.call(this.recordSourceMappingStart, this, [varDecl$$2]);
        var v17524 = sym$$3;
        if(v17524) {
          var v22088 = sym$$3.isMember();
          if(v22088) {
            var v24323 = sym$$3.container;
            if(v24323) {
              v24323 = sym$$3.container.kind() == TypeScript$$12.SymbolKind.Type
            }
            v22088 = v24323
          }
          v17524 = v22088
        }
        if(v17524) {
          var type$$27 = sym$$3.container.type;
          var v17525 = type$$27.isClass();
          if(v17525) {
            v17525 = !JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$3.flags, TypeScript$$12.SymbolFlags.ModuleMember])
          }
          if(v17525) {
            if(this.emitState.container != EmitContainer.Args) {
              if(JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$3.flags, TypeScript$$12.SymbolFlags.Static])) {
                JAM.call(this.writeToOutput, this, [sym$$3.container.name + "."])
              }else {
                JAM.call(this.writeToOutput, this, ["this."])
              }
            }
          }else {
            if(type$$27.hasImplementation()) {
              var v17531 = !JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$3.flags, TypeScript$$12.SymbolFlags.Exported]);
              if(v17531) {
                var v22094 = sym$$3.container == this.checker.gloMod;
                if(!v22094) {
                  v22094 = !JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$3.flags, TypeScript$$12.SymbolFlags.Property])
                }
                v17531 = v22094
              }
              if(v17531) {
                this.emitVarDeclVar()
              }else {
                if(JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [varDecl$$2.varFlags, TypeScript$$12.VarFlags.LocalStatic])) {
                  JAM.call(this.writeToOutput, this, ["."])
                }else {
                  if(this.emitState.container == EmitContainer.DynamicModule) {
                    JAM.call(this.writeToOutput, this, ["exports."])
                  }else {
                    JAM.call(this.writeToOutput, this, [this.moduleName + "."])
                  }
                }
              }
            }else {
              if(tokenId$$39 != TypeScript$$12.TokenID.OpenParen) {
                var v17538 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [sym$$3.flags, TypeScript$$12.SymbolFlags.Exported]);
                if(v17538) {
                  v17538 = sym$$3.container == this.checker.gloMod
                }
                if(v17538) {
                  JAM.call(this.writeToOutput, this, ["this."])
                }else {
                  this.emitVarDeclVar()
                }
              }
            }
          }
        }else {
          if(tokenId$$39 != TypeScript$$12.TokenID.OpenParen) {
            this.emitVarDeclVar()
          }
        }
        JAM.call(this.recordSourceMappingStart, this, [varDecl$$2.id]);
        JAM.call(this.writeToOutput, this, [varDecl$$2.id.actualText]);
        JAM.call(this.recordSourceMappingEnd, this, [varDecl$$2.id]);
        if(hasInitializer) {
          JAM.call(this.writeToOutputTrimmable, this, [" = "]);
          var v9946 = this.varListCountStack;
          JAM.call(v9946.push, v9946, [0]);
          JAM.call(this.emitJavascript, this, [varDecl$$2.init, TypeScript$$12.TokenID.Comma, false]);
          this.varListCountStack.pop()
        }
        this.onEmitVar();
        if(tokenId$$39 != TypeScript$$12.TokenID.OpenParen) {
          if(this.varListCount() < 0) {
            JAM.call(this.writeToOutput, this, [", "])
          }else {
            if(tokenId$$39 != TypeScript$$12.TokenID.For) {
              JAM.call(this.writeToOutputTrimmable, this, [";"])
            }
          }
        }
        JAM.call(this.recordSourceMappingEnd, this, [varDecl$$2]);
        JAM.call(this.emitParensAndCommentsInPlace, this, [varDecl$$2, false])
      }
      return
    }
    function v468() {
      if(this.varListCount() > 0) {
        JAM.call(this.setInVarBlock, this, [this.varListCount() - 1])
      }else {
        if(this.varListCount() < 0) {
          JAM.call(this.setInVarBlock, this, [this.varListCount() + 1])
        }
      }
      return
    }
    function v467() {
      if(this.varListCount() >= 0) {
        JAM.call(this.writeToOutput, this, ["var "]);
        JAM.call(this.setInVarBlock, this, [-this.varListCount()])
      }
      return true
    }
    function v466() {
      var v9960 = this.varListCountStack;
      var v9961 = this.varListCountStack.length - 1;
      introspect(JAM.policy.p1) {
        return v9960[v9961]
      }
    }
    function v465(varDecl$$1) {
      if(varDecl$$1.init) {
        JAM.call(this.emitParensAndCommentsInPlace, this, [varDecl$$1, true]);
        JAM.call(this.recordSourceMappingStart, this, [varDecl$$1]);
        JAM.call(this.recordSourceMappingStart, this, [varDecl$$1.id]);
        JAM.call(this.writeToOutput, this, [varDecl$$1.id.actualText]);
        JAM.call(this.recordSourceMappingEnd, this, [varDecl$$1.id]);
        JAM.call(this.writeToOutput, this, [" = "]);
        JAM.call(this.emitJavascript, this, [varDecl$$1.init, TypeScript$$12.TokenID.Comma, false]);
        JAM.call(this.recordSourceMappingEnd, this, [varDecl$$1]);
        JAM.call(this.writeToOutput, this, [";"]);
        JAM.call(this.emitParensAndCommentsInPlace, this, [varDecl$$1, false])
      }
      return
    }
    function v464(funcDecl$$2) {
      var v17554 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$2.fncFlags, TypeScript$$12.FncFlags.Signature]);
      if(!v17554) {
        v17554 = funcDecl$$2.isOverload
      }
      if(v17554) {
        return
      }
      var temp$$12;
      var tempFnc = this.thisFnc;
      this.thisFnc = funcDecl$$2;
      if(funcDecl$$2.isConstructor) {
        temp$$12 = JAM.call(this.setContainer, this, [EmitContainer.Constructor])
      }else {
        temp$$12 = JAM.call(this.setContainer, this, [EmitContainer.Function])
      }
      var bases$$2 = null;
      var hasSelfRef$$1 = false;
      var funcName = funcDecl$$2.getNameText();
      var v22109 = this.emitState.inObjectLiteral;
      if(!v22109) {
        v22109 = !funcDecl$$2.isAccessor()
      }
      var v17555 = v22109;
      if(v17555) {
        var v22110 = temp$$12 != EmitContainer.Constructor;
        if(!v22110) {
          v22110 = (funcDecl$$2.fncFlags & TypeScript$$12.FncFlags.Method) == TypeScript$$12.FncFlags.None
        }
        v17555 = v22110
      }
      if(v17555) {
        var tempLit = JAM.call(this.setInObjectLiteral, this, [false]);
        if(this.thisClassNode) {
          bases$$2 = this.thisClassNode.extendsList
        }
        hasSelfRef$$1 = JAM.call(Emitter$$1.shouldCaptureThis, Emitter$$1, [funcDecl$$2]);
        JAM.call(this.recordSourceMappingStart, this, [funcDecl$$2]);
        var v17556 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$2.fncFlags, TypeScript$$12.FncFlags.Exported | TypeScript$$12.FncFlags.ClassPropertyMethodExported]);
        if(v17556) {
          var v22113 = funcDecl$$2.type.symbol.container == this.checker.gloMod;
          if(v22113) {
            v22113 = !funcDecl$$2.isConstructor
          }
          v17556 = v22113
        }
        if(v17556) {
          JAM.call(this.writeToOutput, this, ["this." + funcName + " = "]);
          JAM.call(this.emitInnerFunction, this, [funcDecl$$2, false, false, bases$$2, hasSelfRef$$1, this.thisClassNode])
        }else {
          var v17558 = funcDecl$$2.name;
          if(v17558) {
            v17558 = !funcDecl$$2.name.isMissing()
          }
          JAM.call(this.emitInnerFunction, this, [funcDecl$$2, v17558, false, bases$$2, hasSelfRef$$1, this.thisClassNode])
        }
        JAM.call(this.setInObjectLiteral, this, [tempLit])
      }
      JAM.call(this.setContainer, this, [temp$$12]);
      this.thisFnc = tempFnc;
      if(JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$2.fncFlags, TypeScript$$12.FncFlags.Definition])) {
        if(JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$2.fncFlags, TypeScript$$12.FncFlags.Static])) {
          if(this.thisClassNode) {
            if(funcDecl$$2.isAccessor()) {
              JAM.call(this.emitPropertyAccessor, this, [funcDecl$$2, this.thisClassNode.name.actualText, false])
            }else {
              this.emitIndent();
              JAM.call(this.recordSourceMappingStart, this, [funcDecl$$2]);
              JAM.call(this.writeLineToOutput, this, [this.thisClassNode.name.actualText + "." + funcName + " = " + funcName + ";"]);
              JAM.call(this.recordSourceMappingEnd, this, [funcDecl$$2])
            }
          }
        }else {
          var v22119 = this.emitState.container == EmitContainer.Module;
          if(!v22119) {
            v22119 = this.emitState.container == EmitContainer.DynamicModule
          }
          var v17565 = v22119;
          if(v17565) {
            v17565 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$2.fncFlags, TypeScript$$12.FncFlags.Exported | TypeScript$$12.FncFlags.ClassPropertyMethodExported])
          }
          if(v17565) {
            this.emitIndent();
            var v9984;
            if(this.emitState.container == EmitContainer.Module) {
              v9984 = this.moduleName
            }else {
              v9984 = "exports"
            }
            var modName$$1 = v9984;
            JAM.call(this.recordSourceMappingStart, this, [funcDecl$$2]);
            JAM.call(this.writeLineToOutput, this, [modName$$1 + "." + funcName + " = " + funcName + ";"]);
            JAM.call(this.recordSourceMappingEnd, this, [funcDecl$$2])
          }
        }
      }
      return
    }
    function v463(text$$11) {
      JAM.call(this.writeToOutput, this, [text$$11]);
      return
    }
    function v462(operand1$$2, operand2$$2) {
      var temp$$11 = JAM.call(this.setInObjectLiteral, this, [false]);
      JAM.call(this.emitJavascript, this, [operand1$$2, TypeScript$$12.TokenID.Tilde, false]);
      JAM.call(this.writeToOutput, this, ["["]);
      JAM.call(this.emitJavascriptList, this, [operand2$$2, ", ", TypeScript$$12.TokenID.Comma, false, false, false]);
      JAM.call(this.writeToOutput, this, ["]"]);
      JAM.call(this.setInObjectLiteral, this, [temp$$11]);
      return
    }
    function v461(moduleDecl) {
      var modName = moduleDecl.name.actualText;
      if(JAM.call(TypeScript$$12.isTSFile, TypeScript$$12, [modName])) {
        var v9992 = moduleDecl.name;
        JAM.call(v9992.setText, v9992, [JAM.call(modName.substring, modName, [0, modName.length - 3])])
      }else {
        if(JAM.call(TypeScript$$12.isSTRFile, TypeScript$$12, [modName])) {
          var v9994 = moduleDecl.name;
          JAM.call(v9994.setText, v9994, [JAM.call(modName.substring, modName, [0, modName.length - 4])])
        }
      }
      if(!JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [moduleDecl.modFlags, TypeScript$$12.ModuleFlags.Ambient])) {
        var isDynamicMod = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [moduleDecl.modFlags, TypeScript$$12.ModuleFlags.IsDynamic]);
        var prevOutFile = this.outfile;
        var prevOutFileName = this.emittingFileName;
        var prevAllSourceMappers = this.allSourceMappers;
        var prevSourceMapper = this.sourceMapper;
        var prevColumn = this.emitState.column;
        var prevLine = this.emitState.line;
        var temp$$10 = JAM.call(this.setContainer, this, [EmitContainer.Module]);
        var svModuleName = this.moduleName;
        var isExported = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [moduleDecl.modFlags, TypeScript$$12.ModuleFlags.Exported]);
        JAM.set(this.moduleDeclList, this.moduleDeclList.length, moduleDecl);
        var isWholeFile = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [moduleDecl.modFlags, TypeScript$$12.ModuleFlags.IsWholeFile]);
        this.moduleName = moduleDecl.name.actualText;
        if(isDynamicMod) {
          var tsModFileName = JAM.call(TypeScript$$12.stripQuotes, TypeScript$$12, [moduleDecl.name.actualText]);
          var modFilePath = JAM.call(TypeScript$$12.trimModName, TypeScript$$12, [tsModFileName]) + ".js";
          var v10012 = this.emitOptions;
          modFilePath = JAM.call(v10012.mapOutputFileName, v10012, [modFilePath, TypeScript$$12.TypeScriptCompiler.mapToJSFileName]);
          if(this.emitOptions.ioHost) {
            if(JAM.call(TypeScript$$12.switchToForwardSlashes, TypeScript$$12, [modFilePath]) != JAM.call(TypeScript$$12.switchToForwardSlashes, TypeScript$$12, [this.emittingFileName])) {
              this.emittingFileName = modFilePath;
              var v10014 = moduleDecl.containsUnicodeChar;
              if(!v10014) {
                var v17582 = this.emitOptions.emitComments;
                if(v17582) {
                  v17582 = moduleDecl.containsUnicodeCharInComment
                }
                v10014 = v17582
              }
              var useUTF8InOutputfile = v10014;
              var v27322 = JAM.call(this.createFile, this, [this.emittingFileName, useUTF8InOutputfile]);
              this.outfile = v27322;
              if(prevSourceMapper != null) {
                this.allSourceMappers = [];
                var sourceMappingFile = JAM.call(this.createFile, this, [this.emittingFileName + TypeScript$$12.SourceMapper.MapFileExtension, false]);
                JAM.call(this.setSourceMappings, this, [JAM.new(TypeScript$$12.SourceMapper, [tsModFileName, this.emittingFileName, this.outfile, sourceMappingFile, this.errorReporter])]);
                this.emitState.column = 0;
                this.emitState.line = 0
              }
            }else {
              var v10021 = TypeScript$$12.CompilerDiagnostics;
              JAM.call(v10021.assert, v10021, [this.emitOptions.outputMany, "Cannot have dynamic modules compiling into single file"])
            }
          }
          JAM.call(this.setContainer, this, [EmitContainer.DynamicModule]);
          JAM.call(this.recordSourceMappingStart, this, [moduleDecl]);
          if(TypeScript$$12.moduleGenTarget == TypeScript$$12.ModuleGenTarget.Asynchronous) {
            var dependencyList = '["require", "exports"';
            var importList = "require, exports";
            var importStatement = null;
            var i$$43 = 0;
            var v10029 = i$$43 < moduleDecl.mod.importedModules.length;
            for(;v10029;) {
              importStatement = moduleDecl.mod.importedModules[i$$43];
              var v17595 = importStatement.id.sym;
              if(v17595) {
                v17595 = !importStatement.id.sym.onlyReferencedAsTypeRef
              }
              if(v17595) {
                if(i$$43 <= moduleDecl.mod.importedModules.length - 1) {
                  dependencyList = dependencyList + ", ";
                  importList = importList + ", "
                }
                importList = importList + ("__" + importStatement.id.actualText + "__");
                dependencyList = dependencyList + importStatement.firstAliasedModToString()
              }
              i$$43 = i$$43 + 1;
              v10029 = i$$43 < moduleDecl.mod.importedModules.length
            }
            i$$43 = 0;
            var v10030 = i$$43 < moduleDecl.amdDependencies.length;
            for(;v10030;) {
              var v25442 = moduleDecl.amdDependencies;
              introspect(JAM.policy.p1) {
                var v24364 = v25442[i$$43]
              }
              dependencyList = dependencyList + (', "' + v24364 + '"');
              i$$43 = i$$43 + 1;
              v10030 = i$$43 < moduleDecl.amdDependencies.length
            }
            dependencyList = dependencyList + "]";
            JAM.call(this.writeLineToOutput, this, ["define(" + dependencyList + "," + " function(" + importList + ") {"])
          }else {
          }
        }else {
          if(!isExported) {
            JAM.call(this.recordSourceMappingStart, this, [moduleDecl]);
            JAM.call(this.writeToOutput, this, ["var "]);
            JAM.call(this.recordSourceMappingStart, this, [moduleDecl.name]);
            JAM.call(this.writeToOutput, this, [this.moduleName]);
            JAM.call(this.recordSourceMappingEnd, this, [moduleDecl.name]);
            JAM.call(this.writeLineToOutput, this, [";"]);
            JAM.call(this.recordSourceMappingEnd, this, [moduleDecl]);
            this.emitIndent()
          }
          JAM.call(this.writeToOutput, this, ["("]);
          JAM.call(this.recordSourceMappingStart, this, [moduleDecl]);
          JAM.call(this.writeToOutput, this, ["function ("]);
          JAM.call(this.recordSourceMappingStart, this, [moduleDecl.name]);
          JAM.call(this.writeToOutput, this, [this.moduleName]);
          JAM.call(this.recordSourceMappingEnd, this, [moduleDecl.name]);
          JAM.call(this.writeLineToOutput, this, [") {"])
        }
        if(!isWholeFile) {
          JAM.call(this.recordSourceMappingNameStart, this, [this.moduleName])
        }
        var v17605 = !isDynamicMod;
        if(!v17605) {
          v17605 = TypeScript$$12.moduleGenTarget == TypeScript$$12.ModuleGenTarget.Asynchronous
        }
        if(v17605) {
          this.indenter.increaseIndent()
        }
        if(moduleDecl.modFlags & TypeScript$$12.ModuleFlags.MustCaptureThis) {
          JAM.call(this.writeCaptureThisStatement, this, [moduleDecl])
        }
        JAM.call(this.emitJavascriptList, this, [moduleDecl.members, null, TypeScript$$12.TokenID.Semicolon, true, false, false]);
        var v17609 = !isDynamicMod;
        if(!v17609) {
          v17609 = TypeScript$$12.moduleGenTarget == TypeScript$$12.ModuleGenTarget.Asynchronous
        }
        if(v17609) {
          this.indenter.decreaseIndent()
        }
        this.emitIndent();
        if(isDynamicMod) {
          if(TypeScript$$12.moduleGenTarget == TypeScript$$12.ModuleGenTarget.Asynchronous) {
            JAM.call(this.writeLineToOutput, this, ["})"])
          }else {
          }
          if(!isWholeFile) {
            this.recordSourceMappingNameEnd()
          }
          JAM.call(this.recordSourceMappingEnd, this, [moduleDecl]);
          if(this.outfile != prevOutFile) {
            this.Close();
            if(prevSourceMapper != null) {
              this.allSourceMappers = prevAllSourceMappers;
              this.sourceMapper = prevSourceMapper;
              this.emitState.column = prevColumn;
              this.emitState.line = prevLine
            }
            this.outfile = prevOutFile;
            this.emittingFileName = prevOutFileName
          }
        }else {
          var containingMod = null;
          var v17613 = moduleDecl.type;
          if(v17613) {
            var v22151 = moduleDecl.type.symbol.container;
            if(v22151) {
              v22151 = moduleDecl.type.symbol.container.declAST
            }
            v17613 = v22151
          }
          if(v17613) {
            containingMod = moduleDecl.type.symbol.container.declAST
          }
          var v10057 = containingMod;
          if(v10057) {
            v10057 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [containingMod.modFlags, TypeScript$$12.ModuleFlags.IsDynamic])
          }
          var parentIsDynamic = v10057;
          JAM.call(this.recordSourceMappingStart, this, [moduleDecl.endingToken]);
          var v17617 = temp$$10 == EmitContainer.Prog;
          if(v17617) {
            v17617 = isExported
          }
          if(v17617) {
            JAM.call(this.writeToOutput, this, ["}"]);
            if(!isWholeFile) {
              this.recordSourceMappingNameEnd()
            }
            JAM.call(this.recordSourceMappingEnd, this, [moduleDecl.endingToken]);
            JAM.call(this.writeLineToOutput, this, [")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));"])
          }else {
            var v17619 = isExported;
            if(!v17619) {
              v17619 = temp$$10 == EmitContainer.Prog
            }
            if(v17619) {
              var v10062;
              if(svModuleName != "") {
                var v22159;
                if(parentIsDynamic) {
                  v22159 = "exports"
                }else {
                  v22159 = svModuleName
                }
                v10062 = v22159 + "."
              }else {
                v10062 = svModuleName
              }
              var dotMod = v10062;
              JAM.call(this.writeToOutput, this, ["}"]);
              if(!isWholeFile) {
                this.recordSourceMappingNameEnd()
              }
              JAM.call(this.recordSourceMappingEnd, this, [moduleDecl.endingToken]);
              JAM.call(this.writeLineToOutput, this, [")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));"])
            }else {
              var v17623 = !isExported;
              if(v17623) {
                v17623 = temp$$10 != EmitContainer.Prog
              }
              if(v17623) {
                JAM.call(this.writeToOutput, this, ["}"]);
                if(!isWholeFile) {
                  this.recordSourceMappingNameEnd()
                }
                JAM.call(this.recordSourceMappingEnd, this, [moduleDecl.endingToken]);
                JAM.call(this.writeLineToOutput, this, [")(" + this.moduleName + " || (" + this.moduleName + " = {}));"])
              }else {
                JAM.call(this.writeToOutput, this, ["}"]);
                if(!isWholeFile) {
                  this.recordSourceMappingNameEnd()
                }
                JAM.call(this.recordSourceMappingEnd, this, [moduleDecl.endingToken]);
                JAM.call(this.writeLineToOutput, this, [")();"])
              }
            }
          }
          JAM.call(this.recordSourceMappingEnd, this, [moduleDecl]);
          var v17625 = temp$$10 != EmitContainer.Prog;
          if(v17625) {
            v17625 = isExported
          }
          if(v17625) {
            this.emitIndent();
            JAM.call(this.recordSourceMappingStart, this, [moduleDecl]);
            if(parentIsDynamic) {
              JAM.call(this.writeLineToOutput, this, ["var " + this.moduleName + " = exports." + this.moduleName + ";"])
            }else {
              JAM.call(this.writeLineToOutput, this, ["var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";"])
            }
            JAM.call(this.recordSourceMappingEnd, this, [moduleDecl])
          }
        }
        JAM.call(this.setContainer, this, [temp$$10]);
        this.moduleName = svModuleName;
        this.moduleDeclList.length = this.moduleDeclList.length - 1
      }
      return
    }
    function v460(funcDecl$$1, printName, isMember, bases$$1, hasSelfRef, classDecl$$1) {
      var v10078 = funcDecl$$1.isConstructor;
      if(v10078) {
        v10078 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$1.fncFlags, TypeScript$$12.FncFlags.ClassMethod])
      }
      var isClassConstructor = v10078;
      var v10079 = isClassConstructor;
      if(v10079) {
        var v17631 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [this.thisClassNode.type.instanceType.typeFlags, TypeScript$$12.TypeFlags.HasBaseType]);
        if(v17631) {
          v17631 = !JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [this.thisClassNode.type.instanceType.typeFlags, TypeScript$$12.TypeFlags.HasBaseTypeOfObject])
        }
        v10079 = v17631
      }
      var hasNonObjectBaseType = v10079;
      var v10080 = hasNonObjectBaseType;
      if(v10080) {
        v10080 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [this.thisClassNode.varFlags, TypeScript$$12.VarFlags.ClassSuperMustBeFirstCallInConstructor])
      }
      var classPropertiesMustComeAfterSuperCall = v10080;
      var v10081 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$1.fncFlags, TypeScript$$12.FncFlags.IsFunctionExpression]);
      if(v10081) {
        var v17636 = !funcDecl$$1.isParenthesized;
        if(v17636) {
          var v22179 = !funcDecl$$1.isAccessor();
          if(v22179) {
            var v24381 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$1.flags, TypeScript$$12.ASTFlags.ExplicitSemicolon]);
            if(!v24381) {
              v24381 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$1.flags, TypeScript$$12.ASTFlags.AutomaticSemicolon])
            }
            v22179 = v24381
          }
          v17636 = v22179
        }
        v10081 = v17636
      }
      var shouldParenthesize = v10081;
      JAM.call(this.emitParensAndCommentsInPlace, this, [funcDecl$$1, true]);
      if(shouldParenthesize) {
        JAM.call(this.writeToOutput, this, ["("])
      }
      JAM.call(this.recordSourceMappingStart, this, [funcDecl$$1]);
      var v22180 = funcDecl$$1.isAccessor();
      if(v22180) {
        v22180 = funcDecl$$1.accessorSymbol.isObjectLitField
      }
      if(!v22180) {
        JAM.call(this.writeToOutput, this, ["function "])
      }
      if(printName) {
        var id$$8 = funcDecl$$1.getNameText();
        var v17638 = id$$8;
        if(v17638) {
          v17638 = !funcDecl$$1.isAccessor()
        }
        if(v17638) {
          if(funcDecl$$1.name) {
            JAM.call(this.recordSourceMappingStart, this, [funcDecl$$1.name])
          }
          JAM.call(this.writeToOutput, this, [id$$8]);
          if(funcDecl$$1.name) {
            JAM.call(this.recordSourceMappingEnd, this, [funcDecl$$1.name])
          }
        }
      }
      JAM.call(this.writeToOutput, this, ["("]);
      var argsLen = 0;
      var i$$42 = 0;
      var arg$$6;
      var defaultArgs = [];
      if(funcDecl$$1.arguments) {
        var tempContainer = JAM.call(this.setContainer, this, [EmitContainer.Args]);
        argsLen = funcDecl$$1.arguments.members.length;
        var printLen = argsLen;
        if(funcDecl$$1.variableArgList) {
          printLen = printLen - 1
        }
        i$$42 = 0;
        var v10095 = i$$42 < printLen;
        for(;v10095;) {
          arg$$6 = funcDecl$$1.arguments.members[i$$42];
          if(arg$$6.init) {
            JAM.call(defaultArgs.push, defaultArgs, [arg$$6])
          }
          JAM.call(this.emitJavascript, this, [arg$$6, TypeScript$$12.TokenID.OpenParen, false]);
          if(i$$42 < printLen - 1) {
            JAM.call(this.writeToOutput, this, [", "])
          }
          i$$42 = i$$42 + 1;
          v10095 = i$$42 < printLen
        }
        JAM.call(this.setContainer, this, [tempContainer])
      }
      JAM.call(this.writeLineToOutput, this, [") {"]);
      if(funcDecl$$1.isConstructor) {
        JAM.call(this.recordSourceMappingNameStart, this, ["constructor"])
      }else {
        if(funcDecl$$1.isGetAccessor()) {
          JAM.call(this.recordSourceMappingNameStart, this, ["get_" + funcDecl$$1.getNameText()])
        }else {
          if(funcDecl$$1.isSetAccessor()) {
            JAM.call(this.recordSourceMappingNameStart, this, ["set_" + funcDecl$$1.getNameText()])
          }else {
            JAM.call(this.recordSourceMappingNameStart, this, [funcDecl$$1.getNameText()])
          }
        }
      }
      this.indenter.increaseIndent();
      i$$42 = 0;
      var v10110 = i$$42 < defaultArgs.length;
      for(;v10110;) {
        arg$$6 = defaultArgs[i$$42];
        this.emitIndent();
        JAM.call(this.recordSourceMappingStart, this, [arg$$6]);
        JAM.call(this.writeToOutput, this, ["if (typeof " + arg$$6.id.actualText + ' === "undefined") { ']);
        JAM.call(this.recordSourceMappingStart, this, [arg$$6.id]);
        JAM.call(this.writeToOutput, this, [arg$$6.id.actualText]);
        JAM.call(this.recordSourceMappingEnd, this, [arg$$6.id]);
        JAM.call(this.writeToOutput, this, [" = "]);
        JAM.call(this.emitJavascript, this, [arg$$6.init, TypeScript$$12.TokenID.OpenParen, false]);
        JAM.call(this.writeLineToOutput, this, ["; }"]);
        JAM.call(this.recordSourceMappingEnd, this, [arg$$6]);
        i$$42 = i$$42 + 1;
        v10110 = i$$42 < defaultArgs.length
      }
      var v17650 = funcDecl$$1.isConstructor;
      if(v17650) {
        v17650 = funcDecl$$1.classDecl.varFlags & TypeScript$$12.VarFlags.MustCaptureThis
      }
      if(v17650) {
        JAM.call(this.writeCaptureThisStatement, this, [funcDecl$$1])
      }
      var v17651 = funcDecl$$1.isConstructor;
      if(v17651) {
        v17651 = !classPropertiesMustComeAfterSuperCall
      }
      if(v17651) {
        if(funcDecl$$1.arguments) {
          argsLen = funcDecl$$1.arguments.members.length;
          i$$42 = 0;
          var v10121 = i$$42 < argsLen;
          for(;v10121;) {
            arg$$6 = funcDecl$$1.arguments.members[i$$42];
            if((arg$$6.varFlags & TypeScript$$12.VarFlags.Property) != TypeScript$$12.VarFlags.None) {
              this.emitIndent();
              JAM.call(this.recordSourceMappingStart, this, [arg$$6]);
              JAM.call(this.recordSourceMappingStart, this, [arg$$6.id]);
              JAM.call(this.writeToOutput, this, ["this." + arg$$6.id.actualText]);
              JAM.call(this.recordSourceMappingEnd, this, [arg$$6.id]);
              JAM.call(this.writeToOutput, this, [" = "]);
              JAM.call(this.recordSourceMappingStart, this, [arg$$6.id]);
              JAM.call(this.writeToOutput, this, [arg$$6.id.actualText]);
              JAM.call(this.recordSourceMappingEnd, this, [arg$$6.id]);
              JAM.call(this.writeLineToOutput, this, [";"]);
              JAM.call(this.recordSourceMappingEnd, this, [arg$$6])
            }
            i$$42 = i$$42 + 1;
            v10121 = i$$42 < argsLen
          }
        }
        if(!JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$1.fncFlags, TypeScript$$12.FncFlags.ClassMethod])) {
          JAM.call(this.emitConstructorCalls, this, [bases$$1, classDecl$$1])
        }
      }
      if(hasSelfRef) {
        JAM.call(this.writeCaptureThisStatement, this, [funcDecl$$1])
      }
      if(funcDecl$$1.variableArgList) {
        argsLen = funcDecl$$1.arguments.members.length;
        var v10126 = funcDecl$$1.arguments.members;
        var v10127 = argsLen - 1;
        introspect(JAM.policy.p1) {
          var lastArg = v10126[v10127]
        }
        this.emitIndent();
        JAM.call(this.recordSourceMappingStart, this, [lastArg]);
        JAM.call(this.writeToOutput, this, ["var "]);
        JAM.call(this.recordSourceMappingStart, this, [lastArg.id]);
        JAM.call(this.writeToOutput, this, [lastArg.id.actualText]);
        JAM.call(this.recordSourceMappingEnd, this, [lastArg.id]);
        JAM.call(this.writeLineToOutput, this, [" = [];"]);
        JAM.call(this.recordSourceMappingEnd, this, [lastArg]);
        this.emitIndent();
        JAM.call(this.writeToOutput, this, ["for ("]);
        JAM.call(this.recordSourceMappingStart, this, [lastArg]);
        JAM.call(this.writeToOutput, this, ["var _i = 0;"]);
        JAM.call(this.recordSourceMappingEnd, this, [lastArg]);
        JAM.call(this.writeToOutput, this, [" "]);
        JAM.call(this.recordSourceMappingStart, this, [lastArg]);
        JAM.call(this.writeToOutput, this, ["_i < (arguments.length - " + (argsLen - 1) + ")"]);
        JAM.call(this.recordSourceMappingEnd, this, [lastArg]);
        JAM.call(this.writeToOutput, this, ["; "]);
        JAM.call(this.recordSourceMappingStart, this, [lastArg]);
        JAM.call(this.writeToOutput, this, ["_i++"]);
        JAM.call(this.recordSourceMappingEnd, this, [lastArg]);
        JAM.call(this.writeLineToOutput, this, [") {"]);
        this.indenter.increaseIndent();
        this.emitIndent();
        JAM.call(this.recordSourceMappingStart, this, [lastArg]);
        JAM.call(this.writeToOutput, this, [lastArg.id.actualText + "[_i] = arguments[_i + " + (argsLen - 1) + "];"]);
        JAM.call(this.recordSourceMappingEnd, this, [lastArg]);
        JAM.call(this.writeLineToOutput, this, [""]);
        this.indenter.decreaseIndent();
        this.emitIndent();
        JAM.call(this.writeLineToOutput, this, ["}"])
      }
      var v17664 = funcDecl$$1.isConstructor;
      if(v17664) {
        var v22194 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$1.fncFlags, TypeScript$$12.FncFlags.ClassMethod]);
        if(v22194) {
          v22194 = !classPropertiesMustComeAfterSuperCall
        }
        v17664 = v22194
      }
      if(v17664) {
        var nProps = this.thisClassNode.members.members.length;
        i$$42 = 0;
        var v10141 = i$$42 < nProps;
        for(;v10141;) {
          var v24391 = this.thisClassNode.members.members;
          introspect(JAM.policy.p1) {
            var v22196 = v24391[i$$42]
          }
          if(v22196.nodeType == TypeScript$$12.NodeType.VarDecl) {
            var v10137 = this.thisClassNode.members.members;
            introspect(JAM.policy.p1) {
              var varDecl = v10137[i$$42]
            }
            var v17669 = !JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [varDecl.varFlags, TypeScript$$12.VarFlags.Static]);
            if(v17669) {
              v17669 = varDecl.init
            }
            if(v17669) {
              this.emitIndent();
              JAM.call(this.emitJavascriptVarDecl, this, [varDecl, TypeScript$$12.TokenID.Tilde]);
              JAM.call(this.writeLineToOutput, this, [""])
            }
          }
          i$$42 = i$$42 + 1;
          v10141 = i$$42 < nProps
        }
      }
      JAM.call(this.emitBareJavascriptStatements, this, [funcDecl$$1.bod, classPropertiesMustComeAfterSuperCall]);
      this.indenter.decreaseIndent();
      this.emitIndent();
      JAM.call(this.recordSourceMappingStart, this, [funcDecl$$1.endingToken]);
      JAM.call(this.writeToOutput, this, ["}"]);
      this.recordSourceMappingNameEnd();
      JAM.call(this.recordSourceMappingEnd, this, [funcDecl$$1.endingToken]);
      JAM.call(this.recordSourceMappingEnd, this, [funcDecl$$1]);
      if(shouldParenthesize) {
        JAM.call(this.writeToOutput, this, [")"])
      }
      JAM.call(this.recordSourceMappingEnd, this, [funcDecl$$1]);
      JAM.call(this.emitParensAndCommentsInPlace, this, [funcDecl$$1, false]);
      var v17671 = !isMember;
      if(v17671) {
        var v22200 = !JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$1.fncFlags, TypeScript$$12.FncFlags.IsFunctionExpression]);
        if(v22200) {
          var v24395 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$1.fncFlags, TypeScript$$12.FncFlags.Definition]);
          if(!v24395) {
            v24395 = funcDecl$$1.isConstructor
          }
          v22200 = v24395
        }
        v17671 = v22200
      }
      if(v17671) {
        JAM.call(this.writeLineToOutput, this, [""])
      }else {
        if(JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$1.fncFlags, TypeScript$$12.FncFlags.IsFunctionExpression])) {
          var v17674 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$1.flags, TypeScript$$12.ASTFlags.ExplicitSemicolon]);
          if(!v17674) {
            v17674 = JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [funcDecl$$1.flags, TypeScript$$12.ASTFlags.AutomaticSemicolon])
          }
          if(v17674) {
            JAM.call(this.writeLineToOutput, this, [";"])
          }
        }
      }
      return
    }
    function v459(bases, classDecl) {
      if(bases == null) {
        return
      }
      var basesLen = bases.members.length;
      JAM.call(this.recordSourceMappingStart, this, [classDecl]);
      var i$$41 = 0;
      var v10162 = i$$41 < basesLen;
      for(;v10162;) {
        var v10152 = bases.members;
        introspect(JAM.policy.p1) {
          var baseExpr = v10152[i$$41]
        }
        var baseSymbol = null;
        if(baseExpr.nodeType == TypeScript$$12.NodeType.Call) {
          baseSymbol = baseExpr.target.type.symbol
        }else {
          baseSymbol = baseExpr.type.symbol
        }
        var baseName = baseSymbol.name;
        if(baseSymbol.declModule != classDecl.type.symbol.declModule) {
          baseName = baseSymbol.fullName()
        }
        if(baseExpr.nodeType == TypeScript$$12.NodeType.Call) {
          this.emitIndent();
          JAM.call(this.writeToOutput, this, ["_super.call(this"]);
          var args$$5 = baseExpr.arguments;
          var v17682 = args$$5;
          if(v17682) {
            v17682 = args$$5.members.length > 0
          }
          if(v17682) {
            JAM.call(this.writeToOutput, this, [", "]);
            JAM.call(this.emitJavascriptList, this, [args$$5, ", ", TypeScript$$12.TokenID.Comma, false, false, false])
          }
          JAM.call(this.writeToOutput, this, [")"])
        }else {
          var v17684 = baseExpr.type;
          if(v17684) {
            v17684 = baseExpr.type.isClassInstance()
          }
          if(v17684) {
            this.emitIndent();
            JAM.call(this.writeToOutput, this, [classDecl.name.actualText + "._super.constructor"]);
            JAM.call(this.writeToOutput, this, [".call(this)"])
          }
        }
        i$$41 = i$$41 + 1;
        v10162 = i$$41 < basesLen
      }
      JAM.call(this.recordSourceMappingEnd, this, [classDecl]);
      return
    }
    function v458(callNode, target$$40, args$$4) {
      if(!JAM.call(this.emitSuperCall, this, [callNode])) {
        if(!JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [callNode.flags, TypeScript$$12.ASTFlags.ClassBaseConstructorCall])) {
          var v17688 = target$$40.nodeType == TypeScript$$12.NodeType.FuncDecl;
          if(v17688) {
            v17688 = !target$$40.isParenthesized
          }
          if(v17688) {
            JAM.call(this.writeToOutput, this, ["("])
          }
          var v17689 = callNode.target.nodeType == TypeScript$$12.NodeType.Super;
          if(v17689) {
            v17689 = this.emitState.container == EmitContainer.Constructor
          }
          if(v17689) {
            JAM.call(this.writeToOutput, this, ["_super.call"])
          }else {
            JAM.call(this.emitJavascript, this, [target$$40, TypeScript$$12.TokenID.OpenParen, false])
          }
          var v17691 = target$$40.nodeType == TypeScript$$12.NodeType.FuncDecl;
          if(v17691) {
            v17691 = !target$$40.isParenthesized
          }
          if(v17691) {
            JAM.call(this.writeToOutput, this, [")"])
          }
          JAM.call(this.recordSourceMappingStart, this, [args$$4]);
          JAM.call(this.writeToOutput, this, ["("]);
          var v17692 = callNode.target.nodeType == TypeScript$$12.NodeType.Super;
          if(v17692) {
            v17692 = this.emitState.container == EmitContainer.Constructor
          }
          if(v17692) {
            JAM.call(this.writeToOutput, this, ["this"]);
            var v17693 = args$$4;
            if(v17693) {
              v17693 = args$$4.members.length
            }
            if(v17693) {
              JAM.call(this.writeToOutput, this, [", "])
            }
          }
          JAM.call(this.emitJavascriptList, this, [args$$4, ", ", TypeScript$$12.TokenID.Comma, false, false, false]);
          JAM.call(this.writeToOutput, this, [")"]);
          JAM.call(this.recordSourceMappingEnd, this, [args$$4])
        }else {
          this.indenter.decreaseIndent();
          this.indenter.decreaseIndent();
          var constructorCall = new TypeScript$$12.ASTList;
          constructorCall.members[0] = callNode;
          JAM.call(this.emitConstructorCalls, this, [constructorCall, this.thisClassNode]);
          this.indenter.increaseIndent();
          this.indenter.increaseIndent()
        }
      }
      return
    }
    function v457(dotExpr$$2) {
      if(!this.emitOptions.propagateConstants) {
        return false
      }
      var propertyName$$7 = dotExpr$$2.operand2;
      var v17696 = propertyName$$7;
      if(v17696) {
        var v22231 = propertyName$$7.sym;
        if(v22231) {
          v22231 = propertyName$$7.sym.isVariable()
        }
        v17696 = v22231
      }
      if(v17696) {
        if(JAM.call(TypeScript$$12.hasFlag, TypeScript$$12, [propertyName$$7.sym.flags, TypeScript$$12.SymbolFlags.Constant])) {
          if(propertyName$$7.sym.declAST) {
            var boundDecl = propertyName$$7.sym.declAST;
            var v17700 = boundDecl.init;
            if(v17700) {
              v17700 = boundDecl.init.nodeType == TypeScript$$12.NodeType.NumberLit
            }
            if(v17700) {
              var numLit = boundDecl.init;
              JAM.call(this.writeToOutput, this, [numLit.value.toString()]);
              var comment$$1 = " /* ";
              comment$$1 = comment$$1 + propertyName$$7.actualText;
              comment$$1 = comment$$1 + " */ ";
              JAM.call(this.writeToOutput, this, [comment$$1]);
              return true
            }
          }
        }
      }
      return false
    }
    function v456(target$$39, args$$3) {
      JAM.call(this.writeToOutput, this, ["new "]);
      if(target$$39.nodeType == TypeScript$$12.NodeType.TypeRef) {
        var typeRef = target$$39;
        if(typeRef.arrayCount) {
          JAM.call(this.writeToOutput, this, ["Array()"])
        }else {
          JAM.call(this.emitJavascript, this, [typeRef.term, TypeScript$$12.TokenID.Tilde, false]);
          JAM.call(this.writeToOutput, this, ["()"])
        }
      }else {
        JAM.call(this.emitJavascript, this, [target$$39, TypeScript$$12.TokenID.Tilde, false]);
        JAM.call(this.recordSourceMappingStart, this, [args$$3]);
        JAM.call(this.writeToOutput, this, ["("]);
        JAM.call(this.emitJavascriptList, this, [args$$3, ", ", TypeScript$$12.TokenID.Comma, false, false, false]);
        JAM.call(this.writeToOutput, this, [")"]);
        JAM.call(this.recordSourceMappingEnd, this, [args$$3])
      }
      return
    }
    function v455(content$$3) {
      JAM.call(this.writeToOutput, this, ["["]);
      if(content$$3) {
        JAM.call(this.writeLineToOutput, this, [""]);
        this.indenter.increaseIndent();
        JAM.call(this.emitJavascriptList, this, [content$$3, ", ", TypeScript$$12.TokenID.Comma, true, false, false]);
        this.indenter.decreaseIndent();
        this.emitIndent()
      }
      JAM.call(this.writeToOutput, this, ["]"]);
      return
    }
    function v454(content$$2) {
      JAM.call(this.writeLineToOutput, this, ["{"]);
      this.indenter.increaseIndent();
      var inObjectLiteral = JAM.call(this.setInObjectLiteral, this, [true]);
      JAM.call(this.emitJavascriptList, this, [content$$2, ",", TypeScript$$12.TokenID.Comma, true, false, false]);
      JAM.call(this.setInObjectLiteral, this, [inObjectLiteral]);
      this.indenter.decreaseIndent();
      this.emitIndent();
      JAM.call(this.writeToOutput, this, ["}"]);
      return
    }
    function v453(ast$$15, pre$$10) {
      var v10198;
      if(pre$$10) {
        v10198 = ast$$15.preComments
      }else {
        v10198 = ast$$15.postComments
      }
      var comments$$4 = v10198;
      var v17710 = ast$$15.isParenthesized;
      if(v17710) {
        v17710 = !pre$$10
      }
      if(v17710) {
        JAM.call(this.writeToOutput, this, [")"])
      }
      var v17711 = this.emitOptions.emitComments;
      if(v17711) {
        var v22238 = comments$$4;
        if(v22238) {
          v22238 = comments$$4.length != 0
        }
        v17711 = v22238
      }
      if(v17711) {
        var i$$40 = 0;
        var v10201 = i$$40 < comments$$4.length;
        for(;v10201;) {
          introspect(JAM.policy.p1) {
            var v10200 = comments$$4[i$$40]
          }
          JAM.call(this.emitCommentInPlace, this, [v10200]);
          i$$40 = i$$40 + 1;
          v10201 = i$$40 < comments$$4.length
        }
      }
      var v17714 = ast$$15.isParenthesized;
      if(v17714) {
        v17714 = pre$$10
      }
      if(v17714) {
        JAM.call(this.writeToOutput, this, ["("])
      }
      return
    }
    function v452(comment) {
      JAM.call(this.recordSourceMappingStart, this, [comment]);
      var text$$10 = comment.getText();
      var hadNewLine = false;
      if(comment.isBlockComment) {
        if(this.emitState.column == 0) {
          this.emitIndent()
        }
        JAM.call(this.writeToOutput, this, [text$$10[0]]);
        var v17716 = text$$10.length > 1;
        if(!v17716) {
          v17716 = comment.endsLine
        }
        if(v17716) {
          JAM.call(this.writeLineToOutput, this, [""]);
          var i$$39 = 1;
          var v10207 = i$$39 < text$$10.length;
          for(;v10207;) {
            this.emitIndent();
            introspect(JAM.policy.p1) {
              var v10206 = text$$10[i$$39]
            }
            JAM.call(this.writeLineToOutput, this, [v10206]);
            i$$39 = i$$39 + 1;
            v10207 = i$$39 < text$$10.length
          }
          hadNewLine = true
        }
      }else {
        if(this.emitState.column == 0) {
          this.emitIndent()
        }
        JAM.call(this.writeLineToOutput, this, [text$$10[0]]);
        hadNewLine = true
      }
      if(hadNewLine) {
        this.emitIndent()
      }else {
        JAM.call(this.writeToOutput, this, [" "])
      }
      JAM.call(this.recordSourceMappingEnd, this, [comment]);
      return
    }
    function v451() {
      JAM.call(this.writeToOutput, this, [this.getIndentString()]);
      return
    }
    function v450() {
      if(this.emitOptions.minWhitespace) {
        return""
      }else {
        return this.indenter.getIndent()
      }
      return
    }
    function v449(c$$5) {
      var temp$$9 = this.emitState.container;
      this.emitState.container = c$$5;
      return temp$$9
    }
    function v448(val$$5) {
      var temp$$8 = this.emitState.inObjectLiteral;
      this.emitState.inObjectLiteral = val$$5;
      return temp$$8
    }
    function v447(count$$6) {
      this.varListCountStack[this.varListCountStack.length - 1] = count$$6;
      return
    }
    function v446(ast$$14) {
      this.emitIndent();
      JAM.call(this.recordSourceMappingStart, this, [ast$$14]);
      JAM.call(this.writeToOutput, this, [this.captureThisStmtString]);
      JAM.call(this.recordSourceMappingEnd, this, [ast$$14]);
      JAM.call(this.writeLineToOutput, this, [""]);
      return
    }
    function v445(s$$12) {
      if(this.emitOptions.minWhitespace) {
        JAM.call(this.writeToOutput, this, [s$$12]);
        var c$$4 = JAM.call(s$$12.charCodeAt, s$$12, [s$$12.length - 1]);
        var v22244 = c$$4 == TypeScript$$12.LexCodeSpace;
        if(!v22244) {
          var v24414 = c$$4 == TypeScript$$12.LexCodeSMC;
          if(!v24414) {
            v24414 = c$$4 == TypeScript$$12.LexCodeLBR
          }
          v22244 = v24414
        }
        if(!v22244) {
          JAM.call(this.writeToOutput, this, [" "])
        }
      }else {
        var v10224 = this.outfile;
        JAM.call(v10224.WriteLine, v10224, [s$$12]);
        this.emitState.column = 0;
        this.emitState.line = this.emitState.line + 1
      }
      return
    }
    function v444(s$$11) {
      if(this.emitOptions.minWhitespace) {
        s$$11 = s$$11.replace(/[\s]*/g, "")
      }
      JAM.call(this.writeToOutput, this, [s$$11]);
      return
    }
    function v443(s$$10) {
      var v10228 = this.outfile;
      JAM.call(v10228.Write, v10228, [s$$10]);
      var v10229 = this.emitState;
      v10229.column = v10229.column + s$$10.length;
      return
    }
    function v442(mapper) {
      var v10230 = this.allSourceMappers;
      JAM.call(v10230.push, v10230, [mapper]);
      this.sourceMapper = mapper;
      return
    }
    function Emitter$$1(checker$$2, emittingFileName, outfile$$1, emitOptions$$1, errorReporter$$1) {
      this.checker = checker$$2;
      this.emittingFileName = emittingFileName;
      this.outfile = outfile$$1;
      this.emitOptions = emitOptions$$1;
      this.errorReporter = errorReporter$$1;
      this.prologueEmitted = false;
      this.thisClassNode = null;
      this.thisFnc = null;
      this.moduleDeclList = [];
      this.moduleName = "";
      var v27323 = new EmitState;
      this.emitState = v27323;
      var v27324 = new Indenter;
      this.indenter = v27324;
      this.ambientModule = false;
      this.modAliasId = null;
      this.firstModAlias = null;
      this.allSourceMappers = [];
      this.sourceMapper = null;
      this.captureThisStmtString = "var _this = this;";
      this.varListCountStack = [0];
      return
    }
    Emitter$$1.prototype.setSourceMappings = v442;
    Emitter$$1.prototype.writeToOutput = v443;
    Emitter$$1.prototype.writeToOutputTrimmable = v444;
    Emitter$$1.prototype.writeLineToOutput = v445;
    Emitter$$1.prototype.writeCaptureThisStatement = v446;
    Emitter$$1.prototype.setInVarBlock = v447;
    Emitter$$1.prototype.setInObjectLiteral = v448;
    Emitter$$1.prototype.setContainer = v449;
    Emitter$$1.prototype.getIndentString = v450;
    Emitter$$1.prototype.emitIndent = v451;
    Emitter$$1.prototype.emitCommentInPlace = v452;
    Emitter$$1.prototype.emitParensAndCommentsInPlace = v453;
    Emitter$$1.prototype.emitObjectLiteral = v454;
    Emitter$$1.prototype.emitArrayLiteral = v455;
    Emitter$$1.prototype.emitNew = v456;
    Emitter$$1.prototype.tryEmitConstant = v457;
    Emitter$$1.prototype.emitCall = v458;
    Emitter$$1.prototype.emitConstructorCalls = v459;
    Emitter$$1.prototype.emitInnerFunction = v460;
    Emitter$$1.prototype.emitJavascriptModule = v461;
    Emitter$$1.prototype.emitIndex = v462;
    Emitter$$1.prototype.emitStringLiteral = v463;
    Emitter$$1.prototype.emitJavascriptFunction = v464;
    Emitter$$1.prototype.emitAmbientVarDecl = v465;
    Emitter$$1.prototype.varListCount = v466;
    Emitter$$1.prototype.emitVarDeclVar = v467;
    Emitter$$1.prototype.onEmitVar = v468;
    Emitter$$1.prototype.emitJavascriptVarDecl = v469;
    Emitter$$1.prototype.declEnclosed = v470;
    Emitter$$1.prototype.emitJavascriptName = v471;
    Emitter$$1.prototype.emitJavascriptStatements = v472;
    Emitter$$1.prototype.emitBareJavascriptStatements = v473;
    Emitter$$1.prototype.recordSourceMappingNameStart = v474;
    Emitter$$1.prototype.recordSourceMappingNameEnd = v475;
    Emitter$$1.prototype.recordSourceMappingStart = v476;
    Emitter$$1.prototype.recordSourceMappingEnd = v477;
    Emitter$$1.prototype.Close = v478;
    Emitter$$1.prototype.emitJavascriptList = v479;
    Emitter$$1.prototype.emitJavascript = v480;
    Emitter$$1.prototype.emitPropertyAccessor = v481;
    Emitter$$1.prototype.emitPrototypeMember = v482;
    Emitter$$1.prototype.emitAddBaseMethods = v484;
    Emitter$$1.prototype.emitJavascriptClass = v485;
    Emitter$$1.prototype.emitPrologue = v486;
    Emitter$$1.prototype.emitSuperReference = v487;
    Emitter$$1.prototype.emitSuperCall = v488;
    Emitter$$1.prototype.emitThis = v489;
    Emitter$$1.shouldCaptureThis = shouldCaptureThis;
    Emitter$$1.prototype.createFile = v490;
    return Emitter$$1
  }
  function v441() {
    function v440() {
      var v10279 = Indenter$$1.indentStrings;
      var v10280 = this.indentAmt;
      introspect(JAM.policy.p1) {
        var indentString = v10279[v10280]
      }
      if(indentString === undefined) {
        indentString = "";
        var i$$38 = 0;
        var v10281 = i$$38 < this.indentAmt;
        for(;v10281;) {
          indentString = indentString + Indenter$$1.indentStepString;
          i$$38 = i$$38 + Indenter$$1.indentStep;
          v10281 = i$$38 < this.indentAmt
        }
        JAM.set(Indenter$$1.indentStrings, this.indentAmt, indentString)
      }
      return indentString
    }
    function v439() {
      this.indentAmt = this.indentAmt - Indenter$$1.indentStep;
      return
    }
    function v438() {
      this.indentAmt = this.indentAmt + Indenter$$1.indentStep;
      return
    }
    function Indenter$$1() {
      this.indentAmt = 0;
      return
    }
    Indenter$$1.indentStep = 4;
    Indenter$$1.indentStepString = "    ";
    Indenter$$1.indentStrings = [];
    Indenter$$1.prototype.increaseIndent = v438;
    Indenter$$1.prototype.decreaseIndent = v439;
    Indenter$$1.prototype.getIndent = v440;
    return Indenter$$1
  }
  function v437() {
    function v436(fileName$$1, extensionChanger) {
      if(this.outputMany) {
        var updatedFileName = fileName$$1;
        if(this.outputOption != "") {
          updatedFileName = fileName$$1.replace(this.commonDirectoryPath, "");
          updatedFileName = this.outputOption + updatedFileName
        }
        return JAM.call(extensionChanger, null, [updatedFileName, false])
      }else {
        return JAM.call(extensionChanger, null, [this.outputOption, true])
      }
      return
    }
    function EmitOptions$$1(settings$$1) {
      this.ioHost = null;
      this.outputMany = true;
      this.commonDirectoryPath = "";
      this.minWhitespace = settings$$1.minWhitespace;
      this.propagateConstants = settings$$1.propagateConstants;
      this.emitComments = settings$$1.emitComments;
      this.outputOption = settings$$1.outputOption;
      return
    }
    EmitOptions$$1.prototype.mapOutputFileName = v436;
    return EmitOptions$$1
  }
  function v435() {
    function EmitState$$1() {
      this.column = 0;
      this.line = 0;
      this.pretty = false;
      this.inObjectLiteral = false;
      this.container = EmitContainer.Prog;
      return
    }
    return EmitState$$1
  }
  function v434(EmitContainer$$1) {
    EmitContainer$$1._map = [];
    EmitContainer$$1._map[0] = "Prog";
    EmitContainer$$1.Prog = 0;
    EmitContainer$$1._map[1] = "Module";
    EmitContainer$$1.Module = 1;
    EmitContainer$$1._map[2] = "DynamicModule";
    EmitContainer$$1.DynamicModule = 2;
    EmitContainer$$1._map[3] = "Class";
    EmitContainer$$1.Class = 3;
    EmitContainer$$1._map[4] = "Constructor";
    EmitContainer$$1.Constructor = 4;
    EmitContainer$$1._map[5] = "Function";
    EmitContainer$$1.Function = 5;
    EmitContainer$$1._map[6] = "Args";
    EmitContainer$$1.Args = 6;
    EmitContainer$$1._map[7] = "Interface";
    EmitContainer$$1.Interface = 7;
    return
  }
  var v17736 = TypeScript$$12.EmitContainer;
  if(!v17736) {
    v17736 = TypeScript$$12.EmitContainer = {}
  }
  v434(v17736);
  var EmitContainer = TypeScript$$12.EmitContainer;
  var EmitState = v435();
  TypeScript$$12.EmitState = EmitState;
  var EmitOptions = v437();
  TypeScript$$12.EmitOptions = EmitOptions;
  var Indenter = v441();
  TypeScript$$12.Indenter = Indenter;
  var Emitter = v491();
  TypeScript$$12.Emitter = Emitter;
  return
}
function v433(TypeScript$$11) {
  function v432() {
    function EmitSourceMapping(allSourceMappers) {
      function v431(sourceMappings) {
        var i$$37 = 0;
        var v10308 = i$$37 < sourceMappings.length;
        for(;v10308;) {
          introspect(JAM.policy.p1) {
            var sourceMapping = sourceMappings[i$$37]
          }
          JAM.call(recordSourceMapping, null, [sourceMapping.start, sourceMapping.nameIndex]);
          JAM.call(recordSourceMappingSiblings, null, [sourceMapping.childMappings]);
          JAM.call(recordSourceMapping, null, [sourceMapping.end, sourceMapping.nameIndex]);
          i$$37 = i$$37 + 1;
          v10308 = i$$37 < sourceMappings.length
        }
        return
      }
      function v430(mappedPosition, nameIndex) {
        var v17739 = recordedPosition != null;
        if(v17739) {
          var v22249 = recordedPosition.emittedColumn == mappedPosition.emittedColumn;
          if(v22249) {
            v22249 = recordedPosition.emittedLine == mappedPosition.emittedLine
          }
          v17739 = v22249
        }
        if(v17739) {
          return
        }
        if(prevEmittedLine !== mappedPosition.emittedLine) {
          var v10310 = prevEmittedLine < mappedPosition.emittedLine;
          for(;v10310;) {
            prevEmittedColumn = 0;
            mappingsString = mappingsString + ";";
            prevEmittedLine = prevEmittedLine + 1;
            v10310 = prevEmittedLine < mappedPosition.emittedLine
          }
          emitComma = false
        }else {
          if(emitComma) {
            mappingsString = mappingsString + ","
          }
        }
        var v10312 = mappingsString;
        var v17743 = TypeScript$$11.Base64VLQFormat;
        mappingsString = v10312 + JAM.call(v17743.encode, v17743, [mappedPosition.emittedColumn - prevEmittedColumn]);
        prevEmittedColumn = mappedPosition.emittedColumn;
        var v10314 = mappingsString;
        var v17745 = TypeScript$$11.Base64VLQFormat;
        mappingsString = v10314 + JAM.call(v17745.encode, v17745, [currentSourceIndex - prevSourceIndex]);
        prevSourceIndex = currentSourceIndex;
        var v10316 = mappingsString;
        var v17747 = TypeScript$$11.Base64VLQFormat;
        mappingsString = v10316 + JAM.call(v17747.encode, v17747, [mappedPosition.sourceLine - 1 - prevSourceLine]);
        prevSourceLine = mappedPosition.sourceLine - 1;
        var v10319 = mappingsString;
        var v17749 = TypeScript$$11.Base64VLQFormat;
        mappingsString = v10319 + JAM.call(v17749.encode, v17749, [mappedPosition.sourceColumn - prevSourceColumn]);
        prevSourceColumn = mappedPosition.sourceColumn;
        if(nameIndex >= 0) {
          var v10321 = mappingsString;
          var v17751 = TypeScript$$11.Base64VLQFormat;
          mappingsString = v10321 + JAM.call(v17751.encode, v17751, [namesCount + nameIndex - prevNameIndex]);
          prevNameIndex = namesCount + nameIndex
        }
        emitComma = true;
        recordedPosition = mappedPosition;
        return
      }
      var sourceMapper = allSourceMappers[0];
      var v10324 = sourceMapper.jsFile;
      JAM.call(v10324.WriteLine, v10324, ["//@ sourceMappingURL=" + sourceMapper.jsFileName + SourceMapper$$1.MapFileExtension]);
      var sourceMapOut$$1 = sourceMapper.sourceMapOut;
      var mappingsString = "";
      var tsFiles = [];
      var prevEmittedColumn = 0;
      var prevEmittedLine = 0;
      var prevSourceColumn = 0;
      var prevSourceLine = 0;
      var prevSourceIndex = 0;
      var prevNameIndex = 0;
      var namesList = [];
      var namesCount = 0;
      var emitComma = false;
      var recordedPosition = null;
      var sourceMapperIndex = 0;
      var v10332 = sourceMapperIndex < allSourceMappers.length;
      for(;v10332;) {
        sourceMapper = allSourceMappers[sourceMapperIndex];
        var currentSourceIndex = tsFiles.length;
        JAM.call(tsFiles.push, tsFiles, [sourceMapper.tsFileName]);
        if(sourceMapper.names.length > 0) {
          var v10327 = namesList.push;
          JAM.call(v10327.apply, v10327, [namesList, sourceMapper.names])
        }
        var recordSourceMapping = v430;
        var recordSourceMappingSiblings = v431;
        JAM.call(recordSourceMappingSiblings, null, [sourceMapper.sourceMappings, -1]);
        namesCount = namesCount + sourceMapper.names.length;
        sourceMapperIndex = sourceMapperIndex + 1;
        v10332 = sourceMapperIndex < allSourceMappers.length
      }
      if(mappingsString != "") {
        JAM.call(sourceMapOut$$1.Write, sourceMapOut$$1, [JAM.call(JSON2.stringify, JSON2, [{version:3, file:sourceMapper.jsFileName, sources:tsFiles, names:namesList, mappings:mappingsString}])])
      }
      try {
        sourceMapOut$$1.Close()
      }catch(ex) {
        var v10335 = sourceMapper.errorReporter;
        JAM.call(v10335.emitterError, v10335, [null, ex.message])
      }
      return
    }
    function SourceMapper$$1(tsFileName, jsFileName, jsFile, sourceMapOut, errorReporter) {
      this.jsFile = jsFile;
      this.sourceMapOut = sourceMapOut;
      this.errorReporter = errorReporter;
      this.sourceMappings = [];
      this.currentMappings = [];
      this.names = [];
      this.currentNameIndex = [];
      var v10337 = this.currentMappings;
      JAM.call(v10337.push, v10337, [this.sourceMappings]);
      jsFileName = JAM.call(TypeScript$$11.switchToForwardSlashes, TypeScript$$11, [jsFileName]);
      var v27325 = JAM.call(TypeScript$$11.getPrettyName, TypeScript$$11, [jsFileName, false, true]);
      this.jsFileName = v27325;
      var removalIndex = jsFileName.lastIndexOf(this.jsFileName);
      var fixedPath = JAM.call(jsFileName.substring, jsFileName, [0, removalIndex]);
      var v27326 = JAM.call(TypeScript$$11.getRelativePathToFixedPath, TypeScript$$11, [fixedPath, tsFileName]);
      this.tsFileName = v27326;
      return
    }
    SourceMapper$$1.MapFileExtension = ".map";
    SourceMapper$$1.EmitSourceMapping = EmitSourceMapping;
    return SourceMapper$$1
  }
  function v429() {
    function SourceMapping$$1() {
      var v27327 = new SourceMapPosition;
      this.start = v27327;
      var v27328 = new SourceMapPosition;
      this.end = v27328;
      this.nameIndex = -1;
      this.childMappings = [];
      return
    }
    return SourceMapping$$1
  }
  function v428() {
    function SourceMapPosition$$1() {
      return
    }
    return SourceMapPosition$$1
  }
  var SourceMapPosition = v428();
  TypeScript$$11.SourceMapPosition = SourceMapPosition;
  var SourceMapping = v429();
  TypeScript$$11.SourceMapping = SourceMapping;
  var SourceMapper = v432();
  TypeScript$$11.SourceMapper = SourceMapper;
  return
}
function v427() {
  function v426(text$$9, reviver) {
    function v425(a$$3) {
      var v24422 = JAM.call(a$$3.charCodeAt, a$$3, [0]);
      return"\\u" + ("0000" + JAM.call(v24422.toString, v24422, [16])).slice(-4)
    }
    function walk$$1(holder$$1, key$$31) {
      var k$$6 = null;
      var v$$1;
      introspect(JAM.policy.p1) {
        var value$$35 = holder$$1[key$$31]
      }
      var v17761 = value$$35;
      if(v17761) {
        v17761 = typeof value$$35 === "object"
      }
      if(v17761) {
        for(k$$6 in value$$35) {
          var v17762 = Object.prototype.hasOwnProperty;
          if(JAM.call(v17762.call, v17762, [value$$35, k$$6])) {
            v$$1 = walk$$1(value$$35, k$$6);
            if(v$$1 !== undefined) {
              JAM.set(value$$35, k$$6, v$$1)
            }else {
              delete value$$35[k$$6]
            }
          }
        }
      }
      return JAM.call(reviver.call, reviver, [holder$$1, key$$31, value$$35])
    }
    var j$$2;
    text$$9 = String(text$$9);
    cx.lastIndex = 0;
    if(cx.test(text$$9)) {
      text$$9 = text$$9.replace(cx, v425)
    }
    if(/^[\],:{}\s]*$/.test(text$$9.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) {
      var v10345 = "(" + text$$9 + ")";
      if(JAM.isEval(eval)) {
        j$$2 = eval("introspect(JAM.policy.pFull) { " + v10345 + " }")
      }else {
        j$$2 = JAM.call(eval, null, [v10345])
      }
      var v10346;
      if(typeof reviver === "function") {
        v10346 = walk$$1({"":j$$2}, "")
      }else {
        v10346 = j$$2
      }
      return v10346
    }
    throw new SyntaxError("JSON.parse");
  }
  function v424(value$$34, replacer, space) {
    var i$$36;
    gap = "";
    indent$$3 = "";
    if(typeof space === "number") {
      i$$36 = 0;
      var v10348 = i$$36 < space;
      for(;v10348;) {
        indent$$3 = indent$$3 + " ";
        i$$36 = i$$36 + 1;
        v10348 = i$$36 < space
      }
    }else {
      if(typeof space === "string") {
        indent$$3 = space
      }
    }
    rep = replacer;
    var v17769 = replacer;
    if(v17769) {
      var v22262 = typeof replacer !== "function";
      if(v22262) {
        var v24425 = typeof replacer !== "object";
        if(!v24425) {
          v24425 = typeof replacer.length !== "number"
        }
        v22262 = v24425
      }
      v17769 = v22262
    }
    if(v17769) {
      throw new Error("JSON.stringify");
    }
    return str$$6("", {"":value$$34})
  }
  function v423(key$$30) {
    return this.valueOf()
  }
  function v422(key$$29) {
    var v10353;
    if(isFinite(this.valueOf())) {
      v10353 = this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z"
    }else {
      v10353 = null
    }
    return v10353
  }
  function f(n$$1) {
    var v10354;
    if(n$$1 < 10) {
      v10354 = "0" + n$$1
    }else {
      v10354 = n$$1
    }
    return v10354
  }
  function quote(string) {
    function v421(a$$2) {
      introspect(JAM.policy.p1) {
        var c$$3 = meta[a$$2]
      }
      var v10355;
      if(typeof c$$3 === "string") {
        v10355 = c$$3
      }else {
        var v25476 = JAM.call(a$$2.charCodeAt, a$$2, [0]);
        v10355 = "\\u" + ("0000" + JAM.call(v25476.toString, v25476, [16])).slice(-4)
      }
      return v10355
    }
    escapable.lastIndex = 0;
    var v10356;
    if(escapable.test(string)) {
      v10356 = '"' + string.replace(escapable, v421) + '"'
    }else {
      v10356 = '"' + string + '"'
    }
    return v10356
  }
  function str$$6(key$$28, holder) {
    var i$$35;
    var k$$5 = null;
    var v;
    var length$$14;
    var mind = gap;
    var partial;
    introspect(JAM.policy.p1) {
      var value$$33 = holder[key$$28]
    }
    var v17778 = value$$33;
    if(v17778) {
      var v22269 = typeof value$$33 === "object";
      if(v22269) {
        v22269 = typeof value$$33.toJSON === "function"
      }
      v17778 = v22269
    }
    if(v17778) {
      value$$33 = JAM.call(value$$33.toJSON, value$$33, [key$$28])
    }
    if(typeof rep === "function") {
      value$$33 = JAM.call(rep.call, rep, [holder, key$$28, value$$33])
    }
    switch(typeof value$$33) {
      case "string":
        return quote(value$$33);
      case "number":
        var v10359;
        if(isFinite(value$$33)) {
          v10359 = String(value$$33)
        }else {
          v10359 = "null"
        }
        return v10359;
      case "boolean":
      ;
      case "null":
        return String(value$$33);
      case "object":
        if(!value$$33) {
          return"null"
        }
        gap = gap + indent$$3;
        partial = [];
        var v22270 = Object.prototype.toString;
        if(JAM.call(v22270.apply, v22270, [value$$33, []]) === "[object Array]") {
          length$$14 = value$$33.length;
          i$$35 = 0;
          var v10363 = i$$35 < length$$14;
          for(;v10363;) {
            var v10361 = partial;
            var v10362 = i$$35;
            var v17782 = str$$6(i$$35, value$$33);
            if(!v17782) {
              v17782 = "null"
            }
            v10361[v10362] = v17782;
            i$$35 = i$$35 + 1;
            v10363 = i$$35 < length$$14
          }
          var v10364;
          if(partial.length === 0) {
            v10364 = "[]"
          }else {
            var v17783;
            if(gap) {
              v17783 = "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
            }else {
              v17783 = "[" + partial.join(",") + "]"
            }
            v10364 = v17783
          }
          v = v10364;
          gap = mind;
          return v
        }
        var v17785 = rep;
        if(v17785) {
          v17785 = typeof rep === "object"
        }
        if(v17785) {
          length$$14 = rep.length;
          i$$35 = 0;
          var v10368 = i$$35 < length$$14;
          for(;v10368;) {
            introspect(JAM.policy.p1) {
              var v22276 = rep[i$$35]
            }
            if(typeof v22276 === "string") {
              introspect(JAM.policy.p1) {
                k$$5 = rep[i$$35]
              }
              v = str$$6(k$$5, value$$33);
              if(v) {
                var v22277 = quote(k$$5);
                var v24434;
                if(gap) {
                  v24434 = ": "
                }else {
                  v24434 = ":"
                }
                JAM.call(partial.push, partial, [v22277 + v24434 + v])
              }
            }
            i$$35 = i$$35 + 1;
            v10368 = i$$35 < length$$14
          }
        }else {
          for(k$$5 in value$$33) {
            var v17788 = Object.prototype.hasOwnProperty;
            if(JAM.call(v17788.call, v17788, [value$$33, k$$5])) {
              v = str$$6(k$$5, value$$33);
              if(v) {
                var v22280 = quote(k$$5);
                var v24435;
                if(gap) {
                  v24435 = ": "
                }else {
                  v24435 = ":"
                }
                JAM.call(partial.push, partial, [v22280 + v24435 + v])
              }
            }
          }
        }
        var v10372;
        if(partial.length === 0) {
          v10372 = "{}"
        }else {
          var v17790;
          if(gap) {
            v17790 = "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
          }else {
            v17790 = "{" + partial.join(",") + "}"
          }
          v10372 = v17790
        }
        v = v10372;
        gap = mind;
        return v
    }
    return
  }
  if(typeof Date.prototype.toJSON !== "function") {
    Date.prototype.toJSON = v422;
    var strProto = String.prototype;
    var numProto = Number.prototype;
    numProto.JSON = strProto.JSON = Boolean.prototype.toJSON = v423
  }
  var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  var gap;
  var indent$$3;
  var meta = {"\b":"\\b", "\t":"\\t", "\n":"\\n", "\f":"\\f", "\r":"\\r", '"':'\\"', "\\":"\\\\"};
  var rep;
  if(typeof JSON2.stringify !== "function") {
    JSON2.stringify = v424
  }
  if(typeof JSON2.parse !== "function") {
    JSON2.parse = v426
  }
  return
}
function v420(TypeScript$$10) {
  function v419() {
    function decode(inString) {
      var result$$6 = 0;
      var negative = false;
      var shift = 0;
      var i$$34 = 0;
      var v10387 = i$$34 < inString.length;
      for(;v10387;) {
        introspect(JAM.policy.p1) {
          var v10379 = inString[i$$34]
        }
        var byte = JAM.call(Base64Format.decodeChar, Base64Format, [v10379]);
        if(i$$34 === 0) {
          if((byte & 1) === 1) {
            negative = true
          }
          result$$6 = byte >> 1 & 15
        }else {
          result$$6 = result$$6 | (byte & 31) << shift
        }
        var v22288;
        if(i$$34 == 0) {
          v22288 = 4
        }else {
          v22288 = 5
        }
        shift = shift + v22288;
        if((byte & 32) === 32) {
        }else {
          var v17800;
          if(negative) {
            v17800 = -result$$6
          }else {
            v17800 = result$$6
          }
          return{value:v17800, rest:inString.substr(i$$34 + 1)}
        }
        i$$34 = i$$34 + 1;
        v10387 = i$$34 < inString.length
      }
      throw new Error('Base64 value "' + inString + '" finished with a continuation bit');
    }
    function encode$$1(inValue$$1) {
      if(inValue$$1 < 0) {
        inValue$$1 = (-inValue$$1 << 1) + 1
      }else {
        inValue$$1 = inValue$$1 << 1
      }
      var encodedStr = "";
      var v10394 = inValue$$1 > 0;
      do {
        var currentDigit = inValue$$1 & 31;
        inValue$$1 = inValue$$1 >> 5;
        if(inValue$$1 > 0) {
          currentDigit = currentDigit | 32
        }
        encodedStr = encodedStr + JAM.call(Base64Format.encode, Base64Format, [currentDigit]);
        v10394 = inValue$$1 > 0
      }while(v10394);
      return encodedStr
    }
    function Base64VLQFormat$$1() {
      return
    }
    Base64VLQFormat$$1.encode = encode$$1;
    Base64VLQFormat$$1.decode = decode;
    return Base64VLQFormat$$1
  }
  function v418() {
    function decodeChar(inChar) {
      if(inChar.length === 1) {
        return Base64Format$$1.encodedValues.indexOf(inChar)
      }else {
        throw TypeError('"' + inChar + '" must have length 1');
      }
      return
    }
    function encode(inValue) {
      if(inValue < 64) {
        return Base64Format$$1.encodedValues.charAt(inValue)
      }
      throw TypeError(inValue + ": not a 64 based value");
    }
    function Base64Format$$1() {
      return
    }
    Base64Format$$1.encodedValues = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    Base64Format$$1.encode = encode;
    Base64Format$$1.decodeChar = decodeChar;
    return Base64Format$$1
  }
  var Base64Format = v418();
  var Base64VLQFormat = v419();
  TypeScript$$10.Base64VLQFormat = Base64VLQFormat;
  return
}
function v417(TypeScript$$9) {
  function v416() {
    function v415(scope$$5, table$$1) {
      function v414(key$$27, sym$$2, binder) {
        JAM.call(binder.bindSymbol, binder, [scope$$5, sym$$2]);
        return
      }
      JAM.call(table$$1.map, table$$1, [v414, this]);
      return
    }
    function v413(scope$$4, symbol$$2) {
      function v412(id$$7) {
        return JAM.call(scope$$4.find, scope$$4, [id$$7, false, true])
      }
      if(!symbol$$2.bound) {
        var prevLocationInfo = this.checker.locationInfo;
        var v17808 = this.checker.units;
        if(v17808) {
          var v22290 = symbol$$2.unitIndex >= 0;
          if(v22290) {
            v22290 = symbol$$2.unitIndex < this.checker.units.length
          }
          v17808 = v22290
        }
        if(v17808) {
          var v10402 = this.checker;
          var v17809 = this.checker.units;
          var v17810 = symbol$$2.unitIndex;
          introspect(JAM.policy.p1) {
            v10402.locationInfo = v17809[v17810]
          }
        }
        switch(symbol$$2.kind()) {
          case TypeScript$$9.SymbolKind.Type:
            if(symbol$$2.flags & TypeScript$$9.SymbolFlags.Bound) {
              break
            }
            var typeSymbol = symbol$$2;
            typeSymbol.flags = typeSymbol.flags | TypeScript$$9.SymbolFlags.Bound;
            var v17815 = typeSymbol.aliasLink;
            if(v17815) {
              var v22294 = !typeSymbol.type;
              if(v22294) {
                v22294 = typeSymbol.aliasLink.alias.nodeType == TypeScript$$9.NodeType.Name
              }
              v17815 = v22294
            }
            if(v17815) {
              var modPath = typeSymbol.aliasLink.alias.text;
              var v10406 = this.checker;
              var modSym = JAM.call(v10406.findSymbolForDynamicModule, v10406, [modPath, this.checker.locationInfo.filename, v412]);
              if(modSym) {
                var v10408 = typeSymbol;
                var v27329 = modSym.getType();
                v10408.type = v27329
              }
            }
            var v17818 = typeSymbol.type;
            if(v17818) {
              v17818 = typeSymbol.type != this.checker.gloModType
            }
            if(v17818) {
              JAM.call(this.bindType, this, [scope$$4, typeSymbol.type, typeSymbol.instanceType]);
              if(typeSymbol.type.isModuleType()) {
                var i$$33 = 0;
                var v10414 = i$$33 < typeSymbol.expansions.length;
                for(;v10414;) {
                  var v17821 = typeSymbol.expansions;
                  introspect(JAM.policy.p1) {
                    var v10412 = v17821[i$$33]
                  }
                  JAM.call(this.bindType, this, [scope$$4, v10412, typeSymbol.instanceType]);
                  i$$33 = i$$33 + 1;
                  v10414 = i$$33 < typeSymbol.expansions.length
                }
              }
            }
            break;
          case TypeScript$$9.SymbolKind.Field:
            var v10417 = this.checker;
            JAM.call(v10417.resolveTypeLink, v10417, [scope$$4, symbol$$2.field.typeLink, false]);
            break;
          case TypeScript$$9.SymbolKind.Parameter:
            var v10419 = this.checker;
            JAM.call(v10419.resolveTypeLink, v10419, [scope$$4, symbol$$2.parameter.typeLink, true])
        }
        this.checker.locationInfo = prevLocationInfo
      }
      symbol$$2.bound = true;
      return
    }
    function v411(scope$$3, type$$26, instanceType$$1) {
      if(instanceType$$1) {
        JAM.call(this.bindType, this, [scope$$3, instanceType$$1, null])
      }
      if(type$$26.hasMembers()) {
        var members$$5 = type$$26.members;
        var ambientMembers = type$$26.ambientMembers;
        var typeMembers = type$$26.getAllEnclosedTypes();
        var ambientTypeMembers = type$$26.getAllAmbientEnclosedTypes();
        var memberScope = JAM.new(TypeScript$$9.SymbolTableScope, [members$$5, ambientMembers, typeMembers, ambientTypeMembers, type$$26.symbol]);
        var agg = JAM.new(TypeScript$$9.SymbolAggregateScope, [type$$26.symbol]);
        var prevCurrentModDecl = this.checker.currentModDecl;
        var prevBindStatus = this.checker.inBind;
        JAM.call(agg.addParentScope, agg, [memberScope]);
        JAM.call(agg.addParentScope, agg, [scope$$3]);
        if(type$$26.isModuleType()) {
          this.checker.currentModDecl = type$$26.symbol.declAST;
          this.checker.inBind = true
        }
        if(members$$5) {
          JAM.call(this.bind, this, [agg, type$$26.members.allMembers])
        }
        if(typeMembers) {
          JAM.call(this.bind, this, [agg, typeMembers.allMembers])
        }
        if(ambientMembers) {
          JAM.call(this.bind, this, [agg, ambientMembers.allMembers])
        }
        if(ambientTypeMembers) {
          JAM.call(this.bind, this, [agg, ambientTypeMembers.allMembers])
        }
        this.checker.currentModDecl = prevCurrentModDecl;
        this.checker.inBind = prevBindStatus
      }
      if(type$$26.extendsTypeLinks) {
        JAM.call(this.resolveBases, this, [scope$$3, type$$26])
      }
      if(type$$26.construct) {
        JAM.call(this.resolveSignatureGroup, this, [type$$26.construct, scope$$3, instanceType$$1])
      }
      if(type$$26.call) {
        JAM.call(this.resolveSignatureGroup, this, [type$$26.call, scope$$3, null])
      }
      if(type$$26.index) {
        JAM.call(this.resolveSignatureGroup, this, [type$$26.index, scope$$3, null])
      }
      if(type$$26.elementType) {
        JAM.call(this.bindType, this, [scope$$3, type$$26.elementType, null])
      }
      return
    }
    function v410(signatureGroup, scope$$2, instanceType) {
      var supplyVar = !signatureGroup.hasImplementation;
      var i$$32 = 0;
      var len$$9 = signatureGroup.signatures.length;
      var v10464 = i$$32 < len$$9;
      for(;v10464;) {
        var v10451 = signatureGroup.signatures;
        introspect(JAM.policy.p1) {
          var signature = v10451[i$$32]
        }
        if(instanceType) {
          signature.returnType.type = instanceType
        }else {
          var v10453 = this.checker;
          JAM.call(v10453.resolveTypeLink, v10453, [scope$$2, signature.returnType, supplyVar])
        }
        var paramLen = signature.parameters.length;
        var j$$1 = 0;
        var v10457 = j$$1 < paramLen;
        for(;v10457;) {
          var v17827 = signature.parameters;
          introspect(JAM.policy.p1) {
            var v10456 = v17827[j$$1]
          }
          JAM.call(this.bindSymbol, this, [scope$$2, v10456]);
          j$$1 = j$$1 + 1;
          v10457 = j$$1 < paramLen
        }
        if(signature.hasVariableArgList) {
          var v10458 = signature.parameters;
          var v10459 = paramLen - 1;
          introspect(JAM.policy.p1) {
            var lastParam = v10458[v10459]
          }
          lastParam.argsOffset = paramLen - 1;
          if(!lastParam.getType().isArray()) {
            var v10460 = this.checker.errorReporter;
            JAM.call(v10460.simpleErrorFromSym, v10460, [lastParam, "... parameter must have array type"]);
            var v10461 = lastParam.parameter.typeLink;
            var v17831 = this.checker;
            var v27330 = JAM.call(v17831.makeArrayType, v17831, [lastParam.parameter.typeLink.type]);
            v10461.type = v27330
          }
        }
        i$$32 = i$$32 + 1;
        v10464 = i$$32 < len$$9
      }
      return
    }
    function v409(scope$$1, type$$25) {
      var v10465 = type$$25;
      var v27331 = JAM.call(this.resolveBaseTypeLinks, this, [type$$25.extendsTypeLinks, scope$$1]);
      v10465.extendsList = v27331;
      var i$$31 = 0;
      var len$$8 = type$$25.extendsList.length;
      var derivedIsClass = type$$25.isClassInstance();
      var v10475 = i$$31 < len$$8;
      for(;v10475;) {
        var v17834 = type$$25.extendsList;
        introspect(JAM.policy.p1) {
          var v10467 = v17834[i$$31]
        }
        var baseIsClass = v10467.isClassInstance();
        var v22302 = type$$25.extendsList;
        introspect(JAM.policy.p1) {
          var v17835 = v22302[i$$31]
        }
        if(v17835 != this.checker.anyType) {
          var v17837 = type$$25.extendsTypeLinks;
          introspect(JAM.policy.p1) {
            var v10468 = v17837[i$$31]
          }
          var baseRef = v10468.ast;
          if(derivedIsClass) {
            if(!baseIsClass) {
              var v10469 = this.checker.errorReporter;
              var v26088 = type$$25.extendsList;
              introspect(JAM.policy.p1) {
                var v25483 = v26088[i$$31]
              }
              JAM.call(v10469.simpleError, v10469, [baseRef, "A class may only extend other classes, " + v25483.symbol.fullName() + " is not a class."])
            }
          }else {
            if(baseIsClass) {
              var v10472 = this.checker.errorReporter;
              var v26089 = type$$25.extendsList;
              introspect(JAM.policy.p1) {
                var v25484 = v26089[i$$31]
              }
              JAM.call(v10472.simpleError, v10472, [baseRef, "An interface may only extend other interfaces, " + v25484.symbol.fullName() + " is a class."])
            }
          }
        }
        i$$31 = i$$31 + 1;
        v10475 = i$$31 < len$$8
      }
      var v10476 = type$$25;
      var v27332 = JAM.call(this.resolveBaseTypeLinks, this, [type$$25.implementsTypeLinks, scope$$1]);
      v10476.implementsList = v27332;
      if(type$$25.implementsList) {
        i$$31 = 0;
        len$$8 = type$$25.implementsList.length;
        var v10482 = i$$31 < len$$8;
        for(;v10482;) {
          var v10477 = type$$25.implementsList;
          introspect(JAM.policy.p1) {
            var iface = v10477[i$$31]
          }
          var v17844 = type$$25.implementsTypeLinks;
          introspect(JAM.policy.p1) {
            var v10478 = v17844[i$$31]
          }
          baseRef = v10478.ast;
          if(iface.isClassInstance()) {
            if(derivedIsClass) {
              var v10479 = this.checker.errorReporter;
              JAM.call(v10479.simpleError, v10479, [baseRef, "A class may only implement an interface; " + iface.symbol.fullName() + " is a class."])
            }
          }
          i$$31 = i$$31 + 1;
          v10482 = i$$31 < len$$8
        }
      }
      return
    }
    function v408(typeLinks, scope) {
      var extendsList$$3 = null;
      if(typeLinks) {
        extendsList$$3 = new Array;
        var i$$30 = 0;
        var len$$7 = typeLinks.length;
        var v10486 = i$$30 < len$$7;
        for(;v10486;) {
          var v10484 = extendsList$$3;
          var v10485 = i$$30;
          var v17847 = this.checker;
          introspect(JAM.policy.p1) {
            var v17848 = typeLinks[i$$30]
          }
          var v27333 = JAM.call(v17847.resolveBaseTypeLink, v17847, [v17848, scope]);
          v10484[v10485] = v27333;
          i$$30 = i$$30 + 1;
          v10486 = i$$30 < len$$7
        }
      }
      return extendsList$$3
    }
    function Binder$$1(checker$$1) {
      this.checker = checker$$1;
      return
    }
    Binder$$1.prototype.resolveBaseTypeLinks = v408;
    Binder$$1.prototype.resolveBases = v409;
    Binder$$1.prototype.resolveSignatureGroup = v410;
    Binder$$1.prototype.bindType = v411;
    Binder$$1.prototype.bindSymbol = v413;
    Binder$$1.prototype.bind = v415;
    return Binder$$1
  }
  var Binder = v416();
  TypeScript$$9.Binder = Binder;
  return
}
function v407(TypeScript$$8) {
  function v406() {
    function v405(script$$6, position$$1) {
      var lineInfo = {line:-1, col:-1};
      JAM.call(TypeScript$$8.getSourceLineColFromMap, TypeScript$$8, [lineInfo, position$$1, script$$6.locationInfo.lineMap]);
      if(lineInfo.col !== -1) {
        lineInfo.col = lineInfo.col + 1
      }
      return"(" + lineInfo.line + ", " + lineInfo.col + ")"
    }
    function v404(s$$9, targetLength, paddingString, leftPadding) {
      var v10496;
      if(leftPadding) {
        v10496 = ""
      }else {
        v10496 = s$$9
      }
      var result$$5 = v10496;
      var i$$29 = s$$9.length;
      var v10497 = i$$29 < targetLength;
      for(;v10497;) {
        result$$5 = result$$5 + paddingString;
        i$$29 = i$$29 + 1;
        v10497 = i$$29 < targetLength
      }
      var v17854;
      if(leftPadding) {
        v17854 = s$$9
      }else {
        v17854 = ""
      }
      result$$5 = result$$5 + v17854;
      return result$$5
    }
    function v403(linemap) {
      var result$$4 = "[";
      var i$$28 = 0;
      var v10500 = i$$28 < linemap.length;
      for(;v10500;) {
        if(i$$28 > 0) {
          result$$4 = result$$4 + ","
        }
        introspect(JAM.policy.p1) {
          var v17856 = linemap[i$$28]
        }
        result$$4 = result$$4 + v17856;
        i$$28 = i$$28 + 1;
        v10500 = i$$28 < linemap.length
      }
      result$$4 = result$$4 + "]";
      var v10501 = this.logger;
      JAM.call(v10501.log, v10501, ["linemap: " + result$$4]);
      return
    }
    function v402(script$$5, comments$$3, indent$$2) {
      if(comments$$3 == null) {
        return
      }
      var i$$27 = 0;
      var v10505 = i$$27 < comments$$3.length;
      for(;v10505;) {
        introspect(JAM.policy.p1) {
          var v10504 = comments$$3[i$$27]
        }
        JAM.call(this.logNode, this, [script$$5, v10504, indent$$2]);
        i$$27 = i$$27 + 1;
        v10505 = i$$27 < comments$$3.length
      }
      return
    }
    function v401(script$$4, cur$$8, indent$$1) {
      var msg = JAM.call(this.addPadding, this, ["", indent$$1, "| ", true]);
      msg = msg.concat("+ " + cur$$8.treeViewLabel());
      msg = JAM.call(this.addPadding, this, [msg, 70, " ", false]);
      msg = msg + JAM.call(this.addLineColumn, this, [script$$4, cur$$8.minChar]);
      msg = JAM.call(this.addPadding, this, [msg, 80, " ", false]);
      msg = msg + "=> ";
      msg = msg + JAM.call(this.addLineColumn, this, [script$$4, cur$$8.limChar]);
      msg = JAM.call(this.addPadding, this, [msg, 102, " ", false]);
      msg = msg.concat("[" + JAM.call(this.addPadding, this, [cur$$8.minChar.toString(), 1, " ", true]) + ", " + JAM.call(this.addPadding, this, [cur$$8.limChar.toString(), 1, " ", true]) + "]");
      msg = JAM.call(this.addPadding, this, [msg, 115, " ", false]);
      msg = msg.concat("sym=" + cur$$8.sym);
      msg = JAM.call(this.addPadding, this, [msg, 135, " ", false]);
      var v22310;
      if(cur$$8.type === null) {
        v22310 = "null"
      }else {
        v22310 = cur$$8.type.getTypeName()
      }
      msg = msg.concat("type=" + v22310);
      var v10514 = this.logger;
      JAM.call(v10514.log, v10514, [msg]);
      return
    }
    function v400(script$$3) {
      function post$$6(cur$$7, parent$$42) {
        stack.pop();
        return cur$$7
      }
      function pre$$9(cur$$6, parent$$41) {
        JAM.call(stack.push, stack, [cur$$6]);
        var indent = (stack.length - 1) * 2;
        JAM.call(_this.logComments, _this, [script$$3, cur$$6.preComments, indent]);
        JAM.call(_this.logNode, _this, [script$$3, cur$$6, indent]);
        JAM.call(_this.logComments, _this, [script$$3, cur$$6.postComments, indent]);
        return cur$$6
      }
      var _this = this;
      JAM.call(this.logLinemap, this, [script$$3.locationInfo.lineMap]);
      var stack = [];
      var v10519 = TypeScript$$8.getAstWalkerFactory();
      JAM.call(v10519.walk, v10519, [script$$3, pre$$9, post$$6]);
      return
    }
    function AstLogger$$1(logger) {
      this.logger = logger;
      return
    }
    AstLogger$$1.prototype.logScript = v400;
    AstLogger$$1.prototype.logNode = v401;
    AstLogger$$1.prototype.logComments = v402;
    AstLogger$$1.prototype.logLinemap = v403;
    AstLogger$$1.prototype.addPadding = v404;
    AstLogger$$1.prototype.addLineColumn = v405;
    return AstLogger$$1
  }
  var AstLogger = v406();
  TypeScript$$8.AstLogger = AstLogger;
  return
}
function v399(TypeScript$$7) {
  function v398(GetAstPathOptions$$1) {
    GetAstPathOptions$$1._map = [];
    GetAstPathOptions$$1.Default = 0;
    GetAstPathOptions$$1.EdgeInclusive = 1;
    GetAstPathOptions$$1.DontPruneSearchBasedOnPosition = 1 << 1;
    return
  }
  function v397() {
    function AstPathContext$$1() {
      var v27334 = new TypeScript$$7.AstPath;
      this.path = v27334;
      return
    }
    return AstPathContext$$1
  }
  function v396() {
    function v395() {
      var v10527 = this.count() >= 1;
      if(v10527) {
        var v25488 = this.asts;
        var v25489 = this.top - 0;
        introspect(JAM.policy.p1) {
          var v24456 = v25488[v25489]
        }
        var v17869 = v24456.nodeType === TypeScript$$7.NodeType.Block;
        if(v17869) {
          var v25490 = this.asts;
          var v25491 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v24458 = v25490[v25491]
          }
          v17869 = v24458.isStatementBlock === false
        }
        v10527 = v17869
      }
      return v10527
    }
    function v394() {
      var v10528 = this.count() >= 2;
      if(v10528) {
        var v25492 = this.asts;
        var v25493 = this.top - 0;
        introspect(JAM.policy.p1) {
          var v24459 = v25492[v25493]
        }
        var v17871 = v24459.nodeType === TypeScript$$7.NodeType.List;
        if(v17871) {
          var v26094 = this.asts;
          var v26095 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v25494 = v26094[v26095]
          }
          var v22316 = v25494.nodeType === TypeScript$$7.NodeType.New;
          if(v22316) {
            var v26096 = this.asts;
            var v26097 = this.top - 1;
            introspect(JAM.policy.p1) {
              var v25496 = v26096[v26097]
            }
            var v24463 = v25496.arguments;
            var v25497 = this.asts;
            var v25498 = this.top - 0;
            introspect(JAM.policy.p1) {
              var v24464 = v25497[v25498]
            }
            v22316 = v24463 === v24464
          }
          v17871 = v22316
        }
        v10528 = v17871
      }
      return v10528
    }
    function v393() {
      var v10529 = this.count() >= 2;
      if(v10529) {
        var v25499 = this.asts;
        var v25500 = this.top - 0;
        introspect(JAM.policy.p1) {
          var v24465 = v25499[v25500]
        }
        var v17873 = v24465.nodeType === TypeScript$$7.NodeType.List;
        if(v17873) {
          var v26100 = this.asts;
          var v26101 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v25501 = v26100[v26101]
          }
          var v22319 = v25501.nodeType === TypeScript$$7.NodeType.Call;
          if(v22319) {
            var v26102 = this.asts;
            var v26103 = this.top - 1;
            introspect(JAM.policy.p1) {
              var v25503 = v26102[v26103]
            }
            var v24469 = v25503.arguments;
            var v25504 = this.asts;
            var v25505 = this.top - 0;
            introspect(JAM.policy.p1) {
              var v24470 = v25504[v25505]
            }
            v22319 = v24469 === v24470
          }
          v17873 = v22319
        }
        v10529 = v17873
      }
      return v10529
    }
    function v392() {
      var v10530 = this.count() >= 3;
      if(v10530) {
        var v25506 = this.asts;
        var v25507 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24471 = v25506[v25507]
        }
        var v17875 = v24471.nodeType === TypeScript$$7.NodeType.List;
        if(v17875) {
          var v26106 = this.asts;
          var v26107 = this.top - 2;
          introspect(JAM.policy.p1) {
            var v25508 = v26106[v26107]
          }
          var v22322 = v25508.nodeType === TypeScript$$7.NodeType.FuncDecl;
          if(v22322) {
            var v26108 = this.asts;
            var v26109 = this.top - 2;
            introspect(JAM.policy.p1) {
              var v25510 = v26108[v26109]
            }
            var v24475 = v25510.arguments;
            var v25511 = this.asts;
            var v25512 = this.top - 1;
            introspect(JAM.policy.p1) {
              var v24476 = v25511[v25512]
            }
            v22322 = v24475 === v24476
          }
          v17875 = v22322
        }
        v10530 = v17875
      }
      return v10530
    }
    function v391() {
      var v10531 = this.count() >= 2;
      if(v10531) {
        var v25513 = this.asts;
        var v25514 = this.top - 0;
        introspect(JAM.policy.p1) {
          var v24477 = v25513[v25514]
        }
        var v17877 = v24477.nodeType === TypeScript$$7.NodeType.List;
        if(v17877) {
          var v26112 = this.asts;
          var v26113 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v25515 = v26112[v26113]
          }
          var v22325 = v25515.nodeType === TypeScript$$7.NodeType.FuncDecl;
          if(v22325) {
            var v26114 = this.asts;
            var v26115 = this.top - 1;
            introspect(JAM.policy.p1) {
              var v25517 = v26114[v26115]
            }
            var v24481 = v25517.arguments;
            var v25518 = this.asts;
            var v25519 = this.top - 0;
            introspect(JAM.policy.p1) {
              var v24482 = v25518[v25519]
            }
            v22325 = v24481 === v24482
          }
          v17877 = v22325
        }
        v10531 = v17877
      }
      return v10531
    }
    function v390() {
      var v10532 = this.count() >= 1;
      if(v10532) {
        var v25520 = this.asts;
        var v25521 = this.top;
        introspect(JAM.policy.p1) {
          var v24483 = v25520[v25521]
        }
        var v17879 = v24483.nodeType === TypeScript$$7.NodeType.List;
        if(v17879) {
          var v26117 = this.asts;
          var v26118 = this.top;
          introspect(JAM.policy.p1) {
            var v25522 = v26117[v26118]
          }
          v17879 = v25522.members.length === 1
        }
        v10532 = v17879
      }
      return v10532
    }
    function v389() {
      return this.isBodyOfCase()
    }
    function v388() {
      var v10533 = this.count() >= 2;
      if(v10533) {
        var v25523 = this.asts;
        var v25524 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24486 = v25523[v25524]
        }
        var v17881 = v24486.nodeType === TypeScript$$7.NodeType.If;
        if(v17881) {
          var v25525 = this.asts;
          var v25526 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24488 = v25525[v25526]
          }
          var v22331 = v24488.elseBod;
          var v24489 = this.asts;
          var v24490 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22332 = v24489[v24490]
          }
          v17881 = v22331 == v22332
        }
        v10533 = v17881
      }
      return v10533
    }
    function v387() {
      var v10534 = this.count() >= 2;
      if(v10534) {
        var v25528 = this.asts;
        var v25529 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24491 = v25528[v25529]
        }
        var v17883 = v24491.nodeType === TypeScript$$7.NodeType.If;
        if(v17883) {
          var v25530 = this.asts;
          var v25531 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24493 = v25530[v25531]
          }
          var v22335 = v24493.thenBod;
          var v24494 = this.asts;
          var v24495 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22336 = v24494[v24495]
          }
          v17883 = v22335 == v22336
        }
        v10534 = v17883
      }
      return v10534
    }
    function v386() {
      var v10535 = this.count() >= 2;
      if(v10535) {
        var v24496 = this.asts;
        var v24497 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v22337 = v24496[v24497]
        }
        v10535 = v22337.nodeType === TypeScript$$7.NodeType.List
      }
      return v10535
    }
    function v385() {
      var v10536 = this.count() >= 2;
      if(v10536) {
        var v25534 = this.asts;
        var v25535 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24498 = v25534[v25535]
        }
        var v17888 = v24498.nodeType === TypeScript$$7.NodeType.Member;
        if(v17888) {
          var v25536 = this.asts;
          var v25537 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24500 = v25536[v25537]
          }
          var v22341 = v24500.operand2;
          var v24501 = this.asts;
          var v24502 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22342 = v24501[v24502]
          }
          v17888 = v22341 === v22342
        }
        v10536 = v17888
      }
      return v10536
    }
    function v384() {
      var v10537 = this.count() >= 2;
      if(v10537) {
        var v25539 = this.asts;
        var v25540 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24503 = v25539[v25540]
        }
        var v17890 = v24503.nodeType === TypeScript$$7.NodeType.Member;
        if(v17890) {
          var v25541 = this.asts;
          var v25542 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24505 = v25541[v25542]
          }
          var v22345 = v24505.operand1;
          var v24506 = this.asts;
          var v24507 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22346 = v24506[v24507]
          }
          v17890 = v22345 === v22346
        }
        v10537 = v17890
      }
      return v10537
    }
    function v383() {
      var v10538 = this.count() >= 2;
      if(v10538) {
        var v25544 = this.asts;
        var v25545 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24508 = v25544[v25545]
        }
        var v17892 = v24508.nodeType === TypeScript$$7.NodeType.ArrayLit;
        if(v17892) {
          var v26128 = this.asts;
          var v26129 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v25546 = v26128[v26129]
          }
          var v22349 = v25546.nodeType === TypeScript$$7.NodeType.List;
          if(v22349) {
            var v26130 = this.asts;
            var v26131 = this.top - 1;
            introspect(JAM.policy.p1) {
              var v25548 = v26130[v26131]
            }
            var v24512 = v25548.operand;
            var v25549 = this.asts;
            var v25550 = this.top - 0;
            introspect(JAM.policy.p1) {
              var v24513 = v25549[v25550]
            }
            v22349 = v24512 == v24513
          }
          v17892 = v22349
        }
        v10538 = v17892
      }
      return v10538
    }
    function v382() {
      var v10539 = this.count() >= 4;
      if(v10539) {
        var v25551 = this.asts;
        var v25552 = this.top - 3;
        introspect(JAM.policy.p1) {
          var v24514 = v25551[v25552]
        }
        var v17894 = v24514.nodeType === TypeScript$$7.NodeType.ObjectLit;
        if(v17894) {
          var v26134 = this.asts;
          var v26135 = this.top - 2;
          introspect(JAM.policy.p1) {
            var v25553 = v26134[v26135]
          }
          var v22352 = v25553.nodeType === TypeScript$$7.NodeType.List;
          if(v22352) {
            var v26452 = this.asts;
            var v26453 = this.top - 1;
            introspect(JAM.policy.p1) {
              var v26136 = v26452[v26453]
            }
            var v24518 = v26136.nodeType === TypeScript$$7.NodeType.Member;
            if(v24518) {
              var v26595 = this.asts;
              var v26596 = this.top - 0;
              introspect(JAM.policy.p1) {
                var v26454 = v26595[v26596]
              }
              var v25557 = v26454.nodeType === TypeScript$$7.NodeType.Name;
              if(v25557) {
                var v26597 = this.asts;
                var v26598 = this.top - 3;
                introspect(JAM.policy.p1) {
                  var v26456 = v26597[v26598]
                }
                var v26140 = v26456.operand;
                var v26457 = this.asts;
                var v26458 = this.top - 2;
                introspect(JAM.policy.p1) {
                  var v26141 = v26457[v26458]
                }
                v25557 = v26140 == v26141
              }
              v24518 = v25557
            }
            v22352 = v24518
          }
          v17894 = v22352
        }
        v10539 = v17894
      }
      return v10539
    }
    function v381() {
      var v10540 = this.count() >= 3;
      if(v10540) {
        var v25558 = this.asts;
        var v25559 = this.top - 2;
        introspect(JAM.policy.p1) {
          var v24519 = v25558[v25559]
        }
        var v17896 = v24519.nodeType === TypeScript$$7.NodeType.ObjectLit;
        if(v17896) {
          var v26143 = this.asts;
          var v26144 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v25560 = v26143[v26144]
          }
          var v22355 = v25560.nodeType === TypeScript$$7.NodeType.List;
          if(v22355) {
            var v26460 = this.asts;
            var v26461 = this.top - 0;
            introspect(JAM.policy.p1) {
              var v26145 = v26460[v26461]
            }
            var v24523 = v26145.nodeType === TypeScript$$7.NodeType.Member;
            if(v24523) {
              var v26462 = this.asts;
              var v26463 = this.top - 2;
              introspect(JAM.policy.p1) {
                var v26147 = v26462[v26463]
              }
              var v25564 = v26147.operand;
              var v26148 = this.asts;
              var v26149 = this.top - 1;
              introspect(JAM.policy.p1) {
                var v25565 = v26148[v26149]
              }
              v24523 = v25564 == v25565
            }
            v22355 = v24523
          }
          v17896 = v22355
        }
        v10540 = v17896
      }
      return v10540
    }
    function v380() {
      var v10541 = this.count() >= 2;
      if(v10541) {
        var v25566 = this.asts;
        var v25567 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24524 = v25566[v25567]
        }
        var v17898 = v24524.nodeType === TypeScript$$7.NodeType.ObjectLit;
        if(v17898) {
          var v26151 = this.asts;
          var v26152 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v25568 = v26151[v26152]
          }
          var v22358 = v25568.nodeType === TypeScript$$7.NodeType.List;
          if(v22358) {
            var v26466 = this.asts;
            var v26467 = this.top - 1;
            introspect(JAM.policy.p1) {
              var v26153 = v26466[v26467]
            }
            var v25570 = v26153.operand;
            var v26154 = this.asts;
            var v26155 = this.top - 0;
            introspect(JAM.policy.p1) {
              var v25571 = v26154[v26155]
            }
            var v24528 = v25570 == v25571;
            if(v24528) {
              var v26603 = this.asts;
              var v26604 = this.top - 0;
              introspect(JAM.policy.p1) {
                var v26469 = v26603[v26604]
              }
              v24528 = v26469.members.length == 0
            }
            v22358 = v24528
          }
          v17898 = v22358
        }
        v10541 = v17898
      }
      return v10541
    }
    function v379() {
      return this.isListOfObjectLit()
    }
    function v378() {
      var v10542 = this.count() >= 2;
      if(v10542) {
        var v25573 = this.asts;
        var v25574 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24529 = v25573[v25574]
        }
        var v17900 = v24529.nodeType === TypeScript$$7.NodeType.ObjectLit;
        if(v17900) {
          var v26158 = this.asts;
          var v26159 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v25575 = v26158[v26159]
          }
          var v22361 = v25575.nodeType === TypeScript$$7.NodeType.List;
          if(v22361) {
            var v26160 = this.asts;
            var v26161 = this.top - 1;
            introspect(JAM.policy.p1) {
              var v25577 = v26160[v26161]
            }
            var v24533 = v25577.operand;
            var v25578 = this.asts;
            var v25579 = this.top - 0;
            introspect(JAM.policy.p1) {
              var v24534 = v25578[v25579]
            }
            v22361 = v24533 == v24534
          }
          v17900 = v22361
        }
        v10542 = v17900
      }
      return v10542
    }
    function v377() {
      var v10543 = this.count() >= 3;
      if(v10543) {
        var v25580 = this.asts;
        var v25581 = this.top - 2;
        introspect(JAM.policy.p1) {
          var v24535 = v25580[v25581]
        }
        var v17902 = v24535.nodeType === TypeScript$$7.NodeType.Switch;
        if(v17902) {
          var v26164 = this.asts;
          var v26165 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v25582 = v26164[v26165]
          }
          var v22364 = v25582.nodeType === TypeScript$$7.NodeType.List;
          if(v22364) {
            var v26473 = this.asts;
            var v26474 = this.top - 2;
            introspect(JAM.policy.p1) {
              var v26166 = v26473[v26474]
            }
            var v25584 = v26166.caseList;
            var v26167 = this.asts;
            var v26168 = this.top - 1;
            introspect(JAM.policy.p1) {
              var v25585 = v26167[v26168]
            }
            var v24539 = v25584 == v25585;
            if(v24539) {
              var v26476 = this.asts;
              var v26477 = this.top - 2;
              introspect(JAM.policy.p1) {
                var v26169 = v26476[v26477]
              }
              var v25586 = v26169.defaultCase;
              var v26170 = this.asts;
              var v26171 = this.top - 0;
              introspect(JAM.policy.p1) {
                var v25587 = v26170[v26171]
              }
              v24539 = v25586 == v25587
            }
            v22364 = v24539
          }
          v17902 = v22364
        }
        v10543 = v17902
      }
      return v10543
    }
    function v376() {
      var v10544 = this.count() >= 3;
      if(v10544) {
        var v25588 = this.asts;
        var v25589 = this.top - 2;
        introspect(JAM.policy.p1) {
          var v24540 = v25588[v25589]
        }
        var v17904 = v24540.nodeType === TypeScript$$7.NodeType.Switch;
        if(v17904) {
          var v26173 = this.asts;
          var v26174 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v25590 = v26173[v26174]
          }
          var v22367 = v25590.nodeType === TypeScript$$7.NodeType.List;
          if(v22367) {
            var v26175 = this.asts;
            var v26176 = this.top - 2;
            introspect(JAM.policy.p1) {
              var v25592 = v26175[v26176]
            }
            var v24544 = v25592.caseList;
            var v25593 = this.asts;
            var v25594 = this.top - 1;
            introspect(JAM.policy.p1) {
              var v24545 = v25593[v25594]
            }
            v22367 = v24544 == v24545
          }
          v17904 = v22367
        }
        v10544 = v17904
      }
      return v10544
    }
    function v375() {
      var v10545 = this.count() >= 2;
      if(v10545) {
        var v25595 = this.asts;
        var v25596 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24546 = v25595[v25596]
        }
        var v17906 = v24546.nodeType === TypeScript$$7.NodeType.Finally;
        if(v17906) {
          var v25597 = this.asts;
          var v25598 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24548 = v25597[v25598]
          }
          var v22370 = v24548.body;
          var v24549 = this.asts;
          var v24550 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22371 = v24549[v24550]
          }
          v17906 = v22370 == v22371
        }
        v10545 = v17906
      }
      return v10545
    }
    function v374() {
      var v10546 = this.count() >= 2;
      if(v10546) {
        var v25600 = this.asts;
        var v25601 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24551 = v25600[v25601]
        }
        var v17908 = v24551.nodeType === TypeScript$$7.NodeType.With;
        if(v17908) {
          var v25602 = this.asts;
          var v25603 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24553 = v25602[v25603]
          }
          var v22374 = v24553.body;
          var v24554 = this.asts;
          var v24555 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22375 = v24554[v24555]
          }
          v17908 = v22374 == v22375
        }
        v10546 = v17908
      }
      return v10546
    }
    function v373() {
      var v10547 = this.count() >= 2;
      if(v10547) {
        var v25605 = this.asts;
        var v25606 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24556 = v25605[v25606]
        }
        var v17910 = v24556.nodeType === TypeScript$$7.NodeType.ForIn;
        if(v17910) {
          var v25607 = this.asts;
          var v25608 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24558 = v25607[v25608]
          }
          var v22378 = v24558.body;
          var v24559 = this.asts;
          var v24560 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22379 = v24559[v24560]
          }
          v17910 = v22378 == v22379
        }
        v10547 = v17910
      }
      return v10547
    }
    function v372() {
      var v10548 = this.count() >= 2;
      if(v10548) {
        var v25610 = this.asts;
        var v25611 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24561 = v25610[v25611]
        }
        var v17912 = v24561.nodeType === TypeScript$$7.NodeType.While;
        if(v17912) {
          var v25612 = this.asts;
          var v25613 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24563 = v25612[v25613]
          }
          var v22382 = v24563.body;
          var v24564 = this.asts;
          var v24565 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22383 = v24564[v24565]
          }
          v17912 = v22382 == v22383
        }
        v10548 = v17912
      }
      return v10548
    }
    function v371() {
      var v10549 = this.count() >= 2;
      if(v10549) {
        var v25615 = this.asts;
        var v25616 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24566 = v25615[v25616]
        }
        var v17914 = v24566.nodeType === TypeScript$$7.NodeType.DoWhile;
        if(v17914) {
          var v25617 = this.asts;
          var v25618 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24568 = v25617[v25618]
          }
          var v22386 = v24568.body;
          var v24569 = this.asts;
          var v24570 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22387 = v24569[v24570]
          }
          v17914 = v22386 == v22387
        }
        v10549 = v17914
      }
      return v10549
    }
    function v370() {
      var v10550 = this.count() >= 2;
      if(v10550) {
        var v25620 = this.asts;
        var v25621 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24571 = v25620[v25621]
        }
        var v17916 = v24571.nodeType === TypeScript$$7.NodeType.Catch;
        if(v17916) {
          var v25622 = this.asts;
          var v25623 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24573 = v25622[v25623]
          }
          var v22390 = v24573.body;
          var v24574 = this.asts;
          var v24575 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22391 = v24574[v24575]
          }
          v17916 = v22390 == v22391
        }
        v10550 = v17916
      }
      return v10550
    }
    function v369() {
      var v10551 = this.count() >= 2;
      if(v10551) {
        var v25625 = this.asts;
        var v25626 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24576 = v25625[v25626]
        }
        var v17918 = v24576.nodeType === TypeScript$$7.NodeType.Try;
        if(v17918) {
          var v25627 = this.asts;
          var v25628 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24578 = v25627[v25628]
          }
          var v22394 = v24578.body;
          var v24579 = this.asts;
          var v24580 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22395 = v24579[v24580]
          }
          v17918 = v22394 == v22395
        }
        v10551 = v17918
      }
      return v10551
    }
    function v368() {
      var v10552 = this.count() >= 2;
      if(v10552) {
        var v25630 = this.asts;
        var v25631 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24581 = v25630[v25631]
        }
        var v17920 = v24581.nodeType === TypeScript$$7.NodeType.Case;
        if(v17920) {
          var v25632 = this.asts;
          var v25633 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24583 = v25632[v25633]
          }
          var v22398 = v24583.body;
          var v24584 = this.asts;
          var v24585 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22399 = v24584[v24585]
          }
          v17920 = v22398 == v22399
        }
        v10552 = v17920
      }
      return v10552
    }
    function v367() {
      var v10553 = this.count() >= 2;
      if(v10553) {
        var v25635 = this.asts;
        var v25636 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24586 = v25635[v25636]
        }
        var v17922 = v24586.nodeType === TypeScript$$7.NodeType.For;
        if(v17922) {
          var v25637 = this.asts;
          var v25638 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24588 = v25637[v25638]
          }
          var v22402 = v24588.body;
          var v24589 = this.asts;
          var v24590 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22403 = v24589[v24590]
          }
          v17922 = v22402 == v22403
        }
        v10553 = v17922
      }
      return v10553
    }
    function v366() {
      var v10554 = this.count() >= 2;
      if(v10554) {
        var v25640 = this.asts;
        var v25641 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24591 = v25640[v25641]
        }
        var v17924 = v24591.nodeType === TypeScript$$7.NodeType.Block;
        if(v17924) {
          var v25642 = this.asts;
          var v25643 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24593 = v25642[v25643]
          }
          var v22406 = v24593.statements;
          var v24594 = this.asts;
          var v24595 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22407 = v24594[v24595]
          }
          v17924 = v22406 == v22407
        }
        v10554 = v17924
      }
      return v10554
    }
    function v365() {
      var v10555 = this.count() >= 2;
      if(v10555) {
        var v25645 = this.asts;
        var v25646 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24596 = v25645[v25646]
        }
        var v17926 = v24596.nodeType === TypeScript$$7.NodeType.InterfaceDeclaration;
        if(v17926) {
          var v25647 = this.asts;
          var v25648 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24598 = v25647[v25648]
          }
          var v22410 = v24598.members;
          var v24599 = this.asts;
          var v24600 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22411 = v24599[v24600]
          }
          v17926 = v22410 == v22411
        }
        v10555 = v17926
      }
      return v10555
    }
    function v364() {
      var v10556 = this.count() >= 2;
      if(v10556) {
        var v25650 = this.asts;
        var v25651 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24601 = v25650[v25651]
        }
        var v17928 = v24601.nodeType === TypeScript$$7.NodeType.FuncDecl;
        if(v17928) {
          var v25652 = this.asts;
          var v25653 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24603 = v25652[v25653]
          }
          var v22414 = v24603.bod;
          var v24604 = this.asts;
          var v24605 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22415 = v24604[v24605]
          }
          v17928 = v22414 == v22415
        }
        v10556 = v17928
      }
      return v10556
    }
    function v363() {
      var v10557 = this.count() >= 2;
      if(v10557) {
        var v25655 = this.asts;
        var v25656 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24606 = v25655[v25656]
        }
        var v17930 = v24606.nodeType === TypeScript$$7.NodeType.ClassDeclaration;
        if(v17930) {
          var v25657 = this.asts;
          var v25658 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24608 = v25657[v25658]
          }
          var v22418 = v24608.members;
          var v24609 = this.asts;
          var v24610 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22419 = v24609[v24610]
          }
          v17930 = v22418 == v22419
        }
        v10557 = v17930
      }
      return v10557
    }
    function v362() {
      var v10558 = this.count() >= 2;
      if(v10558) {
        var v25660 = this.asts;
        var v25661 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24611 = v25660[v25661]
        }
        var v17932 = v24611.nodeType === TypeScript$$7.NodeType.ModuleDeclaration;
        if(v17932) {
          var v25662 = this.asts;
          var v25663 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24613 = v25662[v25663]
          }
          var v22422 = v24613.members;
          var v24614 = this.asts;
          var v24615 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22423 = v24614[v24615]
          }
          v17932 = v22422 == v22423
        }
        v10558 = v17932
      }
      return v10558
    }
    function v361() {
      var v10559 = this.count() >= 2;
      if(v10559) {
        var v25665 = this.asts;
        var v25666 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24616 = v25665[v25666]
        }
        var v17934 = v24616.nodeType === TypeScript$$7.NodeType.Switch;
        if(v17934) {
          var v25667 = this.asts;
          var v25668 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24618 = v25667[v25668]
          }
          var v22426 = v24618.caseList;
          var v24619 = this.asts;
          var v24620 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22427 = v24619[v24620]
          }
          v17934 = v22426 == v22427
        }
        v10559 = v17934
      }
      return v10559
    }
    function v360() {
      var v10560 = this.count() >= 2;
      if(v10560) {
        var v25670 = this.asts;
        var v25671 = this.top - 1;
        introspect(JAM.policy.p1) {
          var v24621 = v25670[v25671]
        }
        var v17936 = v24621.nodeType === TypeScript$$7.NodeType.Script;
        if(v17936) {
          var v25672 = this.asts;
          var v25673 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v24623 = v25672[v25673]
          }
          var v22430 = v24623.bod;
          var v24624 = this.asts;
          var v24625 = this.top - 0;
          introspect(JAM.policy.p1) {
            var v22431 = v24624[v24625]
          }
          v17936 = v22430 == v22431
        }
        v10560 = v17936
      }
      return v10560
    }
    function v359() {
      var v10561 = this.count() >= 2;
      if(v10561) {
        var v25675 = this.asts;
        var v25676 = this.top - 0;
        introspect(JAM.policy.p1) {
          var v24626 = v25675[v25676]
        }
        var v17938 = v24626.nodeType === TypeScript$$7.NodeType.List;
        if(v17938) {
          var v26211 = this.asts;
          var v26212 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v25677 = v26211[v26212]
          }
          var v22434 = v25677.nodeType === TypeScript$$7.NodeType.ModuleDeclaration;
          if(v22434) {
            var v26482 = this.asts;
            var v26483 = this.top - 1;
            introspect(JAM.policy.p1) {
              var v26213 = v26482[v26483]
            }
            var v25679 = v26213.members;
            var v26214 = this.asts;
            var v26215 = this.top - 0;
            introspect(JAM.policy.p1) {
              var v25680 = v26214[v26215]
            }
            var v24630 = v25679 == v25680;
            if(v24630) {
              var v26485 = this.asts;
              var v26486 = this.top - 1;
              introspect(JAM.policy.p1) {
                var v26216 = v26485[v26486]
              }
              v24630 = JAM.call(TypeScript$$7.hasFlag, TypeScript$$7, [v26216.modFlags, TypeScript$$7.ModuleFlags.IsWholeFile])
            }
            v22434 = v24630
          }
          v17938 = v22434
        }
        v10561 = v17938
      }
      return v10561
    }
    function v358() {
      var v10562 = this.count() >= 1;
      if(v10562) {
        var v25683 = this.asts;
        var v25684 = this.top;
        introspect(JAM.policy.p1) {
          var v24631 = v25683[v25684]
        }
        var v17940 = v24631.nodeType === TypeScript$$7.NodeType.ModuleDeclaration;
        if(v17940) {
          var v25685 = this.asts;
          var v25686 = this.top;
          introspect(JAM.policy.p1) {
            var v24633 = v25685[v25686]
          }
          v17940 = JAM.call(TypeScript$$7.hasFlag, TypeScript$$7, [v24633.modFlags, TypeScript$$7.ModuleFlags.IsWholeFile])
        }
        v10562 = v17940
      }
      return v10562
    }
    function v357() {
      var ast$$13 = lastOf(this.asts);
      var v10564 = this.count() >= 3;
      if(v10564) {
        var v24635 = this.asts;
        var v24636 = this.top;
        introspect(JAM.policy.p1) {
          var v22439 = v24635[v24636]
        }
        var v17942 = v22439 === ast$$13;
        if(v17942) {
          var v26218 = this.asts;
          var v26219 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v25687 = v26218[v26219]
          }
          var v22440 = v25687.nodeType === TypeScript$$7.NodeType.List;
          if(v22440) {
            var v26220 = this.asts;
            var v26221 = this.top - 2;
            introspect(JAM.policy.p1) {
              var v25689 = v26220[v26221]
            }
            v22440 = v25689.nodeType === TypeScript$$7.NodeType.InterfaceDeclaration
          }
          v17942 = v22440
        }
        v10564 = v17942
      }
      return v10564
    }
    function v356() {
      var ast$$12 = lastOf(this.asts);
      var v10566 = this.count() >= 5;
      if(v10566) {
        var v24641 = this.asts;
        var v24642 = this.top;
        introspect(JAM.policy.p1) {
          var v22441 = v24641[v24642]
        }
        var v17944 = v22441 === ast$$12;
        if(v17944) {
          var v26222 = this.asts;
          var v26223 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v25691 = v26222[v26223]
          }
          var v22442 = v25691.nodeType === TypeScript$$7.NodeType.List;
          if(v22442) {
            var v26490 = this.asts;
            var v26491 = this.top - 2;
            introspect(JAM.policy.p1) {
              var v26224 = v26490[v26491]
            }
            var v24645 = v26224.nodeType === TypeScript$$7.NodeType.FuncDecl;
            if(v24645) {
              var v26610 = this.asts;
              var v26611 = this.top - 3;
              introspect(JAM.policy.p1) {
                var v26492 = v26610[v26611]
              }
              var v25695 = v26492.nodeType === TypeScript$$7.NodeType.List;
              if(v25695) {
                var v26676 = this.asts;
                var v26677 = this.top - 4;
                introspect(JAM.policy.p1) {
                  var v26612 = v26676[v26677]
                }
                var v26228 = v26612.nodeType === TypeScript$$7.NodeType.ClassDeclaration;
                if(v26228) {
                  var v26678 = this.asts;
                  var v26679 = this.top - 2;
                  introspect(JAM.policy.p1) {
                    var v26614 = v26678[v26679]
                  }
                  var v26496 = v26614.isConstructor;
                  if(v26496) {
                    var v26747 = this.asts;
                    var v26748 = this.top - 2;
                    introspect(JAM.policy.p1) {
                      var v26726 = v26747[v26748]
                    }
                    var v26680 = v26726.arguments;
                    var v26727 = this.asts;
                    var v26728 = this.top - 1;
                    introspect(JAM.policy.p1) {
                      var v26681 = v26727[v26728]
                    }
                    var v26615 = v26680 === v26681;
                    if(v26615) {
                      var v26750 = this.asts;
                      var v26751 = this.top - 4;
                      introspect(JAM.policy.p1) {
                        var v26729 = v26750[v26751]
                      }
                      var v26682 = v26729.constructorDecl;
                      var v26730 = this.asts;
                      var v26731 = this.top - 2;
                      introspect(JAM.policy.p1) {
                        var v26683 = v26730[v26731]
                      }
                      v26615 = v26682 === v26683
                    }
                    v26496 = v26615
                  }
                  v26228 = v26496
                }
                v25695 = v26228
              }
              v24645 = v25695
            }
            v22442 = v24645
          }
          v17944 = v22442
        }
        v10566 = v17944
      }
      return v10566
    }
    function v355() {
      var ast$$11 = lastOf(this.asts);
      var v10568 = this.count() >= 3;
      if(v10568) {
        var v24646 = this.asts;
        var v24647 = this.top;
        introspect(JAM.policy.p1) {
          var v22443 = v24646[v24647]
        }
        var v17946 = v22443 === ast$$11;
        if(v17946) {
          var v26229 = this.asts;
          var v26230 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v25696 = v26229[v26230]
          }
          var v22444 = v25696.nodeType === TypeScript$$7.NodeType.List;
          if(v22444) {
            var v26231 = this.asts;
            var v26232 = this.top - 2;
            introspect(JAM.policy.p1) {
              var v25698 = v26231[v26232]
            }
            v22444 = v25698.nodeType === TypeScript$$7.NodeType.ClassDeclaration
          }
          v17946 = v22444
        }
        v10568 = v17946
      }
      return v10568
    }
    function v354() {
      var ast$$10 = lastOf(this.asts);
      var v10570 = this.count() >= 3;
      if(v10570) {
        var v24652 = this.asts;
        var v24653 = this.top;
        introspect(JAM.policy.p1) {
          var v22445 = v24652[v24653]
        }
        var v17948 = v22445 === ast$$10;
        if(v17948) {
          var v26233 = this.asts;
          var v26234 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v25700 = v26233[v26234]
          }
          var v22446 = v25700.nodeType === TypeScript$$7.NodeType.List;
          if(v22446) {
            var v26235 = this.asts;
            var v26236 = this.top - 2;
            introspect(JAM.policy.p1) {
              var v25702 = v26235[v26236]
            }
            v22446 = v25702.nodeType === TypeScript$$7.NodeType.ModuleDeclaration
          }
          v17948 = v22446
        }
        v10570 = v17948
      }
      return v10570
    }
    function v353() {
      var ast$$9 = lastOf(this.asts);
      var v10572 = this.count() >= 3;
      if(v10572) {
        var v24658 = this.asts;
        var v24659 = this.top;
        introspect(JAM.policy.p1) {
          var v22447 = v24658[v24659]
        }
        var v17950 = v22447 === ast$$9;
        if(v17950) {
          var v26237 = this.asts;
          var v26238 = this.top - 1;
          introspect(JAM.policy.p1) {
            var v25704 = v26237[v26238]
          }
          var v22448 = v25704.nodeType === TypeScript$$7.NodeType.List;
          if(v22448) {
            var v26239 = this.asts;
            var v26240 = this.top - 2;
            introspect(JAM.policy.p1) {
              var v25706 = v26239[v26240]
            }
            v22448 = v25706.nodeType === TypeScript$$7.NodeType.Script
          }
          v17950 = v22448
        }
        v10572 = v17950
      }
      return v10572
    }
    function v352() {
      var v17951 = this.ast() === null;
      if(!v17951) {
        v17951 = this.parent() === null
      }
      if(v17951) {
        return false
      }
      var v10574 = this.ast().nodeType === TypeScript$$7.NodeType.Name;
      if(v10574) {
        var v17954 = this.parent().nodeType === TypeScript$$7.NodeType.FuncDecl;
        if(v17954) {
          v17954 = this.parent().name === this.ast()
        }
        v10574 = v17954
      }
      return v10574
    }
    function v351() {
      var v17955 = this.ast() === null;
      if(!v17955) {
        v17955 = this.parent() === null
      }
      if(v17955) {
        return false
      }
      var v10576 = this.ast().nodeType === TypeScript$$7.NodeType.Name;
      if(v10576) {
        var v17958 = this.parent().nodeType === TypeScript$$7.NodeType.ModuleDeclaration;
        if(v17958) {
          v17958 = this.parent().name === this.ast()
        }
        v10576 = v17958
      }
      return v10576
    }
    function v350() {
      var v17959 = this.ast() === null;
      if(!v17959) {
        v17959 = this.parent() === null
      }
      if(v17959) {
        return false
      }
      var v10578 = this.ast().nodeType === TypeScript$$7.NodeType.Name;
      if(v10578) {
        var v17962 = this.parent().nodeType === TypeScript$$7.NodeType.VarDecl;
        if(v17962) {
          v17962 = this.parent().id === this.ast()
        }
        v10578 = v17962
      }
      return v10578
    }
    function v349() {
      var v17963 = this.ast() === null;
      if(!v17963) {
        v17963 = this.parent() === null
      }
      if(v17963) {
        return false
      }
      var v10580 = this.ast().nodeType === TypeScript$$7.NodeType.Name;
      if(v10580) {
        var v17966 = this.parent().nodeType === TypeScript$$7.NodeType.ArgDecl;
        if(v17966) {
          v17966 = this.parent().id === this.ast()
        }
        v10580 = v17966
      }
      return v10580
    }
    function v348() {
      var v17967 = this.ast() === null;
      if(!v17967) {
        v17967 = this.parent() === null
      }
      if(v17967) {
        return false
      }
      var v10582 = this.ast().nodeType === TypeScript$$7.NodeType.Name;
      if(v10582) {
        var v17970 = this.parent().nodeType === TypeScript$$7.NodeType.InterfaceDeclaration;
        if(v17970) {
          v17970 = this.parent().name === this.ast()
        }
        v10582 = v17970
      }
      return v10582
    }
    function v347() {
      var v17971 = this.ast() === null;
      if(!v17971) {
        v17971 = this.parent() === null
      }
      if(v17971) {
        return false
      }
      var v10584 = this.ast().nodeType === TypeScript$$7.NodeType.Name;
      if(v10584) {
        var v17974 = this.parent().nodeType === TypeScript$$7.NodeType.ClassDeclaration;
        if(v17974) {
          v17974 = this.parent().name === this.ast()
        }
        v10584 = v17974
      }
      return v10584
    }
    function v346(index$$43) {
      var v10585 = this.asts;
      introspect(JAM.policy.p1) {
        return v10585[index$$43]
      }
    }
    function v345() {
      return this.top + 1
    }
    function v344() {
      return JAM.call(AstPath$$1.reverseIndexOf, AstPath$$1, [this.asts, this.asts.length - this.top])
    }
    function v343() {
      return JAM.call(AstPath$$1.reverseIndexOf, AstPath$$1, [this.asts, this.asts.length - (this.top + 1)])
    }
    function v342() {
      if(this.ast() == null) {
        return TypeScript$$7.NodeType.None
      }
      return this.ast().nodeType
    }
    function v341() {
      if(this.top == this.ast.length - 1) {
        throw new Error("Invalid call to 'down'");
      }
      this.top = this.top + 1;
      return
    }
    function v340() {
      if(this.top <= -1) {
        throw new Error("Invalid call to 'up'");
      }
      this.top = this.top - 1;
      return
    }
    function v339(ast$$8) {
      var v10597 = this.asts.length > this.count();
      for(;v10597;) {
        this.asts.pop();
        v10597 = this.asts.length > this.count()
      }
      this.top = this.asts.length;
      var v10599 = this.asts;
      JAM.call(v10599.push, v10599, [ast$$8]);
      return
    }
    function v338() {
      var head = this.ast();
      this.up();
      var v10601 = this.asts.length > this.count();
      for(;v10601;) {
        this.asts.pop();
        v10601 = this.asts.length > this.count()
      }
      return head
    }
    function v337() {
      function v336(value$$32) {
        return value$$32
      }
      var clone = new AstPath$$1;
      var v10602 = clone;
      var v17993 = this.asts;
      var v27335 = JAM.call(v17993.map, v17993, [v336]);
      v10602.asts = v27335;
      clone.top = this.top;
      return clone
    }
    function reverseIndexOf(items$$1, index$$42) {
      var v10603;
      var v22511 = items$$1 === null;
      if(!v22511) {
        v22511 = items$$1.length <= index$$42
      }
      if(v22511) {
        v10603 = null
      }else {
        v10603 = items$$1[items$$1.length - index$$42 - 1]
      }
      return v10603
    }
    function AstPath$$1() {
      this.asts = [];
      this.top = -1;
      return
    }
    AstPath$$1.reverseIndexOf = reverseIndexOf;
    AstPath$$1.prototype.clone = v337;
    AstPath$$1.prototype.pop = v338;
    AstPath$$1.prototype.push = v339;
    AstPath$$1.prototype.up = v340;
    AstPath$$1.prototype.down = v341;
    AstPath$$1.prototype.nodeType = v342;
    AstPath$$1.prototype.ast = v343;
    AstPath$$1.prototype.parent = v344;
    AstPath$$1.prototype.count = v345;
    AstPath$$1.prototype.get = v346;
    AstPath$$1.prototype.isNameOfClass = v347;
    AstPath$$1.prototype.isNameOfInterface = v348;
    AstPath$$1.prototype.isNameOfArgument = v349;
    AstPath$$1.prototype.isNameOfVariable = v350;
    AstPath$$1.prototype.isNameOfModule = v351;
    AstPath$$1.prototype.isNameOfFunction = v352;
    AstPath$$1.prototype.isChildOfScript = v353;
    AstPath$$1.prototype.isChildOfModule = v354;
    AstPath$$1.prototype.isChildOfClass = v355;
    AstPath$$1.prototype.isArgumentOfClassConstructor = v356;
    AstPath$$1.prototype.isChildOfInterface = v357;
    AstPath$$1.prototype.isTopLevelImplicitModule = v358;
    AstPath$$1.prototype.isBodyOfTopLevelImplicitModule = v359;
    AstPath$$1.prototype.isBodyOfScript = v360;
    AstPath$$1.prototype.isBodyOfSwitch = v361;
    AstPath$$1.prototype.isBodyOfModule = v362;
    AstPath$$1.prototype.isBodyOfClass = v363;
    AstPath$$1.prototype.isBodyOfFunction = v364;
    AstPath$$1.prototype.isBodyOfInterface = v365;
    AstPath$$1.prototype.isBodyOfBlock = v366;
    AstPath$$1.prototype.isBodyOfFor = v367;
    AstPath$$1.prototype.isBodyOfCase = v368;
    AstPath$$1.prototype.isBodyOfTry = v369;
    AstPath$$1.prototype.isBodyOfCatch = v370;
    AstPath$$1.prototype.isBodyOfDoWhile = v371;
    AstPath$$1.prototype.isBodyOfWhile = v372;
    AstPath$$1.prototype.isBodyOfForIn = v373;
    AstPath$$1.prototype.isBodyOfWith = v374;
    AstPath$$1.prototype.isBodyOfFinally = v375;
    AstPath$$1.prototype.isCaseOfSwitch = v376;
    AstPath$$1.prototype.isDefaultCaseOfSwitch = v377;
    AstPath$$1.prototype.isListOfObjectLit = v378;
    AstPath$$1.prototype.isBodyOfObjectLit = v379;
    AstPath$$1.prototype.isEmptyListOfObjectLit = v380;
    AstPath$$1.prototype.isMemberOfObjectLit = v381;
    AstPath$$1.prototype.isNameOfMemberOfObjectLit = v382;
    AstPath$$1.prototype.isListOfArrayLit = v383;
    AstPath$$1.prototype.isTargetOfMember = v384;
    AstPath$$1.prototype.isMemberOfMember = v385;
    AstPath$$1.prototype.isItemOfList = v386;
    AstPath$$1.prototype.isThenOfIf = v387;
    AstPath$$1.prototype.isElseOfIf = v388;
    AstPath$$1.prototype.isBodyOfDefaultCase = v389;
    AstPath$$1.prototype.isSingleStatementList = v390;
    AstPath$$1.prototype.isArgumentListOfFunction = v391;
    AstPath$$1.prototype.isArgumentOfFunction = v392;
    AstPath$$1.prototype.isArgumentListOfCall = v393;
    AstPath$$1.prototype.isArgumentListOfNew = v394;
    AstPath$$1.prototype.isSynthesizedBlock = v395;
    return AstPath$$1
  }
  function lastOf(items) {
    var v10663;
    var v22513 = items === null;
    if(!v22513) {
      v22513 = items.length === 0
    }
    if(v22513) {
      v10663 = null
    }else {
      v10663 = items[items.length - 1]
    }
    return v10663
  }
  function max(a, b$$1) {
    var v10664;
    if(a >= b$$1) {
      v10664 = a
    }else {
      v10664 = b$$1
    }
    return v10664
  }
  function min$$1(a$$1, b$$2) {
    var v10665;
    if(a$$1 <= b$$2) {
      v10665 = a$$1
    }else {
      v10665 = b$$2
    }
    return v10665
  }
  function isValidAstNode(ast$$6) {
    if(ast$$6 === null) {
      return false
    }
    var v18000 = ast$$6.minChar === -1;
    if(!v18000) {
      v18000 = ast$$6.limChar === -1
    }
    if(v18000) {
      return false
    }
    return true
  }
  function getAstPathToPosition(script$$1, pos, options$$5) {
    function pre$$6(cur$$2, parent$$37, walker$$36) {
      if(isValidAstNode(cur$$2)) {
        var v10668 = JAM.call(TypeScript$$7.hasFlag, TypeScript$$7, [options$$5, GetAstPathOptions.EdgeInclusive]);
        if(!v10668) {
          var v18002 = cur$$2.nodeType === TypeScript$$7.NodeType.Name;
          if(!v18002) {
            v18002 = pos === script$$1.limChar
          }
          v10668 = v18002
        }
        var inclusive = v10668;
        var minChar$$1 = cur$$2.minChar;
        var v10669 = cur$$2.limChar;
        var v18004;
        if(inclusive) {
          v18004 = 1
        }else {
          v18004 = 0
        }
        var limChar$$1 = v10669 + v18004;
        var v18005 = pos >= minChar$$1;
        if(v18005) {
          v18005 = pos < limChar$$1
        }
        if(v18005) {
          var previous = ctx.path.ast();
          var v18006 = previous == null;
          if(!v18006) {
            var v22522 = cur$$2.minChar >= previous.minChar;
            if(v22522) {
              v22522 = cur$$2.limChar <= previous.limChar
            }
            v18006 = v22522
          }
          if(v18006) {
            var v10672 = ctx.path;
            JAM.call(v10672.push, v10672, [cur$$2])
          }else {
          }
        }
        if(pos < limChar$$1) {
          lookInComments(cur$$2.preComments)
        }
        if(pos >= minChar$$1) {
          lookInComments(cur$$2.postComments)
        }
        if(!JAM.call(TypeScript$$7.hasFlag, TypeScript$$7, [options$$5, GetAstPathOptions.DontPruneSearchBasedOnPosition])) {
          var v10679 = walker$$36.options;
          var v18008 = minChar$$1 <= pos;
          if(v18008) {
            v18008 = pos <= limChar$$1
          }
          v10679.goChildren = v18008
        }
      }
      return cur$$2
    }
    function lookInComments(comments$$2) {
      var v18009 = comments$$2;
      if(v18009) {
        v18009 = comments$$2.length > 0
      }
      if(v18009) {
        var i$$26 = 0;
        var v10688 = i$$26 < comments$$2.length;
        for(;v10688;) {
          introspect(JAM.policy.p1) {
            var v10682 = comments$$2[i$$26]
          }
          var minChar = v10682.minChar;
          introspect(JAM.policy.p1) {
            var v10683 = comments$$2[i$$26]
          }
          var limChar = v10683.limChar;
          introspect(JAM.policy.p1) {
            var v22526 = comments$$2[i$$26]
          }
          if(!v22526.isBlockComment) {
            limChar = limChar + 1
          }
          var v18012 = pos >= minChar;
          if(v18012) {
            v18012 = pos < limChar
          }
          if(v18012) {
            var v10685 = ctx.path;
            introspect(JAM.policy.p1) {
              var v10686 = comments$$2[i$$26]
            }
            JAM.call(v10685.push, v10685, [v10686])
          }
          i$$26 = i$$26 + 1;
          v10688 = i$$26 < comments$$2.length
        }
      }
      return
    }
    if(typeof options$$5 === "undefined") {
      options$$5 = GetAstPathOptions.Default
    }
    var ctx = new AstPathContext;
    var v10691 = TypeScript$$7.getAstWalkerFactory();
    JAM.call(v10691.walk, v10691, [script$$1, pre$$6, null, null, ctx]);
    return ctx.path
  }
  function getTokenizationOffset(script$$2, position) {
    function pre$$7(cur$$3, parent$$38, walker$$37) {
      if(JAM.call(TypeScript$$7.isValidAstNode, TypeScript$$7, [cur$$3])) {
        if(cur$$3.minChar <= position) {
          bestOffset = max(bestOffset, cur$$3.minChar)
        }
        var v18016 = cur$$3.minChar > position;
        if(!v18016) {
          v18016 = cur$$3.limChar < bestOffset
        }
        if(v18016) {
          walker$$37.options.goChildren = false
        }
      }
      return cur$$3
    }
    var bestOffset = 0;
    var v10697 = TypeScript$$7.getAstWalkerFactory();
    JAM.call(v10697.walk, v10697, [script$$2, pre$$7]);
    return bestOffset
  }
  function walkAST(ast$$7, callback$$27) {
    function post$$5(cur$$5, parent$$40, walker$$39) {
      var path$$5 = walker$$39.state;
      path$$5.pop();
      return cur$$5
    }
    function pre$$8(cur$$4, parent$$39, walker$$38) {
      var path$$4 = walker$$38.state;
      JAM.call(path$$4.push, path$$4, [cur$$4]);
      JAM.call(callback$$27, null, [path$$4, walker$$38]);
      return cur$$4
    }
    var path$$3 = new AstPath;
    var v10698 = TypeScript$$7.getAstWalkerFactory();
    JAM.call(v10698.walk, v10698, [ast$$7, pre$$8, post$$5, null, path$$3]);
    return
  }
  TypeScript$$7.lastOf = lastOf;
  TypeScript$$7.max = max;
  TypeScript$$7.min = min$$1;
  var AstPath = v396();
  TypeScript$$7.AstPath = AstPath;
  TypeScript$$7.isValidAstNode = isValidAstNode;
  var AstPathContext = v397();
  TypeScript$$7.AstPathContext = AstPathContext;
  var v18017 = TypeScript$$7.GetAstPathOptions;
  if(!v18017) {
    v18017 = TypeScript$$7.GetAstPathOptions = {}
  }
  v398(v18017);
  var GetAstPathOptions = TypeScript$$7.GetAstPathOptions;
  TypeScript$$7.getAstPathToPosition = getAstPathToPosition;
  TypeScript$$7.getTokenizationOffset = getTokenizationOffset;
  TypeScript$$7.walkAST = walkAST;
  return
}
function v335(TypeScript$$6) {
  function v334(AstWalkerWithDetailCallback$$1) {
    function walk(script, callback$$25) {
      function post$$4(cur$$1, parent$$36) {
        AstWalkerCallback(false, cur$$1, callback$$25);
        return cur$$1
      }
      function pre$$4(cur, parent$$35) {
        var v10700 = walker$$35.options;
        var v27336 = AstWalkerCallback(true, cur, callback$$25);
        v10700.goChildren = v27336;
        return cur
      }
      var v10701 = TypeScript$$6.getAstWalkerFactory();
      var walker$$35 = JAM.call(v10701.getWalker, v10701, [pre$$4, post$$4]);
      JAM.call(walker$$35.walk, walker$$35, [script, null]);
      return
    }
    function AstWalkerCallback(pre$$5, ast$$5, callback$$26) {
      var nodeType$$12 = ast$$5.nodeType;
      var v18018 = TypeScript$$6.NodeType._map;
      introspect(JAM.policy.p1) {
        var v10702 = v18018[nodeType$$12]
      }
      var callbackString = v10702 + "Callback";
      introspect(JAM.policy.p1) {
        var v10703 = callback$$26[callbackString]
      }
      if(v10703) {
        return JAM.call(JAM.get(callback$$26, callbackString, JAM.policy.p1), callback$$26, [pre$$5, ast$$5])
      }
      if(callback$$26.DefaultCallback) {
        return JAM.call(callback$$26.DefaultCallback, callback$$26, [pre$$5, ast$$5])
      }
      return true
    }
    AstWalkerWithDetailCallback$$1.walk = walk;
    return
  }
  var v18019 = TypeScript$$6.AstWalkerWithDetailCallback;
  if(!v18019) {
    v18019 = TypeScript$$6.AstWalkerWithDetailCallback = {}
  }
  v334(v18019);
  var AstWalkerWithDetailCallback = TypeScript$$6.AstWalkerWithDetailCallback;
  return
}
function v333(TypeScript$$5) {
  function v332(ChildrenWalkers$$1) {
    function walkNone(preAst$$1, parent$$2, walker$$2) {
      return
    }
    function walkListChildren(preAst$$2, parent$$3, walker$$3) {
      var len$$6 = preAst$$2.members.length;
      if(walker$$3.options.reverseSiblings) {
        var i$$25 = len$$6 - 1;
        var v10710 = i$$25 >= 0;
        for(;v10710;) {
          if(walker$$3.options.goNextSibling) {
            var v10707 = preAst$$2.members;
            var v10708 = i$$25;
            var v22533 = preAst$$2.members;
            introspect(JAM.policy.p1) {
              var v18022 = v22533[i$$25]
            }
            var v27337 = JAM.call(walker$$3.walk, walker$$3, [v18022, preAst$$2]);
            v10707[v10708] = v27337
          }
          i$$25 = i$$25 - 1;
          v10710 = i$$25 >= 0
        }
      }else {
        i$$25 = 0;
        var v10714 = i$$25 < len$$6;
        for(;v10714;) {
          if(walker$$3.options.goNextSibling) {
            var v10711 = preAst$$2.members;
            var v10712 = i$$25;
            var v22534 = preAst$$2.members;
            introspect(JAM.policy.p1) {
              var v18024 = v22534[i$$25]
            }
            var v27338 = JAM.call(walker$$3.walk, walker$$3, [v18024, preAst$$2]);
            v10711[v10712] = v27338
          }
          i$$25 = i$$25 + 1;
          v10714 = i$$25 < len$$6
        }
      }
      return
    }
    function walkUnaryExpressionChildren(preAst$$3, parent$$4, walker$$4) {
      if(preAst$$3.castTerm) {
        var v10716 = preAst$$3;
        var v27339 = JAM.call(walker$$4.walk, walker$$4, [preAst$$3.castTerm, preAst$$3]);
        v10716.castTerm = v27339
      }
      if(preAst$$3.operand) {
        var v10718 = preAst$$3;
        var v27340 = JAM.call(walker$$4.walk, walker$$4, [preAst$$3.operand, preAst$$3]);
        v10718.operand = v27340
      }
      return
    }
    function walkBinaryExpressionChildren(preAst$$4, parent$$5, walker$$5) {
      if(walker$$5.options.reverseSiblings) {
        if(preAst$$4.operand2) {
          var v10720 = preAst$$4;
          var v27341 = JAM.call(walker$$5.walk, walker$$5, [preAst$$4.operand2, preAst$$4]);
          v10720.operand2 = v27341
        }
        var v18029 = preAst$$4.operand1;
        if(v18029) {
          v18029 = walker$$5.options.goNextSibling
        }
        if(v18029) {
          var v10722 = preAst$$4;
          var v27342 = JAM.call(walker$$5.walk, walker$$5, [preAst$$4.operand1, preAst$$4]);
          v10722.operand1 = v27342
        }
      }else {
        if(preAst$$4.operand1) {
          var v10724 = preAst$$4;
          var v27343 = JAM.call(walker$$5.walk, walker$$5, [preAst$$4.operand1, preAst$$4]);
          v10724.operand1 = v27343
        }
        var v18032 = preAst$$4.operand2;
        if(v18032) {
          v18032 = walker$$5.options.goNextSibling
        }
        if(v18032) {
          var v10726 = preAst$$4;
          var v27344 = JAM.call(walker$$5.walk, walker$$5, [preAst$$4.operand2, preAst$$4]);
          v10726.operand2 = v27344
        }
      }
      return
    }
    function walkTypeReferenceChildren(preAst$$5, parent$$6, walker$$6) {
      if(preAst$$5.term) {
        var v10729 = preAst$$5;
        var v27345 = JAM.call(walker$$6.walk, walker$$6, [preAst$$5.term, preAst$$5]);
        v10729.term = v27345
      }
      return
    }
    function walkCallExpressionChildren(preAst$$6, parent$$7, walker$$7) {
      if(!walker$$7.options.reverseSiblings) {
        var v10731 = preAst$$6;
        var v27346 = JAM.call(walker$$7.walk, walker$$7, [preAst$$6.target, preAst$$6]);
        v10731.target = v27346
      }
      var v18037 = preAst$$6.arguments;
      if(v18037) {
        v18037 = walker$$7.options.goNextSibling
      }
      if(v18037) {
        var v10733 = preAst$$6;
        var v27347 = JAM.call(walker$$7.walk, walker$$7, [preAst$$6.arguments, preAst$$6]);
        v10733.arguments = v27347
      }
      var v18039 = walker$$7.options.reverseSiblings;
      if(v18039) {
        v18039 = walker$$7.options.goNextSibling
      }
      if(v18039) {
        var v10735 = preAst$$6;
        var v27348 = JAM.call(walker$$7.walk, walker$$7, [preAst$$6.target, preAst$$6]);
        v10735.target = v27348
      }
      return
    }
    function walkTrinaryExpressionChildren(preAst$$7, parent$$8, walker$$8) {
      if(preAst$$7.operand1) {
        var v10737 = preAst$$7;
        var v27349 = JAM.call(walker$$8.walk, walker$$8, [preAst$$7.operand1, preAst$$7]);
        v10737.operand1 = v27349
      }
      var v18042 = preAst$$7.operand2;
      if(v18042) {
        v18042 = walker$$8.options.goNextSibling
      }
      if(v18042) {
        var v10739 = preAst$$7;
        var v27350 = JAM.call(walker$$8.walk, walker$$8, [preAst$$7.operand2, preAst$$7]);
        v10739.operand2 = v27350
      }
      var v18044 = preAst$$7.operand3;
      if(v18044) {
        v18044 = walker$$8.options.goNextSibling
      }
      if(v18044) {
        var v10741 = preAst$$7;
        var v27351 = JAM.call(walker$$8.walk, walker$$8, [preAst$$7.operand3, preAst$$7]);
        v10741.operand3 = v27351
      }
      return
    }
    function walkFuncDeclChildren(preAst$$8, parent$$9, walker$$9) {
      if(preAst$$8.name) {
        var v10743 = preAst$$8;
        var v27352 = JAM.call(walker$$9.walk, walker$$9, [preAst$$8.name, preAst$$8]);
        v10743.name = v27352
      }
      var v18047 = preAst$$8.arguments;
      if(v18047) {
        var v22543 = preAst$$8.arguments.members.length > 0;
        if(v22543) {
          v22543 = walker$$9.options.goNextSibling
        }
        v18047 = v22543
      }
      if(v18047) {
        var v10745 = preAst$$8;
        var v27353 = JAM.call(walker$$9.walk, walker$$9, [preAst$$8.arguments, preAst$$8]);
        v10745.arguments = v27353
      }
      var v18049 = preAst$$8.returnTypeAnnotation;
      if(v18049) {
        v18049 = walker$$9.options.goNextSibling
      }
      if(v18049) {
        var v10747 = preAst$$8;
        var v27354 = JAM.call(walker$$9.walk, walker$$9, [preAst$$8.returnTypeAnnotation, preAst$$8]);
        v10747.returnTypeAnnotation = v27354
      }
      var v18051 = preAst$$8.bod;
      if(v18051) {
        var v22545 = preAst$$8.bod.members.length > 0;
        if(v22545) {
          v22545 = walker$$9.options.goNextSibling
        }
        v18051 = v22545
      }
      if(v18051) {
        var v10749 = preAst$$8;
        var v27355 = JAM.call(walker$$9.walk, walker$$9, [preAst$$8.bod, preAst$$8]);
        v10749.bod = v27355
      }
      return
    }
    function walkBoundDeclChildren(preAst$$9, parent$$10, walker$$10) {
      if(preAst$$9.id) {
        var v10751 = preAst$$9;
        var v27356 = JAM.call(walker$$10.walk, walker$$10, [preAst$$9.id, preAst$$9]);
        v10751.id = v27356
      }
      if(preAst$$9.init) {
        var v10753 = preAst$$9;
        var v27357 = JAM.call(walker$$10.walk, walker$$10, [preAst$$9.init, preAst$$9]);
        v10753.init = v27357
      }
      var v18055 = preAst$$9.typeExpr;
      if(v18055) {
        v18055 = walker$$10.options.goNextSibling
      }
      if(v18055) {
        var v10755 = preAst$$9;
        var v27358 = JAM.call(walker$$10.walk, walker$$10, [preAst$$9.typeExpr, preAst$$9]);
        v10755.typeExpr = v27358
      }
      return
    }
    function walkReturnStatementChildren(preAst$$10, parent$$11, walker$$11) {
      if(preAst$$10.returnExpression) {
        var v10757 = preAst$$10;
        var v27359 = JAM.call(walker$$11.walk, walker$$11, [preAst$$10.returnExpression, preAst$$10]);
        v10757.returnExpression = v27359
      }
      return
    }
    function walkForStatementChildren(preAst$$11, parent$$12, walker$$12) {
      if(preAst$$11.init) {
        var v10759 = preAst$$11;
        var v27360 = JAM.call(walker$$12.walk, walker$$12, [preAst$$11.init, preAst$$11]);
        v10759.init = v27360
      }
      var v18059 = preAst$$11.cond;
      if(v18059) {
        v18059 = walker$$12.options.goNextSibling
      }
      if(v18059) {
        var v10761 = preAst$$11;
        var v27361 = JAM.call(walker$$12.walk, walker$$12, [preAst$$11.cond, preAst$$11]);
        v10761.cond = v27361
      }
      var v18061 = preAst$$11.incr;
      if(v18061) {
        v18061 = walker$$12.options.goNextSibling
      }
      if(v18061) {
        var v10763 = preAst$$11;
        var v27362 = JAM.call(walker$$12.walk, walker$$12, [preAst$$11.incr, preAst$$11]);
        v10763.incr = v27362
      }
      var v18063 = preAst$$11.body;
      if(v18063) {
        v18063 = walker$$12.options.goNextSibling
      }
      if(v18063) {
        var v10765 = preAst$$11;
        var v27363 = JAM.call(walker$$12.walk, walker$$12, [preAst$$11.body, preAst$$11]);
        v10765.body = v27363
      }
      return
    }
    function walkForInStatementChildren(preAst$$12, parent$$13, walker$$13) {
      var v10767 = preAst$$12;
      var v27364 = JAM.call(walker$$13.walk, walker$$13, [preAst$$12.lval, preAst$$12]);
      v10767.lval = v27364;
      if(walker$$13.options.goNextSibling) {
        var v10768 = preAst$$12;
        var v27365 = JAM.call(walker$$13.walk, walker$$13, [preAst$$12.obj, preAst$$12]);
        v10768.obj = v27365
      }
      var v18068 = preAst$$12.body;
      if(v18068) {
        v18068 = walker$$13.options.goNextSibling
      }
      if(v18068) {
        var v10770 = preAst$$12;
        var v27366 = JAM.call(walker$$13.walk, walker$$13, [preAst$$12.body, preAst$$12]);
        v10770.body = v27366
      }
      return
    }
    function walkIfStatementChildren(preAst$$13, parent$$14, walker$$14) {
      var v10772 = preAst$$13;
      var v27367 = JAM.call(walker$$14.walk, walker$$14, [preAst$$13.cond, preAst$$13]);
      v10772.cond = v27367;
      var v18071 = preAst$$13.thenBod;
      if(v18071) {
        v18071 = walker$$14.options.goNextSibling
      }
      if(v18071) {
        var v10773 = preAst$$13;
        var v27368 = JAM.call(walker$$14.walk, walker$$14, [preAst$$13.thenBod, preAst$$13]);
        v10773.thenBod = v27368
      }
      var v18073 = preAst$$13.elseBod;
      if(v18073) {
        v18073 = walker$$14.options.goNextSibling
      }
      if(v18073) {
        var v10775 = preAst$$13;
        var v27369 = JAM.call(walker$$14.walk, walker$$14, [preAst$$13.elseBod, preAst$$13]);
        v10775.elseBod = v27369
      }
      return
    }
    function walkWhileStatementChildren(preAst$$14, parent$$15, walker$$15) {
      var v10777 = preAst$$14;
      var v27370 = JAM.call(walker$$15.walk, walker$$15, [preAst$$14.cond, preAst$$14]);
      v10777.cond = v27370;
      var v18076 = preAst$$14.body;
      if(v18076) {
        v18076 = walker$$15.options.goNextSibling
      }
      if(v18076) {
        var v10778 = preAst$$14;
        var v27371 = JAM.call(walker$$15.walk, walker$$15, [preAst$$14.body, preAst$$14]);
        v10778.body = v27371
      }
      return
    }
    function walkDoWhileStatementChildren(preAst$$15, parent$$16, walker$$16) {
      var v10780 = preAst$$15;
      var v27372 = JAM.call(walker$$16.walk, walker$$16, [preAst$$15.cond, preAst$$15]);
      v10780.cond = v27372;
      var v18079 = preAst$$15.body;
      if(v18079) {
        v18079 = walker$$16.options.goNextSibling
      }
      if(v18079) {
        var v10781 = preAst$$15;
        var v27373 = JAM.call(walker$$16.walk, walker$$16, [preAst$$15.body, preAst$$15]);
        v10781.body = v27373
      }
      return
    }
    function walkBlockChildren(preAst$$16, parent$$17, walker$$17) {
      if(preAst$$16.statements) {
        var v10783 = preAst$$16;
        var v27374 = JAM.call(walker$$17.walk, walker$$17, [preAst$$16.statements, preAst$$16]);
        v10783.statements = v27374
      }
      return
    }
    function walkCaseStatementChildren(preAst$$17, parent$$18, walker$$18) {
      if(preAst$$17.expr) {
        var v10785 = preAst$$17;
        var v27375 = JAM.call(walker$$18.walk, walker$$18, [preAst$$17.expr, preAst$$17]);
        v10785.expr = v27375
      }
      var v18083 = preAst$$17.body;
      if(v18083) {
        v18083 = walker$$18.options.goNextSibling
      }
      if(v18083) {
        var v10787 = preAst$$17;
        var v27376 = JAM.call(walker$$18.walk, walker$$18, [preAst$$17.body, preAst$$17]);
        v10787.body = v27376
      }
      return
    }
    function walkSwitchStatementChildren(preAst$$18, parent$$19, walker$$19) {
      if(preAst$$18.val) {
        var v10789 = preAst$$18;
        var v27377 = JAM.call(walker$$19.walk, walker$$19, [preAst$$18.val, preAst$$18]);
        v10789.val = v27377
      }
      var v18086 = preAst$$18.caseList;
      if(v18086) {
        v18086 = walker$$19.options.goNextSibling
      }
      if(v18086) {
        var v10791 = preAst$$18;
        var v27378 = JAM.call(walker$$19.walk, walker$$19, [preAst$$18.caseList, preAst$$18]);
        v10791.caseList = v27378
      }
      return
    }
    function walkTryChildren(preAst$$19, parent$$20, walker$$20) {
      if(preAst$$19.body) {
        var v10793 = preAst$$19;
        var v27379 = JAM.call(walker$$20.walk, walker$$20, [preAst$$19.body, preAst$$19]);
        v10793.body = v27379
      }
      return
    }
    function walkTryCatchChildren(preAst$$20, parent$$21, walker$$21) {
      if(preAst$$20.tryNode) {
        var v10795 = preAst$$20;
        var v27380 = JAM.call(walker$$21.walk, walker$$21, [preAst$$20.tryNode, preAst$$20]);
        v10795.tryNode = v27380
      }
      var v18090 = preAst$$20.catchNode;
      if(v18090) {
        v18090 = walker$$21.options.goNextSibling
      }
      if(v18090) {
        var v10797 = preAst$$20;
        var v27381 = JAM.call(walker$$21.walk, walker$$21, [preAst$$20.catchNode, preAst$$20]);
        v10797.catchNode = v27381
      }
      return
    }
    function walkTryFinallyChildren(preAst$$21, parent$$22, walker$$22) {
      if(preAst$$21.tryNode) {
        var v10799 = preAst$$21;
        var v27382 = JAM.call(walker$$22.walk, walker$$22, [preAst$$21.tryNode, preAst$$21]);
        v10799.tryNode = v27382
      }
      var v18093 = preAst$$21.finallyNode;
      if(v18093) {
        v18093 = walker$$22.options.goNextSibling
      }
      if(v18093) {
        var v10801 = preAst$$21;
        var v27383 = JAM.call(walker$$22.walk, walker$$22, [preAst$$21.finallyNode, preAst$$21]);
        v10801.finallyNode = v27383
      }
      return
    }
    function walkFinallyChildren(preAst$$22, parent$$23, walker$$23) {
      if(preAst$$22.body) {
        var v10803 = preAst$$22;
        var v27384 = JAM.call(walker$$23.walk, walker$$23, [preAst$$22.body, preAst$$22]);
        v10803.body = v27384
      }
      return
    }
    function walkCatchChildren(preAst$$23, parent$$24, walker$$24) {
      if(preAst$$23.param) {
        var v10805 = preAst$$23;
        var v27385 = JAM.call(walker$$24.walk, walker$$24, [preAst$$23.param, preAst$$23]);
        v10805.param = v27385
      }
      var v18097 = preAst$$23.body;
      if(v18097) {
        v18097 = walker$$24.options.goNextSibling
      }
      if(v18097) {
        var v10807 = preAst$$23;
        var v27386 = JAM.call(walker$$24.walk, walker$$24, [preAst$$23.body, preAst$$23]);
        v10807.body = v27386
      }
      return
    }
    function walkRecordChildren(preAst$$24, parent$$25, walker$$25) {
      var v10809 = preAst$$24;
      var v27387 = JAM.call(walker$$25.walk, walker$$25, [preAst$$24.name, preAst$$24]);
      v10809.name = v27387;
      var v18100 = walker$$25.options.goNextSibling;
      if(v18100) {
        v18100 = preAst$$24.members
      }
      if(v18100) {
        var v10810 = preAst$$24;
        var v27388 = JAM.call(walker$$25.walk, walker$$25, [preAst$$24.members, preAst$$24]);
        v10810.members = v27388
      }
      return
    }
    function walkNamedTypeChildren(preAst$$25, parent$$26, walker$$26) {
      walkRecordChildren(preAst$$25, parent$$26, walker$$26);
      return
    }
    function walkClassDeclChildren(preAst$$26, parent$$27, walker$$27) {
      walkRecordChildren(preAst$$26, parent$$27, walker$$27);
      var v18102 = walker$$27.options.goNextSibling;
      if(v18102) {
        v18102 = preAst$$26.extendsList
      }
      if(v18102) {
        var v10812 = preAst$$26;
        var v27389 = JAM.call(walker$$27.walk, walker$$27, [preAst$$26.extendsList, preAst$$26]);
        v10812.extendsList = v27389
      }
      var v18104 = walker$$27.options.goNextSibling;
      if(v18104) {
        v18104 = preAst$$26.implementsList
      }
      if(v18104) {
        var v10814 = preAst$$26;
        var v27390 = JAM.call(walker$$27.walk, walker$$27, [preAst$$26.implementsList, preAst$$26]);
        v10814.implementsList = v27390
      }
      return
    }
    function walkScriptChildren(preAst$$27, parent$$28, walker$$28) {
      if(preAst$$27.bod) {
        var v10816 = preAst$$27;
        var v27391 = JAM.call(walker$$28.walk, walker$$28, [preAst$$27.bod, preAst$$27]);
        v10816.bod = v27391
      }
      return
    }
    function walkTypeDeclChildren(preAst$$28, parent$$29, walker$$29) {
      walkRecordChildren(preAst$$28, parent$$29, walker$$29);
      var v18107 = walker$$29.options.goNextSibling;
      if(v18107) {
        v18107 = preAst$$28.extendsList
      }
      if(v18107) {
        var v10818 = preAst$$28;
        var v27392 = JAM.call(walker$$29.walk, walker$$29, [preAst$$28.extendsList, preAst$$28]);
        v10818.extendsList = v27392
      }
      var v18109 = walker$$29.options.goNextSibling;
      if(v18109) {
        v18109 = preAst$$28.implementsList
      }
      if(v18109) {
        var v10820 = preAst$$28;
        var v27393 = JAM.call(walker$$29.walk, walker$$29, [preAst$$28.implementsList, preAst$$28]);
        v10820.implementsList = v27393
      }
      return
    }
    function walkModuleDeclChildren(preAst$$29, parent$$30, walker$$30) {
      walkRecordChildren(preAst$$29, parent$$30, walker$$30);
      return
    }
    function walkImportDeclChildren(preAst$$30, parent$$31, walker$$31) {
      if(preAst$$30.id) {
        var v10822 = preAst$$30;
        var v27394 = JAM.call(walker$$31.walk, walker$$31, [preAst$$30.id, preAst$$30]);
        v10822.id = v27394
      }
      if(preAst$$30.alias) {
        var v10824 = preAst$$30;
        var v27395 = JAM.call(walker$$31.walk, walker$$31, [preAst$$30.alias, preAst$$30]);
        v10824.alias = v27395
      }
      return
    }
    function walkWithStatementChildren(preAst$$31, parent$$32, walker$$32) {
      if(preAst$$31.expr) {
        var v10826 = preAst$$31;
        var v27396 = JAM.call(walker$$32.walk, walker$$32, [preAst$$31.expr, preAst$$31]);
        v10826.expr = v27396
      }
      var v18114 = preAst$$31.body;
      if(v18114) {
        v18114 = walker$$32.options.goNextSibling
      }
      if(v18114) {
        var v10828 = preAst$$31;
        var v27397 = JAM.call(walker$$32.walk, walker$$32, [preAst$$31.body, preAst$$31]);
        v10828.body = v27397
      }
      return
    }
    function walkLabelChildren(preAst$$32, parent$$33, walker$$33) {
      return
    }
    function walkLabeledStatementChildren(preAst$$33, parent$$34, walker$$34) {
      var v10830 = preAst$$33;
      var v27398 = JAM.call(walker$$34.walk, walker$$34, [preAst$$33.labels, preAst$$33]);
      v10830.labels = v27398;
      if(walker$$34.options.goNextSibling) {
        var v10831 = preAst$$33;
        var v27399 = JAM.call(walker$$34.walk, walker$$34, [preAst$$33.stmt, preAst$$33]);
        v10831.stmt = v27399
      }
      return
    }
    ChildrenWalkers$$1.walkNone = walkNone;
    ChildrenWalkers$$1.walkListChildren = walkListChildren;
    ChildrenWalkers$$1.walkUnaryExpressionChildren = walkUnaryExpressionChildren;
    ChildrenWalkers$$1.walkBinaryExpressionChildren = walkBinaryExpressionChildren;
    ChildrenWalkers$$1.walkTypeReferenceChildren = walkTypeReferenceChildren;
    ChildrenWalkers$$1.walkCallExpressionChildren = walkCallExpressionChildren;
    ChildrenWalkers$$1.walkTrinaryExpressionChildren = walkTrinaryExpressionChildren;
    ChildrenWalkers$$1.walkFuncDeclChildren = walkFuncDeclChildren;
    ChildrenWalkers$$1.walkBoundDeclChildren = walkBoundDeclChildren;
    ChildrenWalkers$$1.walkReturnStatementChildren = walkReturnStatementChildren;
    ChildrenWalkers$$1.walkForStatementChildren = walkForStatementChildren;
    ChildrenWalkers$$1.walkForInStatementChildren = walkForInStatementChildren;
    ChildrenWalkers$$1.walkIfStatementChildren = walkIfStatementChildren;
    ChildrenWalkers$$1.walkWhileStatementChildren = walkWhileStatementChildren;
    ChildrenWalkers$$1.walkDoWhileStatementChildren = walkDoWhileStatementChildren;
    ChildrenWalkers$$1.walkBlockChildren = walkBlockChildren;
    ChildrenWalkers$$1.walkCaseStatementChildren = walkCaseStatementChildren;
    ChildrenWalkers$$1.walkSwitchStatementChildren = walkSwitchStatementChildren;
    ChildrenWalkers$$1.walkTryChildren = walkTryChildren;
    ChildrenWalkers$$1.walkTryCatchChildren = walkTryCatchChildren;
    ChildrenWalkers$$1.walkTryFinallyChildren = walkTryFinallyChildren;
    ChildrenWalkers$$1.walkFinallyChildren = walkFinallyChildren;
    ChildrenWalkers$$1.walkCatchChildren = walkCatchChildren;
    ChildrenWalkers$$1.walkRecordChildren = walkRecordChildren;
    ChildrenWalkers$$1.walkNamedTypeChildren = walkNamedTypeChildren;
    ChildrenWalkers$$1.walkClassDeclChildren = walkClassDeclChildren;
    ChildrenWalkers$$1.walkScriptChildren = walkScriptChildren;
    ChildrenWalkers$$1.walkTypeDeclChildren = walkTypeDeclChildren;
    ChildrenWalkers$$1.walkModuleDeclChildren = walkModuleDeclChildren;
    ChildrenWalkers$$1.walkImportDeclChildren = walkImportDeclChildren;
    ChildrenWalkers$$1.walkWithStatementChildren = walkWithStatementChildren;
    ChildrenWalkers$$1.walkLabelChildren = walkLabelChildren;
    ChildrenWalkers$$1.walkLabeledStatementChildren = walkLabeledStatementChildren;
    return
  }
  function v331() {
    function v330() {
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.None, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Empty, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.EmptyExpr, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.True, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.False, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.This, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Super, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.QString, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Regex, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Null, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.ArrayLit, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.ObjectLit, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Void, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Comma, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Pos, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Neg, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Delete, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Await, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.In, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Dot, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.From, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Is, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.InstOf, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Typeof, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.NumberLit, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Name, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.TypeRef, ChildrenWalkers.walkTypeReferenceChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Index, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Call, ChildrenWalkers.walkCallExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.New, ChildrenWalkers.walkCallExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Asg, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.AsgAdd, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.AsgSub, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.AsgDiv, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.AsgMul, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.AsgMod, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.AsgAnd, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.AsgXor, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.AsgOr, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.AsgLsh, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.AsgRsh, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.AsgRs2, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.ConditionalExpression, ChildrenWalkers.walkTrinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.LogOr, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.LogAnd, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Or, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Xor, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.And, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Eq, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Ne, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Eqv, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.NEqv, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Lt, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Le, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Gt, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Ge, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Add, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Sub, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Mul, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Div, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Mod, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Lsh, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Rsh, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Rs2, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Not, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.LogNot, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.IncPre, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.DecPre, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.IncPost, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.DecPost, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.TypeAssertion, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.FuncDecl, ChildrenWalkers.walkFuncDeclChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Member, ChildrenWalkers.walkBinaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.VarDecl, ChildrenWalkers.walkBoundDeclChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.ArgDecl, ChildrenWalkers.walkBoundDeclChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Return, ChildrenWalkers.walkReturnStatementChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Break, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Continue, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Throw, ChildrenWalkers.walkUnaryExpressionChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.For, ChildrenWalkers.walkForStatementChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.ForIn, ChildrenWalkers.walkForInStatementChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.If, ChildrenWalkers.walkIfStatementChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.While, ChildrenWalkers.walkWhileStatementChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.DoWhile, ChildrenWalkers.walkDoWhileStatementChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Block, ChildrenWalkers.walkBlockChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Case, ChildrenWalkers.walkCaseStatementChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Switch, ChildrenWalkers.walkSwitchStatementChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Try, ChildrenWalkers.walkTryChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.TryCatch, ChildrenWalkers.walkTryCatchChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.TryFinally, ChildrenWalkers.walkTryFinallyChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Finally, ChildrenWalkers.walkFinallyChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Catch, ChildrenWalkers.walkCatchChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.List, ChildrenWalkers.walkListChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Script, ChildrenWalkers.walkScriptChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.ClassDeclaration, ChildrenWalkers.walkClassDeclChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.InterfaceDeclaration, ChildrenWalkers.walkTypeDeclChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.ModuleDeclaration, ChildrenWalkers.walkModuleDeclChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.ImportDeclaration, ChildrenWalkers.walkImportDeclChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.With, ChildrenWalkers.walkWithStatementChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Label, ChildrenWalkers.walkLabelChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.LabeledStatement, ChildrenWalkers.walkLabeledStatementChildren);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.EBStart, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.GotoEB, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.EndCode, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Error, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Comment, ChildrenWalkers.walkNone);
      JAM.set(this.childrenWalkers, TypeScript$$5.NodeType.Debugger, ChildrenWalkers.walkNone);
      var e$$8;
      for(e$$8 in TypeScript$$5.NodeType._map) {
        var v22566 = this.childrenWalkers;
        introspect(JAM.policy.p1) {
          var v18227 = v22566[e$$8]
        }
        if(v18227 === undefined) {
          throw new Error("initWalkers function is not up to date with enum content!");
        }
      }
      return
    }
    function v329(pre$$3, post$$3, options$$4, state$$3) {
      if(!options$$4) {
        options$$4 = new AstWalkOptions
      }
      return JAM.new(AstWalker, [this.childrenWalkers, pre$$3, post$$3, options$$4, state$$3])
    }
    function v328(pre$$2, post$$2, options$$3, state$$2) {
      return JAM.call(this.getSlowWalker, this, [pre$$2, post$$2, options$$3, state$$2])
    }
    function v327(ast$$4, pre$$1, post$$1, options$$2, state$$1) {
      var v11051 = JAM.call(this.getWalker, this, [pre$$1, post$$1, options$$2, state$$1]);
      return JAM.call(v11051.walk, v11051, [ast$$4, null])
    }
    function AstWalkerFactory$$1() {
      this.childrenWalkers = [];
      this.initChildrenWalkers();
      return
    }
    AstWalkerFactory$$1.prototype.walk = v327;
    AstWalkerFactory$$1.prototype.getWalker = v328;
    AstWalkerFactory$$1.prototype.getSlowWalker = v329;
    AstWalkerFactory$$1.prototype.initChildrenWalkers = v330;
    return AstWalkerFactory$$1
  }
  function v326() {
    function v325(ast$$3, parent$$1) {
      var preAst = JAM.call(this.pre, this, [ast$$3, parent$$1, this]);
      if(preAst === undefined) {
        preAst = ast$$3
      }
      if(this.options.goChildren) {
        var svGoSib = this.options.goNextSibling;
        this.options.goNextSibling = true;
        var v11059 = this.childrenWalkers;
        JAM.call(JAM.get(v11059, ast$$3.nodeType, JAM.policy.p1), v11059, [ast$$3, parent$$1, this]);
        this.options.goNextSibling = svGoSib
      }else {
        this.options.goChildren = true
      }
      if(this.post) {
        var postAst = JAM.call(this.post, this, [preAst, parent$$1, this]);
        if(postAst === undefined) {
          postAst = preAst
        }
        return postAst
      }else {
        return preAst
      }
      return
    }
    function AstWalker$$1(childrenWalkers, pre, post, options$$1, state) {
      this.childrenWalkers = childrenWalkers;
      this.pre = pre;
      this.post = post;
      this.options = options$$1;
      this.state = state;
      return
    }
    AstWalker$$1.prototype.walk = v325;
    return AstWalker$$1
  }
  function v324() {
    function v323(stop) {
      if(typeof stop === "undefined") {
        stop = true
      }
      this.goChildren = !stop;
      this.goNextSibling = !stop;
      return
    }
    function AstWalkOptions$$1() {
      this.goChildren = true;
      this.goNextSibling = true;
      this.reverseSiblings = false;
      return
    }
    AstWalkOptions$$1.prototype.stopWalk = v323;
    return AstWalkOptions$$1
  }
  function getAstWalkerFactory() {
    if(!globalAstWalkerFactory) {
      globalAstWalkerFactory = new AstWalkerFactory
    }
    return globalAstWalkerFactory
  }
  var AstWalkOptions = v324();
  TypeScript$$5.AstWalkOptions = AstWalkOptions;
  var AstWalker = v326();
  var AstWalkerFactory = v331();
  TypeScript$$5.AstWalkerFactory = AstWalkerFactory;
  var globalAstWalkerFactory;
  TypeScript$$5.getAstWalkerFactory = getAstWalkerFactory;
  var ChildrenWalkers;
  var v18230 = ChildrenWalkers;
  if(!v18230) {
    v18230 = ChildrenWalkers = {}
  }
  v332(v18230);
  return
}
function v322(TypeScript$$4) {
  function v321(_super$$47) {
    function v320(emitter$$38, tokenId$$38, startLine$$38) {
      JAM.call(emitter$$38.emitParensAndCommentsInPlace, emitter$$38, [this, true]);
      JAM.call(emitter$$38.recordSourceMappingStart, emitter$$38, [this]);
      JAM.call(emitter$$38.writeLineToOutput, emitter$$38, ["debugger;"]);
      JAM.call(emitter$$38.recordSourceMappingEnd, emitter$$38, [this]);
      JAM.call(emitter$$38.emitParensAndCommentsInPlace, emitter$$38, [this, false]);
      return
    }
    function DebuggerStatement$$1() {
      JAM.call(_super$$47.call, _super$$47, [this, TypeScript$$4.NodeType.Debugger]);
      return
    }
    JAM.call(__extends, null, [DebuggerStatement$$1, _super$$47]);
    DebuggerStatement$$1.prototype.emit = v320;
    return DebuggerStatement$$1
  }
  function v319(_super$$46) {
    function getDocCommentTextOfSignatures(signatures) {
      var comments$$1 = [];
      var i$$24 = 0;
      var v11076 = i$$24 < signatures.length;
      for(;v11076;) {
        var v11073 = TypeScript$$4.Comment;
        introspect(JAM.policy.p1) {
          var v22568 = signatures[i$$24]
        }
        var signatureDocComment = JAM.call(v11073.getDocCommentText, v11073, [v22568.declAST.getDocComments()]);
        if(signatureDocComment != "") {
          JAM.call(comments$$1.push, comments$$1, [signatureDocComment])
        }
        i$$24 = i$$24 + 1;
        v11076 = i$$24 < signatures.length
      }
      return comments$$1.join("\n")
    }
    function getParameterDocCommentText(param$$4, fncDocComments) {
      var v18235 = fncDocComments.length == 0;
      if(!v18235) {
        v18235 = !fncDocComments[0].isBlockComment
      }
      if(v18235) {
        return""
      }
      var i$$23 = 0;
      var v11101 = i$$23 < fncDocComments.length;
      for(;v11101;) {
        introspect(JAM.policy.p1) {
          var v11078 = fncDocComments[i$$23]
        }
        var commentContents = v11078.content;
        var j = commentContents.indexOf("@param", 0);
        var v11100 = 0 <= j;
        for(;v11100;) {
          j = j + 6;
          if(!JAM.call(Comment$$2.isSpaceChar, Comment$$2, [commentContents, j])) {
            j = commentContents.indexOf("@param", j);
            v11100 = 0 <= j;
            continue
          }
          j = JAM.call(Comment$$2.consumeLeadingSpace, Comment$$2, [commentContents, j]);
          if(j == -1) {
            break
          }
          if(JAM.call(commentContents.charCodeAt, commentContents, [j]) == TypeScript$$4.LexCodeLC) {
            j = j + 1;
            var charCode$$3 = 0;
            var curlies = 1;
            var v11085 = j < commentContents.length;
            for(;v11085;) {
              charCode$$3 = JAM.call(commentContents.charCodeAt, commentContents, [j]);
              if(charCode$$3 == TypeScript$$4.LexCodeLC) {
                curlies = curlies + 1;
                j = j + 1;
                v11085 = j < commentContents.length;
                continue
              }
              if(charCode$$3 == TypeScript$$4.LexCodeRC) {
                curlies = curlies - 1;
                if(curlies == 0) {
                  break
                }else {
                  j = j + 1;
                  v11085 = j < commentContents.length;
                  continue
                }
              }
              if(charCode$$3 == TypeScript$$4.LexCodeAtSign) {
                break
              }
              j = j + 1;
              v11085 = j < commentContents.length
            }
            if(j == commentContents.length) {
              break
            }
            if(charCode$$3 == TypeScript$$4.LexCodeAtSign) {
              j = commentContents.indexOf("@param", j);
              v11100 = 0 <= j;
              continue
            }
            j = JAM.call(Comment$$2.consumeLeadingSpace, Comment$$2, [commentContents, j + 1]);
            if(j == -1) {
              break
            }
          }
          var v18249 = param$$4 != commentContents.substr(j, param$$4.length);
          if(!v18249) {
            v18249 = !JAM.call(Comment$$2.isSpaceChar, Comment$$2, [commentContents, j + param$$4.length])
          }
          if(v18249) {
            j = commentContents.indexOf("@param", j);
            v11100 = 0 <= j;
            continue
          }
          j = JAM.call(Comment$$2.consumeLeadingSpace, Comment$$2, [commentContents, j + param$$4.length]);
          if(j == -1) {
            return""
          }
          var endOfParam = commentContents.indexOf("@", j);
          var v18251;
          if(endOfParam < 0) {
            v18251 = commentContents.length
          }else {
            v18251 = endOfParam
          }
          var paramHelpString = JAM.call(commentContents.substring, commentContents, [j, v18251]);
          var paramSpacesToRemove = undefined;
          var paramLineIndex = JAM.call(commentContents.substring, commentContents, [0, j]).lastIndexOf("\n") + 1;
          if(paramLineIndex != 0) {
            var v18253 = paramLineIndex < j;
            if(v18253) {
              v18253 = commentContents.charAt(paramLineIndex + 1) == "\r"
            }
            if(v18253) {
              paramLineIndex = paramLineIndex + 1
            }
          }
          var startSpaceRemovalIndex = JAM.call(Comment$$2.consumeLeadingSpace, Comment$$2, [commentContents, paramLineIndex]);
          var v18254 = startSpaceRemovalIndex != j;
          if(v18254) {
            v18254 = commentContents.charAt(startSpaceRemovalIndex) == "*"
          }
          if(v18254) {
            paramSpacesToRemove = j - startSpaceRemovalIndex - 1
          }
          return JAM.call(Comment$$2.cleanJSDocComment, Comment$$2, [paramHelpString, paramSpacesToRemove])
        }
        i$$23 = i$$23 + 1;
        v11101 = i$$23 < fncDocComments.length
      }
      return""
    }
    function getDocCommentText(comments) {
      var docCommentText$$1 = [];
      var c$$2 = 0;
      var v11104 = c$$2 < comments.length;
      for(;v11104;) {
        introspect(JAM.policy.p1) {
          var v11102 = comments[c$$2]
        }
        var commentText = v11102.getDocCommentText();
        if(commentText != "") {
          JAM.call(docCommentText$$1.push, docCommentText$$1, [commentText])
        }
        c$$2 = c$$2 + 1;
        v11104 = c$$2 < comments.length
      }
      return docCommentText$$1.join("\n")
    }
    function cleanJSDocComment(content$$1, spacesToRemove) {
      var docCommentLines = [];
      content$$1 = content$$1.replace("/**", "");
      var v18258 = content$$1.length >= 2;
      if(v18258) {
        var v22580 = content$$1.charAt(content$$1.length - 1) == "/";
        if(v22580) {
          v22580 = content$$1.charAt(content$$1.length - 2) == "*"
        }
        v18258 = v22580
      }
      if(v18258) {
        content$$1 = JAM.call(content$$1.substring, content$$1, [0, content$$1.length - 2])
      }
      var lines = content$$1.split("\n");
      var inParamTag = false;
      var l = 0;
      var v11114 = l < lines.length;
      for(;v11114;) {
        introspect(JAM.policy.p1) {
          var line$$3 = lines[l]
        }
        var cleanLinePos = JAM.call(Comment$$2.cleanDocCommentLine, Comment$$2, [line$$3, true, spacesToRemove]);
        if(!cleanLinePos) {
          l = l + 1;
          v11114 = l < lines.length;
          continue
        }
        var docCommentText = "";
        var prevPos = cleanLinePos.minChar;
        var i$$22 = line$$3.indexOf("@", cleanLinePos.minChar);
        var v18262 = 0 <= i$$22;
        if(v18262) {
          v18262 = i$$22 < cleanLinePos.limChar
        }
        var v11111 = v18262;
        for(;v11111;) {
          var wasInParamtag = inParamTag;
          var v18263 = line$$3.indexOf("param", i$$22 + 1) == i$$22 + 1;
          if(v18263) {
            v18263 = JAM.call(Comment$$2.isSpaceChar, Comment$$2, [line$$3, i$$22 + 6])
          }
          if(v18263) {
            if(!wasInParamtag) {
              docCommentText = docCommentText + JAM.call(line$$3.substring, line$$3, [prevPos, i$$22])
            }
            prevPos = i$$22;
            inParamTag = true
          }else {
            if(wasInParamtag) {
              prevPos = i$$22;
              inParamTag = false
            }
          }
          i$$22 = line$$3.indexOf("@", i$$22 + 1);
          var v18267 = 0 <= i$$22;
          if(v18267) {
            v18267 = i$$22 < cleanLinePos.limChar
          }
          v11111 = v18267
        }
        if(!inParamTag) {
          docCommentText = docCommentText + JAM.call(line$$3.substring, line$$3, [prevPos, cleanLinePos.limChar])
        }
        var newCleanPos = JAM.call(Comment$$2.cleanDocCommentLine, Comment$$2, [docCommentText, false]);
        if(newCleanPos) {
          if(spacesToRemove == undefined) {
            spacesToRemove = cleanLinePos.jsDocSpacesRemoved
          }
          JAM.call(docCommentLines.push, docCommentLines, [docCommentText])
        }
        l = l + 1;
        v11114 = l < lines.length
      }
      return docCommentLines.join("\n")
    }
    function cleanDocCommentLine(line$$2, jsDocStyleComment, jsDocLineSpaceToRemove) {
      var nonSpaceIndex = JAM.call(Comment$$2.consumeLeadingSpace, Comment$$2, [line$$2, 0]);
      if(nonSpaceIndex != -1) {
        var jsDocSpacesRemoved = nonSpaceIndex;
        var v18271 = jsDocStyleComment;
        if(v18271) {
          v18271 = line$$2.charAt(nonSpaceIndex) == "*"
        }
        if(v18271) {
          var startIndex$$1 = nonSpaceIndex + 1;
          nonSpaceIndex = JAM.call(Comment$$2.consumeLeadingSpace, Comment$$2, [line$$2, startIndex$$1, jsDocLineSpaceToRemove]);
          if(nonSpaceIndex != -1) {
            jsDocSpacesRemoved = nonSpaceIndex - startIndex$$1
          }else {
            return null
          }
        }
        var v18272;
        if(line$$2.charAt(line$$2.length - 1) == "\r") {
          v18272 = line$$2.length - 1
        }else {
          v18272 = line$$2.length
        }
        return{minChar:nonSpaceIndex, limChar:v18272, jsDocSpacesRemoved:jsDocSpacesRemoved}
      }
      return null
    }
    function isSpaceChar(line$$1, index$$41) {
      var length$$13 = line$$1.length;
      if(index$$41 < length$$13) {
        var charCode$$2 = JAM.call(line$$1.charCodeAt, line$$1, [index$$41]);
        var v11119 = charCode$$2 == TypeScript$$4.LexCodeSpace;
        if(!v11119) {
          v11119 = charCode$$2 == TypeScript$$4.LexCodeTAB
        }
        return v11119
      }
      return index$$41 == length$$13
    }
    function consumeLeadingSpace(line, startIndex, maxSpacesToRemove) {
      var endIndex = line.length;
      if(maxSpacesToRemove != undefined) {
        endIndex = JAM.call(TypeScript$$4.min, TypeScript$$4, [startIndex + maxSpacesToRemove, endIndex])
      }
      var v11124 = startIndex < endIndex;
      for(;v11124;) {
        var charCode$$1 = JAM.call(line.charCodeAt, line, [startIndex]);
        var v18276 = charCode$$1 != TypeScript$$4.LexCodeSpace;
        if(v18276) {
          v18276 = charCode$$1 != TypeScript$$4.LexCodeTAB
        }
        if(v18276) {
          return startIndex
        }
        startIndex = startIndex + 1;
        v11124 = startIndex < endIndex
      }
      if(endIndex != line.length) {
        return endIndex
      }
      return-1
    }
    function v318() {
      if(this.docCommentText == null) {
        var v27400 = JAM.call(Comment$$2.cleanJSDocComment, Comment$$2, [this.content]);
        this.docCommentText = v27400
      }
      return this.docCommentText
    }
    function v317() {
      if(this.isBlockComment) {
        return this.content.charAt(2) == "*"
      }
      return false
    }
    function v316() {
      if(this.text == null) {
        if(this.isBlockComment) {
          var v27401 = this.content.split("\n");
          this.text = v27401;
          var i$$21 = 0;
          var v11133 = i$$21 < this.text.length;
          for(;v11133;) {
            var v11131 = this.text;
            var v11132 = i$$21;
            var v22593 = this.text;
            introspect(JAM.policy.p1) {
              var v18282 = v22593[i$$21]
            }
            var v27402 = v18282.replace(/^\s+|\s+$/g, "");
            v11131[v11132] = v27402;
            i$$21 = i$$21 + 1;
            v11133 = i$$21 < this.text.length
          }
        }else {
          this.text = [this.content.replace(/^\s+|\s+$/g, "")]
        }
      }
      return this.text
    }
    function Comment$$2(content, isBlockComment, endsLine) {
      JAM.call(_super$$46.call, _super$$46, [this, TypeScript$$4.NodeType.Comment]);
      this.content = content;
      this.isBlockComment = isBlockComment;
      this.endsLine = endsLine;
      this.text = null;
      this.docCommentText = null;
      return
    }
    JAM.call(__extends, null, [Comment$$2, _super$$46]);
    Comment$$2.prototype.getText = v316;
    Comment$$2.prototype.isDocComment = v317;
    Comment$$2.prototype.getDocCommentText = v318;
    Comment$$2.consumeLeadingSpace = consumeLeadingSpace;
    Comment$$2.isSpaceChar = isSpaceChar;
    Comment$$2.cleanDocCommentLine = cleanDocCommentLine;
    Comment$$2.cleanJSDocComment = cleanJSDocComment;
    Comment$$2.getDocCommentText = getDocCommentText;
    Comment$$2.getParameterDocCommentText = getParameterDocCommentText;
    Comment$$2.getDocCommentTextOfSignatures = getDocCommentTextOfSignatures;
    return Comment$$2
  }
  function v315(_super$$45) {
    function v314(typeFlow$$35) {
      var v27403 = JAM.call(typeFlow$$35.typeCheck, typeFlow$$35, [this.body]);
      this.body = v27403;
      return this
    }
    function v313(context$$26) {
      if(this.body) {
        JAM.call(context$$26.walk, context$$26, [this.body, this])
      }
      context$$26.walker.options.goChildren = false;
      context$$26.noContinuation = false;
      return
    }
    function v312(emitter$$37, tokenId$$37, startLine$$37) {
      JAM.call(emitter$$37.emitParensAndCommentsInPlace, emitter$$37, [this, true]);
      JAM.call(emitter$$37.recordSourceMappingStart, emitter$$37, [this]);
      JAM.call(emitter$$37.writeToOutput, emitter$$37, ["finally"]);
      JAM.call(emitter$$37.emitJavascript, emitter$$37, [this.body, TypeScript$$4.TokenID.Finally, false]);
      JAM.call(emitter$$37.recordSourceMappingEnd, emitter$$37, [this]);
      JAM.call(emitter$$37.emitParensAndCommentsInPlace, emitter$$37, [this, false]);
      return
    }
    function Finally$$1(body$$2) {
      JAM.call(_super$$45.call, _super$$45, [this, TypeScript$$4.NodeType.Finally]);
      this.body = body$$2;
      return
    }
    JAM.call(__extends, null, [Finally$$1, _super$$45]);
    Finally$$1.prototype.emit = v312;
    Finally$$1.prototype.addToControlFlow = v313;
    Finally$$1.prototype.typeCheck = v314;
    return Finally$$1
  }
  function v311(_super$$44) {
    function v310(typeFlow$$34) {
      var prevScope = typeFlow$$34.scope;
      typeFlow$$34.scope = this.containedScope;
      var v27404 = JAM.call(typeFlow$$34.typeCheck, typeFlow$$34, [this.param]);
      this.param = v27404;
      var exceptVar = new TypeScript$$4.ValueLocation;
      var varSym = JAM.new(TypeScript$$4.VariableSymbol, [this.param.id.text, this.param.minChar, typeFlow$$34.checker.locationInfo.unitIndex, exceptVar]);
      exceptVar.symbol = varSym;
      var v11157 = exceptVar;
      var v27405 = new TypeScript$$4.TypeLink;
      v11157.typeLink = v27405;
      exceptVar.typeLink.type = typeFlow$$34.anyType;
      var thisFnc = typeFlow$$34.thisFnc;
      var v18293 = thisFnc;
      if(v18293) {
        v18293 = thisFnc.type
      }
      if(v18293) {
        exceptVar.symbol.container = thisFnc.type.symbol
      }else {
        exceptVar.symbol.container = null
      }
      this.param.sym = exceptVar.symbol;
      var v11163 = typeFlow$$34.scope;
      JAM.call(v11163.enter, v11163, [exceptVar.symbol.container, this.param, exceptVar.symbol, typeFlow$$34.checker.errorReporter, false, false, false]);
      var v27406 = JAM.call(typeFlow$$34.typeCheck, typeFlow$$34, [this.body]);
      this.body = v27406;
      if(typeFlow$$34.checker.inProvisionalTypecheckMode()) {
        var table = typeFlow$$34.scope.getTable();
        JAM.set(table.secondaryTable.table, exceptVar.symbol.name, undefined)
      }
      this.type = typeFlow$$34.voidType;
      typeFlow$$34.scope = prevScope;
      return this
    }
    function v309(context$$25) {
      if(this.param) {
        JAM.call(context$$25.addContent, context$$25, [this.param]);
        var bodBlock = new TypeScript$$4.BasicBlock;
        var v11175 = context$$25.current;
        JAM.call(v11175.addSuccessor, v11175, [bodBlock]);
        context$$25.current = bodBlock
      }
      if(this.body) {
        JAM.call(context$$25.walk, context$$25, [this.body, this])
      }
      context$$25.noContinuation = false;
      context$$25.walker.options.goChildren = false;
      return
    }
    function v308(emitter$$36, tokenId$$36, startLine$$36) {
      JAM.call(emitter$$36.emitParensAndCommentsInPlace, emitter$$36, [this, true]);
      JAM.call(emitter$$36.recordSourceMappingStart, emitter$$36, [this]);
      JAM.call(emitter$$36.writeToOutput, emitter$$36, [" "]);
      JAM.call(emitter$$36.recordSourceMappingStart, emitter$$36, [this.statement]);
      JAM.call(emitter$$36.writeToOutput, emitter$$36, ["catch ("]);
      JAM.call(emitter$$36.emitJavascript, emitter$$36, [this.param, TypeScript$$4.TokenID.OpenParen, false]);
      JAM.call(emitter$$36.writeToOutput, emitter$$36, [")"]);
      JAM.call(emitter$$36.recordSourceMappingEnd, emitter$$36, [this.statement]);
      JAM.call(emitter$$36.emitJavascript, emitter$$36, [this.body, TypeScript$$4.TokenID.Catch, false]);
      JAM.call(emitter$$36.recordSourceMappingEnd, emitter$$36, [this]);
      JAM.call(emitter$$36.emitParensAndCommentsInPlace, emitter$$36, [this, false]);
      return
    }
    function Catch$$1(param$$3, body$$1) {
      JAM.call(_super$$44.call, _super$$44, [this, TypeScript$$4.NodeType.Catch]);
      this.param = param$$3;
      this.body = body$$1;
      var v27407 = new ASTSpan;
      this.statement = v27407;
      this.containedScope = null;
      if(this.param) {
        var v11187 = this.param;
        v11187.varFlags = v11187.varFlags | TypeScript$$4.VarFlags.AutoInit
      }
      return
    }
    JAM.call(__extends, null, [Catch$$1, _super$$44]);
    Catch$$1.prototype.emit = v308;
    Catch$$1.prototype.addToControlFlow = v309;
    Catch$$1.prototype.typeCheck = v310;
    return Catch$$1
  }
  function v307(_super$$43) {
    function v306(context$$24) {
      if(this.body) {
        JAM.call(context$$24.walk, context$$24, [this.body, this])
      }
      context$$24.walker.options.goChildren = false;
      context$$24.noContinuation = false;
      return
    }
    function v305(typeFlow$$33) {
      var v27408 = JAM.call(typeFlow$$33.typeCheck, typeFlow$$33, [this.body]);
      this.body = v27408;
      return this
    }
    function v304(emitter$$35, tokenId$$35, startLine$$35) {
      JAM.call(emitter$$35.emitParensAndCommentsInPlace, emitter$$35, [this, true]);
      JAM.call(emitter$$35.recordSourceMappingStart, emitter$$35, [this]);
      JAM.call(emitter$$35.writeToOutput, emitter$$35, ["try "]);
      JAM.call(emitter$$35.emitJavascript, emitter$$35, [this.body, TypeScript$$4.TokenID.Try, false]);
      JAM.call(emitter$$35.recordSourceMappingEnd, emitter$$35, [this]);
      JAM.call(emitter$$35.emitParensAndCommentsInPlace, emitter$$35, [this, false]);
      return
    }
    function Try$$1(body) {
      JAM.call(_super$$43.call, _super$$43, [this, TypeScript$$4.NodeType.Try]);
      this.body = body;
      return
    }
    JAM.call(__extends, null, [Try$$1, _super$$43]);
    Try$$1.prototype.emit = v304;
    Try$$1.prototype.typeCheck = v305;
    Try$$1.prototype.addToControlFlow = v306;
    return Try$$1
  }
  function v303(_super$$42) {
    function v302(typeFlow$$32) {
      var v27409 = JAM.call(typeFlow$$32.typeCheck, typeFlow$$32, [this.tryNode]);
      this.tryNode = v27409;
      var v27410 = JAM.call(typeFlow$$32.typeCheck, typeFlow$$32, [this.catchNode]);
      this.catchNode = v27410;
      this.type = typeFlow$$32.voidType;
      return this
    }
    function v301(context$$23) {
      var beforeTry = context$$23.current;
      var tryBlock = new TypeScript$$4.BasicBlock;
      JAM.call(beforeTry.addSuccessor, beforeTry, [tryBlock]);
      context$$23.current = tryBlock;
      var afterTryCatch = new TypeScript$$4.BasicBlock;
      JAM.call(context$$23.pushStatement, context$$23, [this, null, afterTryCatch]);
      JAM.call(context$$23.walk, context$$23, [this.tryNode, this]);
      if(!context$$23.noContinuation) {
        if(context$$23.current) {
          var v11207 = context$$23.current;
          JAM.call(v11207.addSuccessor, v11207, [afterTryCatch])
        }
      }
      var v11210 = context$$23;
      var v27411 = new TypeScript$$4.BasicBlock;
      v11210.current = v27411;
      JAM.call(beforeTry.addSuccessor, beforeTry, [context$$23.current]);
      JAM.call(context$$23.walk, context$$23, [this.catchNode, this]);
      context$$23.popStatement();
      if(!context$$23.noContinuation) {
        if(context$$23.current) {
          var v11213 = context$$23.current;
          JAM.call(v11213.addSuccessor, v11213, [afterTryCatch])
        }
      }
      context$$23.current = afterTryCatch;
      context$$23.walker.options.goChildren = false;
      return
    }
    function v300(emitter$$34, tokenId$$34, startLine$$34) {
      JAM.call(emitter$$34.emitParensAndCommentsInPlace, emitter$$34, [this, true]);
      JAM.call(emitter$$34.recordSourceMappingStart, emitter$$34, [this]);
      JAM.call(emitter$$34.emitJavascript, emitter$$34, [this.tryNode, TypeScript$$4.TokenID.Try, false]);
      JAM.call(emitter$$34.emitJavascript, emitter$$34, [this.catchNode, TypeScript$$4.TokenID.Catch, false]);
      JAM.call(emitter$$34.recordSourceMappingEnd, emitter$$34, [this]);
      JAM.call(emitter$$34.emitParensAndCommentsInPlace, emitter$$34, [this, false]);
      return
    }
    function v299() {
      return true
    }
    function TryCatch$$1(tryNode$$1, catchNode) {
      JAM.call(_super$$42.call, _super$$42, [this, TypeScript$$4.NodeType.TryCatch]);
      this.tryNode = tryNode$$1;
      this.catchNode = catchNode;
      return
    }
    JAM.call(__extends, null, [TryCatch$$1, _super$$42]);
    TryCatch$$1.prototype.isCompoundStatement = v299;
    TryCatch$$1.prototype.emit = v300;
    TryCatch$$1.prototype.addToControlFlow = v301;
    TryCatch$$1.prototype.typeCheck = v302;
    return TryCatch$$1
  }
  function v298(_super$$41) {
    function v297(context$$22) {
      var afterFinally = new TypeScript$$4.BasicBlock;
      JAM.call(context$$22.walk, context$$22, [this.tryNode, this]);
      var finBlock = new TypeScript$$4.BasicBlock;
      if(context$$22.current) {
        var v11229 = context$$22.current;
        JAM.call(v11229.addSuccessor, v11229, [finBlock])
      }
      context$$22.current = finBlock;
      JAM.call(context$$22.pushStatement, context$$22, [this, null, afterFinally]);
      JAM.call(context$$22.walk, context$$22, [this.finallyNode, this]);
      var v18314 = !context$$22.noContinuation;
      if(v18314) {
        v18314 = context$$22.current
      }
      if(v18314) {
        var v11232 = context$$22.current;
        JAM.call(v11232.addSuccessor, v11232, [afterFinally])
      }
      if(afterFinally.predecessors.length > 0) {
        context$$22.current = afterFinally
      }else {
        context$$22.noContinuation = true
      }
      context$$22.popStatement();
      context$$22.walker.options.goChildren = false;
      return
    }
    function v296(typeFlow$$31) {
      var v27412 = JAM.call(typeFlow$$31.typeCheck, typeFlow$$31, [this.tryNode]);
      this.tryNode = v27412;
      var v27413 = JAM.call(typeFlow$$31.typeCheck, typeFlow$$31, [this.finallyNode]);
      this.finallyNode = v27413;
      this.type = typeFlow$$31.voidType;
      return this
    }
    function v295(emitter$$33, tokenId$$33, startLine$$33) {
      JAM.call(emitter$$33.recordSourceMappingStart, emitter$$33, [this]);
      JAM.call(emitter$$33.emitJavascript, emitter$$33, [this.tryNode, TypeScript$$4.TokenID.Try, false]);
      JAM.call(emitter$$33.emitJavascript, emitter$$33, [this.finallyNode, TypeScript$$4.TokenID.Finally, false]);
      JAM.call(emitter$$33.recordSourceMappingEnd, emitter$$33, [this]);
      return
    }
    function v294() {
      return true
    }
    function TryFinally$$1(tryNode, finallyNode) {
      JAM.call(_super$$41.call, _super$$41, [this, TypeScript$$4.NodeType.TryFinally]);
      this.tryNode = tryNode;
      this.finallyNode = finallyNode;
      return
    }
    JAM.call(__extends, null, [TryFinally$$1, _super$$41]);
    TryFinally$$1.prototype.isCompoundStatement = v294;
    TryFinally$$1.prototype.emit = v295;
    TryFinally$$1.prototype.typeCheck = v296;
    TryFinally$$1.prototype.addToControlFlow = v297;
    return TryFinally$$1
  }
  function v293(_super$$40) {
    function v292(typeFlow$$30) {
      var prevInTCTR = typeFlow$$30.inTypeRefTypeCheck;
      typeFlow$$30.inTypeRefTypeCheck = true;
      var typeLink = JAM.call(TypeScript$$4.getTypeLink, TypeScript$$4, [this, typeFlow$$30.checker, true]);
      var v11248 = typeFlow$$30.checker;
      JAM.call(v11248.resolveTypeLink, v11248, [typeFlow$$30.scope, typeLink, false]);
      if(this.term) {
        JAM.call(typeFlow$$30.typeCheck, typeFlow$$30, [this.term])
      }
      JAM.call(typeFlow$$30.checkForVoidConstructor, typeFlow$$30, [typeLink.type, this]);
      this.type = typeLink.type;
      if(this.term) {
        this.term.type = this.type
      }
      typeFlow$$30.inTypeRefTypeCheck = prevInTCTR;
      return this
    }
    function v291(emitter$$32, tokenId$$32, startLine$$32) {
      throw new Error("should not emit a type ref");
    }
    function TypeReference$$1(term, arrayCount) {
      JAM.call(_super$$40.call, _super$$40, [this, TypeScript$$4.NodeType.TypeRef]);
      this.term = term;
      this.arrayCount = arrayCount;
      return
    }
    JAM.call(__extends, null, [TypeReference$$1, _super$$40]);
    TypeReference$$1.prototype.emit = v291;
    TypeReference$$1.prototype.typeCheck = v292;
    return TypeReference$$1
  }
  function v290(_super$$39) {
    function v289(context$$21) {
      var execBlock$$1 = new TypeScript$$4.BasicBlock;
      var v11259 = context$$21.currentSwitch;
      var v11260 = context$$21.currentSwitch.length - 1;
      introspect(JAM.policy.p1) {
        var sw$$2 = v11259[v11260]
      }
      if(this.expr) {
        var exprBlock = new TypeScript$$4.BasicBlock;
        context$$21.current = exprBlock;
        JAM.call(sw$$2.addSuccessor, sw$$2, [exprBlock]);
        JAM.call(context$$21.addContent, context$$21, [this.expr]);
        JAM.call(exprBlock.addSuccessor, exprBlock, [execBlock$$1])
      }else {
        JAM.call(sw$$2.addSuccessor, sw$$2, [execBlock$$1])
      }
      context$$21.current = execBlock$$1;
      if(this.body) {
        JAM.call(context$$21.walk, context$$21, [this.body, this])
      }
      context$$21.noContinuation = false;
      context$$21.walker.options.goChildren = false;
      return
    }
    function v288(typeFlow$$29) {
      var v27414 = JAM.call(typeFlow$$29.typeCheck, typeFlow$$29, [this.expr]);
      this.expr = v27414;
      JAM.call(typeFlow$$29.typeCheck, typeFlow$$29, [this.body]);
      this.type = typeFlow$$29.voidType;
      return this
    }
    function v287(emitter$$31, tokenId$$31, startLine$$31) {
      JAM.call(emitter$$31.emitParensAndCommentsInPlace, emitter$$31, [this, true]);
      JAM.call(emitter$$31.recordSourceMappingStart, emitter$$31, [this]);
      if(this.expr) {
        JAM.call(emitter$$31.writeToOutput, emitter$$31, ["case "]);
        JAM.call(emitter$$31.emitJavascript, emitter$$31, [this.expr, TypeScript$$4.TokenID.Identifier, false])
      }else {
        JAM.call(emitter$$31.writeToOutput, emitter$$31, ["default"])
      }
      JAM.call(emitter$$31.writeToOutput, emitter$$31, [":"]);
      var v18324 = this.body.members.length == 1;
      if(v18324) {
        v18324 = this.body.members[0].nodeType == TypeScript$$4.NodeType.Block
      }
      if(v18324) {
        JAM.call(emitter$$31.emitJavascriptStatements, emitter$$31, [this.body, false])
      }else {
        JAM.call(emitter$$31.writeLineToOutput, emitter$$31, [""]);
        emitter$$31.indenter.increaseIndent();
        JAM.call(emitter$$31.emitBareJavascriptStatements, emitter$$31, [this.body]);
        emitter$$31.indenter.decreaseIndent()
      }
      JAM.call(emitter$$31.recordSourceMappingEnd, emitter$$31, [this]);
      JAM.call(emitter$$31.emitParensAndCommentsInPlace, emitter$$31, [this, false]);
      return
    }
    function CaseStatement$$1() {
      JAM.call(_super$$39.call, _super$$39, [this, TypeScript$$4.NodeType.Case]);
      this.expr = null;
      return
    }
    JAM.call(__extends, null, [CaseStatement$$1, _super$$39]);
    CaseStatement$$1.prototype.emit = v287;
    CaseStatement$$1.prototype.typeCheck = v288;
    CaseStatement$$1.prototype.addToControlFlow = v289;
    return CaseStatement$$1
  }
  function v286(_super$$38) {
    function v285(context$$20) {
      var condBlock$$2 = context$$20.current;
      JAM.call(context$$20.addContent, context$$20, [this.val]);
      var execBlock = new TypeScript$$4.BasicBlock;
      var afterSwitch = new TypeScript$$4.BasicBlock;
      JAM.call(condBlock$$2.addSuccessor, condBlock$$2, [execBlock]);
      JAM.call(context$$20.pushSwitch, context$$20, [execBlock]);
      context$$20.current = execBlock;
      JAM.call(context$$20.pushStatement, context$$20, [this, execBlock, afterSwitch]);
      JAM.call(context$$20.walk, context$$20, [this.caseList, this]);
      context$$20.popSwitch();
      var targetInfo$$4 = context$$20.popStatement();
      var hasCondContinuation = this.defaultCase == null;
      if(this.defaultCase == null) {
        JAM.call(condBlock$$2.addSuccessor, condBlock$$2, [afterSwitch])
      }
      if(afterSwitch.predecessors.length > 0) {
        context$$20.noContinuation = false;
        context$$20.current = afterSwitch
      }else {
        context$$20.noContinuation = true
      }
      context$$20.walker.options.goChildren = false;
      return
    }
    function v284(typeFlow$$28) {
      var len$$5 = this.caseList.members.length;
      var v27415 = JAM.call(typeFlow$$28.typeCheck, typeFlow$$28, [this.val]);
      this.val = v27415;
      var i$$20 = 0;
      var v11293 = i$$20 < len$$5;
      for(;v11293;) {
        var v11291 = this.caseList.members;
        var v11292 = i$$20;
        var v22606 = this.caseList.members;
        introspect(JAM.policy.p1) {
          var v18331 = v22606[i$$20]
        }
        var v27416 = JAM.call(typeFlow$$28.typeCheck, typeFlow$$28, [v18331]);
        v11291[v11292] = v27416;
        i$$20 = i$$20 + 1;
        v11293 = i$$20 < len$$5
      }
      var v27417 = JAM.call(typeFlow$$28.typeCheck, typeFlow$$28, [this.defaultCase]);
      this.defaultCase = v27417;
      this.type = typeFlow$$28.voidType;
      return this
    }
    function v283(emitter$$30, tokenId$$30, startLine$$30) {
      JAM.call(emitter$$30.emitParensAndCommentsInPlace, emitter$$30, [this, true]);
      JAM.call(emitter$$30.recordSourceMappingStart, emitter$$30, [this]);
      var temp$$7 = JAM.call(emitter$$30.setInObjectLiteral, emitter$$30, [false]);
      JAM.call(emitter$$30.recordSourceMappingStart, emitter$$30, [this.statement]);
      JAM.call(emitter$$30.writeToOutput, emitter$$30, ["switch("]);
      JAM.call(emitter$$30.emitJavascript, emitter$$30, [this.val, TypeScript$$4.TokenID.Identifier, false]);
      JAM.call(emitter$$30.writeToOutput, emitter$$30, [")"]);
      JAM.call(emitter$$30.recordSourceMappingEnd, emitter$$30, [this.statement]);
      JAM.call(emitter$$30.writeLineToOutput, emitter$$30, [" {"]);
      emitter$$30.indenter.increaseIndent();
      var casesLen = this.caseList.members.length;
      var i$$19 = 0;
      var v11303 = i$$19 < casesLen;
      for(;v11303;) {
        var v11301 = this.caseList.members;
        introspect(JAM.policy.p1) {
          var caseExpr = v11301[i$$19]
        }
        JAM.call(emitter$$30.emitJavascript, emitter$$30, [caseExpr, TypeScript$$4.TokenID.Case, true]);
        i$$19 = i$$19 + 1;
        v11303 = i$$19 < casesLen
      }
      emitter$$30.indenter.decreaseIndent();
      emitter$$30.emitIndent();
      JAM.call(emitter$$30.writeToOutput, emitter$$30, ["}"]);
      JAM.call(emitter$$30.setInObjectLiteral, emitter$$30, [temp$$7]);
      JAM.call(emitter$$30.recordSourceMappingEnd, emitter$$30, [this]);
      JAM.call(emitter$$30.emitParensAndCommentsInPlace, emitter$$30, [this, false]);
      return
    }
    function v282() {
      return true
    }
    function SwitchStatement$$1(val$$4) {
      JAM.call(_super$$38.call, _super$$38, [this, TypeScript$$4.NodeType.Switch]);
      this.val = val$$4;
      this.defaultCase = null;
      var v27418 = new ASTSpan;
      this.statement = v27418;
      return
    }
    JAM.call(__extends, null, [SwitchStatement$$1, _super$$38]);
    SwitchStatement$$1.prototype.isCompoundStatement = v282;
    SwitchStatement$$1.prototype.emit = v283;
    SwitchStatement$$1.prototype.typeCheck = v284;
    SwitchStatement$$1.prototype.addToControlFlow = v285;
    return SwitchStatement$$1
  }
  function v281(_super$$37) {
    function v280(typeFlow$$27) {
      return JAM.call(typeFlow$$27.typeCheckWith, typeFlow$$27, [this])
    }
    function v279(emitter$$29, tokenId$$29, startLine$$29) {
      JAM.call(emitter$$29.emitParensAndCommentsInPlace, emitter$$29, [this, true]);
      JAM.call(emitter$$29.recordSourceMappingStart, emitter$$29, [this]);
      JAM.call(emitter$$29.writeToOutput, emitter$$29, ["with ("]);
      if(this.expr) {
        JAM.call(emitter$$29.emitJavascript, emitter$$29, [this.expr, TypeScript$$4.TokenID.With, false])
      }
      JAM.call(emitter$$29.writeToOutput, emitter$$29, [")"]);
      JAM.call(emitter$$29.emitJavascriptStatements, emitter$$29, [this.body, true]);
      JAM.call(emitter$$29.recordSourceMappingEnd, emitter$$29, [this]);
      JAM.call(emitter$$29.emitParensAndCommentsInPlace, emitter$$29, [this, false]);
      return
    }
    function v278() {
      return true
    }
    function WithStatement$$1(expr$$3) {
      JAM.call(_super$$37.call, _super$$37, [this, TypeScript$$4.NodeType.With]);
      this.expr = expr$$3;
      this.withSym = null;
      return
    }
    JAM.call(__extends, null, [WithStatement$$1, _super$$37]);
    WithStatement$$1.prototype.isCompoundStatement = v278;
    WithStatement$$1.prototype.emit = v279;
    WithStatement$$1.prototype.typeCheck = v280;
    return WithStatement$$1
  }
  function v277(_super$$36) {
    function v276(context$$19) {
      if(this.init) {
        JAM.call(context$$19.addContent, context$$19, [this.init])
      }
      var loopHeader$$3 = context$$19.current;
      var loopStart$$3 = new TypeScript$$4.BasicBlock;
      var afterLoop$$3 = new TypeScript$$4.BasicBlock;
      JAM.call(loopHeader$$3.addSuccessor, loopHeader$$3, [loopStart$$3]);
      context$$19.current = loopStart$$3;
      var condBlock$$1 = null;
      var continueTarget = loopStart$$3;
      var incrBB = null;
      if(this.incr) {
        incrBB = new TypeScript$$4.BasicBlock;
        continueTarget = incrBB
      }
      if(this.cond) {
        condBlock$$1 = context$$19.current;
        JAM.call(context$$19.addContent, context$$19, [this.cond]);
        var v11325 = context$$19;
        var v27419 = new TypeScript$$4.BasicBlock;
        v11325.current = v27419;
        JAM.call(condBlock$$1.addSuccessor, condBlock$$1, [context$$19.current])
      }
      var targetInfo$$3 = null;
      if(this.body) {
        JAM.call(context$$19.pushStatement, context$$19, [this, continueTarget, afterLoop$$3]);
        JAM.call(context$$19.walk, context$$19, [this.body, this]);
        targetInfo$$3 = context$$19.popStatement()
      }
      if(this.incr) {
        if(context$$19.noContinuation) {
          if(incrBB.predecessors.length == 0) {
            JAM.call(context$$19.addUnreachable, context$$19, [this.incr])
          }
        }else {
          var v11332 = context$$19.current;
          JAM.call(v11332.addSuccessor, v11332, [incrBB]);
          context$$19.current = incrBB;
          JAM.call(context$$19.addContent, context$$19, [this.incr])
        }
      }
      var loopEnd$$3 = context$$19.current;
      if(!context$$19.noContinuation) {
        JAM.call(loopEnd$$3.addSuccessor, loopEnd$$3, [loopStart$$3])
      }
      if(condBlock$$1) {
        JAM.call(condBlock$$1.addSuccessor, condBlock$$1, [afterLoop$$3]);
        context$$19.noContinuation = false
      }
      if(afterLoop$$3.predecessors.length > 0) {
        context$$19.noContinuation = false;
        context$$19.current = afterLoop$$3
      }
      context$$19.walker.options.goChildren = false;
      return
    }
    function v275(typeFlow$$26) {
      return JAM.call(typeFlow$$26.typeCheckFor, typeFlow$$26, [this])
    }
    function v274(emitter$$28, tokenId$$28, startLine$$28) {
      JAM.call(emitter$$28.emitParensAndCommentsInPlace, emitter$$28, [this, true]);
      JAM.call(emitter$$28.recordSourceMappingStart, emitter$$28, [this]);
      var temp$$6 = JAM.call(emitter$$28.setInObjectLiteral, emitter$$28, [false]);
      JAM.call(emitter$$28.writeToOutput, emitter$$28, ["for("]);
      if(this.init) {
        if(this.init.nodeType != TypeScript$$4.NodeType.List) {
          JAM.call(emitter$$28.emitJavascript, emitter$$28, [this.init, TypeScript$$4.TokenID.For, false])
        }else {
          JAM.call(emitter$$28.setInVarBlock, emitter$$28, [this.init.members.length]);
          JAM.call(emitter$$28.emitJavascriptList, emitter$$28, [this.init, null, TypeScript$$4.TokenID.For, false, false, false])
        }
      }
      JAM.call(emitter$$28.writeToOutput, emitter$$28, ["; "]);
      JAM.call(emitter$$28.emitJavascript, emitter$$28, [this.cond, TypeScript$$4.TokenID.For, false]);
      JAM.call(emitter$$28.writeToOutput, emitter$$28, ["; "]);
      JAM.call(emitter$$28.emitJavascript, emitter$$28, [this.incr, TypeScript$$4.TokenID.For, false]);
      JAM.call(emitter$$28.writeToOutput, emitter$$28, [")"]);
      JAM.call(emitter$$28.emitJavascriptStatements, emitter$$28, [this.body, true]);
      JAM.call(emitter$$28.setInObjectLiteral, emitter$$28, [temp$$6]);
      JAM.call(emitter$$28.recordSourceMappingEnd, emitter$$28, [this]);
      JAM.call(emitter$$28.emitParensAndCommentsInPlace, emitter$$28, [this, false]);
      return
    }
    function v273() {
      return true
    }
    function ForStatement$$1(init) {
      JAM.call(_super$$36.call, _super$$36, [this, TypeScript$$4.NodeType.For]);
      this.init = init;
      return
    }
    JAM.call(__extends, null, [ForStatement$$1, _super$$36]);
    ForStatement$$1.prototype.isLoop = v273;
    ForStatement$$1.prototype.emit = v274;
    ForStatement$$1.prototype.typeCheck = v275;
    ForStatement$$1.prototype.addToControlFlow = v276;
    return ForStatement$$1
  }
  function v272(_super$$35) {
    function v271(context$$18) {
      if(this.lval) {
        JAM.call(context$$18.addContent, context$$18, [this.lval])
      }
      if(this.obj) {
        JAM.call(context$$18.addContent, context$$18, [this.obj])
      }
      var loopHeader$$2 = context$$18.current;
      var loopStart$$2 = new TypeScript$$4.BasicBlock;
      var afterLoop$$2 = new TypeScript$$4.BasicBlock;
      JAM.call(loopHeader$$2.addSuccessor, loopHeader$$2, [loopStart$$2]);
      context$$18.current = loopStart$$2;
      if(this.body) {
        JAM.call(context$$18.pushStatement, context$$18, [this, loopStart$$2, afterLoop$$2]);
        JAM.call(context$$18.walk, context$$18, [this.body, this]);
        context$$18.popStatement()
      }
      if(!context$$18.noContinuation) {
        var loopEnd$$2 = context$$18.current;
        JAM.call(loopEnd$$2.addSuccessor, loopEnd$$2, [loopStart$$2])
      }
      context$$18.current = afterLoop$$2;
      context$$18.noContinuation = false;
      JAM.call(loopHeader$$2.addSuccessor, loopHeader$$2, [afterLoop$$2]);
      context$$18.walker.options.goChildren = false;
      return
    }
    function v270(typeFlow$$25) {
      if(typeFlow$$25.checker.styleSettings.forin) {
        if(!this.isFiltered()) {
          var v11366 = typeFlow$$25.checker.errorReporter;
          JAM.call(v11366.styleError, v11366, [this, "no hasOwnProperty filter"])
        }
      }
      return JAM.call(typeFlow$$25.typeCheckForIn, typeFlow$$25, [this])
    }
    function v269(emitter$$27, tokenId$$27, startLine$$27) {
      JAM.call(emitter$$27.emitParensAndCommentsInPlace, emitter$$27, [this, true]);
      JAM.call(emitter$$27.recordSourceMappingStart, emitter$$27, [this]);
      var temp$$5 = JAM.call(emitter$$27.setInObjectLiteral, emitter$$27, [false]);
      JAM.call(emitter$$27.recordSourceMappingStart, emitter$$27, [this.statement]);
      JAM.call(emitter$$27.writeToOutput, emitter$$27, ["for("]);
      JAM.call(emitter$$27.emitJavascript, emitter$$27, [this.lval, TypeScript$$4.TokenID.For, false]);
      JAM.call(emitter$$27.writeToOutput, emitter$$27, [" in "]);
      JAM.call(emitter$$27.emitJavascript, emitter$$27, [this.obj, TypeScript$$4.TokenID.For, false]);
      JAM.call(emitter$$27.writeToOutput, emitter$$27, [")"]);
      JAM.call(emitter$$27.recordSourceMappingEnd, emitter$$27, [this.statement]);
      JAM.call(emitter$$27.emitJavascriptStatements, emitter$$27, [this.body, true]);
      JAM.call(emitter$$27.setInObjectLiteral, emitter$$27, [temp$$5]);
      JAM.call(emitter$$27.recordSourceMappingEnd, emitter$$27, [this]);
      JAM.call(emitter$$27.emitParensAndCommentsInPlace, emitter$$27, [this, false]);
      return
    }
    function v268() {
      if(this.body) {
        var singleItem = null;
        if(this.body.nodeType == TypeScript$$4.NodeType.List) {
          var stmts = this.body;
          if(stmts.members.length == 1) {
            singleItem = stmts.members[0]
          }
        }else {
          singleItem = this.body
        }
        if(singleItem !== null) {
          if(singleItem.nodeType == TypeScript$$4.NodeType.Block) {
            var block = singleItem;
            var v18364 = block.statements !== null;
            if(v18364) {
              v18364 = block.statements.members.length == 1
            }
            if(v18364) {
              singleItem = block.statements.members[0]
            }
          }
          if(singleItem.nodeType == TypeScript$$4.NodeType.If) {
            var cond$$2 = singleItem.cond;
            if(cond$$2.nodeType == TypeScript$$4.NodeType.Call) {
              var target$$38 = cond$$2.target;
              if(target$$38.nodeType == TypeScript$$4.NodeType.Dot) {
                var binex = target$$38;
                var v18372 = binex.operand1.nodeType == TypeScript$$4.NodeType.Name;
                if(v18372) {
                  var v22624 = this.obj.nodeType == TypeScript$$4.NodeType.Name;
                  if(v22624) {
                    v22624 = binex.operand1.actualText == this.obj.actualText
                  }
                  v18372 = v22624
                }
                if(v18372) {
                  var prop$$4 = binex.operand2;
                  if(prop$$4.actualText == "hasOwnProperty") {
                    var args$$2 = cond$$2.arguments;
                    var v18374 = args$$2 !== null;
                    if(v18374) {
                      v18374 = args$$2.members.length == 1
                    }
                    if(v18374) {
                      var arg$$5 = args$$2.members[0];
                      var v18375 = arg$$5.nodeType == TypeScript$$4.NodeType.Name;
                      if(v18375) {
                        v18375 = this.lval.nodeType == TypeScript$$4.NodeType.Name
                      }
                      if(v18375) {
                        if(this.lval.actualText == arg$$5.actualText) {
                          return true
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return false
    }
    function v267() {
      return true
    }
    function ForInStatement$$1(lval, obj$$16) {
      JAM.call(_super$$35.call, _super$$35, [this, TypeScript$$4.NodeType.ForIn]);
      this.lval = lval;
      this.obj = obj$$16;
      var v27420 = new ASTSpan;
      this.statement = v27420;
      var v18379 = this.lval;
      if(v18379) {
        v18379 = this.lval.nodeType == TypeScript$$4.NodeType.VarDecl
      }
      if(v18379) {
        var v11394 = this.lval;
        v11394.varFlags = v11394.varFlags | TypeScript$$4.VarFlags.AutoInit
      }
      return
    }
    JAM.call(__extends, null, [ForInStatement$$1, _super$$35]);
    ForInStatement$$1.prototype.isLoop = v267;
    ForInStatement$$1.prototype.isFiltered = v268;
    ForInStatement$$1.prototype.emit = v269;
    ForInStatement$$1.prototype.typeCheck = v270;
    ForInStatement$$1.prototype.addToControlFlow = v271;
    return ForInStatement$$1
  }
  function v266(_super$$34) {
    function EndCode$$1() {
      JAM.call(_super$$34.call, _super$$34, [this, TypeScript$$4.NodeType.EndCode]);
      return
    }
    JAM.call(__extends, null, [EndCode$$1, _super$$34]);
    return EndCode$$1
  }
  function v265(_super$$33) {
    function v264(typeFlow$$24) {
      return JAM.call(typeFlow$$24.typeCheckReturn, typeFlow$$24, [this])
    }
    function v263(context$$17) {
      var v11402 = _super$$33.prototype.addToControlFlow;
      JAM.call(v11402.call, v11402, [this, context$$17]);
      context$$17.returnStmt();
      return
    }
    function v262(emitter$$26, tokenId$$26, startLine$$26) {
      JAM.call(emitter$$26.emitParensAndCommentsInPlace, emitter$$26, [this, true]);
      JAM.call(emitter$$26.recordSourceMappingStart, emitter$$26, [this]);
      var temp$$4 = JAM.call(emitter$$26.setInObjectLiteral, emitter$$26, [false]);
      if(this.returnExpression) {
        JAM.call(emitter$$26.writeToOutput, emitter$$26, ["return "]);
        JAM.call(emitter$$26.emitJavascript, emitter$$26, [this.returnExpression, TypeScript$$4.TokenID.Semicolon, false]);
        if(this.returnExpression.nodeType === TypeScript$$4.NodeType.FuncDecl) {
          JAM.call(emitter$$26.writeToOutput, emitter$$26, [";"])
        }
      }else {
        JAM.call(emitter$$26.writeToOutput, emitter$$26, ["return;"])
      }
      JAM.call(emitter$$26.setInObjectLiteral, emitter$$26, [temp$$4]);
      JAM.call(emitter$$26.recordSourceMappingEnd, emitter$$26, [this]);
      JAM.call(emitter$$26.emitParensAndCommentsInPlace, emitter$$26, [this, false]);
      return
    }
    function ReturnStatement$$1() {
      JAM.call(_super$$33.call, _super$$33, [this, TypeScript$$4.NodeType.Return]);
      this.returnExpression = null;
      return
    }
    JAM.call(__extends, null, [ReturnStatement$$1, _super$$33]);
    ReturnStatement$$1.prototype.emit = v262;
    ReturnStatement$$1.prototype.addToControlFlow = v263;
    ReturnStatement$$1.prototype.typeCheck = v264;
    return ReturnStatement$$1
  }
  function v261(_super$$32) {
    function v260(context$$16) {
      var v11411 = this.cond;
      JAM.call(v11411.addToControlFlow, v11411, [context$$16]);
      var afterIf = new TypeScript$$4.BasicBlock;
      var beforeIf = context$$16.current;
      JAM.call(context$$16.pushStatement, context$$16, [this, beforeIf, afterIf]);
      var hasContinuation = false;
      var v11413 = context$$16;
      var v27421 = new TypeScript$$4.BasicBlock;
      v11413.current = v27421;
      JAM.call(beforeIf.addSuccessor, beforeIf, [context$$16.current]);
      JAM.call(context$$16.walk, context$$16, [this.thenBod, this]);
      if(!context$$16.noContinuation) {
        hasContinuation = true;
        var v11416 = context$$16.current;
        JAM.call(v11416.addSuccessor, v11416, [afterIf])
      }
      if(this.elseBod) {
        var v11418 = context$$16;
        var v27422 = new TypeScript$$4.BasicBlock;
        v11418.current = v27422;
        context$$16.noContinuation = false;
        JAM.call(beforeIf.addSuccessor, beforeIf, [context$$16.current]);
        JAM.call(context$$16.walk, context$$16, [this.elseBod, this]);
        if(!context$$16.noContinuation) {
          hasContinuation = true;
          var v11421 = context$$16.current;
          JAM.call(v11421.addSuccessor, v11421, [afterIf])
        }else {
          if(hasContinuation) {
            context$$16.noContinuation = false
          }
        }
      }else {
        JAM.call(beforeIf.addSuccessor, beforeIf, [afterIf]);
        context$$16.noContinuation = false;
        hasContinuation = true
      }
      var targetInfo$$2 = context$$16.popStatement();
      if(afterIf.predecessors.length > 0) {
        context$$16.noContinuation = false;
        hasContinuation = true
      }
      if(hasContinuation) {
        context$$16.current = afterIf
      }
      context$$16.walker.options.goChildren = false;
      return
    }
    function v259(typeFlow$$23) {
      return JAM.call(typeFlow$$23.typeCheckIf, typeFlow$$23, [this])
    }
    function v258(emitter$$25, tokenId$$25, startLine$$25) {
      JAM.call(emitter$$25.emitParensAndCommentsInPlace, emitter$$25, [this, true]);
      JAM.call(emitter$$25.recordSourceMappingStart, emitter$$25, [this]);
      var temp$$3 = JAM.call(emitter$$25.setInObjectLiteral, emitter$$25, [false]);
      JAM.call(emitter$$25.recordSourceMappingStart, emitter$$25, [this.statement]);
      JAM.call(emitter$$25.writeToOutput, emitter$$25, ["if("]);
      JAM.call(emitter$$25.emitJavascript, emitter$$25, [this.cond, TypeScript$$4.TokenID.If, false]);
      JAM.call(emitter$$25.writeToOutput, emitter$$25, [")"]);
      JAM.call(emitter$$25.recordSourceMappingEnd, emitter$$25, [this.statement]);
      JAM.call(emitter$$25.emitJavascriptStatements, emitter$$25, [this.thenBod, true]);
      if(this.elseBod) {
        if(this.elseBod.nodeType === TypeScript$$4.NodeType.If) {
          JAM.call(emitter$$25.writeToOutput, emitter$$25, [" else "]);
          var v11431 = this.elseBod;
          JAM.call(v11431.emit, v11431, [emitter$$25, tokenId$$25, false])
        }else {
          JAM.call(emitter$$25.writeToOutput, emitter$$25, [" else"]);
          JAM.call(emitter$$25.emitJavascriptStatements, emitter$$25, [this.elseBod, true])
        }
      }
      JAM.call(emitter$$25.setInObjectLiteral, emitter$$25, [temp$$3]);
      JAM.call(emitter$$25.recordSourceMappingEnd, emitter$$25, [this]);
      JAM.call(emitter$$25.emitParensAndCommentsInPlace, emitter$$25, [this, false]);
      return
    }
    function v257() {
      return true
    }
    function IfStatement$$1(cond$$1) {
      JAM.call(_super$$32.call, _super$$32, [this, TypeScript$$4.NodeType.If]);
      this.cond = cond$$1;
      this.elseBod = null;
      var v27423 = new ASTSpan;
      this.statement = v27423;
      return
    }
    JAM.call(__extends, null, [IfStatement$$1, _super$$32]);
    IfStatement$$1.prototype.isCompoundStatement = v257;
    IfStatement$$1.prototype.emit = v258;
    IfStatement$$1.prototype.typeCheck = v259;
    IfStatement$$1.prototype.addToControlFlow = v260;
    return IfStatement$$1
  }
  function v256(_super$$31) {
    function v255(context$$15) {
      var loopHeader$$1 = context$$15.current;
      var loopStart$$1 = new TypeScript$$4.BasicBlock;
      var afterLoop$$1 = new TypeScript$$4.BasicBlock;
      JAM.call(loopHeader$$1.addSuccessor, loopHeader$$1, [loopStart$$1]);
      context$$15.current = loopStart$$1;
      var targetInfo$$1 = null;
      if(this.body) {
        JAM.call(context$$15.pushStatement, context$$15, [this, loopStart$$1, afterLoop$$1]);
        JAM.call(context$$15.walk, context$$15, [this.body, this]);
        targetInfo$$1 = context$$15.popStatement()
      }
      if(!context$$15.noContinuation) {
        var loopEnd$$1 = context$$15.current;
        JAM.call(loopEnd$$1.addSuccessor, loopEnd$$1, [loopStart$$1]);
        JAM.call(context$$15.addContent, context$$15, [this.cond]);
        context$$15.current = afterLoop$$1;
        JAM.call(loopEnd$$1.addSuccessor, loopEnd$$1, [afterLoop$$1])
      }else {
        JAM.call(context$$15.addUnreachable, context$$15, [this.cond])
      }
      context$$15.walker.options.goChildren = false;
      return
    }
    function v254(typeFlow$$22) {
      return JAM.call(typeFlow$$22.typeCheckDoWhile, typeFlow$$22, [this])
    }
    function v253(emitter$$24, tokenId$$24, startLine$$24) {
      JAM.call(emitter$$24.emitParensAndCommentsInPlace, emitter$$24, [this, true]);
      JAM.call(emitter$$24.recordSourceMappingStart, emitter$$24, [this]);
      var temp$$2 = JAM.call(emitter$$24.setInObjectLiteral, emitter$$24, [false]);
      JAM.call(emitter$$24.writeToOutput, emitter$$24, ["do"]);
      JAM.call(emitter$$24.emitJavascriptStatements, emitter$$24, [this.body, true]);
      JAM.call(emitter$$24.recordSourceMappingStart, emitter$$24, [this.whileAST]);
      JAM.call(emitter$$24.writeToOutput, emitter$$24, ["while"]);
      JAM.call(emitter$$24.recordSourceMappingEnd, emitter$$24, [this.whileAST]);
      JAM.call(emitter$$24.writeToOutput, emitter$$24, ["("]);
      JAM.call(emitter$$24.emitJavascript, emitter$$24, [this.cond, TypeScript$$4.TokenID.CloseParen, false]);
      JAM.call(emitter$$24.writeToOutput, emitter$$24, [")"]);
      JAM.call(emitter$$24.setInObjectLiteral, emitter$$24, [temp$$2]);
      JAM.call(emitter$$24.recordSourceMappingEnd, emitter$$24, [this]);
      JAM.call(emitter$$24.writeToOutput, emitter$$24, [";"]);
      JAM.call(emitter$$24.emitParensAndCommentsInPlace, emitter$$24, [this, false]);
      return
    }
    function v252() {
      return true
    }
    function DoWhileStatement$$1() {
      JAM.call(_super$$31.call, _super$$31, [this, TypeScript$$4.NodeType.DoWhile]);
      this.body = null;
      this.whileAST = null;
      this.cond = null;
      return
    }
    JAM.call(__extends, null, [DoWhileStatement$$1, _super$$31]);
    DoWhileStatement$$1.prototype.isLoop = v252;
    DoWhileStatement$$1.prototype.emit = v253;
    DoWhileStatement$$1.prototype.typeCheck = v254;
    DoWhileStatement$$1.prototype.addToControlFlow = v255;
    return DoWhileStatement$$1
  }
  function v251(_super$$30) {
    function v250(context$$14) {
      var loopHeader = context$$14.current;
      var loopStart = new TypeScript$$4.BasicBlock;
      var afterLoop = new TypeScript$$4.BasicBlock;
      JAM.call(loopHeader.addSuccessor, loopHeader, [loopStart]);
      context$$14.current = loopStart;
      JAM.call(context$$14.addContent, context$$14, [this.cond]);
      var condBlock = context$$14.current;
      var targetInfo = null;
      if(this.body) {
        var v11461 = context$$14;
        var v27424 = new TypeScript$$4.BasicBlock;
        v11461.current = v27424;
        JAM.call(condBlock.addSuccessor, condBlock, [context$$14.current]);
        JAM.call(context$$14.pushStatement, context$$14, [this, loopStart, afterLoop]);
        JAM.call(context$$14.walk, context$$14, [this.body, this]);
        targetInfo = context$$14.popStatement()
      }
      if(!context$$14.noContinuation) {
        var loopEnd = context$$14.current;
        JAM.call(loopEnd.addSuccessor, loopEnd, [loopStart])
      }
      context$$14.current = afterLoop;
      JAM.call(condBlock.addSuccessor, condBlock, [afterLoop]);
      context$$14.noContinuation = false;
      context$$14.walker.options.goChildren = false;
      return
    }
    function v249(typeFlow$$21) {
      return JAM.call(typeFlow$$21.typeCheckWhile, typeFlow$$21, [this])
    }
    function v248(emitter$$23, tokenId$$23, startLine$$23) {
      JAM.call(emitter$$23.emitParensAndCommentsInPlace, emitter$$23, [this, true]);
      JAM.call(emitter$$23.recordSourceMappingStart, emitter$$23, [this]);
      var temp$$1 = JAM.call(emitter$$23.setInObjectLiteral, emitter$$23, [false]);
      JAM.call(emitter$$23.writeToOutput, emitter$$23, ["while("]);
      JAM.call(emitter$$23.emitJavascript, emitter$$23, [this.cond, TypeScript$$4.TokenID.While, false]);
      JAM.call(emitter$$23.writeToOutput, emitter$$23, [")"]);
      JAM.call(emitter$$23.emitJavascriptStatements, emitter$$23, [this.body, false]);
      JAM.call(emitter$$23.setInObjectLiteral, emitter$$23, [temp$$1]);
      JAM.call(emitter$$23.recordSourceMappingEnd, emitter$$23, [this]);
      JAM.call(emitter$$23.emitParensAndCommentsInPlace, emitter$$23, [this, false]);
      return
    }
    function v247() {
      return true
    }
    function WhileStatement$$1(cond) {
      JAM.call(_super$$30.call, _super$$30, [this, TypeScript$$4.NodeType.While]);
      this.cond = cond;
      this.body = null;
      return
    }
    JAM.call(__extends, null, [WhileStatement$$1, _super$$30]);
    WhileStatement$$1.prototype.isLoop = v247;
    WhileStatement$$1.prototype.emit = v248;
    WhileStatement$$1.prototype.typeCheck = v249;
    WhileStatement$$1.prototype.addToControlFlow = v250;
    return WhileStatement$$1
  }
  function v246(_super$$29) {
    function v245(emitter$$22, tokenId$$22, startLine$$22) {
      JAM.call(emitter$$22.emitParensAndCommentsInPlace, emitter$$22, [this, true]);
      JAM.call(emitter$$22.recordSourceMappingStart, emitter$$22, [this]);
      if(this.nodeType == TypeScript$$4.NodeType.Break) {
        JAM.call(emitter$$22.writeToOutput, emitter$$22, ["break"])
      }else {
        JAM.call(emitter$$22.writeToOutput, emitter$$22, ["continue"])
      }
      if(this.target) {
        JAM.call(emitter$$22.writeToOutput, emitter$$22, [" " + this.target])
      }
      JAM.call(emitter$$22.recordSourceMappingEnd, emitter$$22, [this]);
      JAM.call(emitter$$22.writeToOutput, emitter$$22, [";"]);
      JAM.call(emitter$$22.emitParensAndCommentsInPlace, emitter$$22, [this, false]);
      return
    }
    function v244(context$$13) {
      var v11478 = _super$$29.prototype.addToControlFlow;
      JAM.call(v11478.call, v11478, [this, context$$13]);
      JAM.call(context$$13.unconditionalBranch, context$$13, [this.resolvedTarget, this.nodeType == TypeScript$$4.NodeType.Continue]);
      return
    }
    function v243(parser, stmt$$2) {
      if(stmt$$2.isLoop()) {
        this.resolvedTarget = stmt$$2;
        return true
      }
      if(this.nodeType === TypeScript$$4.NodeType.Continue) {
        JAM.call(parser.reportParseError, parser, ["continue statement applies only to loops"]);
        return false
      }else {
        var v18413 = stmt$$2.nodeType == TypeScript$$4.NodeType.Switch;
        if(!v18413) {
          v18413 = this.target
        }
        if(v18413) {
          this.resolvedTarget = stmt$$2;
          return true
        }else {
          JAM.call(parser.reportParseError, parser, ["break statement with no label can apply only to a loop or switch statement"]);
          return false
        }
      }
      return
    }
    function v242() {
      return this.target
    }
    function Jump$$1(nodeType$$11) {
      JAM.call(_super$$29.call, _super$$29, [this, nodeType$$11]);
      this.target = null;
      this.resolvedTarget = null;
      return
    }
    JAM.call(__extends, null, [Jump$$1, _super$$29]);
    Jump$$1.prototype.hasExplicitTarget = v242;
    Jump$$1.prototype.setResolvedTarget = v243;
    Jump$$1.prototype.addToControlFlow = v244;
    Jump$$1.prototype.emit = v245;
    return Jump$$1
  }
  function v241(_super$$28) {
    function v240(typeFlow$$20) {
      if(!typeFlow$$20.checker.styleSettings.emptyBlocks) {
        var v18415 = this.statements === null;
        if(!v18415) {
          v18415 = this.statements.members.length == 0
        }
        if(v18415) {
          var v11488 = typeFlow$$20.checker.errorReporter;
          JAM.call(v11488.styleError, v11488, [this, "empty block"])
        }
      }
      JAM.call(typeFlow$$20.typeCheck, typeFlow$$20, [this.statements]);
      return this
    }
    function v239(context$$12) {
      var afterIfNeeded = new TypeScript$$4.BasicBlock;
      JAM.call(context$$12.pushStatement, context$$12, [this, context$$12.current, afterIfNeeded]);
      if(this.statements) {
        JAM.call(context$$12.walk, context$$12, [this.statements, this])
      }
      context$$12.walker.options.goChildren = false;
      context$$12.popStatement();
      if(afterIfNeeded.predecessors.length > 0) {
        var v11497 = context$$12.current;
        JAM.call(v11497.addSuccessor, v11497, [afterIfNeeded]);
        context$$12.current = afterIfNeeded
      }
      return
    }
    function v238(emitter$$21, tokenId$$21, startLine$$21) {
      JAM.call(emitter$$21.emitParensAndCommentsInPlace, emitter$$21, [this, true]);
      JAM.call(emitter$$21.recordSourceMappingStart, emitter$$21, [this]);
      if(this.isStatementBlock) {
        JAM.call(emitter$$21.writeLineToOutput, emitter$$21, [" {"]);
        emitter$$21.indenter.increaseIndent()
      }else {
        JAM.call(emitter$$21.setInVarBlock, emitter$$21, [this.statements.members.length])
      }
      var temp = JAM.call(emitter$$21.setInObjectLiteral, emitter$$21, [false]);
      if(this.statements) {
        JAM.call(emitter$$21.emitJavascriptList, emitter$$21, [this.statements, null, TypeScript$$4.TokenID.Semicolon, true, false, false])
      }
      if(this.isStatementBlock) {
        emitter$$21.indenter.decreaseIndent();
        emitter$$21.emitIndent();
        JAM.call(emitter$$21.writeToOutput, emitter$$21, ["}"])
      }
      JAM.call(emitter$$21.setInObjectLiteral, emitter$$21, [temp]);
      JAM.call(emitter$$21.recordSourceMappingEnd, emitter$$21, [this]);
      JAM.call(emitter$$21.emitParensAndCommentsInPlace, emitter$$21, [this, false]);
      return
    }
    function Block$$1(statements, isStatementBlock) {
      JAM.call(_super$$28.call, _super$$28, [this, TypeScript$$4.NodeType.Block]);
      this.statements = statements;
      this.isStatementBlock = isStatementBlock;
      return
    }
    JAM.call(__extends, null, [Block$$1, _super$$28]);
    Block$$1.prototype.emit = v238;
    Block$$1.prototype.addToControlFlow = v239;
    Block$$1.prototype.typeCheck = v240;
    return Block$$1
  }
  function v237(_super$$27) {
    function v236(context$$11) {
      var beforeBB = context$$11.current;
      var bb = new TypeScript$$4.BasicBlock;
      context$$11.current = bb;
      JAM.call(beforeBB.addSuccessor, beforeBB, [bb]);
      return
    }
    function v235(typeFlow$$19) {
      JAM.call(typeFlow$$19.typeCheck, typeFlow$$19, [this.labels]);
      var v11513 = this.stmt;
      var v27425 = JAM.call(v11513.typeCheck, v11513, [typeFlow$$19]);
      this.stmt = v27425;
      return this
    }
    function v234(emitter$$20, tokenId$$20, startLine$$20) {
      JAM.call(emitter$$20.emitParensAndCommentsInPlace, emitter$$20, [this, true]);
      JAM.call(emitter$$20.recordSourceMappingStart, emitter$$20, [this]);
      if(this.labels) {
        var labelsLen = this.labels.members.length;
        var i$$18 = 0;
        var v11516 = i$$18 < labelsLen;
        for(;v11516;) {
          var v18423 = this.labels.members;
          introspect(JAM.policy.p1) {
            var v11515 = v18423[i$$18]
          }
          JAM.call(v11515.emit, v11515, [emitter$$20, tokenId$$20, startLine$$20]);
          i$$18 = i$$18 + 1;
          v11516 = i$$18 < labelsLen
        }
      }
      var v11518 = this.stmt;
      JAM.call(v11518.emit, v11518, [emitter$$20, tokenId$$20, true]);
      JAM.call(emitter$$20.recordSourceMappingEnd, emitter$$20, [this]);
      JAM.call(emitter$$20.emitParensAndCommentsInPlace, emitter$$20, [this, false]);
      return
    }
    function LabeledStatement$$1(labels, stmt$$1) {
      JAM.call(_super$$27.call, _super$$27, [this, TypeScript$$4.NodeType.LabeledStatement]);
      this.labels = labels;
      this.stmt = stmt$$1;
      return
    }
    JAM.call(__extends, null, [LabeledStatement$$1, _super$$27]);
    LabeledStatement$$1.prototype.emit = v234;
    LabeledStatement$$1.prototype.typeCheck = v235;
    LabeledStatement$$1.prototype.addToControlFlow = v236;
    return LabeledStatement$$1
  }
  function v233(_super$$26) {
    function v232(typeFlow$$18) {
      this.type = typeFlow$$18.voidType;
      return this
    }
    function v231() {
      return this.isLoop()
    }
    function v230() {
      return true
    }
    function v229() {
      return false
    }
    function Statement$$1(nodeType$$10) {
      JAM.call(_super$$26.call, _super$$26, [this, nodeType$$10]);
      this.flags = this.flags | TypeScript$$4.ASTFlags.IsStatement;
      return
    }
    JAM.call(__extends, null, [Statement$$1, _super$$26]);
    Statement$$1.prototype.isLoop = v229;
    Statement$$1.prototype.isStatementOrExpression = v230;
    Statement$$1.prototype.isCompoundStatement = v231;
    Statement$$1.prototype.typeCheck = v232;
    return Statement$$1
  }
  function v228(_super$$25) {
    function v227(emitter$$19, tokenId$$19, startLine$$19) {
      return
    }
    function v226(typeFlow$$17) {
      return JAM.call(typeFlow$$17.typeCheckInterface, typeFlow$$17, [this])
    }
    function InterfaceDeclaration$$1(name$$39, members$$4, extendsList$$2, implementsList$$2) {
      JAM.call(_super$$25.call, _super$$25, [this, TypeScript$$4.NodeType.InterfaceDeclaration, name$$39, extendsList$$2, implementsList$$2, members$$4]);
      return
    }
    JAM.call(__extends, null, [InterfaceDeclaration$$1, _super$$25]);
    InterfaceDeclaration$$1.prototype.typeCheck = v226;
    InterfaceDeclaration$$1.prototype.emit = v227;
    return InterfaceDeclaration$$1
  }
  function v225(_super$$24) {
    function v224(emitter$$18, tokenId$$18, startLine$$18) {
      JAM.call(emitter$$18.emitJavascriptClass, emitter$$18, [this]);
      return
    }
    function v223(typeFlow$$16) {
      return JAM.call(typeFlow$$16.typeCheckClass, typeFlow$$16, [this])
    }
    function ClassDeclaration$$1(name$$38, members$$3, extendsList$$1, implementsList$$1) {
      JAM.call(_super$$24.call, _super$$24, [this, TypeScript$$4.NodeType.ClassDeclaration, name$$38, extendsList$$1, implementsList$$1, members$$3]);
      this.knownMemberNames = {};
      this.constructorDecl = null;
      this.constructorNestingLevel = 0;
      this.endingToken = null;
      return
    }
    JAM.call(__extends, null, [ClassDeclaration$$1, _super$$24]);
    ClassDeclaration$$1.prototype.typeCheck = v223;
    ClassDeclaration$$1.prototype.emit = v224;
    return ClassDeclaration$$1
  }
  function v222(_super$$23) {
    function v221() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.varFlags, TypeScript$$4.VarFlags.Ambient])
    }
    function v220() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.varFlags, TypeScript$$4.VarFlags.Exported])
    }
    function TypeDeclaration$$1(nodeType$$9, name$$37, extendsList, implementsList, members$$2) {
      JAM.call(_super$$23.call, _super$$23, [this, nodeType$$9, name$$37, members$$2]);
      this.extendsList = extendsList;
      this.implementsList = implementsList;
      this.varFlags = TypeScript$$4.VarFlags.None;
      return
    }
    JAM.call(__extends, null, [TypeDeclaration$$1, _super$$23]);
    TypeDeclaration$$1.prototype.isExported = v220;
    TypeDeclaration$$1.prototype.isAmbient = v221;
    return TypeDeclaration$$1
  }
  function v219(_super$$22) {
    function v218(emitter$$17, tokenId$$17, startLine$$17) {
      if(!JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.modFlags, TypeScript$$4.ModuleFlags.ShouldEmitModuleDecl])) {
        JAM.call(emitter$$17.emitParensAndCommentsInPlace, emitter$$17, [this, true]);
        JAM.call(emitter$$17.recordSourceMappingStart, emitter$$17, [this]);
        JAM.call(emitter$$17.emitJavascriptModule, emitter$$17, [this]);
        JAM.call(emitter$$17.recordSourceMappingEnd, emitter$$17, [this]);
        JAM.call(emitter$$17.emitParensAndCommentsInPlace, emitter$$17, [this, false])
      }
      return
    }
    function v217(typeFlow$$15) {
      return JAM.call(typeFlow$$15.typeCheckModule, typeFlow$$15, [this])
    }
    function v216() {
      this.modFlags = this.modFlags & ~TypeScript$$4.ModuleFlags.ShouldEmitModuleDecl;
      return
    }
    function v215() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.modFlags, TypeScript$$4.ModuleFlags.IsEnum])
    }
    function v214() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.modFlags, TypeScript$$4.ModuleFlags.Ambient])
    }
    function v213() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.modFlags, TypeScript$$4.ModuleFlags.Exported])
    }
    function ModuleDeclaration$$1(name$$36, members$$1, vars$$2, scopes$$2, endingToken) {
      JAM.call(_super$$22.call, _super$$22, [this, TypeScript$$4.NodeType.ModuleDeclaration, name$$36, members$$1]);
      this.endingToken = endingToken;
      this.modFlags = TypeScript$$4.ModuleFlags.ShouldEmitModuleDecl;
      this.amdDependencies = [];
      this.containsUnicodeChar = false;
      this.containsUnicodeCharInComment = false;
      this.vars = vars$$2;
      this.scopes = scopes$$2;
      this.prettyName = this.name.actualText;
      return
    }
    JAM.call(__extends, null, [ModuleDeclaration$$1, _super$$22]);
    ModuleDeclaration$$1.prototype.isExported = v213;
    ModuleDeclaration$$1.prototype.isAmbient = v214;
    ModuleDeclaration$$1.prototype.isEnum = v215;
    ModuleDeclaration$$1.prototype.recordNonInterface = v216;
    ModuleDeclaration$$1.prototype.typeCheck = v217;
    ModuleDeclaration$$1.prototype.emit = v218;
    return ModuleDeclaration$$1
  }
  function v212(_super$$21) {
    function v211() {
      return true
    }
    function NamedDeclaration$$1(nodeType$$8, name$$35, members) {
      JAM.call(_super$$21.call, _super$$21, [this, nodeType$$8]);
      this.name = name$$35;
      this.members = members;
      this.leftCurlyCount = 0;
      this.rightCurlyCount = 0;
      return
    }
    JAM.call(__extends, null, [NamedDeclaration$$1, _super$$21]);
    NamedDeclaration$$1.prototype.isDeclaration = v211;
    return NamedDeclaration$$1
  }
  function v210(_super$$20) {
    function v209(symbol$$1) {
      var i$$17 = 0;
      var v11558 = i$$17 < this.externallyVisibleImportedSymbols.length;
      for(;v11558;) {
        var v22658 = this.externallyVisibleImportedSymbols;
        introspect(JAM.policy.p1) {
          var v18439 = v22658[i$$17]
        }
        if(v18439 == symbol$$1) {
          return true
        }
        i$$17 = i$$17 + 1;
        v11558 = i$$17 < this.externallyVisibleImportedSymbols.length
      }
      return false
    }
    function v208(symbol, checker) {
      if(JAM.call(this.isExternallyVisibleSymbol, this, [symbol])) {
        return
      }
      var v22660 = symbol.getType().symbol;
      if(!JAM.call(v22660.isExternallyVisible, v22660, [checker])) {
        var quotes = "";
        var moduleName = symbol.getType().symbol.prettyName;
        if(!JAM.call(TypeScript$$4.isQuoted, TypeScript$$4, [moduleName])) {
          quotes = "'"
        }
        var v11562 = checker.errorReporter;
        JAM.call(v11562.simpleError, v11562, [symbol.declAST, "Externally visible import statement uses non exported module " + quotes + moduleName + quotes])
      }
      var v11566 = this.externallyVisibleImportedSymbols;
      JAM.call(v11566.push, v11566, [symbol]);
      return
    }
    function v207(emitter$$16, tokenId$$16, startLine$$16) {
      if(JAM.call(this.emitRequired, this, [emitter$$16.emitOptions])) {
        JAM.call(emitter$$16.emitParensAndCommentsInPlace, emitter$$16, [this.bod, true]);
        JAM.call(emitter$$16.emitJavascriptList, emitter$$16, [this.bod, null, TypeScript$$4.TokenID.Semicolon, true, false, false, true, this.requiresExtendsBlock]);
        JAM.call(emitter$$16.emitParensAndCommentsInPlace, emitter$$16, [this.bod, false])
      }
      return
    }
    function v206(emitOptions) {
      if(this.cachedEmitRequired != undefined) {
        return this.cachedEmitRequired
      }
      var v18448 = !this.isDeclareFile;
      if(v18448) {
        var v22663 = !this.isResident;
        if(v22663) {
          v22663 = this.bod
        }
        v18448 = v22663
      }
      if(v18448) {
        var i$$16 = 0;
        var len$$4 = this.bod.members.length;
        var v11585 = i$$16 < len$$4;
        for(;v11585;) {
          var v11575 = this.bod.members;
          introspect(JAM.policy.p1) {
            var stmt = v11575[i$$16]
          }
          if(stmt.nodeType == TypeScript$$4.NodeType.ModuleDeclaration) {
            if(!JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [stmt.modFlags, TypeScript$$4.ModuleFlags.ShouldEmitModuleDecl | TypeScript$$4.ModuleFlags.Ambient])) {
              return JAM.call(this.setCachedEmitRequired, this, [true])
            }
          }else {
            if(stmt.nodeType == TypeScript$$4.NodeType.ClassDeclaration) {
              if(!JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [stmt.varFlags, TypeScript$$4.VarFlags.Ambient])) {
                return JAM.call(this.setCachedEmitRequired, this, [true])
              }
            }else {
              if(stmt.nodeType == TypeScript$$4.NodeType.VarDecl) {
                if(!JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [stmt.varFlags, TypeScript$$4.VarFlags.Ambient])) {
                  return JAM.call(this.setCachedEmitRequired, this, [true])
                }
              }else {
                if(stmt.nodeType == TypeScript$$4.NodeType.FuncDecl) {
                  if(!stmt.isSignature()) {
                    return JAM.call(this.setCachedEmitRequired, this, [true])
                  }
                }else {
                  var v18463 = stmt.nodeType != TypeScript$$4.NodeType.InterfaceDeclaration;
                  if(v18463) {
                    v18463 = stmt.nodeType != TypeScript$$4.NodeType.Empty
                  }
                  if(v18463) {
                    return JAM.call(this.setCachedEmitRequired, this, [true])
                  }
                }
              }
            }
          }
          i$$16 = i$$16 + 1;
          v11585 = i$$16 < len$$4
        }
        var v18464 = emitOptions.emitComments;
        if(v18464) {
          var v24737 = this.bod.preComments;
          if(v24737) {
            v24737 = this.bod.preComments.length > 0
          }
          var v22678 = v24737;
          if(!v22678) {
            var v24738 = this.bod.postComments;
            if(v24738) {
              v24738 = this.bod.postComments.length > 0
            }
            v22678 = v24738
          }
          v18464 = v22678
        }
        if(v18464) {
          return JAM.call(this.setCachedEmitRequired, this, [true])
        }
      }
      return JAM.call(this.setCachedEmitRequired, this, [false])
    }
    function v205() {
      return"Script"
    }
    function v204(typeFlow$$14) {
      return JAM.call(typeFlow$$14.typeCheckScript, typeFlow$$14, [this])
    }
    function v203(value$$31) {
      this.cachedEmitRequired = value$$31;
      return this.cachedEmitRequired
    }
    function Script$$1(vars$$1, scopes$$1) {
      JAM.call(_super$$20.call, _super$$20, [this, JAM.new(Identifier, ["script"]), null, false, null, vars$$1, scopes$$1, null, TypeScript$$4.NodeType.Script]);
      this.locationInfo = null;
      this.referencedFiles = [];
      this.requiresGlobal = false;
      this.requiresExtendsBlock = false;
      this.isResident = false;
      this.isDeclareFile = false;
      this.hasBeenTypeChecked = false;
      this.topLevelMod = null;
      this.leftCurlyCount = 0;
      this.rightCurlyCount = 0;
      this.containsUnicodeChar = false;
      this.containsUnicodeCharInComment = false;
      this.externallyVisibleImportedSymbols = [];
      this.vars = vars$$1;
      this.scopes = scopes$$1;
      return
    }
    JAM.call(__extends, null, [Script$$1, _super$$20]);
    Script$$1.prototype.setCachedEmitRequired = v203;
    Script$$1.prototype.typeCheck = v204;
    Script$$1.prototype.treeViewLabel = v205;
    Script$$1.prototype.emitRequired = v206;
    Script$$1.prototype.emit = v207;
    Script$$1.prototype.AddExternallyVisibleImportedSymbol = v208;
    Script$$1.prototype.isExternallyVisibleSymbol = v209;
    return Script$$1
  }
  function v202() {
    function LocationInfo$$1(filename, lineMap, unitIndex) {
      this.filename = filename;
      this.lineMap = lineMap;
      this.unitIndex = unitIndex;
      return
    }
    return LocationInfo$$1
  }
  function v201(_super$$19) {
    function v200() {
      return(this.fncFlags & TypeScript$$4.FncFlags.Signature) != TypeScript$$4.FncFlags.None
    }
    function v199() {
      this.fncFlags = TypeScript$$4.FncFlags.None;
      return
    }
    function v198() {
      if(this.name == null) {
        return"funcExpr"
      }else {
        return"func: " + this.name.actualText
      }
      return
    }
    function v197() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.Static])
    }
    function v196() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.Public])
    }
    function v195() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.Private])
    }
    function v194() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.Exported])
    }
    function v193() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.Ambient])
    }
    function v192() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.SetAccessor])
    }
    function v191() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.GetAccessor])
    }
    function v190() {
      var v11616 = JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.GetAccessor]);
      if(!v11616) {
        v11616 = JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.SetAccessor])
      }
      return v11616
    }
    function v189() {
      return this.name === null
    }
    function v188() {
      var v11618 = this.isCallMember();
      if(!v11618) {
        var v18483 = this.isIndexerMember();
        if(!v18483) {
          v18483 = this.isConstructMember()
        }
        v11618 = v18483
      }
      return v11618
    }
    function v187() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.IndexerMember])
    }
    function v186() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.ConstructMember])
    }
    function v185() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.CallMember])
    }
    function v184() {
      return(this.fncFlags & TypeScript$$4.FncFlags.Method) != TypeScript$$4.FncFlags.None
    }
    function v183() {
      if(this.name) {
        return this.name.actualText
      }else {
        return this.hint
      }
      return
    }
    function v182(emitter$$15, tokenId$$15, startLine$$15) {
      JAM.call(emitter$$15.emitJavascriptFunction, emitter$$15, [this]);
      return
    }
    function v181(typeFlow$$13) {
      return JAM.call(typeFlow$$13.typeCheckFunction, typeFlow$$13, [this])
    }
    function v180() {
      function controlFlowPrefix(ast$$2, parent, walker$$1) {
        JAM.call(ast$$2.addToControlFlow, ast$$2, [walker$$1.state]);
        return ast$$2
      }
      var entry$$1 = new TypeScript$$4.BasicBlock;
      var exit = new TypeScript$$4.BasicBlock;
      var context$$10 = JAM.new(TypeScript$$4.ControlFlowContext, [entry$$1, exit]);
      var v11633 = TypeScript$$4.getAstWalkerFactory();
      var walker = JAM.call(v11633.getWalker, v11633, [controlFlowPrefix, null, null, context$$10]);
      context$$10.walker = walker;
      JAM.call(walker.walk, walker, [this.bod, this]);
      return context$$10
    }
    function v179(sym$$1) {
      if(this.jumpRefs == null) {
        var v27426 = new Array;
        this.jumpRefs = v27426
      }
      var id$$6 = JAM.new(Identifier, [sym$$1.name]);
      JAM.set(this.jumpRefs, this.jumpRefs.length, id$$6);
      id$$6.sym = sym$$1;
      var v11639 = id$$6;
      var v27427 = JAM.call(this.addCloRef, this, [id$$6, null]);
      v11639.cloId = v27427;
      return
    }
    function v178(id$$5, sym) {
      if(this.envids == null) {
        var v27428 = new Array;
        this.envids = v27428
      }
      JAM.set(this.envids, this.envids.length, id$$5);
      var outerFnc = this.enclosingFnc;
      if(sym) {
        var v18495 = outerFnc;
        if(v18495) {
          v18495 = outerFnc.type.symbol != sym.container
        }
        var v11643 = v18495;
        for(;v11643;) {
          JAM.call(outerFnc.addJumpRef, outerFnc, [sym]);
          outerFnc = outerFnc.enclosingFnc;
          var v18496 = outerFnc;
          if(v18496) {
            v18496 = outerFnc.type.symbol != sym.container
          }
          v11643 = v18496
        }
      }
      return this.envids.length - 1
    }
    function v177() {
      this.fncFlags = this.fncFlags | TypeScript$$4.FncFlags.HasSuperReferenceInFatArrowFunction;
      return
    }
    function v176() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.HasSuperReferenceInFatArrowFunction])
    }
    function v175() {
      this.fncFlags = this.fncFlags | TypeScript$$4.FncFlags.HasSelfReference;
      return
    }
    function v174() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.fncFlags, TypeScript$$4.FncFlags.HasSelfReference])
    }
    function v173() {
      if(this.internalNameCache == null) {
        var extName = this.getNameText();
        if(extName) {
          this.internalNameCache = "_internal_" + extName
        }else {
          var v11649 = internalId;
          internalId = internalId + 1;
          this.internalNameCache = "_internal_" + v11649
        }
      }
      return this.internalNameCache
    }
    function v172() {
      return true
    }
    function FuncDecl$$1(name$$34, bod, isConstructor, args$$1, vars, scopes, statics, nodeType$$7) {
      JAM.call(_super$$19.call, _super$$19, [this, nodeType$$7]);
      this.name = name$$34;
      this.bod = bod;
      this.isConstructor = isConstructor;
      this.arguments = args$$1;
      this.vars = vars;
      this.scopes = scopes;
      this.statics = statics;
      this.hint = null;
      this.fncFlags = TypeScript$$4.FncFlags.None;
      this.returnTypeAnnotation = null;
      this.variableArgList = false;
      this.jumpRefs = null;
      this.internalNameCache = null;
      this.tmp1Declared = false;
      this.enclosingFnc = null;
      this.freeVariables = [];
      this.unitIndex = -1;
      this.classDecl = null;
      this.boundToProperty = null;
      this.isOverload = false;
      this.innerStaticFuncs = [];
      this.isTargetTypedAsMethod = false;
      this.isInlineCallLiteral = false;
      this.accessorSymbol = null;
      this.leftCurlyCount = 0;
      this.rightCurlyCount = 0;
      this.returnStatementsWithExpressions = [];
      this.scopeType = null;
      this.endingToken = null;
      return
    }
    JAM.call(__extends, null, [FuncDecl$$1, _super$$19]);
    FuncDecl$$1.prototype.isDeclaration = v172;
    FuncDecl$$1.prototype.internalName = v173;
    FuncDecl$$1.prototype.hasSelfReference = v174;
    FuncDecl$$1.prototype.setHasSelfReference = v175;
    FuncDecl$$1.prototype.hasSuperReferenceInFatArrowFunction = v176;
    FuncDecl$$1.prototype.setHasSuperReferenceInFatArrowFunction = v177;
    FuncDecl$$1.prototype.addCloRef = v178;
    FuncDecl$$1.prototype.addJumpRef = v179;
    FuncDecl$$1.prototype.buildControlFlow = v180;
    FuncDecl$$1.prototype.typeCheck = v181;
    FuncDecl$$1.prototype.emit = v182;
    FuncDecl$$1.prototype.getNameText = v183;
    FuncDecl$$1.prototype.isMethod = v184;
    FuncDecl$$1.prototype.isCallMember = v185;
    FuncDecl$$1.prototype.isConstructMember = v186;
    FuncDecl$$1.prototype.isIndexerMember = v187;
    FuncDecl$$1.prototype.isSpecialFn = v188;
    FuncDecl$$1.prototype.isAnonymousFn = v189;
    FuncDecl$$1.prototype.isAccessor = v190;
    FuncDecl$$1.prototype.isGetAccessor = v191;
    FuncDecl$$1.prototype.isSetAccessor = v192;
    FuncDecl$$1.prototype.isAmbient = v193;
    FuncDecl$$1.prototype.isExported = v194;
    FuncDecl$$1.prototype.isPrivate = v195;
    FuncDecl$$1.prototype.isPublic = v196;
    FuncDecl$$1.prototype.isStatic = v197;
    FuncDecl$$1.prototype.treeViewLabel = v198;
    FuncDecl$$1.prototype.ClearFlags = v199;
    FuncDecl$$1.prototype.isSignature = v200;
    return FuncDecl$$1
  }
  function v171(_super$$18) {
    function v170(emitter$$14, tokenId$$14, startLine$$14) {
      JAM.call(emitter$$14.emitParensAndCommentsInPlace, emitter$$14, [this, true]);
      JAM.call(emitter$$14.recordSourceMappingStart, emitter$$14, [this]);
      JAM.call(emitter$$14.writeToOutput, emitter$$14, [this.id.actualText]);
      JAM.call(emitter$$14.recordSourceMappingEnd, emitter$$14, [this]);
      JAM.call(emitter$$14.emitParensAndCommentsInPlace, emitter$$14, [this, false]);
      return
    }
    function v169() {
      return"arg: " + this.id.actualText
    }
    function v168() {
      var v11683 = this.isOptional;
      if(!v11683) {
        v11683 = this.init
      }
      return v11683
    }
    function ArgDecl$$1(id$$4) {
      JAM.call(_super$$18.call, _super$$18, [this, id$$4, TypeScript$$4.NodeType.ArgDecl, 0]);
      this.isOptional = false;
      this.parameterPropertySym = null;
      return
    }
    JAM.call(__extends, null, [ArgDecl$$1, _super$$18]);
    ArgDecl$$1.prototype.isOptionalArg = v168;
    ArgDecl$$1.prototype.treeViewLabel = v169;
    ArgDecl$$1.prototype.emit = v170;
    return ArgDecl$$1
  }
  function v167(_super$$17) {
    function v166() {
      return"var " + this.id.actualText
    }
    function v165(emitter$$13, tokenId$$13, startLine$$13) {
      JAM.call(emitter$$13.emitJavascriptVarDecl, emitter$$13, [this, tokenId$$13]);
      return
    }
    function v164() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.varFlags, TypeScript$$4.VarFlags.Static])
    }
    function v163() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.varFlags, TypeScript$$4.VarFlags.Exported])
    }
    function v162() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.varFlags, TypeScript$$4.VarFlags.Ambient])
    }
    function VarDecl$$1(id$$3, nest) {
      JAM.call(_super$$17.call, _super$$17, [this, id$$3, TypeScript$$4.NodeType.VarDecl, nest]);
      return
    }
    JAM.call(__extends, null, [VarDecl$$1, _super$$17]);
    VarDecl$$1.prototype.isAmbient = v162;
    VarDecl$$1.prototype.isExported = v163;
    VarDecl$$1.prototype.isStatic = v164;
    VarDecl$$1.prototype.emit = v165;
    VarDecl$$1.prototype.treeViewLabel = v166;
    return VarDecl$$1
  }
  function v161(_super$$16) {
    function v160() {
      return this.treeViewLabel()
    }
    function v159(typeFlow$$12) {
      return JAM.call(typeFlow$$12.typeCheckBoundDecl, typeFlow$$12, [this])
    }
    function v158() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.varFlags, TypeScript$$4.VarFlags.Property])
    }
    function v157() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.varFlags, TypeScript$$4.VarFlags.Public])
    }
    function v156() {
      return JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.varFlags, TypeScript$$4.VarFlags.Private])
    }
    function v155() {
      return true
    }
    function v154() {
      return true
    }
    function BoundDecl$$1(id$$2, nodeType$$6, nestingLevel) {
      JAM.call(_super$$16.call, _super$$16, [this, nodeType$$6]);
      this.id = id$$2;
      this.nestingLevel = nestingLevel;
      this.init = null;
      this.typeExpr = null;
      this.varFlags = TypeScript$$4.VarFlags.None;
      this.sym = null;
      return
    }
    JAM.call(__extends, null, [BoundDecl$$1, _super$$16]);
    BoundDecl$$1.prototype.isDeclaration = v154;
    BoundDecl$$1.prototype.isStatementOrExpression = v155;
    BoundDecl$$1.prototype.isPrivate = v156;
    BoundDecl$$1.prototype.isPublic = v157;
    BoundDecl$$1.prototype.isProperty = v158;
    BoundDecl$$1.prototype.typeCheck = v159;
    BoundDecl$$1.prototype.printLabel = v160;
    return BoundDecl$$1
  }
  function v153(_super$$15) {
    function v152() {
      if(this.alias.nodeType == TypeScript$$4.NodeType.Name) {
        return this.alias.actualText
      }else {
        var dotExpr$$1 = this.alias;
        var firstMod = dotExpr$$1.operand1;
        return firstMod.actualText
      }
      return
    }
    function v151(aliasAST) {
      if(typeof aliasAST === "undefined") {
        aliasAST = this.alias
      }
      if(aliasAST.nodeType == TypeScript$$4.NodeType.Name) {
        return aliasAST.actualText
      }else {
        var dotExpr = aliasAST;
        return JAM.call(this.getAliasName, this, [dotExpr.operand1]) + "." + JAM.call(this.getAliasName, this, [dotExpr.operand2])
      }
      return
    }
    function v150(typeFlow$$11) {
      return JAM.call(typeFlow$$11.typeCheckImportDecl, typeFlow$$11, [this])
    }
    function v149(emitter$$12, tokenId$$12, startLine$$12) {
      var mod = this.alias.type;
      var v18524 = !this.isDynamicImport;
      if(!v18524) {
        var v22695 = this.id.sym;
        if(v22695) {
          v22695 = !this.id.sym.onlyReferencedAsTypeRef
        }
        v18524 = v22695
      }
      if(v18524) {
        var prevModAliasId = emitter$$12.modAliasId;
        var prevFirstModAlias = emitter$$12.firstModAlias;
        JAM.call(emitter$$12.recordSourceMappingStart, emitter$$12, [this]);
        JAM.call(emitter$$12.emitParensAndCommentsInPlace, emitter$$12, [this, true]);
        JAM.call(emitter$$12.writeToOutput, emitter$$12, ["var " + this.id.actualText + " = "]);
        emitter$$12.modAliasId = this.id.actualText;
        var v11724 = emitter$$12;
        var v27429 = this.firstAliasedModToString();
        v11724.firstModAlias = v27429;
        JAM.call(emitter$$12.emitJavascript, emitter$$12, [this.alias, TypeScript$$4.TokenID.Tilde, false]);
        if(!this.isDynamicImport) {
          JAM.call(emitter$$12.writeToOutput, emitter$$12, [";"])
        }
        JAM.call(emitter$$12.emitParensAndCommentsInPlace, emitter$$12, [this, false]);
        JAM.call(emitter$$12.recordSourceMappingEnd, emitter$$12, [this]);
        emitter$$12.modAliasId = prevModAliasId;
        emitter$$12.firstModAlias = prevFirstModAlias
      }
      return
    }
    function v148() {
      return true
    }
    function v147() {
      return true
    }
    function ImportDeclaration$$1(id$$1, alias) {
      JAM.call(_super$$15.call, _super$$15, [this, TypeScript$$4.NodeType.ImportDeclaration]);
      this.id = id$$1;
      this.alias = alias;
      this.varFlags = TypeScript$$4.VarFlags.None;
      this.isDynamicImport = false;
      return
    }
    JAM.call(__extends, null, [ImportDeclaration$$1, _super$$15]);
    ImportDeclaration$$1.prototype.isStatementOrExpression = v147;
    ImportDeclaration$$1.prototype.isDeclaration = v148;
    ImportDeclaration$$1.prototype.emit = v149;
    ImportDeclaration$$1.prototype.typeCheck = v150;
    ImportDeclaration$$1.prototype.getAliasName = v151;
    ImportDeclaration$$1.prototype.firstAliasedModToString = v152;
    return ImportDeclaration$$1
  }
  function v146(_super$$14) {
    function ModuleElement$$1(nodeType$$5) {
      JAM.call(_super$$14.call, _super$$14, [this, nodeType$$5]);
      return
    }
    JAM.call(__extends, null, [ModuleElement$$1, _super$$14]);
    return ModuleElement$$1
  }
  function v145(_super$$13) {
    function v144() {
      return this.text
    }
    function v143() {
      return"st: " + this.text
    }
    function v142(typeFlow$$10) {
      this.type = typeFlow$$10.stringType;
      return this
    }
    function v141(emitter$$11, tokenId$$11, startLine$$11) {
      JAM.call(emitter$$11.emitParensAndCommentsInPlace, emitter$$11, [this, true]);
      JAM.call(emitter$$11.recordSourceMappingStart, emitter$$11, [this]);
      JAM.call(emitter$$11.emitStringLiteral, emitter$$11, [this.text]);
      JAM.call(emitter$$11.recordSourceMappingEnd, emitter$$11, [this]);
      JAM.call(emitter$$11.emitParensAndCommentsInPlace, emitter$$11, [this, false]);
      return
    }
    function StringLiteral$$1(text$$8) {
      JAM.call(_super$$13.call, _super$$13, [this, TypeScript$$4.NodeType.QString]);
      this.text = text$$8;
      return
    }
    JAM.call(__extends, null, [StringLiteral$$1, _super$$13]);
    StringLiteral$$1.prototype.emit = v141;
    StringLiteral$$1.prototype.typeCheck = v142;
    StringLiteral$$1.prototype.treeViewLabel = v143;
    StringLiteral$$1.prototype.printLabel = v144;
    return StringLiteral$$1
  }
  function v140(_super$$12) {
    function v139(emitter$$10, tokenId$$10, startLine$$10) {
      JAM.call(emitter$$10.emitParensAndCommentsInPlace, emitter$$10, [this, true]);
      JAM.call(emitter$$10.recordSourceMappingStart, emitter$$10, [this]);
      JAM.call(emitter$$10.writeToOutput, emitter$$10, [this.regex.toString()]);
      JAM.call(emitter$$10.recordSourceMappingEnd, emitter$$10, [this]);
      JAM.call(emitter$$10.emitParensAndCommentsInPlace, emitter$$10, [this, false]);
      return
    }
    function v138(typeFlow$$9) {
      this.type = typeFlow$$9.regexType;
      return this
    }
    function RegexLiteral$$1(regex$$1) {
      JAM.call(_super$$12.call, _super$$12, [this, TypeScript$$4.NodeType.Regex]);
      this.regex = regex$$1;
      return
    }
    JAM.call(__extends, null, [RegexLiteral$$1, _super$$12]);
    RegexLiteral$$1.prototype.typeCheck = v138;
    RegexLiteral$$1.prototype.emit = v139;
    return RegexLiteral$$1
  }
  function v137(_super$$11) {
    function v136() {
      if(Math.floor(this.value) != this.value) {
        return this.value.toFixed(2).toString()
      }else {
        if(this.hasEmptyFraction) {
          return this.value.toString() + ".0"
        }else {
          return this.value.toString()
        }
      }
      return
    }
    function v135(emitter$$9, tokenId$$9, startLine$$9) {
      JAM.call(emitter$$9.emitParensAndCommentsInPlace, emitter$$9, [this, true]);
      JAM.call(emitter$$9.recordSourceMappingStart, emitter$$9, [this]);
      if(this.isNegativeZero) {
        JAM.call(emitter$$9.writeToOutput, emitter$$9, ["-"])
      }
      JAM.call(emitter$$9.writeToOutput, emitter$$9, [this.value.toString()]);
      if(this.hasEmptyFraction) {
        JAM.call(emitter$$9.writeToOutput, emitter$$9, [".0"])
      }
      JAM.call(emitter$$9.recordSourceMappingEnd, emitter$$9, [this]);
      JAM.call(emitter$$9.emitParensAndCommentsInPlace, emitter$$9, [this, false]);
      return
    }
    function v134() {
      return"num: " + this.printLabel()
    }
    function v133(typeFlow$$8) {
      this.type = typeFlow$$8.doubleType;
      return this
    }
    function NumberLiteral$$1(value$$30, hasEmptyFraction) {
      JAM.call(_super$$11.call, _super$$11, [this, TypeScript$$4.NodeType.NumberLit]);
      this.value = value$$30;
      this.hasEmptyFraction = hasEmptyFraction;
      this.isNegativeZero = false;
      return
    }
    JAM.call(__extends, null, [NumberLiteral$$1, _super$$11]);
    NumberLiteral$$1.prototype.typeCheck = v133;
    NumberLiteral$$1.prototype.treeViewLabel = v134;
    NumberLiteral$$1.prototype.emit = v135;
    NumberLiteral$$1.prototype.printLabel = v136;
    return NumberLiteral$$1
  }
  function v132(_super$$10) {
    function v131(emitter$$8, tokenId$$8, startLine$$8) {
      JAM.call(emitter$$8.emitParensAndCommentsInPlace, emitter$$8, [this, true]);
      JAM.call(emitter$$8.recordSourceMappingStart, emitter$$8, [this]);
      JAM.call(emitter$$8.emitJavascript, emitter$$8, [this.operand1, TypeScript$$4.TokenID.Question, false]);
      JAM.call(emitter$$8.writeToOutput, emitter$$8, [" ? "]);
      JAM.call(emitter$$8.emitJavascript, emitter$$8, [this.operand2, TypeScript$$4.TokenID.Question, false]);
      JAM.call(emitter$$8.writeToOutput, emitter$$8, [" : "]);
      JAM.call(emitter$$8.emitJavascript, emitter$$8, [this.operand3, TypeScript$$4.TokenID.Question, false]);
      JAM.call(emitter$$8.recordSourceMappingEnd, emitter$$8, [this]);
      JAM.call(emitter$$8.emitParensAndCommentsInPlace, emitter$$8, [this, false]);
      return
    }
    function v130(typeFlow$$7) {
      return JAM.call(typeFlow$$7.typeCheckQMark, typeFlow$$7, [this])
    }
    function ConditionalExpression$$1(operand1$$1, operand2$$1, operand3) {
      JAM.call(_super$$10.call, _super$$10, [this, TypeScript$$4.NodeType.ConditionalExpression]);
      this.operand1 = operand1$$1;
      this.operand2 = operand2$$1;
      this.operand3 = operand3;
      return
    }
    JAM.call(__extends, null, [ConditionalExpression$$1, _super$$10]);
    ConditionalExpression$$1.prototype.typeCheck = v130;
    ConditionalExpression$$1.prototype.emit = v131;
    return ConditionalExpression$$1
  }
  function v129(_super$$9) {
    function v128(emitter$$7, tokenId$$7, startLine$$7) {
      var v11771 = TypeScript$$4.nodeTypeToTokTable;
      var v11772 = this.nodeType;
      introspect(JAM.policy.p1) {
        var binTokenId = v11771[v11772]
      }
      JAM.call(emitter$$7.emitParensAndCommentsInPlace, emitter$$7, [this, true]);
      JAM.call(emitter$$7.recordSourceMappingStart, emitter$$7, [this]);
      if(binTokenId != undefined) {
        JAM.call(emitter$$7.emitJavascript, emitter$$7, [this.operand1, binTokenId, false]);
        var v24745 = TypeScript$$4.tokenTable;
        introspect(JAM.policy.p1) {
          var v22699 = v24745[binTokenId]
        }
        if(v22699.text == "instanceof") {
          JAM.call(emitter$$7.writeToOutput, emitter$$7, [" instanceof "])
        }else {
          var v24746 = TypeScript$$4.tokenTable;
          introspect(JAM.policy.p1) {
            var v22700 = v24746[binTokenId]
          }
          if(v22700.text == "in") {
            JAM.call(emitter$$7.writeToOutput, emitter$$7, [" in "])
          }else {
            var v25729 = TypeScript$$4.tokenTable;
            introspect(JAM.policy.p1) {
              var v24747 = v25729[binTokenId]
            }
            JAM.call(emitter$$7.writeToOutputTrimmable, emitter$$7, [" " + v24747.text + " "])
          }
        }
        JAM.call(emitter$$7.emitJavascript, emitter$$7, [this.operand2, binTokenId, false])
      }else {
        switch(this.nodeType) {
          case TypeScript$$4.NodeType.Dot:
            if(!JAM.call(emitter$$7.tryEmitConstant, emitter$$7, [this])) {
              JAM.call(emitter$$7.emitJavascript, emitter$$7, [this.operand1, TypeScript$$4.TokenID.Dot, false]);
              JAM.call(emitter$$7.writeToOutput, emitter$$7, ["."]);
              JAM.call(emitter$$7.emitJavascriptName, emitter$$7, [this.operand2, false])
            }
            break;
          case TypeScript$$4.NodeType.Index:
            JAM.call(emitter$$7.emitIndex, emitter$$7, [this.operand1, this.operand2]);
            break;
          case TypeScript$$4.NodeType.Member:
            var v18547 = this.operand2.nodeType == TypeScript$$4.NodeType.FuncDecl;
            if(v18547) {
              v18547 = this.operand2.isAccessor()
            }
            if(v18547) {
              var funcDecl = this.operand2;
              if(JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [funcDecl.fncFlags, TypeScript$$4.FncFlags.GetAccessor])) {
                JAM.call(emitter$$7.writeToOutput, emitter$$7, ["get "])
              }else {
                JAM.call(emitter$$7.writeToOutput, emitter$$7, ["set "])
              }
              JAM.call(emitter$$7.emitJavascript, emitter$$7, [this.operand1, TypeScript$$4.TokenID.Colon, false])
            }else {
              JAM.call(emitter$$7.emitJavascript, emitter$$7, [this.operand1, TypeScript$$4.TokenID.Colon, false]);
              JAM.call(emitter$$7.writeToOutputTrimmable, emitter$$7, [": "])
            }
            JAM.call(emitter$$7.emitJavascript, emitter$$7, [this.operand2, TypeScript$$4.TokenID.Comma, false]);
            break;
          case TypeScript$$4.NodeType.Comma:
            JAM.call(emitter$$7.emitJavascript, emitter$$7, [this.operand1, TypeScript$$4.TokenID.Comma, false]);
            if(emitter$$7.emitState.inObjectLiteral) {
              JAM.call(emitter$$7.writeLineToOutput, emitter$$7, [", "])
            }else {
              JAM.call(emitter$$7.writeToOutput, emitter$$7, [","])
            }
            JAM.call(emitter$$7.emitJavascript, emitter$$7, [this.operand2, TypeScript$$4.TokenID.Comma, false]);
            break;
          case TypeScript$$4.NodeType.Is:
            throw new Error("should be de-sugared during type check");;
          default:
            throw new Error("please implement in derived class");
        }
      }
      JAM.call(emitter$$7.recordSourceMappingEnd, emitter$$7, [this]);
      JAM.call(emitter$$7.emitParensAndCommentsInPlace, emitter$$7, [this, false]);
      return
    }
    function v127(typeFlow$$6) {
      switch(this.nodeType) {
        case TypeScript$$4.NodeType.Dot:
          return JAM.call(typeFlow$$6.typeCheckDotOperator, typeFlow$$6, [this]);
        case TypeScript$$4.NodeType.Asg:
          return JAM.call(typeFlow$$6.typeCheckAsgOperator, typeFlow$$6, [this]);
        case TypeScript$$4.NodeType.Add:
        ;
        case TypeScript$$4.NodeType.Sub:
        ;
        case TypeScript$$4.NodeType.Mul:
        ;
        case TypeScript$$4.NodeType.Div:
        ;
        case TypeScript$$4.NodeType.Mod:
        ;
        case TypeScript$$4.NodeType.Or:
        ;
        case TypeScript$$4.NodeType.And:
          return JAM.call(typeFlow$$6.typeCheckArithmeticOperator, typeFlow$$6, [this, false]);
        case TypeScript$$4.NodeType.Xor:
          return JAM.call(typeFlow$$6.typeCheckBitwiseOperator, typeFlow$$6, [this, false]);
        case TypeScript$$4.NodeType.Ne:
        ;
        case TypeScript$$4.NodeType.Eq:
          var text$$7;
          if(typeFlow$$6.checker.styleSettings.eqeqeq) {
            var v11799 = TypeScript$$4.nodeTypeTable;
            var v11800 = this.nodeType;
            introspect(JAM.policy.p1) {
              text$$7 = v11799[v11800]
            }
            var v11801 = typeFlow$$6.checker.errorReporter;
            JAM.call(v11801.styleError, v11801, [this, "use of " + text$$7])
          }else {
            if(typeFlow$$6.checker.styleSettings.eqnull) {
              var v11803 = TypeScript$$4.nodeTypeTable;
              var v11804 = this.nodeType;
              introspect(JAM.policy.p1) {
                text$$7 = v11803[v11804]
              }
              var v18559 = this.operand2 !== null;
              if(v18559) {
                v18559 = this.operand2.nodeType == TypeScript$$4.NodeType.Null
              }
              if(v18559) {
                var v11805 = typeFlow$$6.checker.errorReporter;
                JAM.call(v11805.styleError, v11805, [this, "use of " + text$$7 + " to compare with null"])
              }
            }
          }
        ;
        case TypeScript$$4.NodeType.Eqv:
        ;
        case TypeScript$$4.NodeType.NEqv:
        ;
        case TypeScript$$4.NodeType.Lt:
        ;
        case TypeScript$$4.NodeType.Le:
        ;
        case TypeScript$$4.NodeType.Ge:
        ;
        case TypeScript$$4.NodeType.Gt:
          return JAM.call(typeFlow$$6.typeCheckBooleanOperator, typeFlow$$6, [this]);
        case TypeScript$$4.NodeType.Index:
          return JAM.call(typeFlow$$6.typeCheckIndex, typeFlow$$6, [this]);
        case TypeScript$$4.NodeType.Member:
          this.type = typeFlow$$6.voidType;
          return this;
        case TypeScript$$4.NodeType.LogOr:
          return JAM.call(typeFlow$$6.typeCheckLogOr, typeFlow$$6, [this]);
        case TypeScript$$4.NodeType.LogAnd:
          return JAM.call(typeFlow$$6.typeCheckLogAnd, typeFlow$$6, [this]);
        case TypeScript$$4.NodeType.AsgAdd:
        ;
        case TypeScript$$4.NodeType.AsgSub:
        ;
        case TypeScript$$4.NodeType.AsgMul:
        ;
        case TypeScript$$4.NodeType.AsgDiv:
        ;
        case TypeScript$$4.NodeType.AsgMod:
        ;
        case TypeScript$$4.NodeType.AsgOr:
        ;
        case TypeScript$$4.NodeType.AsgAnd:
          return JAM.call(typeFlow$$6.typeCheckArithmeticOperator, typeFlow$$6, [this, true]);
        case TypeScript$$4.NodeType.AsgXor:
          return JAM.call(typeFlow$$6.typeCheckBitwiseOperator, typeFlow$$6, [this, true]);
        case TypeScript$$4.NodeType.Lsh:
        ;
        case TypeScript$$4.NodeType.Rsh:
        ;
        case TypeScript$$4.NodeType.Rs2:
          return JAM.call(typeFlow$$6.typeCheckShift, typeFlow$$6, [this, false]);
        case TypeScript$$4.NodeType.AsgLsh:
        ;
        case TypeScript$$4.NodeType.AsgRsh:
        ;
        case TypeScript$$4.NodeType.AsgRs2:
          return JAM.call(typeFlow$$6.typeCheckShift, typeFlow$$6, [this, true]);
        case TypeScript$$4.NodeType.Comma:
          return JAM.call(typeFlow$$6.typeCheckCommaOperator, typeFlow$$6, [this]);
        case TypeScript$$4.NodeType.InstOf:
          return JAM.call(typeFlow$$6.typeCheckInstOf, typeFlow$$6, [this]);
        case TypeScript$$4.NodeType.In:
          return JAM.call(typeFlow$$6.typeCheckInOperator, typeFlow$$6, [this]);
        case TypeScript$$4.NodeType.From:
          var v11810 = typeFlow$$6.checker.errorReporter;
          JAM.call(v11810.simpleError, v11810, [this, "Illegal use of 'from' keyword in binary expression"]);
          break;
        default:
          throw new Error("please implement in derived class");
      }
      return this
    }
    function BinaryExpression$$1(nodeType$$4, operand1, operand2) {
      JAM.call(_super$$9.call, _super$$9, [this, nodeType$$4]);
      this.operand1 = operand1;
      this.operand2 = operand2;
      return
    }
    JAM.call(__extends, null, [BinaryExpression$$1, _super$$9]);
    BinaryExpression$$1.prototype.typeCheck = v127;
    BinaryExpression$$1.prototype.emit = v128;
    return BinaryExpression$$1
  }
  function v126(_super$$8) {
    function v125(emitter$$6, tokenId$$6, startLine$$6) {
      JAM.call(emitter$$6.emitParensAndCommentsInPlace, emitter$$6, [this, true]);
      JAM.call(emitter$$6.recordSourceMappingStart, emitter$$6, [this]);
      if(this.nodeType == TypeScript$$4.NodeType.New) {
        JAM.call(emitter$$6.emitNew, emitter$$6, [this.target, this.arguments])
      }else {
        JAM.call(emitter$$6.emitCall, emitter$$6, [this, this.target, this.arguments])
      }
      JAM.call(emitter$$6.recordSourceMappingEnd, emitter$$6, [this]);
      JAM.call(emitter$$6.emitParensAndCommentsInPlace, emitter$$6, [this, false]);
      return
    }
    function v124(typeFlow$$5) {
      if(this.nodeType == TypeScript$$4.NodeType.New) {
        return JAM.call(typeFlow$$5.typeCheckNew, typeFlow$$5, [this])
      }else {
        return JAM.call(typeFlow$$5.typeCheckCall, typeFlow$$5, [this])
      }
      return
    }
    function CallExpression$$1(nodeType$$3, target$$37, args) {
      JAM.call(_super$$8.call, _super$$8, [this, nodeType$$3]);
      this.target = target$$37;
      this.arguments = args;
      this.signature = null;
      this.minChar = this.target.minChar;
      return
    }
    JAM.call(__extends, null, [CallExpression$$1, _super$$8]);
    CallExpression$$1.prototype.typeCheck = v124;
    CallExpression$$1.prototype.emit = v125;
    return CallExpression$$1
  }
  function v123(_super$$7) {
    function v122(emitter$$5, tokenId$$5, startLine$$5) {
      JAM.call(emitter$$5.emitParensAndCommentsInPlace, emitter$$5, [this, true]);
      JAM.call(emitter$$5.recordSourceMappingStart, emitter$$5, [this]);
      switch(this.nodeType) {
        case TypeScript$$4.NodeType.IncPost:
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.PlusPlus, false]);
          JAM.call(emitter$$5.writeToOutput, emitter$$5, ["++"]);
          break;
        case TypeScript$$4.NodeType.LogNot:
          JAM.call(emitter$$5.writeToOutput, emitter$$5, ["!"]);
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.Exclamation, false]);
          break;
        case TypeScript$$4.NodeType.DecPost:
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.MinusMinus, false]);
          JAM.call(emitter$$5.writeToOutput, emitter$$5, ["--"]);
          break;
        case TypeScript$$4.NodeType.ObjectLit:
          JAM.call(emitter$$5.emitObjectLiteral, emitter$$5, [this.operand]);
          break;
        case TypeScript$$4.NodeType.ArrayLit:
          JAM.call(emitter$$5.emitArrayLiteral, emitter$$5, [this.operand]);
          break;
        case TypeScript$$4.NodeType.Not:
          JAM.call(emitter$$5.writeToOutput, emitter$$5, ["~"]);
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.Tilde, false]);
          break;
        case TypeScript$$4.NodeType.Neg:
          JAM.call(emitter$$5.writeToOutput, emitter$$5, ["-"]);
          if(this.operand.nodeType == TypeScript$$4.NodeType.Neg) {
            this.operand.isParenthesized = true
          }
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.Minus, false]);
          break;
        case TypeScript$$4.NodeType.Pos:
          JAM.call(emitter$$5.writeToOutput, emitter$$5, ["+"]);
          if(this.operand.nodeType == TypeScript$$4.NodeType.Pos) {
            this.operand.isParenthesized = true
          }
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.Plus, false]);
          break;
        case TypeScript$$4.NodeType.IncPre:
          JAM.call(emitter$$5.writeToOutput, emitter$$5, ["++"]);
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.PlusPlus, false]);
          break;
        case TypeScript$$4.NodeType.DecPre:
          JAM.call(emitter$$5.writeToOutput, emitter$$5, ["--"]);
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.MinusMinus, false]);
          break;
        case TypeScript$$4.NodeType.Throw:
          JAM.call(emitter$$5.writeToOutput, emitter$$5, ["throw "]);
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.Tilde, false]);
          JAM.call(emitter$$5.writeToOutput, emitter$$5, [";"]);
          break;
        case TypeScript$$4.NodeType.Typeof:
          JAM.call(emitter$$5.writeToOutput, emitter$$5, ["typeof "]);
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.Tilde, false]);
          break;
        case TypeScript$$4.NodeType.Delete:
          JAM.call(emitter$$5.writeToOutput, emitter$$5, ["delete "]);
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.Tilde, false]);
          break;
        case TypeScript$$4.NodeType.Void:
          JAM.call(emitter$$5.writeToOutput, emitter$$5, ["void "]);
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.Tilde, false]);
          break;
        case TypeScript$$4.NodeType.TypeAssertion:
          JAM.call(emitter$$5.emitJavascript, emitter$$5, [this.operand, TypeScript$$4.TokenID.Tilde, false]);
          break;
        default:
          throw new Error("please implement in derived class");
      }
      JAM.call(emitter$$5.recordSourceMappingEnd, emitter$$5, [this]);
      JAM.call(emitter$$5.emitParensAndCommentsInPlace, emitter$$5, [this, false]);
      return
    }
    function v121(typeFlow$$4) {
      switch(this.nodeType) {
        case TypeScript$$4.NodeType.Not:
          return JAM.call(typeFlow$$4.typeCheckBitNot, typeFlow$$4, [this]);
        case TypeScript$$4.NodeType.LogNot:
          return JAM.call(typeFlow$$4.typeCheckLogNot, typeFlow$$4, [this]);
        case TypeScript$$4.NodeType.Pos:
        ;
        case TypeScript$$4.NodeType.Neg:
          return JAM.call(typeFlow$$4.typeCheckUnaryNumberOperator, typeFlow$$4, [this]);
        case TypeScript$$4.NodeType.IncPost:
        ;
        case TypeScript$$4.NodeType.IncPre:
        ;
        case TypeScript$$4.NodeType.DecPost:
        ;
        case TypeScript$$4.NodeType.DecPre:
          return JAM.call(typeFlow$$4.typeCheckIncOrDec, typeFlow$$4, [this]);
        case TypeScript$$4.NodeType.ArrayLit:
          JAM.call(typeFlow$$4.typeCheckArrayLit, typeFlow$$4, [this]);
          return this;
        case TypeScript$$4.NodeType.ObjectLit:
          JAM.call(typeFlow$$4.typeCheckObjectLit, typeFlow$$4, [this]);
          return this;
        case TypeScript$$4.NodeType.Throw:
          var v27430 = JAM.call(typeFlow$$4.typeCheck, typeFlow$$4, [this.operand]);
          this.operand = v27430;
          this.type = typeFlow$$4.voidType;
          return this;
        case TypeScript$$4.NodeType.Typeof:
          var v27431 = JAM.call(typeFlow$$4.typeCheck, typeFlow$$4, [this.operand]);
          this.operand = v27431;
          this.type = typeFlow$$4.stringType;
          return this;
        case TypeScript$$4.NodeType.Delete:
          var v27432 = JAM.call(typeFlow$$4.typeCheck, typeFlow$$4, [this.operand]);
          this.operand = v27432;
          this.type = typeFlow$$4.booleanType;
          break;
        case TypeScript$$4.NodeType.TypeAssertion:
          var v27433 = JAM.call(typeFlow$$4.typeCheck, typeFlow$$4, [this.castTerm]);
          this.castTerm = v27433;
          var applyTargetType = !this.operand.isParenthesized;
          var v11861;
          if(applyTargetType) {
            v11861 = this.castTerm.type
          }else {
            v11861 = null
          }
          var targetType = v11861;
          var v11862 = typeFlow$$4.checker;
          JAM.call(v11862.typeCheckWithContextualType, v11862, [targetType, typeFlow$$4.checker.inProvisionalTypecheckMode(), true, this.operand]);
          JAM.call(typeFlow$$4.castWithCoercion, typeFlow$$4, [this.operand, this.castTerm.type, false, true]);
          this.type = this.castTerm.type;
          return this;
        case TypeScript$$4.NodeType.Void:
          var v27434 = JAM.call(typeFlow$$4.typeCheck, typeFlow$$4, [this.operand]);
          this.operand = v27434;
          this.type = typeFlow$$4.checker.undefinedType;
          break;
        default:
          throw new Error("please implement in derived class");
      }
      return this
    }
    function v120(context$$9) {
      var v11871 = _super$$7.prototype.addToControlFlow;
      JAM.call(v11871.call, v11871, [this, context$$9]);
      if(this.nodeType == TypeScript$$4.NodeType.Throw) {
        context$$9.returnStmt()
      }
      return
    }
    function UnaryExpression$$1(nodeType$$2, operand) {
      JAM.call(_super$$7.call, _super$$7, [this, nodeType$$2]);
      this.operand = operand;
      this.targetType = null;
      this.castTerm = null;
      return
    }
    JAM.call(__extends, null, [UnaryExpression$$1, _super$$7]);
    UnaryExpression$$1.prototype.addToControlFlow = v120;
    UnaryExpression$$1.prototype.typeCheck = v121;
    UnaryExpression$$1.prototype.emit = v122;
    return UnaryExpression$$1
  }
  function v119(_super$$6) {
    function v118() {
      return true
    }
    function v117() {
      return true
    }
    function Expression$$1(nodeType$$1) {
      JAM.call(_super$$6.call, _super$$6, [this, nodeType$$1]);
      return
    }
    JAM.call(__extends, null, [Expression$$1, _super$$6]);
    Expression$$1.prototype.isExpression = v117;
    Expression$$1.prototype.isStatementOrExpression = v118;
    return Expression$$1
  }
  function v116(_super$$5) {
    function v115(emitter$$4, tokenId$$4, startLine$$4) {
      JAM.call(emitter$$4.emitParensAndCommentsInPlace, emitter$$4, [this, true]);
      JAM.call(emitter$$4.recordSourceMappingStart, emitter$$4, [this]);
      JAM.call(emitter$$4.recordSourceMappingStart, emitter$$4, [this.id]);
      JAM.call(emitter$$4.writeToOutput, emitter$$4, [this.id.actualText]);
      JAM.call(emitter$$4.recordSourceMappingEnd, emitter$$4, [this.id]);
      JAM.call(emitter$$4.writeLineToOutput, emitter$$4, [":"]);
      JAM.call(emitter$$4.recordSourceMappingEnd, emitter$$4, [this]);
      JAM.call(emitter$$4.emitParensAndCommentsInPlace, emitter$$4, [this, false]);
      return
    }
    function v114(typeFlow$$3) {
      this.type = typeFlow$$3.voidType;
      return this
    }
    function v113() {
      return this.id.actualText + ":"
    }
    function Label$$1(id) {
      JAM.call(_super$$5.call, _super$$5, [this, TypeScript$$4.NodeType.Label]);
      this.id = id;
      return
    }
    JAM.call(__extends, null, [Label$$1, _super$$5]);
    Label$$1.prototype.printLabel = v113;
    Label$$1.prototype.typeCheck = v114;
    Label$$1.prototype.emit = v115;
    return Label$$1
  }
  function v112(_super$$4) {
    function v111(emitter$$3, tokenId$$3, startLine$$3) {
      return
    }
    function v110() {
      return true
    }
    function MissingIdentifier$$1() {
      JAM.call(_super$$4.call, _super$$4, [this, "__missing"]);
      return
    }
    JAM.call(__extends, null, [MissingIdentifier$$1, _super$$4]);
    MissingIdentifier$$1.prototype.isMissing = v110;
    MissingIdentifier$$1.prototype.emit = v111;
    return MissingIdentifier$$1
  }
  function v109(_super$$3) {
    function fromToken(token$$4) {
      return new Identifier$$1(token$$4.getText(), token$$4.hasEscapeSequence)
    }
    function v108(emitter$$2, tokenId$$2, startLine$$2) {
      JAM.call(emitter$$2.emitJavascriptName, emitter$$2, [this, true]);
      return
    }
    function v107(typeFlow$$2) {
      return JAM.call(typeFlow$$2.typeCheckName, typeFlow$$2, [this])
    }
    function v106() {
      if(this.actualText) {
        return"id: " + this.actualText
      }else {
        return"name node"
      }
      return
    }
    function v105() {
      return"id: " + this.actualText
    }
    function v104() {
      return true
    }
    function v103() {
      return false
    }
    function v102(actualText$$1, hasEscapeSequence$$1) {
      this.actualText = actualText$$1;
      if(hasEscapeSequence$$1) {
        var v27435 = JAM.call(AST.getResolvedIdentifierName, AST, [actualText$$1]);
        this.text = v27435
      }else {
        this.text = actualText$$1
      }
      return
    }
    function Identifier$$1(actualText, hasEscapeSequence) {
      JAM.call(_super$$3.call, _super$$3, [this, TypeScript$$4.NodeType.Name]);
      this.actualText = actualText;
      this.hasEscapeSequence = hasEscapeSequence;
      this.sym = null;
      this.cloId = -1;
      JAM.call(this.setText, this, [actualText, hasEscapeSequence]);
      return
    }
    JAM.call(__extends, null, [Identifier$$1, _super$$3]);
    Identifier$$1.prototype.setText = v102;
    Identifier$$1.prototype.isMissing = v103;
    Identifier$$1.prototype.isLeaf = v104;
    Identifier$$1.prototype.treeViewLabel = v105;
    Identifier$$1.prototype.printLabel = v106;
    Identifier$$1.prototype.typeCheck = v107;
    Identifier$$1.prototype.emit = v108;
    Identifier$$1.fromToken = fromToken;
    return Identifier$$1
  }
  function v101(_super$$2) {
    function v100(typeFlow$$1) {
      var len$$3 = this.members.length;
      typeFlow$$1.nestingLevel = typeFlow$$1.nestingLevel + 1;
      var i$$15 = 0;
      var v11905 = i$$15 < len$$3;
      for(;v11905;) {
        var v18596 = this.members;
        introspect(JAM.policy.p1) {
          var v11904 = v18596[i$$15]
        }
        if(v11904) {
          var v11902 = this.members;
          var v11903 = i$$15;
          var v22718 = this.members;
          introspect(JAM.policy.p1) {
            var v18597 = v22718[i$$15]
          }
          var v27436 = JAM.call(v18597.typeCheck, v18597, [typeFlow$$1]);
          v11902[v11903] = v27436
        }
        i$$15 = i$$15 + 1;
        v11905 = i$$15 < len$$3
      }
      typeFlow$$1.nestingLevel = typeFlow$$1.nestingLevel - 1;
      return this
    }
    function v99(emitter$$1, tokenId$$1, startLine$$1) {
      JAM.call(emitter$$1.recordSourceMappingStart, emitter$$1, [this]);
      JAM.call(emitter$$1.emitJavascriptList, emitter$$1, [this, null, TypeScript$$4.TokenID.Semicolon, startLine$$1, false, false]);
      JAM.call(emitter$$1.recordSourceMappingEnd, emitter$$1, [this]);
      return
    }
    function v98(ast$$1) {
      if(ast$$1.nodeType == TypeScript$$4.NodeType.List) {
        var list = ast$$1;
        var i$$14 = 0;
        var len$$2 = list.members.length;
        var v11909 = i$$14 < len$$2;
        for(;v11909;) {
          var v18602 = list.members;
          introspect(JAM.policy.p1) {
            var v11908 = v18602[i$$14]
          }
          JAM.call(this.append, this, [v11908]);
          i$$14 = i$$14 + 1;
          v11909 = i$$14 < len$$2
        }
      }else {
        JAM.call(this.append, this, [ast$$1])
      }
      return this
    }
    function v97(ast) {
      JAM.set(this.members, this.members.length, ast);
      return this
    }
    function v96(context$$8) {
      var len$$1 = this.members.length;
      var i$$13 = 0;
      var v11918 = i$$13 < len$$1;
      for(;v11918;) {
        if(context$$8.noContinuation) {
          var v18604 = this.members;
          introspect(JAM.policy.p1) {
            var v11914 = v18604[i$$13]
          }
          JAM.call(context$$8.addUnreachable, context$$8, [v11914]);
          break
        }else {
          var v11915 = this.members;
          var v11916 = i$$13;
          var v22720 = this.members;
          introspect(JAM.policy.p1) {
            var v18605 = v22720[i$$13]
          }
          var v27437 = JAM.call(context$$8.walk, context$$8, [v18605, this]);
          v11915[v11916] = v27437
        }
        i$$13 = i$$13 + 1;
        v11918 = i$$13 < len$$1
      }
      context$$8.walker.options.goChildren = false;
      return
    }
    function ASTList$$1() {
      JAM.call(_super$$2.call, _super$$2, [this, TypeScript$$4.NodeType.List]);
      this.enclosingScope = null;
      var v27438 = new Array;
      this.members = v27438;
      return
    }
    JAM.call(__extends, null, [ASTList$$1, _super$$2]);
    ASTList$$1.prototype.addToControlFlow = v96;
    ASTList$$1.prototype.append = v97;
    ASTList$$1.prototype.appendAll = v98;
    ASTList$$1.prototype.emit = v99;
    ASTList$$1.prototype.typeCheck = v100;
    return ASTList$$1
  }
  function v95(_super$$1) {
    function IncompleteAST$$1(min, lim) {
      JAM.call(_super$$1.call, _super$$1, [this, TypeScript$$4.NodeType.Error]);
      this.minChar = min;
      this.limChar = lim;
      return
    }
    JAM.call(__extends, null, [IncompleteAST$$1, _super$$1]);
    return IncompleteAST$$1
  }
  function v94(_super) {
    function v93() {
      var v18609 = !this.isDeclaration();
      if(!v18609) {
        var v22722 = !this.preComments;
        if(!v22722) {
          v22722 = this.preComments.length == 0
        }
        v18609 = v22722
      }
      if(v18609) {
        return[]
      }
      if(!this.docComments) {
        var preCommentsLength = this.preComments.length;
        var docComments = [];
        var i$$12 = preCommentsLength - 1;
        var v11933 = i$$12 >= 0;
        for(;v11933;) {
          var v22724 = this.preComments;
          introspect(JAM.policy.p1) {
            var v18611 = v22724[i$$12]
          }
          if(v18611.isDocComment()) {
            var v11929;
            if(docComments.length > 0) {
              v11929 = docComments[docComments.length - 1]
            }else {
              v11929 = null
            }
            var prevDocComment = v11929;
            var v18614 = prevDocComment == null;
            if(!v18614) {
              var v26250 = this.preComments;
              introspect(JAM.policy.p1) {
                var v25731 = v26250[i$$12]
              }
              var v22727 = v25731.limLine == prevDocComment.minLine;
              if(!v22727) {
                var v26505 = this.preComments;
                introspect(JAM.policy.p1) {
                  var v26251 = v26505[i$$12]
                }
                v22727 = v26251.limLine + 1 == prevDocComment.minLine
              }
              v18614 = v22727
            }
            if(v18614) {
              var v18615 = this.preComments;
              introspect(JAM.policy.p1) {
                var v11930 = v18615[i$$12]
              }
              JAM.call(docComments.push, docComments, [v11930]);
              i$$12 = i$$12 - 1;
              v11933 = i$$12 >= 0;
              continue
            }
          }
          break
        }
        var v27439 = docComments.reverse();
        this.docComments = v27439
      }
      return this.docComments
    }
    function getResolvedIdentifierName(name$$33) {
      if(!name$$33) {
        return""
      }
      var resolved = "";
      var start$$6 = 0;
      var i$$11 = 0;
      var v11938 = i$$11 <= name$$33.length - 6;
      for(;v11938;) {
        var v18617 = name$$33.charAt(i$$11) == "\\";
        if(v18617) {
          v18617 = name$$33.charAt(i$$11 + 1) == "u"
        }
        if(v18617) {
          var charCode = parseInt(name$$33.substr(i$$11 + 2, 4), 16);
          resolved = resolved + name$$33.substr(start$$6, i$$11 - start$$6);
          resolved = resolved + String.fromCharCode(charCode);
          i$$11 = i$$11 + 6;
          start$$6 = i$$11;
          v11938 = i$$11 <= name$$33.length - 6;
          continue
        }
        i$$11 = i$$11 + 1;
        v11938 = i$$11 <= name$$33.length - 6
      }
      resolved = resolved + JAM.call(name$$33.substring, name$$33, [start$$6]);
      return resolved
    }
    function v92() {
      var v11939 = TypeScript$$4.NodeType._map;
      var v11940 = this.nodeType;
      introspect(JAM.policy.p1) {
        return v11939[v11940]
      }
    }
    function v91(container, freeUses) {
      return
    }
    function v90(context$$7) {
      context$$7.walker.options.goChildren = false;
      JAM.call(context$$7.addContent, context$$7, [this]);
      return
    }
    function v89() {
      var v22735 = TypeScript$$4.nodeTypeTable;
      var v22736 = this.nodeType;
      introspect(JAM.policy.p1) {
        var v18629 = v22735[v22736]
      }
      if(v18629 !== undefined) {
        var v11942 = TypeScript$$4.nodeTypeTable;
        var v11943 = this.nodeType;
        introspect(JAM.policy.p1) {
          return v11942[v11943]
        }
      }else {
        var v11944 = TypeScript$$4.NodeType._map;
        var v11945 = this.nodeType;
        introspect(JAM.policy.p1) {
          return v11944[v11945]
        }
      }
      return
    }
    function v88(context$$6) {
      context$$6.startLine();
      var lineCol = {line:-1, col:-1};
      var limLineCol = {line:-1, col:-1};
      if(context$$6.parser !== null) {
        var v11947 = context$$6.parser;
        JAM.call(v11947.getSourceLineCol, v11947, [lineCol, this.minChar]);
        var v11949 = context$$6.parser;
        JAM.call(v11949.getSourceLineCol, v11949, [limLineCol, this.limChar]);
        JAM.call(context$$6.write, context$$6, ["(" + lineCol.line + "," + lineCol.col + ")--" + "(" + limLineCol.line + "," + limLineCol.col + "): "])
      }
      var lab = this.printLabel();
      if(JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [this.flags, TypeScript$$4.ASTFlags.Error])) {
        lab = lab + " (Error)"
      }
      JAM.call(context$$6.writeLine, context$$6, [lab]);
      return
    }
    function v87(emitter, tokenId, startLine) {
      JAM.call(emitter.emitParensAndCommentsInPlace, emitter, [this, true]);
      switch(this.nodeType) {
        case TypeScript$$4.NodeType.This:
          JAM.call(emitter.recordSourceMappingStart, emitter, [this]);
          var v18635 = emitter.thisFnc;
          if(v18635) {
            v18635 = JAM.call(TypeScript$$4.hasFlag, TypeScript$$4, [emitter.thisFnc.fncFlags, TypeScript$$4.FncFlags.IsFatArrowFunction])
          }
          if(v18635) {
            JAM.call(emitter.writeToOutput, emitter, ["_this"])
          }else {
            JAM.call(emitter.writeToOutput, emitter, ["this"])
          }
          JAM.call(emitter.recordSourceMappingEnd, emitter, [this]);
          break;
        case TypeScript$$4.NodeType.Null:
          JAM.call(emitter.recordSourceMappingStart, emitter, [this]);
          JAM.call(emitter.writeToOutput, emitter, ["null"]);
          JAM.call(emitter.recordSourceMappingEnd, emitter, [this]);
          break;
        case TypeScript$$4.NodeType.False:
          JAM.call(emitter.recordSourceMappingStart, emitter, [this]);
          JAM.call(emitter.writeToOutput, emitter, ["false"]);
          JAM.call(emitter.recordSourceMappingEnd, emitter, [this]);
          break;
        case TypeScript$$4.NodeType.True:
          JAM.call(emitter.recordSourceMappingStart, emitter, [this]);
          JAM.call(emitter.writeToOutput, emitter, ["true"]);
          JAM.call(emitter.recordSourceMappingEnd, emitter, [this]);
          break;
        case TypeScript$$4.NodeType.Super:
          JAM.call(emitter.recordSourceMappingStart, emitter, [this]);
          emitter.emitSuperReference();
          JAM.call(emitter.recordSourceMappingEnd, emitter, [this]);
          break;
        case TypeScript$$4.NodeType.EndCode:
        ;
        case TypeScript$$4.NodeType.Error:
        ;
        case TypeScript$$4.NodeType.EmptyExpr:
          break;
        case TypeScript$$4.NodeType.Empty:
          JAM.call(emitter.recordSourceMappingStart, emitter, [this]);
          JAM.call(emitter.recordSourceMappingEnd, emitter, [this]);
          break;
        case TypeScript$$4.NodeType.Void:
          JAM.call(emitter.recordSourceMappingStart, emitter, [this]);
          JAM.call(emitter.writeToOutput, emitter, ["void "]);
          JAM.call(emitter.recordSourceMappingEnd, emitter, [this]);
          break;
        default:
          throw new Error("please implement in derived class");
      }
      JAM.call(emitter.emitParensAndCommentsInPlace, emitter, [this, false]);
      return
    }
    function v86(typeFlow) {
      switch(this.nodeType) {
        case TypeScript$$4.NodeType.Error:
        ;
        case TypeScript$$4.NodeType.EmptyExpr:
          this.type = typeFlow.anyType;
          break;
        case TypeScript$$4.NodeType.This:
          return JAM.call(typeFlow.typeCheckThis, typeFlow, [this]);
        case TypeScript$$4.NodeType.Null:
          this.type = typeFlow.nullType;
          break;
        case TypeScript$$4.NodeType.False:
        ;
        case TypeScript$$4.NodeType.True:
          this.type = typeFlow.booleanType;
          break;
        case TypeScript$$4.NodeType.Super:
          return JAM.call(typeFlow.typeCheckSuper, typeFlow, [this]);
        case TypeScript$$4.NodeType.EndCode:
        ;
        case TypeScript$$4.NodeType.Empty:
        ;
        case TypeScript$$4.NodeType.Void:
          this.type = typeFlow.voidType;
          break;
        default:
          throw new Error("please implement in derived class");
      }
      return this
    }
    function v85() {
      return false
    }
    function v84() {
      var v11957 = this.isStatementOrExpression();
      if(v11957) {
        v11957 = !this.isCompoundStatement()
      }
      return v11957
    }
    function v83() {
      return false
    }
    function v82() {
      return false
    }
    function v81() {
      return false
    }
    function AST$$1(nodeType) {
      JAM.call(_super.call, _super, [this]);
      this.nodeType = nodeType;
      this.type = null;
      this.flags = TypeScript$$4.ASTFlags.Writeable;
      this.passCreated = TypeScript$$4.CompilerDiagnostics.analysisPass;
      this.preComments = null;
      this.postComments = null;
      this.docComments = null;
      this.isParenthesized = false;
      return
    }
    JAM.call(__extends, null, [AST$$1, _super]);
    AST$$1.prototype.isExpression = v81;
    AST$$1.prototype.isStatementOrExpression = v82;
    AST$$1.prototype.isCompoundStatement = v83;
    AST$$1.prototype.isLeaf = v84;
    AST$$1.prototype.isDeclaration = v85;
    AST$$1.prototype.typeCheck = v86;
    AST$$1.prototype.emit = v87;
    AST$$1.prototype.print = v88;
    AST$$1.prototype.printLabel = v89;
    AST$$1.prototype.addToControlFlow = v90;
    AST$$1.prototype.netFreeUses = v91;
    AST$$1.prototype.treeViewLabel = v92;
    AST$$1.getResolvedIdentifierName = getResolvedIdentifierName;
    AST$$1.prototype.getDocComments = v93;
    return AST$$1
  }
  function v80() {
    function ASTSpan$$1() {
      this.minChar = -1;
      this.limChar = -1;
      return
    }
    return ASTSpan$$1
  }
  var ASTSpan = v80();
  TypeScript$$4.ASTSpan = ASTSpan;
  var AST = v94(ASTSpan);
  TypeScript$$4.AST = AST;
  var IncompleteAST = v95(AST);
  TypeScript$$4.IncompleteAST = IncompleteAST;
  var ASTList = v101(AST);
  TypeScript$$4.ASTList = ASTList;
  var Identifier = v109(AST);
  TypeScript$$4.Identifier = Identifier;
  var MissingIdentifier = v112(Identifier);
  TypeScript$$4.MissingIdentifier = MissingIdentifier;
  var Label = v116(AST);
  TypeScript$$4.Label = Label;
  var Expression = v119(AST);
  TypeScript$$4.Expression = Expression;
  var UnaryExpression = v123(Expression);
  TypeScript$$4.UnaryExpression = UnaryExpression;
  var CallExpression = v126(Expression);
  TypeScript$$4.CallExpression = CallExpression;
  var BinaryExpression = v129(Expression);
  TypeScript$$4.BinaryExpression = BinaryExpression;
  var ConditionalExpression = v132(Expression);
  TypeScript$$4.ConditionalExpression = ConditionalExpression;
  var NumberLiteral = v137(Expression);
  TypeScript$$4.NumberLiteral = NumberLiteral;
  var RegexLiteral = v140(Expression);
  TypeScript$$4.RegexLiteral = RegexLiteral;
  var StringLiteral = v145(Expression);
  TypeScript$$4.StringLiteral = StringLiteral;
  var ModuleElement = v146(AST);
  TypeScript$$4.ModuleElement = ModuleElement;
  var ImportDeclaration = v153(ModuleElement);
  TypeScript$$4.ImportDeclaration = ImportDeclaration;
  var BoundDecl = v161(AST);
  TypeScript$$4.BoundDecl = BoundDecl;
  var VarDecl = v167(BoundDecl);
  TypeScript$$4.VarDecl = VarDecl;
  var ArgDecl = v171(BoundDecl);
  TypeScript$$4.ArgDecl = ArgDecl;
  var internalId = 0;
  var FuncDecl = v201(AST);
  TypeScript$$4.FuncDecl = FuncDecl;
  var LocationInfo = v202();
  TypeScript$$4.LocationInfo = LocationInfo;
  var v11973 = TypeScript$$4;
  var v27440 = JAM.new(LocationInfo, ["unknown", null, -1]);
  v11973.unknownLocationInfo = v27440;
  var Script = v210(FuncDecl);
  TypeScript$$4.Script = Script;
  var NamedDeclaration = v212(ModuleElement);
  TypeScript$$4.NamedDeclaration = NamedDeclaration;
  var ModuleDeclaration = v219(NamedDeclaration);
  TypeScript$$4.ModuleDeclaration = ModuleDeclaration;
  var TypeDeclaration = v222(NamedDeclaration);
  TypeScript$$4.TypeDeclaration = TypeDeclaration;
  var ClassDeclaration = v225(TypeDeclaration);
  TypeScript$$4.ClassDeclaration = ClassDeclaration;
  var InterfaceDeclaration = v228(TypeDeclaration);
  TypeScript$$4.InterfaceDeclaration = InterfaceDeclaration;
  var Statement = v233(ModuleElement);
  TypeScript$$4.Statement = Statement;
  var LabeledStatement = v237(Statement);
  TypeScript$$4.LabeledStatement = LabeledStatement;
  var Block = v241(Statement);
  TypeScript$$4.Block = Block;
  var Jump = v246(Statement);
  TypeScript$$4.Jump = Jump;
  var WhileStatement = v251(Statement);
  TypeScript$$4.WhileStatement = WhileStatement;
  var DoWhileStatement = v256(Statement);
  TypeScript$$4.DoWhileStatement = DoWhileStatement;
  var IfStatement = v261(Statement);
  TypeScript$$4.IfStatement = IfStatement;
  var ReturnStatement = v265(Statement);
  TypeScript$$4.ReturnStatement = ReturnStatement;
  var EndCode = v266(AST);
  TypeScript$$4.EndCode = EndCode;
  var ForInStatement = v272(Statement);
  TypeScript$$4.ForInStatement = ForInStatement;
  var ForStatement = v277(Statement);
  TypeScript$$4.ForStatement = ForStatement;
  var WithStatement = v281(Statement);
  TypeScript$$4.WithStatement = WithStatement;
  var SwitchStatement = v286(Statement);
  TypeScript$$4.SwitchStatement = SwitchStatement;
  var CaseStatement = v290(Statement);
  TypeScript$$4.CaseStatement = CaseStatement;
  var TypeReference = v293(AST);
  TypeScript$$4.TypeReference = TypeReference;
  var TryFinally = v298(Statement);
  TypeScript$$4.TryFinally = TryFinally;
  var TryCatch = v303(Statement);
  TypeScript$$4.TryCatch = TryCatch;
  var Try = v307(Statement);
  TypeScript$$4.Try = Try;
  var Catch = v311(Statement);
  TypeScript$$4.Catch = Catch;
  var Finally = v315(Statement);
  TypeScript$$4.Finally = Finally;
  var Comment$$1 = v319(AST);
  TypeScript$$4.Comment = Comment$$1;
  var DebuggerStatement = v321(Statement);
  TypeScript$$4.DebuggerStatement = DebuggerStatement;
  return
}
function v79(d, b) {
  function __() {
    this.constructor = d;
    return
  }
  __.prototype = b.prototype;
  var v11974 = d;
  var v27441 = new __;
  v11974.prototype = v27441;
  return
}
function v78(TypeScript$$3) {
  function v77() {
    function v76(key$$26, data$$32) {
      var lookupData = JAM.call(this.lookup, this, [key$$26]);
      if(lookupData) {
        return false
      }
      JAM.set(this.keys, this.keys.length, key$$26);
      JAM.set(this.values, this.values.length, data$$32);
      return true
    }
    function v75(key$$25, findValue) {
      var searchArray = this.keys;
      if(findValue) {
        searchArray = this.values
      }
      var i$$10 = 0;
      var v11982 = i$$10 < searchArray.length;
      for(;v11982;) {
        introspect(JAM.policy.p1) {
          var v18640 = searchArray[i$$10]
        }
        if(v18640 == key$$25) {
          var v18641 = this.keys;
          introspect(JAM.policy.p1) {
            var v11979 = v18641[i$$10]
          }
          var v18642 = this.values;
          introspect(JAM.policy.p1) {
            var v11980 = v18642[i$$10]
          }
          return{key:v11979, data:v11980}
        }
        i$$10 = i$$10 + 1;
        v11982 = i$$10 < searchArray.length
      }
      return null
    }
    function SimpleHashTable$$1() {
      this.keys = [];
      this.values = [];
      return
    }
    SimpleHashTable$$1.prototype.lookup = v75;
    SimpleHashTable$$1.prototype.add = v76;
    return SimpleHashTable$$1
  }
  function v74() {
    function v73(key$$24) {
      var current$$2;
      var val$$3 = JAM.call(this.hashFn, this, [key$$24]);
      val$$3 = val$$3 % this.size;
      var v11986 = this.table;
      introspect(JAM.policy.p1) {
        current$$2 = v11986[val$$3]
      }
      var v11988 = current$$2 != null;
      for(;v11988;) {
        if(JAM.call(this.equalsFn, this, [key$$24, current$$2.key])) {
          return current$$2.data
        }
        current$$2 = current$$2.next;
        v11988 = current$$2 != null
      }
      return null
    }
    function v72() {
      return this.itemCount
    }
    function v71(key$$23) {
      var current$$1;
      var val$$2 = JAM.call(this.hashFn, this, [key$$23]);
      val$$2 = val$$2 % this.size;
      var result$$3 = null;
      var prevEntry = null;
      var v11990 = this.table;
      introspect(JAM.policy.p1) {
        current$$1 = v11990[val$$2]
      }
      var v11993 = current$$1 != null;
      for(;v11993;) {
        if(JAM.call(this.equalsFn, this, [key$$23, current$$1.key])) {
          result$$3 = current$$1.data;
          this.itemCount = this.itemCount - 1;
          if(prevEntry) {
            prevEntry.next = current$$1.next
          }else {
            JAM.set(this.table, val$$2, current$$1.next)
          }
          break
        }
        prevEntry = current$$1;
        current$$1 = current$$1.next;
        v11993 = current$$1 != null
      }
      return result$$3
    }
    function v70(key$$22, data$$31) {
      var current;
      var entry = JAM.new(HashEntry, [key$$22, data$$31]);
      var val$$1 = JAM.call(this.hashFn, this, [key$$22]);
      val$$1 = val$$1 % this.size;
      var v11995 = this.table;
      introspect(JAM.policy.p1) {
        current = v11995[val$$1]
      }
      var v11997 = current != null;
      for(;v11997;) {
        if(JAM.call(this.equalsFn, this, [key$$22, current.key])) {
          return false
        }
        current = current.next;
        v11997 = current != null
      }
      var v11998 = this.table;
      introspect(JAM.policy.p1) {
        entry.next = v11998[val$$1]
      }
      JAM.set(this.table, val$$1, entry);
      this.itemCount = this.itemCount + 1;
      return true
    }
    function HashTable$$1(size$$4, hashFn, equalsFn) {
      this.size = size$$4;
      this.hashFn = hashFn;
      this.equalsFn = equalsFn;
      this.itemCount = 0;
      var v27442 = new Array;
      this.table = v27442;
      var i$$9 = 0;
      var v12001 = i$$9 < this.size;
      for(;v12001;) {
        this.table[i$$9] = null;
        i$$9 = i$$9 + 1;
        v12001 = i$$9 < this.size
      }
      return
    }
    HashTable$$1.prototype.add = v70;
    HashTable$$1.prototype.remove = v71;
    HashTable$$1.prototype.count = v72;
    HashTable$$1.prototype.lookup = v73;
    return HashTable$$1
  }
  function v69() {
    function HashEntry$$1(key$$21, data$$30) {
      this.key = key$$21;
      this.data = data$$30;
      return
    }
    return HashEntry$$1
  }
  function v68() {
    function v67(key$$20) {
      var v12006 = this.primaryTable;
      var data$$29 = JAM.call(v12006.lookup, v12006, [key$$20]);
      if(data$$29 != undefined) {
        return data$$29
      }else {
        var v12007 = this.secondaryTable;
        return JAM.call(v12007.lookup, v12007, [key$$20])
      }
      return
    }
    function v66() {
      return this.primaryTable.count() + this.secondaryTable.count()
    }
    function v65(fn$$5, context$$5) {
      var v18653 = this.primaryTable;
      var v12011 = JAM.call(v18653.some, v18653, [fn$$5, context$$5]);
      if(!v12011) {
        var v18654 = this.secondaryTable;
        v12011 = JAM.call(v18654.some, v18654, [fn$$5, context$$5])
      }
      return v12011
    }
    function v64(fn$$4, context$$4) {
      var v18656 = this.primaryTable;
      var v12012 = JAM.call(v18656.every, v18656, [fn$$4, context$$4]);
      if(v12012) {
        var v18657 = this.secondaryTable;
        v12012 = JAM.call(v18657.every, v18657, [fn$$4, context$$4])
      }
      return v12012
    }
    function v63(fn$$3, context$$3) {
      var v12013 = this.primaryTable;
      JAM.call(v12013.map, v12013, [fn$$3, context$$3]);
      var v12014 = this.secondaryTable;
      JAM.call(v12014.map, v12014, [fn$$3, context$$3]);
      return
    }
    function v62(key$$19, data$$28) {
      if(this.insertPrimary) {
        var v12015 = this.primaryTable;
        return JAM.call(v12015.addOrUpdate, v12015, [key$$19, data$$28])
      }else {
        var v12016 = this.secondaryTable;
        return JAM.call(v12016.addOrUpdate, v12016, [key$$19, data$$28])
      }
      return
    }
    function v61(key$$18, data$$27) {
      if(this.insertPrimary) {
        var v12018 = this.primaryTable;
        return JAM.call(v12018.add, v12018, [key$$18, data$$27])
      }else {
        var v12019 = this.secondaryTable;
        return JAM.call(v12019.add, v12019, [key$$18, data$$27])
      }
      return
    }
    function v60() {
      return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys())
    }
    function DualStringHashTable$$1(primaryTable, secondaryTable) {
      this.primaryTable = primaryTable;
      this.secondaryTable = secondaryTable;
      this.insertPrimary = true;
      return
    }
    DualStringHashTable$$1.prototype.getAllKeys = v60;
    DualStringHashTable$$1.prototype.add = v61;
    DualStringHashTable$$1.prototype.addOrUpdate = v62;
    DualStringHashTable$$1.prototype.map = v63;
    DualStringHashTable$$1.prototype.every = v64;
    DualStringHashTable$$1.prototype.some = v65;
    DualStringHashTable$$1.prototype.count = v66;
    DualStringHashTable$$1.prototype.lookup = v67;
    return DualStringHashTable$$1
  }
  function v59() {
    function v58(key$$17) {
      var v12031 = this.table;
      introspect(JAM.policy.p1) {
        var data$$26 = v12031[key$$17]
      }
      if(data$$26 != undefined) {
        return data$$26
      }else {
        return null
      }
      return
    }
    function v57() {
      return this.itemCount
    }
    function v56(fn$$2, context$$2) {
      var k$$4;
      for(k$$4 in this.table) {
        var v12033 = this.table;
        introspect(JAM.policy.p1) {
          var data$$25 = v12033[k$$4]
        }
        if(data$$25 != undefined) {
          var v22742 = this.table;
          introspect(JAM.policy.p1) {
            var v18660 = v22742[k$$4]
          }
          if(JAM.call(fn$$2, null, [k$$4, v18660, context$$2])) {
            return true
          }
        }
      }
      return false
    }
    function v55(fn$$1, context$$1) {
      var k$$3;
      for(k$$3 in this.table) {
        var v12037 = this.table;
        introspect(JAM.policy.p1) {
          var data$$24 = v12037[k$$3]
        }
        if(data$$24 != undefined) {
          var v24764 = this.table;
          introspect(JAM.policy.p1) {
            var v22743 = v24764[k$$3]
          }
          if(!JAM.call(fn$$1, null, [k$$3, v22743, context$$1])) {
            return false
          }
        }
      }
      return true
    }
    function v54(fn, context) {
      var k$$2;
      for(k$$2 in this.table) {
        var v12041 = this.table;
        introspect(JAM.policy.p1) {
          var data$$23 = v12041[k$$2]
        }
        if(data$$23 != undefined) {
          var v18662 = this.table;
          introspect(JAM.policy.p1) {
            var v12042 = v18662[k$$2]
          }
          JAM.call(fn, null, [k$$2, v12042, context])
        }
      }
      return
    }
    function v53(key$$16, data$$22) {
      var v22744 = this.table;
      introspect(JAM.policy.p1) {
        var v18663 = v22744[key$$16]
      }
      if(v18663 != undefined) {
        JAM.set(this.table, key$$16, data$$22);
        return false
      }
      JAM.set(this.table, key$$16, data$$22);
      this.itemCount = this.itemCount + 1;
      return true
    }
    function v52(key$$15, data$$21) {
      var v22745 = this.table;
      introspect(JAM.policy.p1) {
        var v18665 = v22745[key$$15]
      }
      if(v18665 != undefined) {
        return false
      }
      JAM.set(this.table, key$$15, data$$21);
      this.itemCount = this.itemCount + 1;
      return true
    }
    function v51() {
      var result$$2 = [];
      var k$$1;
      for(k$$1 in this.table) {
        var v22746 = this.table;
        introspect(JAM.policy.p1) {
          var v18667 = v22746[k$$1]
        }
        if(v18667 != undefined) {
          result$$2[result$$2.length] = k$$1
        }
      }
      return result$$2
    }
    function StringHashTable$$1() {
      this.itemCount = 0;
      var v27443 = new BlockIntrinsics;
      this.table = v27443;
      return
    }
    StringHashTable$$1.prototype.getAllKeys = v51;
    StringHashTable$$1.prototype.add = v52;
    StringHashTable$$1.prototype.addOrUpdate = v53;
    StringHashTable$$1.prototype.map = v54;
    StringHashTable$$1.prototype.every = v55;
    StringHashTable$$1.prototype.some = v56;
    StringHashTable$$1.prototype.count = v57;
    StringHashTable$$1.prototype.lookup = v58;
    return StringHashTable$$1
  }
  function v50() {
    function BlockIntrinsics$$1() {
      this.prototype = undefined;
      this.toString = undefined;
      this.toLocaleString = undefined;
      this.valueOf = undefined;
      this.hasOwnProperty = undefined;
      this.propertyIsEnumerable = undefined;
      this.isPrototypeOf = undefined;
      this["constructor"] = undefined;
      return
    }
    return BlockIntrinsics$$1
  }
  function numberHashFn(key$$14) {
    var c2 = 668265261;
    key$$14 = key$$14 ^ 61 ^ key$$14 >>> 16;
    key$$14 = key$$14 + (key$$14 << 3);
    key$$14 = key$$14 ^ key$$14 >>> 4;
    key$$14 = key$$14 * c2;
    key$$14 = key$$14 ^ key$$14 >>> 15;
    return key$$14
  }
  function combineHashes(key1, key2) {
    return key2 ^ (key1 >> 5) + key1
  }
  var BlockIntrinsics = v50();
  TypeScript$$3.BlockIntrinsics = BlockIntrinsics;
  var StringHashTable = v59();
  TypeScript$$3.StringHashTable = StringHashTable;
  var DualStringHashTable = v68();
  TypeScript$$3.DualStringHashTable = DualStringHashTable;
  TypeScript$$3.numberHashFn = numberHashFn;
  TypeScript$$3.combineHashes = combineHashes;
  var HashEntry = v69();
  TypeScript$$3.HashEntry = HashEntry;
  var HashTable = v74();
  TypeScript$$3.HashTable = HashTable;
  var SimpleHashTable = v77();
  TypeScript$$3.SimpleHashTable = SimpleHashTable;
  return
}
function v49(TypeScript$$2) {
  var v12067 = TypeScript$$2.NodeType;
  if(!v12067) {
    v12067 = TypeScript$$2.NodeType = {}
  }
  var NodeType$$inline_0 = v12067;
  NodeType$$inline_0._map = [];
  NodeType$$inline_0._map[0] = "None";
  NodeType$$inline_0.None = 0;
  NodeType$$inline_0._map[1] = "Empty";
  NodeType$$inline_0.Empty = 1;
  NodeType$$inline_0._map[2] = "EmptyExpr";
  NodeType$$inline_0.EmptyExpr = 2;
  NodeType$$inline_0._map[3] = "True";
  NodeType$$inline_0.True = 3;
  NodeType$$inline_0._map[4] = "False";
  NodeType$$inline_0.False = 4;
  NodeType$$inline_0._map[5] = "This";
  NodeType$$inline_0.This = 5;
  NodeType$$inline_0._map[6] = "Super";
  NodeType$$inline_0.Super = 6;
  NodeType$$inline_0._map[7] = "QString";
  NodeType$$inline_0.QString = 7;
  NodeType$$inline_0._map[8] = "Regex";
  NodeType$$inline_0.Regex = 8;
  NodeType$$inline_0._map[9] = "Null";
  NodeType$$inline_0.Null = 9;
  NodeType$$inline_0._map[10] = "ArrayLit";
  NodeType$$inline_0.ArrayLit = 10;
  NodeType$$inline_0._map[11] = "ObjectLit";
  NodeType$$inline_0.ObjectLit = 11;
  NodeType$$inline_0._map[12] = "Void";
  NodeType$$inline_0.Void = 12;
  NodeType$$inline_0._map[13] = "Comma";
  NodeType$$inline_0.Comma = 13;
  NodeType$$inline_0._map[14] = "Pos";
  NodeType$$inline_0.Pos = 14;
  NodeType$$inline_0._map[15] = "Neg";
  NodeType$$inline_0.Neg = 15;
  NodeType$$inline_0._map[16] = "Delete";
  NodeType$$inline_0.Delete = 16;
  NodeType$$inline_0._map[17] = "Await";
  NodeType$$inline_0.Await = 17;
  NodeType$$inline_0._map[18] = "In";
  NodeType$$inline_0.In = 18;
  NodeType$$inline_0._map[19] = "Dot";
  NodeType$$inline_0.Dot = 19;
  NodeType$$inline_0._map[20] = "From";
  NodeType$$inline_0.From = 20;
  NodeType$$inline_0._map[21] = "Is";
  NodeType$$inline_0.Is = 21;
  NodeType$$inline_0._map[22] = "InstOf";
  NodeType$$inline_0.InstOf = 22;
  NodeType$$inline_0._map[23] = "Typeof";
  NodeType$$inline_0.Typeof = 23;
  NodeType$$inline_0._map[24] = "NumberLit";
  NodeType$$inline_0.NumberLit = 24;
  NodeType$$inline_0._map[25] = "Name";
  NodeType$$inline_0.Name = 25;
  NodeType$$inline_0._map[26] = "TypeRef";
  NodeType$$inline_0.TypeRef = 26;
  NodeType$$inline_0._map[27] = "Index";
  NodeType$$inline_0.Index = 27;
  NodeType$$inline_0._map[28] = "Call";
  NodeType$$inline_0.Call = 28;
  NodeType$$inline_0._map[29] = "New";
  NodeType$$inline_0.New = 29;
  NodeType$$inline_0._map[30] = "Asg";
  NodeType$$inline_0.Asg = 30;
  NodeType$$inline_0._map[31] = "AsgAdd";
  NodeType$$inline_0.AsgAdd = 31;
  NodeType$$inline_0._map[32] = "AsgSub";
  NodeType$$inline_0.AsgSub = 32;
  NodeType$$inline_0._map[33] = "AsgDiv";
  NodeType$$inline_0.AsgDiv = 33;
  NodeType$$inline_0._map[34] = "AsgMul";
  NodeType$$inline_0.AsgMul = 34;
  NodeType$$inline_0._map[35] = "AsgMod";
  NodeType$$inline_0.AsgMod = 35;
  NodeType$$inline_0._map[36] = "AsgAnd";
  NodeType$$inline_0.AsgAnd = 36;
  NodeType$$inline_0._map[37] = "AsgXor";
  NodeType$$inline_0.AsgXor = 37;
  NodeType$$inline_0._map[38] = "AsgOr";
  NodeType$$inline_0.AsgOr = 38;
  NodeType$$inline_0._map[39] = "AsgLsh";
  NodeType$$inline_0.AsgLsh = 39;
  NodeType$$inline_0._map[40] = "AsgRsh";
  NodeType$$inline_0.AsgRsh = 40;
  NodeType$$inline_0._map[41] = "AsgRs2";
  NodeType$$inline_0.AsgRs2 = 41;
  NodeType$$inline_0._map[42] = "ConditionalExpression";
  NodeType$$inline_0.ConditionalExpression = 42;
  NodeType$$inline_0._map[43] = "LogOr";
  NodeType$$inline_0.LogOr = 43;
  NodeType$$inline_0._map[44] = "LogAnd";
  NodeType$$inline_0.LogAnd = 44;
  NodeType$$inline_0._map[45] = "Or";
  NodeType$$inline_0.Or = 45;
  NodeType$$inline_0._map[46] = "Xor";
  NodeType$$inline_0.Xor = 46;
  NodeType$$inline_0._map[47] = "And";
  NodeType$$inline_0.And = 47;
  NodeType$$inline_0._map[48] = "Eq";
  NodeType$$inline_0.Eq = 48;
  NodeType$$inline_0._map[49] = "Ne";
  NodeType$$inline_0.Ne = 49;
  NodeType$$inline_0._map[50] = "Eqv";
  NodeType$$inline_0.Eqv = 50;
  NodeType$$inline_0._map[51] = "NEqv";
  NodeType$$inline_0.NEqv = 51;
  NodeType$$inline_0._map[52] = "Lt";
  NodeType$$inline_0.Lt = 52;
  NodeType$$inline_0._map[53] = "Le";
  NodeType$$inline_0.Le = 53;
  NodeType$$inline_0._map[54] = "Gt";
  NodeType$$inline_0.Gt = 54;
  NodeType$$inline_0._map[55] = "Ge";
  NodeType$$inline_0.Ge = 55;
  NodeType$$inline_0._map[56] = "Add";
  NodeType$$inline_0.Add = 56;
  NodeType$$inline_0._map[57] = "Sub";
  NodeType$$inline_0.Sub = 57;
  NodeType$$inline_0._map[58] = "Mul";
  NodeType$$inline_0.Mul = 58;
  NodeType$$inline_0._map[59] = "Div";
  NodeType$$inline_0.Div = 59;
  NodeType$$inline_0._map[60] = "Mod";
  NodeType$$inline_0.Mod = 60;
  NodeType$$inline_0._map[61] = "Lsh";
  NodeType$$inline_0.Lsh = 61;
  NodeType$$inline_0._map[62] = "Rsh";
  NodeType$$inline_0.Rsh = 62;
  NodeType$$inline_0._map[63] = "Rs2";
  NodeType$$inline_0.Rs2 = 63;
  NodeType$$inline_0._map[64] = "Not";
  NodeType$$inline_0.Not = 64;
  NodeType$$inline_0._map[65] = "LogNot";
  NodeType$$inline_0.LogNot = 65;
  NodeType$$inline_0._map[66] = "IncPre";
  NodeType$$inline_0.IncPre = 66;
  NodeType$$inline_0._map[67] = "DecPre";
  NodeType$$inline_0.DecPre = 67;
  NodeType$$inline_0._map[68] = "IncPost";
  NodeType$$inline_0.IncPost = 68;
  NodeType$$inline_0._map[69] = "DecPost";
  NodeType$$inline_0.DecPost = 69;
  NodeType$$inline_0._map[70] = "TypeAssertion";
  NodeType$$inline_0.TypeAssertion = 70;
  NodeType$$inline_0._map[71] = "FuncDecl";
  NodeType$$inline_0.FuncDecl = 71;
  NodeType$$inline_0._map[72] = "Member";
  NodeType$$inline_0.Member = 72;
  NodeType$$inline_0._map[73] = "VarDecl";
  NodeType$$inline_0.VarDecl = 73;
  NodeType$$inline_0._map[74] = "ArgDecl";
  NodeType$$inline_0.ArgDecl = 74;
  NodeType$$inline_0._map[75] = "Return";
  NodeType$$inline_0.Return = 75;
  NodeType$$inline_0._map[76] = "Break";
  NodeType$$inline_0.Break = 76;
  NodeType$$inline_0._map[77] = "Continue";
  NodeType$$inline_0.Continue = 77;
  NodeType$$inline_0._map[78] = "Throw";
  NodeType$$inline_0.Throw = 78;
  NodeType$$inline_0._map[79] = "For";
  NodeType$$inline_0.For = 79;
  NodeType$$inline_0._map[80] = "ForIn";
  NodeType$$inline_0.ForIn = 80;
  NodeType$$inline_0._map[81] = "If";
  NodeType$$inline_0.If = 81;
  NodeType$$inline_0._map[82] = "While";
  NodeType$$inline_0.While = 82;
  NodeType$$inline_0._map[83] = "DoWhile";
  NodeType$$inline_0.DoWhile = 83;
  NodeType$$inline_0._map[84] = "Block";
  NodeType$$inline_0.Block = 84;
  NodeType$$inline_0._map[85] = "Case";
  NodeType$$inline_0.Case = 85;
  NodeType$$inline_0._map[86] = "Switch";
  NodeType$$inline_0.Switch = 86;
  NodeType$$inline_0._map[87] = "Try";
  NodeType$$inline_0.Try = 87;
  NodeType$$inline_0._map[88] = "TryCatch";
  NodeType$$inline_0.TryCatch = 88;
  NodeType$$inline_0._map[89] = "TryFinally";
  NodeType$$inline_0.TryFinally = 89;
  NodeType$$inline_0._map[90] = "Finally";
  NodeType$$inline_0.Finally = 90;
  NodeType$$inline_0._map[91] = "Catch";
  NodeType$$inline_0.Catch = 91;
  NodeType$$inline_0._map[92] = "List";
  NodeType$$inline_0.List = 92;
  NodeType$$inline_0._map[93] = "Script";
  NodeType$$inline_0.Script = 93;
  NodeType$$inline_0._map[94] = "ClassDeclaration";
  NodeType$$inline_0.ClassDeclaration = 94;
  NodeType$$inline_0._map[95] = "InterfaceDeclaration";
  NodeType$$inline_0.InterfaceDeclaration = 95;
  NodeType$$inline_0._map[96] = "ModuleDeclaration";
  NodeType$$inline_0.ModuleDeclaration = 96;
  NodeType$$inline_0._map[97] = "ImportDeclaration";
  NodeType$$inline_0.ImportDeclaration = 97;
  NodeType$$inline_0._map[98] = "With";
  NodeType$$inline_0.With = 98;
  NodeType$$inline_0._map[99] = "Label";
  NodeType$$inline_0.Label = 99;
  NodeType$$inline_0._map[100] = "LabeledStatement";
  NodeType$$inline_0.LabeledStatement = 100;
  NodeType$$inline_0._map[101] = "EBStart";
  NodeType$$inline_0.EBStart = 101;
  NodeType$$inline_0._map[102] = "GotoEB";
  NodeType$$inline_0.GotoEB = 102;
  NodeType$$inline_0._map[103] = "EndCode";
  NodeType$$inline_0.EndCode = 103;
  NodeType$$inline_0._map[104] = "Error";
  NodeType$$inline_0.Error = 104;
  NodeType$$inline_0._map[105] = "Comment";
  NodeType$$inline_0.Comment = 105;
  NodeType$$inline_0._map[106] = "Debugger";
  NodeType$$inline_0.Debugger = 106;
  NodeType$$inline_0.GeneralNode = NodeType$$inline_0.FuncDecl;
  NodeType$$inline_0.LastAsg = NodeType$$inline_0.AsgRs2;
  var NodeType = TypeScript$$2.NodeType;
  return
}
function v48(TypeScript$$1) {
  function v47(ModuleGenTarget$$1) {
    ModuleGenTarget$$1._map = [];
    ModuleGenTarget$$1.Synchronous = 0;
    ModuleGenTarget$$1.Asynchronous = 1;
    ModuleGenTarget$$1.Local = 1 << 1;
    return
  }
  function v46(CodeGenTarget$$1) {
    CodeGenTarget$$1._map = [];
    CodeGenTarget$$1.ES3 = 0;
    CodeGenTarget$$1.ES5 = 1;
    return
  }
  function v45(TypeRelationshipFlags$$1) {
    TypeRelationshipFlags$$1._map = [];
    TypeRelationshipFlags$$1.SuccessfulComparison = 0;
    TypeRelationshipFlags$$1.SourceIsNullTargetIsVoidOrUndefined = 1;
    TypeRelationshipFlags$$1.RequiredPropertyIsMissing = 1 << 1;
    TypeRelationshipFlags$$1.IncompatibleSignatures = 1 << 2;
    TypeRelationshipFlags$$1.SourceSignatureHasTooManyParameters = 3;
    TypeRelationshipFlags$$1.IncompatibleReturnTypes = 1 << 4;
    TypeRelationshipFlags$$1.IncompatiblePropertyTypes = 1 << 5;
    TypeRelationshipFlags$$1.IncompatibleParameterTypes = 1 << 6;
    return
  }
  function v44(TypeFlags$$1) {
    TypeFlags$$1._map = [];
    TypeFlags$$1.None = 0;
    TypeFlags$$1.HasImplementation = 1;
    TypeFlags$$1.HasSelfReference = 1 << 1;
    TypeFlags$$1.MergeResult = 1 << 2;
    TypeFlags$$1.IsEnum = 1 << 3;
    TypeFlags$$1.BuildingName = 1 << 4;
    TypeFlags$$1.HasBaseType = 1 << 5;
    TypeFlags$$1.HasBaseTypeOfObject = 1 << 6;
    TypeFlags$$1.IsClass = 1 << 7;
    return
  }
  function v43(SignatureFlags$$1) {
    SignatureFlags$$1._map = [];
    SignatureFlags$$1.None = 0;
    SignatureFlags$$1.IsIndexer = 1;
    SignatureFlags$$1.IsStringIndexer = 1 << 1;
    SignatureFlags$$1.IsNumberIndexer = 1 << 2;
    return
  }
  function v42(FncFlags$$1) {
    FncFlags$$1._map = [];
    FncFlags$$1.None = 0;
    FncFlags$$1.Exported = 1;
    FncFlags$$1.Private = 1 << 1;
    FncFlags$$1.Public = 1 << 2;
    FncFlags$$1.Ambient = 1 << 3;
    FncFlags$$1.Static = 1 << 4;
    FncFlags$$1.LocalStatic = 1 << 5;
    FncFlags$$1.GetAccessor = 1 << 6;
    FncFlags$$1.SetAccessor = 1 << 7;
    FncFlags$$1.Definition = 1 << 8;
    FncFlags$$1.Signature = 1 << 9;
    FncFlags$$1.Method = 1 << 10;
    FncFlags$$1.HasReturnExpression = 1 << 11;
    FncFlags$$1.CallMember = 1 << 12;
    FncFlags$$1.ConstructMember = 1 << 13;
    FncFlags$$1.HasSelfReference = 1 << 14;
    FncFlags$$1.IsFatArrowFunction = 1 << 15;
    FncFlags$$1.IndexerMember = 1 << 16;
    FncFlags$$1.IsFunctionExpression = 1 << 17;
    FncFlags$$1.ClassMethod = 1 << 18;
    FncFlags$$1.ClassPropertyMethodExported = 1 << 19;
    FncFlags$$1.HasSuperReferenceInFatArrowFunction = 1 << 20;
    FncFlags$$1.IsPropertyBound = 1 << 21;
    return
  }
  function v41(VarFlags$$1) {
    VarFlags$$1._map = [];
    VarFlags$$1.None = 0;
    VarFlags$$1.Exported = 1;
    VarFlags$$1.Private = 1 << 1;
    VarFlags$$1.Public = 1 << 2;
    VarFlags$$1.Ambient = 1 << 3;
    VarFlags$$1.Static = 1 << 4;
    VarFlags$$1.LocalStatic = 1 << 5;
    VarFlags$$1.GetAccessor = 1 << 6;
    VarFlags$$1.SetAccessor = 1 << 7;
    VarFlags$$1.AutoInit = 1 << 8;
    VarFlags$$1.Property = 1 << 9;
    VarFlags$$1.Readonly = 1 << 10;
    VarFlags$$1.Class = 1 << 11;
    VarFlags$$1.ClassProperty = 1 << 12;
    VarFlags$$1.ClassBodyProperty = 1 << 13;
    VarFlags$$1.ClassConstructorProperty = 1 << 14;
    VarFlags$$1.ClassSuperMustBeFirstCallInConstructor = 1 << 15;
    VarFlags$$1.Constant = 1 << 16;
    VarFlags$$1.MustCaptureThis = 1 << 17;
    return
  }
  function v40(SymbolFlags$$1) {
    SymbolFlags$$1._map = [];
    SymbolFlags$$1.None = 0;
    SymbolFlags$$1.Exported = 1;
    SymbolFlags$$1.Private = 1 << 1;
    SymbolFlags$$1.Public = 1 << 2;
    SymbolFlags$$1.Ambient = 1 << 3;
    SymbolFlags$$1.Static = 1 << 4;
    SymbolFlags$$1.LocalStatic = 1 << 5;
    SymbolFlags$$1.GetAccessor = 1 << 6;
    SymbolFlags$$1.SetAccessor = 1 << 7;
    SymbolFlags$$1.Property = 1 << 8;
    SymbolFlags$$1.Readonly = 1 << 9;
    SymbolFlags$$1.ModuleMember = 1 << 10;
    SymbolFlags$$1.InterfaceMember = 1 << 11;
    SymbolFlags$$1.ClassMember = 1 << 12;
    SymbolFlags$$1.BuiltIn = 1 << 13;
    SymbolFlags$$1.TypeSetDuringScopeAssignment = 1 << 14;
    SymbolFlags$$1.Constant = 1 << 15;
    SymbolFlags$$1.Optional = 1 << 16;
    SymbolFlags$$1.RecursivelyReferenced = 1 << 17;
    SymbolFlags$$1.Bound = 1 << 18;
    SymbolFlags$$1.CompilerGenerated = 1 << 19;
    return
  }
  function v39(ModuleFlags$$1) {
    ModuleFlags$$1._map = [];
    ModuleFlags$$1.None = 0;
    ModuleFlags$$1.Exported = 1;
    ModuleFlags$$1.Private = 1 << 1;
    ModuleFlags$$1.Public = 1 << 2;
    ModuleFlags$$1.Ambient = 1 << 3;
    ModuleFlags$$1.Static = 1 << 4;
    ModuleFlags$$1.LocalStatic = 1 << 5;
    ModuleFlags$$1.GetAccessor = 1 << 6;
    ModuleFlags$$1.SetAccessor = 1 << 7;
    ModuleFlags$$1.IsEnum = 1 << 8;
    ModuleFlags$$1.ShouldEmitModuleDecl = 1 << 9;
    ModuleFlags$$1.IsWholeFile = 1 << 10;
    ModuleFlags$$1.IsDynamic = 1 << 11;
    ModuleFlags$$1.MustCaptureThis = 1 << 12;
    return
  }
  function v38(DeclFlags$$1) {
    DeclFlags$$1._map = [];
    DeclFlags$$1.None = 0;
    DeclFlags$$1.Exported = 1;
    DeclFlags$$1.Private = 1 << 1;
    DeclFlags$$1.Public = 1 << 2;
    DeclFlags$$1.Ambient = 1 << 3;
    DeclFlags$$1.Static = 1 << 4;
    DeclFlags$$1.LocalStatic = 1 << 5;
    DeclFlags$$1.GetAccessor = 1 << 6;
    DeclFlags$$1.SetAccessor = 1 << 7;
    return
  }
  function v37(ASTFlags$$1) {
    ASTFlags$$1._map = [];
    ASTFlags$$1.None = 0;
    ASTFlags$$1.ExplicitSemicolon = 1;
    ASTFlags$$1.AutomaticSemicolon = 1 << 1;
    ASTFlags$$1.Writeable = 1 << 2;
    ASTFlags$$1.Error = 1 << 3;
    ASTFlags$$1.DotLHSPartial = 1 << 4;
    ASTFlags$$1.DotLHS = 1 << 5;
    ASTFlags$$1.IsStatement = 1 << 6;
    ASTFlags$$1.StrictMode = 1 << 7;
    ASTFlags$$1.PossibleOptionalParameter = 1 << 8;
    ASTFlags$$1.ClassBaseConstructorCall = 1 << 9;
    ASTFlags$$1.OptionalName = 1 << 10;
    ASTFlags$$1.SkipNextRParen = 1 << 11;
    return
  }
  function v36(Modifiers$$1) {
    Modifiers$$1._map = [];
    Modifiers$$1.None = 0;
    Modifiers$$1.Private = 1;
    Modifiers$$1.Public = 1 << 1;
    Modifiers$$1.Readonly = 1 << 2;
    Modifiers$$1.Ambient = 1 << 3;
    Modifiers$$1.Exported = 1 << 4;
    Modifiers$$1.Getter = 1 << 5;
    Modifiers$$1.Setter = 1 << 6;
    Modifiers$$1.Static = 1 << 7;
    return
  }
  function v35(AllowedElements$$1) {
    AllowedElements$$1._map = [];
    AllowedElements$$1.None = 0;
    AllowedElements$$1.ModuleDeclarations = 1 << 2;
    AllowedElements$$1.ClassDeclarations = 1 << 3;
    AllowedElements$$1.InterfaceDeclarations = 1 << 4;
    AllowedElements$$1.AmbientDeclarations = 1 << 10;
    AllowedElements$$1.Properties = 1 << 11;
    AllowedElements$$1.Global = AllowedElements$$1.ModuleDeclarations | AllowedElements$$1.ClassDeclarations | AllowedElements$$1.InterfaceDeclarations | AllowedElements$$1.AmbientDeclarations;
    AllowedElements$$1.QuickParse = AllowedElements$$1.Global | AllowedElements$$1.Properties;
    return
  }
  function v34(ErrorRecoverySet$$1) {
    ErrorRecoverySet$$1._map = [];
    ErrorRecoverySet$$1.None = 0;
    ErrorRecoverySet$$1.Comma = 1;
    ErrorRecoverySet$$1.SColon = 1 << 1;
    ErrorRecoverySet$$1.Asg = 1 << 2;
    ErrorRecoverySet$$1.BinOp = 1 << 3;
    ErrorRecoverySet$$1.RBrack = 1 << 4;
    ErrorRecoverySet$$1.RCurly = 1 << 5;
    ErrorRecoverySet$$1.RParen = 1 << 6;
    ErrorRecoverySet$$1.Dot = 1 << 7;
    ErrorRecoverySet$$1.Colon = 1 << 8;
    ErrorRecoverySet$$1.PrimType = 1 << 9;
    ErrorRecoverySet$$1.AddOp = 1 << 10;
    ErrorRecoverySet$$1.LCurly = 1 << 11;
    ErrorRecoverySet$$1.PreOp = 1 << 12;
    ErrorRecoverySet$$1.RegExp = 1 << 13;
    ErrorRecoverySet$$1.LParen = 1 << 14;
    ErrorRecoverySet$$1.LBrack = 1 << 15;
    ErrorRecoverySet$$1.Scope = 1 << 16;
    ErrorRecoverySet$$1.In = 1 << 17;
    ErrorRecoverySet$$1.SCase = 1 << 18;
    ErrorRecoverySet$$1.Else = 1 << 19;
    ErrorRecoverySet$$1.Catch = 1 << 20;
    ErrorRecoverySet$$1.Var = 1 << 21;
    ErrorRecoverySet$$1.Stmt = 1 << 22;
    ErrorRecoverySet$$1.While = 1 << 23;
    ErrorRecoverySet$$1.ID = 1 << 24;
    ErrorRecoverySet$$1.Prefix = 1 << 25;
    ErrorRecoverySet$$1.Literal = 1 << 26;
    ErrorRecoverySet$$1.RLit = 1 << 27;
    ErrorRecoverySet$$1.Func = 1 << 28;
    ErrorRecoverySet$$1.EOF = 1 << 29;
    ErrorRecoverySet$$1.TypeScriptS = 1 << 30;
    ErrorRecoverySet$$1.ExprStart = ErrorRecoverySet$$1.SColon | ErrorRecoverySet$$1.AddOp | ErrorRecoverySet$$1.LCurly | ErrorRecoverySet$$1.PreOp | ErrorRecoverySet$$1.RegExp | ErrorRecoverySet$$1.LParen | ErrorRecoverySet$$1.LBrack | ErrorRecoverySet$$1.ID | ErrorRecoverySet$$1.Prefix | ErrorRecoverySet$$1.RLit | ErrorRecoverySet$$1.Func | ErrorRecoverySet$$1.Literal;
    ErrorRecoverySet$$1.StmtStart = ErrorRecoverySet$$1.ExprStart | ErrorRecoverySet$$1.SColon | ErrorRecoverySet$$1.Var | ErrorRecoverySet$$1.Stmt | ErrorRecoverySet$$1.While | ErrorRecoverySet$$1.TypeScriptS;
    ErrorRecoverySet$$1.Postfix = ErrorRecoverySet$$1.Dot | ErrorRecoverySet$$1.LParen | ErrorRecoverySet$$1.LBrack;
    return
  }
  function hasFlag(val, flag$$1) {
    return(val & flag$$1) != 0
  }
  function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags) {
    return fncOrVarOrSymbolOrModuleFlags
  }
  function flagsToString(e$$7, flags$$1) {
    var builder = "";
    var i$$8 = 1;
    var v12189 = i$$8 < 1 << 31;
    for(;v12189;) {
      if((flags$$1 & i$$8) != 0) {
        var k;
        for(k in e$$7) {
          introspect(JAM.policy.p1) {
            var v18680 = e$$7[k]
          }
          if(v18680 == i$$8) {
            if(builder.length > 0) {
              builder = builder + "|"
            }
            builder = builder + k;
            break
          }
        }
      }
      i$$8 = i$$8 << 1;
      v12189 = i$$8 < 1 << 31
    }
    return builder
  }
  TypeScript$$1.hasFlag = hasFlag;
  var v18683 = TypeScript$$1.ErrorRecoverySet;
  if(!v18683) {
    v18683 = TypeScript$$1.ErrorRecoverySet = {}
  }
  v34(v18683);
  var ErrorRecoverySet = TypeScript$$1.ErrorRecoverySet;
  var v18684 = TypeScript$$1.AllowedElements;
  if(!v18684) {
    v18684 = TypeScript$$1.AllowedElements = {}
  }
  v35(v18684);
  var AllowedElements = TypeScript$$1.AllowedElements;
  var v18685 = TypeScript$$1.Modifiers;
  if(!v18685) {
    v18685 = TypeScript$$1.Modifiers = {}
  }
  v36(v18685);
  var Modifiers = TypeScript$$1.Modifiers;
  var v18686 = TypeScript$$1.ASTFlags;
  if(!v18686) {
    v18686 = TypeScript$$1.ASTFlags = {}
  }
  v37(v18686);
  var ASTFlags = TypeScript$$1.ASTFlags;
  var v18687 = TypeScript$$1.DeclFlags;
  if(!v18687) {
    v18687 = TypeScript$$1.DeclFlags = {}
  }
  v38(v18687);
  var DeclFlags = TypeScript$$1.DeclFlags;
  var v18688 = TypeScript$$1.ModuleFlags;
  if(!v18688) {
    v18688 = TypeScript$$1.ModuleFlags = {}
  }
  v39(v18688);
  var ModuleFlags = TypeScript$$1.ModuleFlags;
  var v18689 = TypeScript$$1.SymbolFlags;
  if(!v18689) {
    v18689 = TypeScript$$1.SymbolFlags = {}
  }
  v40(v18689);
  var SymbolFlags = TypeScript$$1.SymbolFlags;
  var v18690 = TypeScript$$1.VarFlags;
  if(!v18690) {
    v18690 = TypeScript$$1.VarFlags = {}
  }
  v41(v18690);
  var VarFlags = TypeScript$$1.VarFlags;
  var v18691 = TypeScript$$1.FncFlags;
  if(!v18691) {
    v18691 = TypeScript$$1.FncFlags = {}
  }
  v42(v18691);
  var FncFlags = TypeScript$$1.FncFlags;
  var v18692 = TypeScript$$1.SignatureFlags;
  if(!v18692) {
    v18692 = TypeScript$$1.SignatureFlags = {}
  }
  v43(v18692);
  var SignatureFlags = TypeScript$$1.SignatureFlags;
  TypeScript$$1.ToDeclFlags = ToDeclFlags;
  var v18693 = TypeScript$$1.TypeFlags;
  if(!v18693) {
    v18693 = TypeScript$$1.TypeFlags = {}
  }
  v44(v18693);
  var TypeFlags = TypeScript$$1.TypeFlags;
  var v18694 = TypeScript$$1.TypeRelationshipFlags;
  if(!v18694) {
    v18694 = TypeScript$$1.TypeRelationshipFlags = {}
  }
  v45(v18694);
  var TypeRelationshipFlags = TypeScript$$1.TypeRelationshipFlags;
  var v18695 = TypeScript$$1.CodeGenTarget;
  if(!v18695) {
    v18695 = TypeScript$$1.CodeGenTarget = {}
  }
  v46(v18695);
  var CodeGenTarget = TypeScript$$1.CodeGenTarget;
  var v18696 = TypeScript$$1.ModuleGenTarget;
  if(!v18696) {
    v18696 = TypeScript$$1.ModuleGenTarget = {}
  }
  v47(v18696);
  var ModuleGenTarget = TypeScript$$1.ModuleGenTarget;
  TypeScript$$1.codeGenTarget = CodeGenTarget.ES3;
  TypeScript$$1.moduleGenTarget = ModuleGenTarget.Synchronous;
  TypeScript$$1.optimizeModuleCodeGen = true;
  TypeScript$$1.flagsToString = flagsToString;
  return
}
function v33(s$$8) {
  var i$$7 = 0;
  var v12205 = i$$7 < s$$8.length;
  for(;v12205;) {
    var c$$1 = JAM.call(s$$8.charCodeAt, s$$8, [i$$7]);
    this.cumulative_checksum = this.cumulative_checksum << 1 ^ c$$1;
    i$$7 = i$$7 + 1;
    v12205 = i$$7 < s$$8.length
  }
  return
}
function v32() {
  if(this.checksum != this.cumulative_checksum) {
    throw new Error("Wrong checksum.");
  }
  this.cumulative_checksum = 0;
  return
}
function v31(s$$7) {
  JAM.call(this.Verify, this, [s$$7 + "\n"]);
  return
}
function v30(s$$6) {
  JAM.call(this.Verify, this, [s$$6]);
  return
}
function v29(s$$5) {
  var i$$6 = 0;
  var v12209 = i$$6 < s$$5.length;
  for(;v12209;) {
    var c = JAM.call(s$$5.charCodeAt, s$$5, [i$$6]);
    this.cumulative_checksum = this.cumulative_checksum << 1 ^ c;
    i$$6 = i$$6 + 1;
    v12209 = i$$6 < s$$5.length
  }
  return
}
function v28() {
  if(this.checksum != this.cumulative_checksum) {
    throw new Error("Wrong checksum.");
  }
  this.cumulative_checksum = 0;
  return
}
function v27(s$$4) {
  JAM.call(this.Verify, this, [s$$4 + "\n"]);
  return
}
function v26(s$$3) {
  JAM.call(this.Verify, this, [s$$3]);
  return
}
function v25(runner$$2) {
  function RunNextSetup() {
    if(index$$40 < length$$12) {
      try {
        var v18707 = suite$$1.benchmarks;
        introspect(JAM.policy.p1) {
          var v12212 = v18707[index$$40]
        }
        v12212.Setup()
      }catch(e$$4) {
        JAM.call(suite$$1.NotifyError, suite$$1, [e$$4]);
        return null
      }
      return RunNextBenchmark
    }
    suite$$1.NotifyResult();
    return null
  }
  function RunNextBenchmark() {
    try {
      var v18708 = suite$$1.benchmarks;
      introspect(JAM.policy.p1) {
        var v12214 = v18708[index$$40]
      }
      data$$20 = JAM.call(suite$$1.RunSingleBenchmark, suite$$1, [v12214, data$$20])
    }catch(e$$5) {
      JAM.call(suite$$1.NotifyError, suite$$1, [e$$5]);
      return null
    }
    var v12215;
    if(data$$20 == null) {
      v12215 = RunNextTearDown
    }else {
      v12215 = RunNextBenchmark()
    }
    return v12215
  }
  function RunNextTearDown() {
    try {
      var v18710 = suite$$1.benchmarks;
      var v18711 = index$$40;
      index$$40 = index$$40 + 1;
      introspect(JAM.policy.p1) {
        var v12216 = v18710[v18711]
      }
      v12216.TearDown()
    }catch(e$$6) {
      JAM.call(suite$$1.NotifyError, suite$$1, [e$$6]);
      return null
    }
    return RunNextSetup
  }
  BenchmarkSuite.ResetRNG();
  this.results = [];
  this.runner = runner$$2;
  var length$$12 = this.benchmarks.length;
  var index$$40 = 0;
  var suite$$1 = this;
  var data$$20;
  return RunNextSetup()
}
function v24(benchmark$$1, data$$18) {
  function Measure(data$$19) {
    var elapsed = 0;
    var start$$4 = new Date;
    var i$$5 = 0;
    var v18712;
    if(doDeterministic$$1) {
      v18712 = i$$5 < benchmark$$1.deterministicIterations
    }else {
      v18712 = elapsed < 1E3
    }
    var v12219 = v18712;
    for(;v12219;) {
      benchmark$$1.run();
      elapsed = new Date - start$$4;
      i$$5 = i$$5 + 1;
      var v18713;
      if(doDeterministic$$1) {
        v18713 = i$$5 < benchmark$$1.deterministicIterations
      }else {
        v18713 = elapsed < 1E3
      }
      v12219 = v18713
    }
    if(data$$19 != null) {
      data$$19.runs = data$$19.runs + i$$5;
      data$$19.elapsed = data$$19.elapsed + elapsed
    }
    return
  }
  var config = BenchmarkSuite.config;
  var v12221;
  if(config.doWarmup !== undefined) {
    v12221 = config.doWarmup
  }else {
    v12221 = benchmark$$1.doWarmup
  }
  var doWarmup$$1 = v12221;
  var v12222;
  if(config.doDeterministic !== undefined) {
    v12222 = config.doDeterministic
  }else {
    v12222 = benchmark$$1.doDeterministic
  }
  var doDeterministic$$1 = v12222;
  var v18718 = !doWarmup$$1;
  if(v18718) {
    v18718 = data$$18 == null
  }
  if(v18718) {
    data$$18 = {runs:0, elapsed:0}
  }
  if(data$$18 == null) {
    Measure(null);
    return{runs:0, elapsed:0}
  }else {
    Measure(data$$18);
    if(data$$18.runs < benchmark$$1.minIterations) {
      return data$$18
    }
    var usec = data$$18.elapsed * 1E3 / data$$18.runs;
    var v12227;
    if(benchmark$$1.rmsResult != null) {
      v12227 = benchmark$$1.rmsResult()
    }else {
      v12227 = 0
    }
    var rms = v12227;
    JAM.call(this.NotifyStep, this, [new BenchmarkResult(benchmark$$1, usec, rms)]);
    return null
  }
  return
}
function v23(error$$2) {
  if(this.runner.NotifyError) {
    var v12230 = this.runner;
    JAM.call(v12230.NotifyError, v12230, [this.name, error$$2])
  }
  if(this.runner.NotifyStep) {
    var v12233 = this.runner;
    JAM.call(v12233.NotifyStep, v12233, [this.name])
  }
  return
}
function v22(runner$$1) {
  var v12236 = BenchmarkSuite.scores;
  JAM.call(v12236.push, v12236, [1]);
  if(runner$$1.NotifyResult) {
    JAM.call(runner$$1.NotifyResult, runner$$1, [this.name, "Skipped"])
  }
  return
}
function v21() {
  var mean = JAM.call(BenchmarkSuite.GeometricMeanTime, BenchmarkSuite, [this.results]);
  var score$$1 = this.reference[0] / mean;
  var v12241 = BenchmarkSuite.scores;
  JAM.call(v12241.push, v12241, [score$$1]);
  if(this.runner.NotifyResult) {
    var formatted$$1 = JAM.call(BenchmarkSuite.FormatScore, BenchmarkSuite, [100 * score$$1]);
    var v12243 = this.runner;
    JAM.call(v12243.NotifyResult, v12243, [this.name, formatted$$1])
  }
  if(this.reference.length == 2) {
    var meanLatency = JAM.call(BenchmarkSuite.GeometricMeanLatency, BenchmarkSuite, [this.results]);
    if(meanLatency != 0) {
      var scoreLatency = this.reference[1] / meanLatency;
      var v12248 = BenchmarkSuite.scores;
      JAM.call(v12248.push, v12248, [scoreLatency]);
      if(this.runner.NotifyResult) {
        var formattedLatency = JAM.call(BenchmarkSuite.FormatScore, BenchmarkSuite, [100 * scoreLatency]);
        var v12250 = this.runner;
        JAM.call(v12250.NotifyResult, v12250, [this.name + "Latency", formattedLatency])
      }
    }
  }
  return
}
function v20(result$$1) {
  var v12255 = this.results;
  JAM.call(v12255.push, v12255, [result$$1]);
  if(this.runner.NotifyStep) {
    var v12256 = this.runner;
    JAM.call(v12256.NotifyStep, v12256, [result$$1.benchmark.name])
  }
  return
}
function v19(value$$29) {
  if(value$$29 > 100) {
    return value$$29.toFixed(0)
  }else {
    return value$$29.toPrecision(3)
  }
  return
}
function v18(measurements$$1) {
  var log$$2 = 0;
  var hasLatencyResult = false;
  var i$$4 = 0;
  var v12261 = i$$4 < measurements$$1.length;
  for(;v12261;) {
    introspect(JAM.policy.p1) {
      var v22773 = measurements$$1[i$$4]
    }
    if(v22773.latency != 0) {
      var v18735 = log$$2;
      introspect(JAM.policy.p1) {
        var v24769 = measurements$$1[i$$4]
      }
      log$$2 = v18735 + JAM.call(Math.log, Math, [v24769.latency]);
      hasLatencyResult = true
    }
    i$$4 = i$$4 + 1;
    v12261 = i$$4 < measurements$$1.length
  }
  if(hasLatencyResult) {
    return Math.pow(Math.E, log$$2 / measurements$$1.length)
  }else {
    return 0
  }
  return
}
function v17(measurements) {
  var log$$1 = 0;
  var i$$3 = 0;
  var v12264 = i$$3 < measurements.length;
  for(;v12264;) {
    var v18740 = log$$1;
    introspect(JAM.policy.p1) {
      var v24770 = measurements[i$$3]
    }
    log$$1 = v18740 + JAM.call(Math.log, Math, [v24770.time]);
    i$$3 = i$$3 + 1;
    v12264 = i$$3 < measurements.length
  }
  return Math.pow(Math.E, log$$1 / measurements.length)
}
function v16(numbers) {
  var log = 0;
  var i$$2 = 0;
  var v12267 = i$$2 < numbers.length;
  for(;v12267;) {
    var v18745 = log;
    introspect(JAM.policy.p1) {
      var v22776 = numbers[i$$2]
    }
    log = v18745 + JAM.call(Math.log, Math, [v22776]);
    i$$2 = i$$2 + 1;
    v12267 = i$$2 < numbers.length
  }
  return Math.pow(Math.E, log / numbers.length)
}
function v15() {
  var result = 0;
  var suites$$1 = BenchmarkSuite.suites;
  var i$$1 = 0;
  var v12270 = i$$1 < suites$$1.length;
  for(;v12270;) {
    introspect(JAM.policy.p1) {
      var v24771 = suites$$1[i$$1]
    }
    result = result + v24771.benchmarks.length;
    i$$1 = i$$1 + 1;
    v12270 = i$$1 < suites$$1.length
  }
  return result
}
function v14(runner, skipBenchmarks$$1) {
  function RunStep() {
    var v18752 = continuation;
    if(!v18752) {
      v18752 = index$$39 < length$$11
    }
    var v12276 = v18752;
    for(;v12276;) {
      if(continuation) {
        continuation = continuation()
      }else {
        var v12271 = index$$39;
        index$$39 = index$$39 + 1;
        introspect(JAM.policy.p1) {
          var suite = suites[v12271]
        }
        if(runner.NotifyStart) {
          JAM.call(runner.NotifyStart, runner, [suite.name])
        }
        if(skipBenchmarks$$1.indexOf(suite.name) > -1) {
          JAM.call(suite.NotifySkipped, suite, [runner])
        }else {
          continuation = JAM.call(suite.RunStep, suite, [runner])
        }
      }
      var v18754 = continuation;
      if(v18754) {
        var v22780 = typeof window != "undefined";
        if(v22780) {
          v22780 = window.setTimeout
        }
        v18754 = v22780
      }
      if(v18754) {
        window.setTimeout(RunStep, 25);
        return
      }
      var v18755 = continuation;
      if(!v18755) {
        v18755 = index$$39 < length$$11
      }
      v12276 = v18755
    }
    if(runner.NotifyScore) {
      var score = JAM.call(BenchmarkSuite.GeometricMean, BenchmarkSuite, [BenchmarkSuite.scores]);
      var formatted = JAM.call(BenchmarkSuite.FormatScore, BenchmarkSuite, [100 * score]);
      JAM.call(runner.NotifyScore, runner, [formatted])
    }
    return
  }
  var v12280;
  if(typeof skipBenchmarks$$1 === "undefined") {
    v12280 = []
  }else {
    v12280 = skipBenchmarks$$1
  }
  skipBenchmarks$$1 = v12280;
  var continuation = null;
  var suites = BenchmarkSuite.suites;
  var length$$11 = suites.length;
  BenchmarkSuite.scores = [];
  var index$$39 = 0;
  RunStep();
  return
}
function v13() {
  function v12() {
    function v11() {
      seed = seed + 2127912214 + (seed << 12) & 4294967295;
      seed = (seed ^ 3345072700 ^ seed >>> 19) & 4294967295;
      seed = seed + 374761393 + (seed << 5) & 4294967295;
      seed = (seed + 3550635116 ^ seed << 9) & 4294967295;
      seed = seed + 4251993797 + (seed << 3) & 4294967295;
      seed = (seed ^ 3042594569 ^ seed >>> 16) & 4294967295;
      return(seed & 268435455) / 268435456
    }
    var seed = 49734321;
    return v11
  }
  var v12288 = Math;
  var v27444 = v12();
  v12288.random = v27444;
  return
}
function v10(s$$2) {
  throw"Alert called with argument: " + s$$2;
}
function v9() {
  return this.time
}
function v8() {
  var v12289 = performance.now;
  if(!v12289) {
    var v18769 = performance.mozNow;
    if(!v18769) {
      var v22783 = performance.msNow;
      if(!v22783) {
        var v24773 = performance.oNow;
        if(!v24773) {
          var v25739 = performance.webkitNow;
          if(!v25739) {
            v25739 = Date.now
          }
          v24773 = v25739
        }
        v22783 = v24773
      }
      v18769 = v22783
    }
    v12289 = v18769
  }
  return v12289
}
function Benchmark(name$$31, doWarmup, doDeterministic, deterministicIterations, run, setup, tearDown, rmsResult, minIterations) {
  function v1() {
    return
  }
  function v0() {
    return
  }
  this.name = name$$31;
  this.doWarmup = doWarmup;
  this.doDeterministic = doDeterministic;
  this.deterministicIterations = deterministicIterations;
  this.run = run;
  var v12290;
  if(setup) {
    v12290 = setup
  }else {
    v12290 = v0
  }
  this.Setup = v12290;
  var v12291;
  if(tearDown) {
    v12291 = tearDown
  }else {
    v12291 = v1
  }
  this.TearDown = v12291;
  var v12292;
  if(rmsResult) {
    v12292 = rmsResult
  }else {
    v12292 = null
  }
  this.rmsResult = v12292;
  var v12293;
  if(minIterations) {
    v12293 = minIterations
  }else {
    v12293 = 32
  }
  this.minIterations = v12293;
  return
}
function BenchmarkResult(benchmark, time, latency) {
  this.benchmark = benchmark;
  this.time = time;
  this.latency = latency;
  return
}
function BenchmarkSuite(name$$32, reference, benchmarks$$1) {
  this.name = name$$32;
  this.reference = reference;
  this.benchmarks = benchmarks$$1;
  var v12294 = BenchmarkSuite.suites;
  JAM.call(v12294.push, v12294, [this]);
  return
}
function setupTypescript() {
  return
}
function tearDownTypescript() {
  compiler_input = null;
  return
}
function runTypescript() {
  function v5(path$$2) {
    return path$$2
  }
  function v4(path$$1) {
    return false
  }
  function v3(path) {
    return false
  }
  function v2(fileName) {
    return outfile
  }
  var compiler = createCompiler();
  JAM.call(compiler.addUnit, compiler, [compiler_input, "compiler_input.ts"]);
  parseErrors = [];
  compiler.reTypeCheck();
  JAM.call(compiler.emit, compiler, [{createFile:v2, fileExists:v3, directoryExists:v4, resolvePath:v5}]);
  var v18771 = parseErrors.length != 192;
  if(v18771) {
    v18771 = parseErrors.length != 193
  }
  if(v18771) {
    throw new Error("Parse errors.");
  }
  compiler = null;
  return
}
function createCompiler() {
  function v6(start$$5, len, message$$10) {
    JAM.call(parseErrors.push, parseErrors, [{start:start$$5, len:len, message:message$$10}]);
    return
  }
  var settings = new TypeScript.CompilationSettings;
  settings.codeGenTarget = TypeScript.CodeGenTarget.ES5;
  var compiler$$1 = JAM.new(TypeScript.TypeScriptCompiler, [outerr, new TypeScript.NullLogger, settings]);
  JAM.call(compiler$$1.setErrorCallback, compiler$$1, [v6]);
  compiler$$1.parser.errorRecovery = true;
  compiler$$1.typeCheck();
  return compiler$$1
}
function ShowBox(name$$93) {
  function v7(entry$$3) {
    if(name$$93.valueOf() === entry$$3.valueOf()) {
      var box1 = document.getElementById("Box-" + name$$93 + "Latency");
      box1.style.visibility = "visible"
    }
    return
  }
  var box = document.getElementById("Box-" + name$$93);
  box.style.visibility = "visible";
  var bar = document.getElementById("progress-bar").style.width = "" + (completed = completed + 1) / benchmarks * 100 + "%";
  latencyBenchmarks.forEach(v7);
  return
}
function AddResult(name$$94, result$$41) {
  JAM.call(console.log, console, [name$$94 + ": " + result$$41]);
  var box$$1 = document.getElementById("Result-" + name$$94);
  JAM.set(box$$1, "innerHTML", result$$41);
  return
}
function AddError(name$$95, error$$4) {
  JAM.call(console.log, console, [name$$95 + ": " + error$$4.message]);
  if(error$$4 == "TypedArrayUnsupported") {
    AddResult(name$$95, "<b>Unsupported</b>")
  }else {
    if(error$$4 == "PerformanceNowUnsupported") {
      AddResult(name$$95, "<b>Timer error</b>")
    }else {
      AddResult(name$$95, "<b>Error</b>")
    }
  }
  success = false;
  return
}
function AddScore(score$$2) {
  var status$$1 = document.getElementById("main-banner");
  if(success) {
    JAM.set(status$$1, "innerHTML", "Octane Score: " + score$$2)
  }else {
    JAM.set(status$$1, "innerHTML", "Octane Score (incomplete): " + score$$2)
  }
  document.getElementById("progress-bar-container").style.visibility = "hidden";
  document.getElementById("bottom-text").style.visibility = "visible";
  document.getElementById("inside-anchor").removeChild(document.getElementById("bar-appendix"));
  document.getElementById("alertbox").style.visibility = "hidden";
  return
}
function Run() {
  JAM.set(document.getElementById("main-banner"), "innerHTML", "Running Octane...");
  JAM.set(document.getElementById("bar-appendix"), "innerHTML", '<br/><div class="progress progress-striped" id="progress-bar-container" style="visibility:hidden"><div class="bar"style="width: 0%;" id="progress-bar"></div></div>');
  var anchor = document.getElementById("run-octane");
  var parent$$73 = document.getElementById("main-container");
  JAM.call(parent$$73.appendChild, parent$$73, [document.getElementById("inside-anchor")]);
  parent$$73.removeChild(anchor);
  JAM.set(document.getElementById("startup-text"), "innerHTML", "");
  document.getElementById("progress-bar-container").style.visibility = "visible";
  JAM.call(BenchmarkSuite.RunSuites, BenchmarkSuite, [{NotifyStart:ShowBox, NotifyError:AddError, NotifyResult:AddResult, NotifyScore:AddScore}, skipBenchmarks]);
  return
}
function CheckCompatibility() {
  var v12325 = typeof Uint8Array != "undefined";
  if(v12325) {
    var v18786 = typeof Float64Array != "undefined";
    if(v18786) {
      v18786 = typeof(new Uint8Array(0)).subarray != "undefined"
    }
    v12325 = v18786
  }
  var hasTypedArrays = v12325;
  if(!hasTypedArrays) {
    JAM.call(console.log, console, ["Typed Arrays not supported"]);
    document.getElementById("alertbox").style.display = "block"
  }
  if(window.document.URL.indexOf("skip_zlib=1") >= 0) {
    JAM.call(skipBenchmarks.push, skipBenchmarks, ["zlib"])
  }
  if(window.document.URL.indexOf("auto=1") >= 0) {
    Run()
  }
  return
}
function Load() {
  JAM.call(setTimeout, null, [CheckCompatibility, 200]);
  return
}
var performance = performance || {};
var v12330 = performance;
var v27445 = v8();
v12330.now = v27445;
BenchmarkResult.prototype.valueOf = v9;
BenchmarkSuite.suites = [];
BenchmarkSuite.version = "9";
BenchmarkSuite.config = {doWarmup:undefined, doDeterministic:undefined};
alert = v10;
BenchmarkSuite.ResetRNG = v13;
BenchmarkSuite.RunSuites = v14;
BenchmarkSuite.CountBenchmarks = v15;
BenchmarkSuite.GeometricMean = v16;
BenchmarkSuite.GeometricMeanTime = v17;
BenchmarkSuite.GeometricMeanLatency = v18;
BenchmarkSuite.FormatScore = v19;
BenchmarkSuite.prototype.NotifyStep = v20;
BenchmarkSuite.prototype.NotifyResult = v21;
BenchmarkSuite.prototype.NotifySkipped = v22;
BenchmarkSuite.prototype.NotifyError = v23;
BenchmarkSuite.prototype.RunSingleBenchmark = v24;
BenchmarkSuite.prototype.RunStep = v25;
var typescript = new BenchmarkSuite("Typescript", [255011322], [new Benchmark("Typescript", false, true, 5, runTypescript, setupTypescript, tearDownTypescript, null, 1)]);
var parseErrors = [];
var outfile = {checksum:-412589664, cumulative_checksum:0, Write:v26, WriteLine:v27, Close:v28, Verify:v29};
var outerr = {checksum:0, cumulative_checksum:0, Write:v30, WriteLine:v31, Close:v32, Verify:v33};
var v27697 = '//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nmodule TypeScript {\n    export class AstLogger {\n\n        constructor (public logger: ILogger) { }\n\n        public logScript(script: TypeScript.Script): void {\n            this.logLinemap(script.locationInfo.lineMap);\n\n            var stack: AST[]= [];\n\n            var pre = (cur: TypeScript.AST, parent: TypeScript.AST) => {\n                stack.push(cur);\n                var indent = (stack.length - 1) * 2;\n                this.logComments(script, cur.preComments, indent);\n                this.logNode(script, cur, indent);\n                this.logComments(script, cur.postComments, indent);\n                return cur;\n            }\n\n            var post = (cur: TypeScript.AST, parent: TypeScript.AST) => {\n                stack.pop();\n                return cur;\n            }\n\n            TypeScript.getAstWalkerFactory().walk(script, pre, post);\n        }\n\n\n        public logNode(script: TypeScript.Script, cur: TypeScript.AST, indent: number) {\n            var msg = this.addPadding("", indent, "| ", true);\n\n            msg = msg.concat("+ " + cur.treeViewLabel());\n            msg = this.addPadding(msg, 70, " ", false);\n\n            msg = msg + this.addLineColumn(script, cur.minChar);\n            msg = this.addPadding(msg, 80, " ", false);\n\n            msg = msg + "=> ";\n            msg = msg + this.addLineColumn(script, cur.limChar);\n            msg = this.addPadding(msg, 102, " ", false);\n\n            msg = msg.concat("[" + this.addPadding(cur.minChar.toString(), 1, " ", true) + ", " + this.addPadding(cur.limChar.toString(), 1, " ", true) + "]");\n\n            msg = this.addPadding(msg, 115, " ", false);\n            msg = msg.concat("sym=" + (<any>cur).sym);\n\n            msg = this.addPadding(msg, 135, " ", false);\n            msg = msg.concat("type=" + (cur.type === null ? "null" : cur.type.getTypeName()));\n            this.logger.log(msg);\n        }\n\n        private logComments(script: TypeScript.Script, comments: TypeScript.AST[], indent: number) {\n            if (comments == null)\n                return;\n\n            for (var i = 0; i < comments.length; i++) {\n                this.logNode(script, comments[i], indent);\n            }\n        }\n\n        public logLinemap(linemap: number[]) {\n            var result = "[";\n            for (var i = 0; i < linemap.length; i++) {\n                if (i > 0)\n                    result += ",";\n                result += linemap[i];\n            }\n            result += "]";\n            this.logger.log("linemap: " + result);\n        }\n\n        private addPadding(s: string, targetLength: number, paddingString: string, leftPadding: bool): string {\n            var result = (leftPadding ? "" : s);\n            for (var i = s.length; i < targetLength; i++) {\n                result = result + paddingString;\n            }\n            result = result + (leftPadding ? s : "");\n            return result;\n        }\n\n        private addLineColumn(script: TypeScript.Script, position: numbe' + 
'r): string {\n            // just for calling getSourceLineColFromMap\n            var lineInfo = {\n                line: -1,\n                col: -1\n            }\n            TypeScript.getSourceLineColFromMap(lineInfo, position, script.locationInfo.lineMap);\n\n            if (lineInfo.col !== -1) {\n                lineInfo.col++; //TODO: function above seems to consider line as 1-based, and column as 0-based\n            }\n\n            return "(" + lineInfo.line + ", " + lineInfo.col + ")";\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export function lastOf(items: any[]): any {\n        return (items === null || items.length === 0) ? null : items[items.length - 1];\n    }\n\n    export function max(a: number, b: number): number {\n        return a >= b ? a : b;\n    }\n\n    export function min(a: number, b: number): number {\n        return a <= b ? a : b;\n    }\n\n    //\n    // Helper class representing a path from a root ast node to a (grand)child ast node.\n    // This is helpful as our tree don\'t have parents.\n    //\n    export class AstPath {\n        public asts: TypeScript.AST[] = [];\n        public top: number = -1;\n\n        static reverseIndexOf(items: any[], index: number): any {\n            return (items === null || items.length <= index) ? null : items[items.length - index - 1];\n        }\n\n        public clone(): AstPath {\n            var clone = new AstPath();\n            clone.asts = this.asts.map((value) => { return value; });\n            clone.top = this.top;\n            return clone;\n        }\n\n        public pop(): TypeScript.AST {\n            var head = this.ast();\n            this.up();\n\n            while (this.asts.length > this.count()) {\n                this.asts.pop();\n            }\n            return head;\n        }\n\n        public push(ast: TypeScript.AST) {\n            while (this.asts.length > this.count()) {\n                this.asts.pop();\n            }\n            this.top = this.asts.length;\n            this.asts.push(ast);\n        }\n\n        public up() {\n            if (this.top <= -1)\n                throw new Error("Invalid call to \'up\'");\n            this.top--;\n        }\n\n        public down() {\n            if (this.top == this.ast.length - 1)\n                throw new Error("Invalid call to \'down\'");\n            this.top++;\n        }\n\n        public nodeType(): TypeScript.NodeType {\n            if (this.ast() == null)\n                return TypeScript.NodeType.None;\n            return this.ast().nodeType;\n        }\n\n        public ast() {\n            return <TypeScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));\n        }\n\n        public parent() {\n            return <TypeScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);\n        }\n\n        public count() {\n            return this.top + 1;\n        }\n\n        public get(index: number): TypeScript.AST {\n            return this.asts[index];\n        }\n\n        public isNameOfClass(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.ClassDeclaration) &&\n                ((<TypeScript.InterfaceDeclaration>this.parent()).name === this.ast());\n        }\n\n        public isNameOfInterface(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.InterfaceDeclaration) &&\n                ((<TypeScript.InterfaceDeclaration>this.parent()).name === this.ast());\n        }\n\n        public isNameOfArgument(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.ArgDecl) &&\n                ((<TypeScript.ArgDecl>this.parent()).id === this.ast());\n        }\n\n        public isNameOfVariable(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === Ty';
var v27696 = v27697 + "peScript.NodeType.VarDecl) &&\n                ((<TypeScript.VarDecl>this.parent()).id === this.ast());\n        }\n\n        public isNameOfModule(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.ModuleDeclaration) &&\n                ((<TypeScript.ModuleDeclaration>this.parent()).name === this.ast());\n        }\n\n        public isNameOfFunction(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.FuncDecl) &&\n                ((<TypeScript.FuncDecl>this.parent()).name === this.ast());\n        }\n\n        public isChildOfScript(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Script;\n        }\n\n        public isChildOfModule(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ModuleDeclaration;\n        }\n\n        public isChildOfClass(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ClassDeclaration;\n        }\n\n        public isArgumentOfClassConstructor(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 5 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl &&\n                this.asts[this.top - 3].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 4].nodeType === TypeScript.NodeType.ClassDeclaration &&\n                ((<TypeScript.FuncDecl>this.asts[this.top - 2]).isConstructor) &&\n                ((<TypeScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1]) &&\n                ((<TypeScript.ClassDeclaration>this.asts[this.top - 4]).constructorDecl === this.asts[this.top - 2]);\n        }\n\n        public isChildOfInterface(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.InterfaceDeclaration;\n        }\n\n        public isTopLevelImplicitModule() {\n            return this.count() >= 1 &&\n                this.asts[this.top].nodeType === TypeScript.NodeType.ModuleDeclaration &&\n                TypeScript.hasFlag((<TypeScript.ModuleDeclaration>this.asts[this.top]).modFlags, TypeScript.ModuleFlags.IsWholeFile);\n        }\n\n        public isBodyOfTopLevelImplicitModule() {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ModuleDeclaration &&\n                 (<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] &&\n                TypeScript.hasFlag((<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).modFlags, TypeScript.ModuleFlags.IsWholeFile);\n        }\n\n        public isBodyOfScript(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Script &&\n                 (<TypeScript.Script>this.asts[this.top - 1]).bod == this.asts[this.top - 0];\n        }\n\n        public isBodyOfSwitch(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Switch &&\n                 (<TypeScript.SwitchStatement>this.asts[this.top - 1]).caseList == this.asts[this.top - 0];\n        }\n\n        public isBodyOfModule(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ModuleDeclaration &&\n                 (<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        public isBodyOfClass(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ClassDeclaration &&\n                 (<T";
var v27695 = v27696 + "ypeScript.ClassDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        public isBodyOfFunction(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl &&\n                 (<TypeScript.FuncDecl>this.asts[this.top - 1]).bod == this.asts[this.top - 0];\n        }\n\n        public isBodyOfInterface(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.InterfaceDeclaration &&\n                 (<TypeScript.InterfaceDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        public isBodyOfBlock(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Block &&\n                (<TypeScript.Block>this.asts[this.top - 1]).statements == this.asts[this.top - 0];\n        }\n\n        public isBodyOfFor(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.For &&\n                (<TypeScript.ForStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfCase(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Case &&\n                (<TypeScript.CaseStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfTry(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Try &&\n                (<TypeScript.Try>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfCatch(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Catch &&\n                (<TypeScript.Catch>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfDoWhile(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.DoWhile &&\n                (<TypeScript.DoWhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfWhile(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.While &&\n                (<TypeScript.WhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfForIn(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ForIn &&\n                (<TypeScript.ForInStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfWith(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.With &&\n                (<TypeScript.WithStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfFinally(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Finally &&\n                (<TypeScript.Finally>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isCaseOfSwitch(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1];\n        }\n\n        public isDefaultCaseOfSwitch(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1] &&\n                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).defaultCase == this.asts[this.top - 0];\n        }\n\n        public isListOfObjectLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];\n        }\n\n        public isBodyOfObjectLit(): bool {\n            return this.isListOfObjectLit();\n        }\n\n        public isEmptyListOfObjectLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.UnaryExpression>this.asts[t";
var v27694 = v27695 + "his.top - 1]).operand == this.asts[this.top - 0] &&\n                (<TypeScript.ASTList>this.asts[this.top - 0]).members.length == 0;\n        }\n\n        public isMemberOfObjectLit(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Member &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 2]).operand == this.asts[this.top - 1];\n        }\n\n        public isNameOfMemberOfObjectLit(): bool {\n            return this.count() >= 4 &&\n                this.asts[this.top - 3].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Name &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 3]).operand == this.asts[this.top - 2];\n        }\n\n        public isListOfArrayLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ArrayLit &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];\n        }\n\n        public isTargetOfMember(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&\n                (<TypeScript.BinaryExpression>this.asts[this.top - 1]).operand1 === this.asts[this.top - 0];\n        }\n\n        public isMemberOfMember(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&\n                (<TypeScript.BinaryExpression>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];\n        }\n\n        public isItemOfList(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List;\n            //(<Tools.ASTList>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];\n        }\n\n        public isThenOfIf(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.If &&\n                (<TypeScript.IfStatement>this.asts[this.top - 1]).thenBod == this.asts[this.top - 0];\n        }\n\n        public isElseOfIf(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.If &&\n                (<TypeScript.IfStatement>this.asts[this.top - 1]).elseBod == this.asts[this.top - 0];\n        }\n\n        public isBodyOfDefaultCase(): bool {\n            return this.isBodyOfCase();\n        }\n\n        public isSingleStatementList(): bool {\n            return this.count() >= 1 &&\n                this.asts[this.top].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.ASTList>this.asts[this.top]).members.length === 1;\n        }\n\n        public isArgumentListOfFunction(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl &&\n                (<TypeScript.FuncDecl>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];\n        }\n\n        public isArgumentOfFunction(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl &&\n                (<TypeScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1];\n        }\n\n        public isArgumentListOfCall(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Call &&\n                (<TypeScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];\n        }\n\n        public isArgumentListOfNew(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.New &&\n                (<TypeScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];\n        }\n\n        public isSynthesizedBlock(): bool {\n            return this.count() >= 1 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Block &&\n                (<TypeScript.Block>this.asts[this.top - 0]).isStatementBlock === false;\n        }\n    }\n\n    export function isValidAstNode(ast: Typ";
var v27693 = v27694 + 'eScript.ASTSpan): bool {\n        if (ast === null)\n            return false;\n\n        if (ast.minChar === -1 || ast.limChar === -1)\n            return false;\n\n        return true;\n    }\n\n    export class AstPathContext {\n        public path = new TypeScript.AstPath();\n    }\n\n    export enum GetAstPathOptions {\n        Default = 0,\n        EdgeInclusive = 1,\n        //We need this options dealing with an AST coming from an incomplete AST. For example:\n        //     class foo { // r\n        // If we ask for the AST at the position after the "r" character, we won\'t see we are \n        // inside a comment, because the "class" AST node has a limChar corresponding to the position of \n        // the "{" character, meaning we don\'t traverse the tree down to the stmt list of the class, meaning\n        // we don\'t find the "precomment" attached to the errorneous empty stmt.\n        //TODO: It would be nice to be able to get rid of this.\n        DontPruneSearchBasedOnPosition = 1 << 1,\n    }\n\n    ///\n    /// Return the stack of AST nodes containing "position"\n    ///\n    export function getAstPathToPosition(script: TypeScript.AST, pos: number, options = GetAstPathOptions.Default): TypeScript.AstPath {\n        var lookInComments = (comments: TypeScript.Comment[]) => {\n            if (comments && comments.length > 0) {\n                for (var i = 0; i < comments.length; i++) {\n                    var minChar = comments[i].minChar;\n                    var limChar = comments[i].limChar;\n                    if (!comments[i].isBlockComment) {\n                        limChar++; // For single line comments, include 1 more character (for the newline)\n                    }\n                    if (pos >= minChar && pos < limChar) {\n                        ctx.path.push(comments[i]);\n                    }\n                }\n            }\n        }\n\n        var pre = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: IAstWalker) {\n            if (isValidAstNode(cur)) {\n\n                // Add "cur" to the stack if it contains our position\n                // For "identifier" nodes, we need a special case: A position equal to "limChar" is\n                // valid, since the position corresponds to a caret position (in between characters)\n                // For example:\n                //  bar\n                //  0123\n                // If "position == 3", the caret is at the "right" of the "r" character, which should be considered valid\n                var inclusive =\n                    hasFlag(options, GetAstPathOptions.EdgeInclusive) ||\n                    cur.nodeType === TypeScript.NodeType.Name ||\n                    pos === script.limChar; // Special "EOF" case\n\n                var minChar = cur.minChar;\n                var limChar = cur.limChar + (inclusive ? 1 : 0)\n                if (pos >= minChar && pos < limChar) {\n\n                    // TODO: Since AST is sometimes not correct wrt to position, only add "cur" if it\'s better\n                    //       than top of the stack.\n                    var previous = ctx.path.ast();\n                    if (previous == null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {\n                        ctx.path.push(cur);\n                    }\n                    else {\n                        //logger.log("TODO: Ignoring node because minChar, limChar not better than previous node in stack");\n                    }\n                }\n\n                // The AST walker skips comments, but we might be in one, so check the pre/post comments for this node manually\n                if (pos < limChar) {\n                    lookInComments(cur.preComments);\n                }\n                if (pos >= minChar) {\n                    lookInComments(cur.postComments);\n                }\n\n                if (!hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition)) {\n                    // Don\'t go further down the tree if pos is outside of [minChar, limChar]\n                    walker.options.goChildren = (minChar <= pos && pos <= limChar);\n                }\n            }\n            return cur;\n        }\n\n        var ctx = new AstPathContext();\n        TypeScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);\n        return ctx.path;\n    }\n\n    //\n    // Find a source text offset that is safe for lexing tokens at the given position.\n    // This is used when "position" might be inside a comment or string, etc.\n    //\n    export function getTokenizationOffset(script: TypeScript.Script, position: number): number {\n        var bestOffset = 0;\n        var pre = (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker): TypeScript.AST => {\n            if (TypeScript.isValidAstNode(cur)) {\n                // Did we find a closer offset?\n                if (cur.minChar <= position) {\n                    bestOffset = max(bestOffset, cur.minChar);\n                }\n\n                // Stop the walk if this node is not related to ';
var v27692 = v27693 + '"minChar"\n                if (cur.minChar > position || cur.limChar < bestOffset) {\n                    walker.options.goChildren = false;\n                }\n            }\n\n            return cur;\n        }\n\n        TypeScript.getAstWalkerFactory().walk(script, pre);\n        return bestOffset;\n    }\n\n    ///\n    /// Simple function to Walk an AST using a simple callback function.\n    ///\n    export function walkAST(ast: TypeScript.AST, callback: (path: AstPath, walker: TypeScript.IAstWalker) => void ): void {\n        var pre = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {\n            var path: TypeScript.AstPath = walker.state;\n            path.push(cur);\n            callback(path, walker);\n            return cur;\n        }\n        var post = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {\n            var path: TypeScript.AstPath = walker.state;\n            path.pop();\n            return cur;\n        }\n\n        var path = new AstPath();\n        TypeScript.getAstWalkerFactory().walk(ast, pre, post, null, path);\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class ASTSpan {\n        public minChar: number = -1;  // -1 = "undefined" or "compiler generated"\n        public limChar: number = -1;  // -1 = "undefined" or "compiler generated"   \n    }\n\n    export class AST extends ASTSpan {\n        public type: Type = null;\n        public flags = ASTFlags.Writeable;\n\n        // REVIEW: for diagnostic purposes\n        public passCreated: number = CompilerDiagnostics.analysisPass;\n\n        public preComments: Comment[] = null;\n        public postComments: Comment[] = null;\n        private docComments: Comment[] = null;\n\n        public isParenthesized = false;\n\n        constructor (public nodeType: NodeType) {\n            super();\n        }\n\n        public isExpression() { return false; }\n\n        public isStatementOrExpression() { return false; }\n\n        public isCompoundStatement() { return false; }\n\n        public isLeaf() { return this.isStatementOrExpression() && (!this.isCompoundStatement()); }\n        \n        public isDeclaration() { return false; }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Error:\n                case NodeType.EmptyExpr:\n                    this.type = typeFlow.anyType;\n                    break;\n                case NodeType.This:\n                    return typeFlow.typeCheckThis(this);\n                case NodeType.Null:\n                    this.type = typeFlow.nullType;\n                    break;\n                case NodeType.False:\n                case NodeType.True:\n                    this.type = typeFlow.booleanType;\n                    break;\n                case NodeType.Super:\n                    return typeFlow.typeCheckSuper(this);\n                case NodeType.EndCode:\n                case NodeType.Empty:\n                case NodeType.Void:\n                    this.type = typeFlow.voidType;\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            switch (this.nodeType) {\n                case NodeType.This:\n                    emitter.recordSourceMappingStart(this);\n                    if (emitter.thisFnc && (hasFlag(emitter.thisFnc.fncFlags, FncFlags.IsFatArrowFunction))) {\n                        emitter.writeToOutput("_this");\n                    }\n                    else {\n                        emitter.writeToOutput("this");\n                    }\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.Null:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("null");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.False:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("false");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.True';
var v27691 = v27692 + ':\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("true");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.Super:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.emitSuperReference();\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.EndCode:\n                case NodeType.Error:\n                case NodeType.EmptyExpr:\n                    break;\n                case NodeType.Empty:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.Void:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("void ");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public print(context: PrintContext) {\n            context.startLine();\n            var lineCol = { line: -1, col: -1 };\n            var limLineCol = { line: -1, col: -1 };\n            if (context.parser !== null) {\n                context.parser.getSourceLineCol(lineCol, this.minChar);\n                context.parser.getSourceLineCol(limLineCol, this.limChar);\n                context.write("(" + lineCol.line + "," + lineCol.col + ")--" +\n                              "(" + limLineCol.line + "," + limLineCol.col + "): ");\n            }\n            var lab = this.printLabel();\n            if (hasFlag(this.flags, ASTFlags.Error)) {\n                lab += " (Error)";\n            }\n            context.writeLine(lab);\n        }\n\n        public printLabel() {\n            if (nodeTypeTable[this.nodeType] !== undefined) {\n                return nodeTypeTable[this.nodeType];\n            }\n            else {\n                return (<any>NodeType)._map[this.nodeType];\n            }\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            // by default, AST adds itself to current basic block and does not check its children\n            context.walker.options.goChildren = false;\n            context.addContent(this);\n        }\n\n        public netFreeUses(container: Symbol, freeUses: StringHashTable) {\n        }\n\n        public treeViewLabel() {\n            return (<any>NodeType)._map[this.nodeType];\n        }\n\n        public static getResolvedIdentifierName(name: string): string {\n            if (!name) return "";\n\n            var resolved = "";\n            var start = 0;\n            var i = 0;\n            while(i <= name.length - 6) {\n                // Look for escape sequence \\uxxxx\n                if (name.charAt(i) == \'\\\\\' && name.charAt(i+1) == \'u\') {\n                    var charCode = parseInt(name.substr(i + 2, 4), 16);\n                    resolved += name.substr(start, i - start);\n                    resolved += String.fromCharCode(charCode);\n                    i += 6;\n                    start = i;\n                    continue;\n                } \n                i++;\n            }\n            // Append remaining string\n            resolved += name.substring(start);\n            return resolved;\n        }\n\n        public getDocComments() : Comment[] {\n            if (!this.isDeclaration() || !this.preComments || this.preComments.length == 0) {\n                return [];\n            }\n\n            if (!this.docComments) {\n                var preCommentsLength = this.preComments.length;\n                var docComments: Comment[] = [];\n                for (var i = preCommentsLength - 1; i >= 0; i--) {\n                    if (this.preComments[i].isDocComment()) {\n                        var prevDocComment = docComments.length > 0 ? docComments[docComments.length - 1] : null;\n                        if (prevDocComment == null || // If the help comments were not yet set then this is the comment\n                             (this.preComments[i].limLine == prevDocComment.minLine ||\n                              this.preComments[i].limLine + 1 == prevDocComment.minLine)) { // On same line or next line\n                            docComments.push(this.preComments[i]);\n                            continue;\n                        }\n                    }\n                    break;\n                }\n\n                this.docComments = docComments.reverse();\n            }\n\n            return this.docComments;\n        }\n    }\n\n    export class IncompleteAST extends AST {\n        constructor (min: number, lim: number) {\n            super(NodeType.Error);\n\n            this.minChar = min;\n            this.limChar = lim;\n        }\n    }\n\n    export class ASTList extends AST {\n        public enclosingScope: SymbolScope = null;\n        publ';
var v27690 = v27691 + "ic members: AST[] = new AST[];\n\n        constructor () {\n            super(NodeType.List);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var len = this.members.length;\n            for (var i = 0; i < len; i++) {\n                if (context.noContinuation) {\n                    context.addUnreachable(this.members[i]);\n                    break;\n                }\n                else {\n                    this.members[i] = context.walk(this.members[i], this);\n                }\n            }\n            context.walker.options.goChildren = false;\n        }\n\n        public append(ast: AST) {\n            this.members[this.members.length] = ast;\n            return this;\n        }\n\n        public appendAll(ast: AST) {\n            if (ast.nodeType == NodeType.List) {\n                var list = <ASTList>ast;\n                for (var i = 0, len = list.members.length; i < len; i++) {\n                    this.append(list.members[i]);\n                }\n            }\n            else {\n                this.append(ast);\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascriptList(this, null, TokenID.Semicolon, startLine, false, false);\n            emitter.recordSourceMappingEnd(this);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var len = this.members.length;\n            typeFlow.nestingLevel++;\n            for (var i = 0; i < len; i++) {\n                if (this.members[i]) {\n                    this.members[i] = this.members[i].typeCheck(typeFlow);\n                }\n            }\n            typeFlow.nestingLevel--;\n            return this;\n        }\n    }\n\n    export class Identifier extends AST {\n        public sym: Symbol = null;\n        public cloId = -1;\n        public text: string;\n\n        // 'actualText' is the text that the user has entered for the identifier. the text might \n        // include any Unicode escape sequences (e.g.: \\u0041 for 'A'). 'text', however, contains \n        // the resolved value of any escape sequences in the actual text; so in the previous \n        // example, actualText = '\\u0041', text = 'A'.\n        //\n        // For purposes of finding a symbol, use text, as this will allow you to match all \n        // variations of the variable text. For full-fidelity translation of the user input, such\n        // as emitting, use the actualText field.\n        // \n        // Note: \n        //    To change text, and to avoid running into a situation where 'actualText' does not \n        //    match 'text', always use setText.\n        constructor (public actualText: string, public hasEscapeSequence?: bool) {\n            super(NodeType.Name);\n            this.setText(actualText, hasEscapeSequence);\n        }\n\n        public setText(actualText: string, hasEscapeSequence?: bool) {\n            this.actualText = actualText;\n            if (hasEscapeSequence) {\n                this.text = AST.getResolvedIdentifierName(actualText);\n            }\n            else {\n                this.text = actualText;\n            }\n        }\n\n        public isMissing() { return false; }\n        public isLeaf() { return true; }\n\n        public treeViewLabel() {\n            return \"id: \" + this.actualText;\n        }\n\n        public printLabel() {\n            if (this.actualText) {\n                return \"id: \" + this.actualText;\n            }\n            else {\n                return \"name node\";\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckName(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptName(this, true);\n        }\n\n        public static fromToken(token: Token): Identifier {\n            return new Identifier(token.getText(), (<IdentifierToken>token).hasEscapeSequence);\n        }\n    }\n\n    export class MissingIdentifier extends Identifier {\n        constructor () {\n            super(\"__missing\");\n        }\n\n        public isMissing() {\n            return true;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            // Emit nothing for a missing ID\n        }\n    }\n\n    export class Label extends AST {\n        constructor (public id: Identifier) {\n            super(NodeType.Label);\n        }\n\n        public printLabel() { return this.id.actualText + \":\"; }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.recordSourceMappingStart(this.id);\n            emitter.writeToOutput(this.id.actualText);\n            emitter.recordSourceMappingEnd(this.id);";
var v27689 = v27690 + '\n            emitter.writeLineToOutput(":");\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class Expression extends AST {\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n        }\n\n        public isExpression() { return true; }\n\n        public isStatementOrExpression() { return true; }\n    }\n\n    export class UnaryExpression extends Expression {\n        public targetType: Type = null; // Target type for an object literal (null if no target type)\n        public castTerm: AST = null;\n\n        constructor (nodeType: NodeType, public operand: AST) {\n            super(nodeType);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            // TODO: add successor as catch block/finally block if present\n            if (this.nodeType == NodeType.Throw) {\n                context.returnStmt();\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Not:\n                    return typeFlow.typeCheckBitNot(this);\n\n                case NodeType.LogNot:\n                    return typeFlow.typeCheckLogNot(this);\n\n                case NodeType.Pos:\n                case NodeType.Neg:\n                    return typeFlow.typeCheckUnaryNumberOperator(this);\n\n                case NodeType.IncPost:\n                case NodeType.IncPre:\n                case NodeType.DecPost:\n                case NodeType.DecPre:\n                    return typeFlow.typeCheckIncOrDec(this);\n\n                case NodeType.ArrayLit:\n                    typeFlow.typeCheckArrayLit(this);\n                    return this;\n\n                case NodeType.ObjectLit:\n                    typeFlow.typeCheckObjectLit(this);\n                    return this;\n\n                case NodeType.Throw:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.voidType;\n                    return this;\n\n                case NodeType.Typeof:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.stringType;\n                    return this;\n\n                case NodeType.Delete:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.booleanType;\n                    break;\n\n                case NodeType.TypeAssertion:\n                    this.castTerm = typeFlow.typeCheck(this.castTerm);\n                    var applyTargetType = !this.operand.isParenthesized;\n\n                    var targetType = applyTargetType ? this.castTerm.type : null;\n\n                    typeFlow.checker.typeCheckWithContextualType(targetType, typeFlow.checker.inProvisionalTypecheckMode(), true, this.operand);\n                    typeFlow.castWithCoercion(this.operand, this.castTerm.type, false, true);\n                    this.type = this.castTerm.type;\n                    return this;\n\n                case NodeType.Void:\n                    // REVIEW - Although this is good to do for completeness\'s sake,\n                    // this shouldn\'t be strictly necessary from the void operator\'s\n                    // point of view\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.checker.undefinedType;\n                    break;\n\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            switch (this.nodeType) {\n                case NodeType.IncPost:\n                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);\n                    emitter.writeToOutput("++");\n                    break;\n                case NodeType.LogNot:\n                    emitter.writeToOutput("!");\n                    emitter.emitJavascript(this.operand, TokenID.Exclamation, false);\n                    break;\n                case NodeType.DecPost:\n                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);\n                    emitter.writeToOutput("--");\n                    break;\n                case NodeType.ObjectLit:\n                    emitter.emitObjectLiteral(<ASTList>this.operand);\n                    break;\n                case NodeType.ArrayLit:\n                    emitter.emitArrayLiteral(<ASTList>this.operand);\n                    break;\n                case NodeType.Not:\n                    emitter.writeToOutput("~");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Neg:\n                    emitter.writeToOutput("-"';
var v27688 = v27689 + ');\n                    if (this.operand.nodeType == NodeType.Neg) {\n                        this.operand.isParenthesized = true;\n                    }\n                    emitter.emitJavascript(this.operand, TokenID.Minus, false);\n                    break;\n                case NodeType.Pos:\n                    emitter.writeToOutput("+");\n                    if (this.operand.nodeType == NodeType.Pos) {\n                        this.operand.isParenthesized = true;\n                    }\n                    emitter.emitJavascript(this.operand, TokenID.Plus, false);\n                    break;\n                case NodeType.IncPre:\n                    emitter.writeToOutput("++");\n                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);\n                    break;\n                case NodeType.DecPre:\n                    emitter.writeToOutput("--");\n                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);\n                    break;\n                case NodeType.Throw:\n                    emitter.writeToOutput("throw ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    emitter.writeToOutput(";");\n                    break;\n                case NodeType.Typeof:\n                    emitter.writeToOutput("typeof ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Delete:\n                    emitter.writeToOutput("delete ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Void:\n                    emitter.writeToOutput("void ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.TypeAssertion:\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class CallExpression extends Expression {\n        constructor (nodeType: NodeType,\n                     public target: AST,\n                     public arguments: ASTList) {\n            super(nodeType);\n            this.minChar = this.target.minChar;\n        }\n\n        public signature: Signature = null;\n\n        public typeCheck(typeFlow: TypeFlow) {\n            if (this.nodeType == NodeType.New) {\n                return typeFlow.typeCheckNew(this);\n            }\n            else {\n                return typeFlow.typeCheckCall(this);\n            }\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n\n            if (this.nodeType == NodeType.New) {\n                emitter.emitNew(this.target, this.arguments);\n            }\n            else {\n                emitter.emitCall(this, this.target, this.arguments);\n            }\n\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class BinaryExpression extends Expression {\n        constructor (nodeType: NodeType, public operand1: AST, public operand2: AST) {\n            super(nodeType);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Dot:\n                    return typeFlow.typeCheckDotOperator(this);\n                case NodeType.Asg:\n                    return typeFlow.typeCheckAsgOperator(this);\n                case NodeType.Add:\n                case NodeType.Sub:\n                case NodeType.Mul:\n                case NodeType.Div:\n                case NodeType.Mod:\n                case NodeType.Or:\n                case NodeType.And:\n                    return typeFlow.typeCheckArithmeticOperator(this, false);\n                case NodeType.Xor:\n                    return typeFlow.typeCheckBitwiseOperator(this, false);\n                case NodeType.Ne:\n                case NodeType.Eq:\n                    var text: string;\n                    if (typeFlow.checker.styleSettings.eqeqeq) {\n                        text = nodeTypeTable[this.nodeType];\n                        typeFlow.checker.errorReporter.styleError(this, "use of " + text);\n                    }\n                    else if (typeFlow.checker.styleSettings.eqnull) {\n                        text = nodeTypeTable[this.nodeType];\n                        if ((this.operand2 !== null) && (this.operand2.nodeType == NodeType.Null)) {\n                            typeFlow.checker.errorReporter.styleError(this, "use of " + text + " to compare with null");\n                        }\n                    }\n         ';
var v27687 = v27688 + '       case NodeType.Eqv:\n                case NodeType.NEqv:\n                case NodeType.Lt:\n                case NodeType.Le:\n                case NodeType.Ge:\n                case NodeType.Gt:\n                    return typeFlow.typeCheckBooleanOperator(this);\n                case NodeType.Index:\n                    return typeFlow.typeCheckIndex(this);\n                case NodeType.Member:\n                    this.type = typeFlow.voidType;\n                    return this;\n                case NodeType.LogOr:\n                    return typeFlow.typeCheckLogOr(this);\n                case NodeType.LogAnd:\n                    return typeFlow.typeCheckLogAnd(this);\n                case NodeType.AsgAdd:\n                case NodeType.AsgSub:\n                case NodeType.AsgMul:\n                case NodeType.AsgDiv:\n                case NodeType.AsgMod:\n                case NodeType.AsgOr:\n                case NodeType.AsgAnd:\n                    return typeFlow.typeCheckArithmeticOperator(this, true);\n                case NodeType.AsgXor:\n                    return typeFlow.typeCheckBitwiseOperator(this, true);\n                case NodeType.Lsh:\n                case NodeType.Rsh:\n                case NodeType.Rs2:\n                    return typeFlow.typeCheckShift(this, false);\n                case NodeType.AsgLsh:\n                case NodeType.AsgRsh:\n                case NodeType.AsgRs2:\n                    return typeFlow.typeCheckShift(this, true);\n                case NodeType.Comma:\n                    return typeFlow.typeCheckCommaOperator(this);\n                case NodeType.InstOf:\n                    return typeFlow.typeCheckInstOf(this);\n                case NodeType.In:\n                    return typeFlow.typeCheckInOperator(this);\n                case NodeType.From:\n                    typeFlow.checker.errorReporter.simpleError(this, "Illegal use of \'from\' keyword in binary expression");\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            var binTokenId = nodeTypeToTokTable[this.nodeType];\n\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (binTokenId != undefined) {\n\n                emitter.emitJavascript(this.operand1, binTokenId, false);\n\n                if (tokenTable[binTokenId].text == "instanceof") {\n                    emitter.writeToOutput(" instanceof ");\n                }\n                else if (tokenTable[binTokenId].text == "in") {\n                    emitter.writeToOutput(" in ");\n                }\n                else {\n                    emitter.writeToOutputTrimmable(" " + tokenTable[binTokenId].text + " ");\n                }\n\n                emitter.emitJavascript(this.operand2, binTokenId, false);\n            }\n            else {\n                switch (this.nodeType) {\n                    case NodeType.Dot:\n                        if (!emitter.tryEmitConstant(this)) {\n                            emitter.emitJavascript(this.operand1, TokenID.Dot, false);\n                            emitter.writeToOutput(".");\n                            emitter.emitJavascriptName(<Identifier>this.operand2, false);\n                        }\n                        break;\n                    case NodeType.Index:\n                        emitter.emitIndex(this.operand1, this.operand2);\n                        break;\n\n                    case NodeType.Member:\n                        if (this.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>this.operand2).isAccessor()) {\n                            var funcDecl = <FuncDecl>this.operand2;\n                            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                                emitter.writeToOutput("get ");\n                            }\n                            else {\n                                emitter.writeToOutput("set ");\n                            }\n                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);\n                        }\n                        else {\n                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);\n                            emitter.writeToOutputTrimmable(": ");\n                        }\n                        emitter.emitJavascript(this.operand2, TokenID.Comma, false);\n                        break;\n                    case NodeType.Comma:\n                        emitter.emitJavascript(this.operand1, TokenID.Comma, false);\n                        if (emitter.emitState.inObjectLiteral) {\n                            emitter.writeLineToOutput(", ");\n                        }\n                        else {\n                            emitter.writeToOutput(",");\n                        }\n                        emitter.emitJavascript(this.op';
var v27686 = v27687 + 'erand2, TokenID.Comma, false);\n                        break;\n                    case NodeType.Is:\n                        throw new Error("should be de-sugared during type check");\n                    default:\n                        throw new Error("please implement in derived class");\n                }\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class ConditionalExpression extends Expression {\n        constructor (public operand1: AST,\n                     public operand2: AST,\n                     public operand3: AST) {\n            super(NodeType.ConditionalExpression);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckQMark(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.operand1, TokenID.Question, false);\n            emitter.writeToOutput(" ? ");\n            emitter.emitJavascript(this.operand2, TokenID.Question, false);\n            emitter.writeToOutput(" : ");\n            emitter.emitJavascript(this.operand3, TokenID.Question, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class NumberLiteral extends Expression {\n        constructor (public value: number, public hasEmptyFraction?: bool) {\n            super(NodeType.NumberLit);\n        }\n\n        public isNegativeZero = false;\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.doubleType;\n            return this;\n        }\n\n        public treeViewLabel() {\n            return "num: " + this.printLabel();\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.isNegativeZero) {\n                emitter.writeToOutput("-");\n            }\n\n            emitter.writeToOutput(this.value.toString());\n\n            if (this.hasEmptyFraction)\n                emitter.writeToOutput(".0");\n\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public printLabel() {\n            if (Math.floor(this.value) != this.value) {\n                return this.value.toFixed(2).toString();\n            }\n            else if (this.hasEmptyFraction) {\n                return this.value.toString() + ".0";\n            }\n            else {\n                return this.value.toString();\n            }\n        }\n    }\n\n    export class RegexLiteral extends Expression {\n        constructor (public regex) {\n            super(NodeType.Regex);\n        }\n        \n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.regexType;\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(this.regex.toString());\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class StringLiteral extends Expression {\n        constructor (public text: string) {\n            super(NodeType.QString);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitStringLiteral(this.text);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.stringType;\n            return this;\n        }\n\n        public treeViewLabel() {\n            return "st: " + this.text;\n        }\n\n        public printLabel() {\n            return this.text;\n        }\n    }\n\n    export class ModuleElement extends AST {\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n        }\n    }\n\n    export class ImportDeclaration extends ModuleElement {\n        public isStatementOrExpression() { return true; }\n        public varFlags = VarFlags.None;\n        public isDynamicImport = false;\n        public isDeclaration() { return true; }\n\n        constructor (public id: Identifier, public alias: AST) {\n            super(NodeType.ImportDeclaration);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            var mod = <ModuleType>this.alias.type;\n            // REVIEW: Only modules may be aliased for now, though there\'s no real\n            // restriction on what the typ';
var v27685 = v27686 + 'e symbol may be\n            if (!this.isDynamicImport || (this.id.sym && !(<TypeSymbol>this.id.sym).onlyReferencedAsTypeRef)) {\n                var prevModAliasId = emitter.modAliasId;\n                var prevFirstModAlias = emitter.firstModAlias;\n\n                emitter.recordSourceMappingStart(this);\n                emitter.emitParensAndCommentsInPlace(this, true);\n                emitter.writeToOutput("var " + this.id.actualText + " = ");\n                emitter.modAliasId = this.id.actualText;\n                emitter.firstModAlias = this.firstAliasedModToString();\n                emitter.emitJavascript(this.alias, TokenID.Tilde, false);\n                // the dynamic import case will insert the semi-colon automatically\n                if (!this.isDynamicImport) {\n                    emitter.writeToOutput(";");\n                }\n                emitter.emitParensAndCommentsInPlace(this, false);\n                emitter.recordSourceMappingEnd(this);\n\n                emitter.modAliasId = prevModAliasId;\n                emitter.firstModAlias = prevFirstModAlias;\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckImportDecl(this);\n        }\n\n        public getAliasName(aliasAST?: AST = this.alias) : string {\n            if (aliasAST.nodeType == NodeType.Name) {\n                return (<Identifier>aliasAST).actualText;\n            } else {\n                var dotExpr = <BinaryExpression>aliasAST;\n                return this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2);\n            }\n        }\n\n        public firstAliasedModToString() {\n            if (this.alias.nodeType == NodeType.Name) {\n                return (<Identifier>this.alias).actualText;\n            }\n            else {\n                var dotExpr = <BinaryExpression>this.alias;\n                var firstMod = <Identifier>dotExpr.operand1;\n                return firstMod.actualText;\n            }\n        }\n    }\n\n    export class BoundDecl extends AST {\n        public init: AST = null;\n        public typeExpr: AST = null;\n        public varFlags = VarFlags.None;\n        public sym: Symbol = null;\n        public isDeclaration() { return true; }\n\n        constructor (public id: Identifier, nodeType: NodeType, public nestingLevel: number) {\n            super(nodeType);\n        }\n\n        public isStatementOrExpression() { return true; }\n\n        public isPrivate() { return hasFlag(this.varFlags, VarFlags.Private); }\n        public isPublic() { return hasFlag(this.varFlags, VarFlags.Public); }\n        public isProperty() { return hasFlag(this.varFlags, VarFlags.Property); }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckBoundDecl(this);\n        }\n\n        public printLabel() {\n            return this.treeViewLabel();\n        }\n    }\n\n    export class VarDecl extends BoundDecl {\n        constructor (id: Identifier, nest: number) {\n            super(id, NodeType.VarDecl, nest);\n        }\n\n        public isAmbient() { return hasFlag(this.varFlags, VarFlags.Ambient); }\n        public isExported() { return hasFlag(this.varFlags, VarFlags.Exported); }\n        public isStatic() { return hasFlag(this.varFlags, VarFlags.Static); }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptVarDecl(this, tokenId);\n        }\n\n        public treeViewLabel() {\n            return "var " + this.id.actualText;\n        }\n    }\n\n    export class ArgDecl extends BoundDecl {\n        constructor (id: Identifier) {\n            super(id, NodeType.ArgDecl, 0);\n        }\n\n        public isOptional = false;\n\n        public isOptionalArg() { return this.isOptional || this.init; }\n\n        public treeViewLabel() {\n            return "arg: " + this.id.actualText;\n        }\n\n        public parameterPropertySym: FieldSymbol = null;\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(this.id.actualText);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    var internalId = 0;\n\n    export class FuncDecl extends AST {\n        public hint: string = null;\n        public fncFlags = FncFlags.None;\n        public returnTypeAnnotation: AST = null;\n        public symbols: IHashTable;\n        public variableArgList = false;\n        public signature: Signature;\n        public envids: Identifier[];\n        public jumpRefs: Identifier[] = null;\n        public internalNameCache: string = null;\n        public tmp1Declared = false;\n        public enclosingFnc: FuncDecl = null;\n        public freeVariables: Symbol[] = [];\n        public unitIndex = -1;\n        public classDecl: NamedDeclaration = null;\n        public boundToProperty: VarDecl = null;\n        public isOverload = fa';
var v27684 = v27685 + 'lse;\n        public innerStaticFuncs: FuncDecl[] = [];\n        public isTargetTypedAsMethod = false;\n        public isInlineCallLiteral = false;\n        public accessorSymbol: Symbol = null;\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public returnStatementsWithExpressions: ReturnStatement[] = [];\n        public scopeType: Type = null; // Type of the FuncDecl, before target typing\n        public endingToken: ASTSpan = null;\n        public isDeclaration() { return true; }\n\n        constructor (public name: Identifier, public bod: ASTList, public isConstructor: bool,\n                     public arguments: ASTList, public vars: ASTList, public scopes: ASTList, public statics: ASTList,\n                     nodeType: number) {\n\n            super(nodeType);\n        }\n\n        public internalName(): string {\n            if (this.internalNameCache == null) {\n                var extName = this.getNameText();\n                if (extName) {\n                    this.internalNameCache = "_internal_" + extName;\n                }\n                else {\n                    this.internalNameCache = "_internal_" + internalId++;\n                }\n            }\n            return this.internalNameCache;\n        }\n\n        public hasSelfReference() { return hasFlag(this.fncFlags, FncFlags.HasSelfReference); }\n        public setHasSelfReference() { this.fncFlags |= FncFlags.HasSelfReference; }\n\n        public hasSuperReferenceInFatArrowFunction() { return hasFlag(this.fncFlags, FncFlags.HasSuperReferenceInFatArrowFunction); }\n        public setHasSuperReferenceInFatArrowFunction() { this.fncFlags |= FncFlags.HasSuperReferenceInFatArrowFunction; }\n\n        public addCloRef(id: Identifier, sym: Symbol): number {\n            if (this.envids == null) {\n                this.envids = new Identifier[];\n            }\n            this.envids[this.envids.length] = id;\n            var outerFnc = this.enclosingFnc;\n            if (sym) {\n                while (outerFnc && (outerFnc.type.symbol != sym.container)) {\n                    outerFnc.addJumpRef(sym);\n                    outerFnc = outerFnc.enclosingFnc;\n                }\n            }\n            return this.envids.length - 1;\n        }\n\n        public addJumpRef(sym: Symbol): void {\n            if (this.jumpRefs == null) {\n                this.jumpRefs = new Identifier[];\n            }\n            var id = new Identifier(sym.name);\n            this.jumpRefs[this.jumpRefs.length] = id;\n            id.sym = sym;\n            id.cloId = this.addCloRef(id, null);\n        }\n\n        public buildControlFlow(): ControlFlowContext {\n            var entry = new BasicBlock();\n            var exit = new BasicBlock();\n\n            var context = new ControlFlowContext(entry, exit);\n\n            var controlFlowPrefix = (ast: AST, parent: AST, walker: IAstWalker) => {\n                ast.addToControlFlow(walker.state);\n                return ast;\n            }\n\n            var walker = getAstWalkerFactory().getWalker(controlFlowPrefix, null, null, context);\n            context.walker = walker;\n            walker.walk(this.bod, this);\n\n            return context;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckFunction(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptFunction(this);\n        }\n\n        public getNameText() {\n            if (this.name) {\n                return this.name.actualText;\n            }\n            else {\n                return this.hint;\n            }\n        }\n\n        public isMethod() {\n            return (this.fncFlags & FncFlags.Method) != FncFlags.None;\n        }\n\n        public isCallMember() { return hasFlag(this.fncFlags, FncFlags.CallMember); }\n        public isConstructMember() { return hasFlag(this.fncFlags, FncFlags.ConstructMember); }\n        public isIndexerMember() { return hasFlag(this.fncFlags, FncFlags.IndexerMember); }\n        public isSpecialFn() { return this.isCallMember() || this.isIndexerMember() || this.isConstructMember(); }\n        public isAnonymousFn() { return this.name === null; }\n        public isAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor) || hasFlag(this.fncFlags, FncFlags.SetAccessor); }\n        public isGetAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor); }\n        public isSetAccessor() { return hasFlag(this.fncFlags, FncFlags.SetAccessor); }\n        public isAmbient() { return hasFlag(this.fncFlags, FncFlags.Ambient); }\n        public isExported() { return hasFlag(this.fncFlags, FncFlags.Exported); }\n        public isPrivate() { return hasFlag(this.fncFlags, FncFlags.Private); }\n        public isPublic() { return hasFlag(this.fncFlags, FncFlags.Public); }\n        public isStatic() { return hasFlag(this.fncFlags, FncFlags.Static); }\n\n        public treeViewLabel() {\n            if (this.name == null) {\n                return "funcExpr";\n      ';
var v27683 = v27684 + '      }\n            else {\n                return "func: " + this.name.actualText\n            }\n        }\n\n        public ClearFlags(): void {\n            this.fncFlags = FncFlags.None;\n        }\n\n        public isSignature() { return (this.fncFlags & FncFlags.Signature) != FncFlags.None; }\n    }\n\n    export class LocationInfo {\n        constructor (public filename: string, public lineMap: number[], public unitIndex) { }\n    }\n\n    export var unknownLocationInfo = new LocationInfo("unknown", null, -1);\n\n    export class Script extends FuncDecl {\n        public locationInfo: LocationInfo = null;\n        public referencedFiles: IFileReference[] = [];\n        public requiresGlobal = false;\n        public requiresExtendsBlock = false;\n        public isResident = false;\n        public isDeclareFile = false;\n        public hasBeenTypeChecked = false;\n        public topLevelMod: ModuleDeclaration = null;\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public vars: ASTList;\n        public scopes: ASTList;\n        // Remember if the script contains Unicode chars, that is needed when generating code for this script object to decide the output file correct encoding.\n        public containsUnicodeChar = false;\n        public containsUnicodeCharInComment = false;\n        public cachedEmitRequired: bool;\n\n        private setCachedEmitRequired(value: bool) {\n            this.cachedEmitRequired = value;\n            return this.cachedEmitRequired;\n        }\n\n        constructor (vars: ASTList, scopes: ASTList) {\n            super(new Identifier("script"), null, false, null, vars, scopes, null, NodeType.Script);\n            this.vars = vars;\n            this.scopes = scopes;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckScript(this);\n        }\n\n        public treeViewLabel() {\n            return "Script";\n        }\n\n        public emitRequired(emitOptions: EmitOptions) {\n            if (this.cachedEmitRequired != undefined) {\n                return this.cachedEmitRequired;\n            }\n\n            if (!this.isDeclareFile && !this.isResident && this.bod) {\n                if (this.bod.members.length == 0) {\n                    // allow empty files that are not declare files \n                    return this.setCachedEmitRequired(true);\n                }\n\n                for (var i = 0, len = this.bod.members.length; i < len; i++) {\n                    var stmt = this.bod.members[i];\n                    if (stmt.nodeType == NodeType.ModuleDeclaration) {\n                        if (!hasFlag((<ModuleDeclaration>stmt).modFlags, ModuleFlags.ShouldEmitModuleDecl | ModuleFlags.Ambient)) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.ClassDeclaration) {\n                        if (!hasFlag((<ClassDeclaration>stmt).varFlags, VarFlags.Ambient)) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.VarDecl) {\n                        if (!hasFlag((<VarDecl>stmt).varFlags, VarFlags.Ambient)) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.FuncDecl) {\n                        if (!(<FuncDecl>stmt).isSignature()) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType != NodeType.InterfaceDeclaration && stmt.nodeType != NodeType.Empty) {\n                        return this.setCachedEmitRequired(true);\n                    }\n                }\n\n                if ( emitOptions.emitComments &&\n                    ((this.bod.preComments && this.bod.preComments.length > 0) || (this.bod.postComments && this.bod.postComments.length > 0))) {\n                    return this.setCachedEmitRequired(true);\n                }\n            }\n            return this.setCachedEmitRequired(false);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            if (this.emitRequired(emitter.emitOptions)) {\n                emitter.emitParensAndCommentsInPlace(this.bod, true);\n                emitter.emitJavascriptList(this.bod, null, TokenID.Semicolon, true, false, false, true, this.requiresExtendsBlock);\n                emitter.emitParensAndCommentsInPlace(this.bod, false);\n            }\n        }\n\n        private externallyVisibleImportedSymbols: Symbol[] = [];\n\n        public AddExternallyVisibleImportedSymbol(symbol: Symbol, checker: TypeChecker) {\n            if (this.isExternallyVisibleSymbol(symbol)) {\n                return;\n            }\n\n            // Before adding check if the external symbol is also marked for visibility\n            if (!symbol.getType().symbol.isExter';
var v27682 = v27683 + 'nallyVisible(checker)) {\n                // Report error\n                var quotes = "";\n                var moduleName = symbol.getType().symbol.prettyName;\n                if (!isQuoted(moduleName)) {\n                    quotes = "\'";\n                }\n                checker.errorReporter.simpleError(symbol.declAST, "Externally visible import statement uses non exported module " + quotes + moduleName + quotes);\n            }\n            this.externallyVisibleImportedSymbols.push(symbol);\n        }\n\n        public isExternallyVisibleSymbol(symbol: Symbol) {\n            for (var i = 0 ; i < this.externallyVisibleImportedSymbols.length; i++) {\n                if (this.externallyVisibleImportedSymbols[i] == symbol) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    export class NamedDeclaration extends ModuleElement {\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public isDeclaration() { return true; }\n\n        constructor (nodeType: NodeType,\n                     public name: Identifier,\n                     public members: ASTList) {\n            super(nodeType);\n        }\n    }\n\n    export class ModuleDeclaration extends NamedDeclaration {\n        public modFlags = ModuleFlags.ShouldEmitModuleDecl;\n        public mod: ModuleType;\n        public prettyName: string;\n        public amdDependencies: string[] = [];\n        public vars: ASTList;\n        public scopes: ASTList;\n        // Remember if the module contains Unicode chars, that is needed for dynamic module as we will generate a file for each.\n        public containsUnicodeChar = false;\n        public containsUnicodeCharInComment = false;\n\n        constructor (name: Identifier, members: ASTList, vars: ASTList, scopes: ASTList, public endingToken: ASTSpan) {\n            super(NodeType.ModuleDeclaration, name, members);\n\n            this.vars = vars;\n            this.scopes = scopes;\n            this.prettyName = this.name.actualText;\n        }\n\n        public isExported() { return hasFlag(this.modFlags, ModuleFlags.Exported); }\n        public isAmbient() { return hasFlag(this.modFlags, ModuleFlags.Ambient); }\n        public isEnum() { return hasFlag(this.modFlags, ModuleFlags.IsEnum); }\n\n        public recordNonInterface() {\n            this.modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckModule(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            if (!hasFlag(this.modFlags, ModuleFlags.ShouldEmitModuleDecl)) {\n                emitter.emitParensAndCommentsInPlace(this, true);\n                emitter.emitJavascriptModule(this);\n                emitter.emitParensAndCommentsInPlace(this, false);\n            }\n        }\n    }\n\n    export class TypeDeclaration extends NamedDeclaration {\n        public varFlags = VarFlags.None;\n\n        constructor (nodeType: NodeType,\n                     name: Identifier,\n                     public extendsList: ASTList,\n                     public implementsList: ASTList,\n                     members: ASTList) {\n            super(nodeType, name, members);\n        }\n\n        public isExported() { \n            return hasFlag(this.varFlags, VarFlags.Exported);\n        }\n\n        public isAmbient() {\n            return hasFlag(this.varFlags, VarFlags.Ambient);\n        }\n    }\n\n    export class ClassDeclaration extends TypeDeclaration {\n        public knownMemberNames: any = {};\n        public constructorDecl: FuncDecl = null;\n        public constructorNestingLevel = 0;\n        public endingToken: ASTSpan = null;\n\n        constructor (name: Identifier,\n                     members: ASTList,\n                     extendsList: ASTList,\n                     implementsList: ASTList) {\n            super(NodeType.ClassDeclaration, name, extendsList, implementsList, members);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckClass(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptClass(this);\n        }\n    }\n\n    export class InterfaceDeclaration extends TypeDeclaration {\n        constructor (name: Identifier,\n                     members: ASTList,\n                     extendsList: ASTList,\n                     implementsList: ASTList) {\n            super(NodeType.InterfaceDeclaration, name, extendsList, implementsList, members);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckInterface(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n        }\n    }\n\n    export class Statement extends ModuleElement {\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n            this.flags |= ASTFlags.IsStatement;\n        }\n\n        public isLoop() { return false; }\n\n        public i';
var v27681 = v27682 + 'sStatementOrExpression() { return true; }\n\n        public isCompoundStatement() { return this.isLoop(); }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.voidType;\n            return this;\n        }\n    }\n\n    export class LabeledStatement extends Statement {\n        constructor (public labels: ASTList, public stmt: AST) {\n            super(NodeType.LabeledStatement);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.labels) {\n                var labelsLen = this.labels.members.length;\n                for (var i = 0; i < labelsLen; i++) {\n                    this.labels.members[i].emit(emitter, tokenId, startLine);\n                }\n            }\n            this.stmt.emit(emitter, tokenId, true);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            typeFlow.typeCheck(this.labels);\n            this.stmt = this.stmt.typeCheck(typeFlow);\n            return this;\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            var beforeBB = context.current;\n            var bb = new BasicBlock();\n            context.current = bb;\n            beforeBB.addSuccessor(bb);\n        }\n    }\n\n    export class Block extends Statement {\n        constructor (public statements: ASTList,\n                     public isStatementBlock: bool) {\n            super(NodeType.Block);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.isStatementBlock) {\n                emitter.writeLineToOutput(" {");\n                emitter.indenter.increaseIndent();\n            } else {\n                emitter.setInVarBlock(this.statements.members.length);\n            }\n            var temp = emitter.setInObjectLiteral(false);\n            if (this.statements) {\n                emitter.emitJavascriptList(this.statements, null, TokenID.Semicolon, true, false, false);\n            }\n            if (this.isStatementBlock) {\n                emitter.indenter.decreaseIndent();\n                emitter.emitIndent();\n                emitter.writeToOutput("}");\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var afterIfNeeded = new BasicBlock();\n            context.pushStatement(this, context.current, afterIfNeeded);\n            if (this.statements) {\n                context.walk(this.statements, this);\n            }\n            context.walker.options.goChildren = false;\n            context.popStatement();\n            if (afterIfNeeded.predecessors.length > 0) {\n                context.current.addSuccessor(afterIfNeeded);\n                context.current = afterIfNeeded;\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            if (!typeFlow.checker.styleSettings.emptyBlocks) {\n                if ((this.statements === null) || (this.statements.members.length == 0)) {\n                    typeFlow.checker.errorReporter.styleError(this, "empty block");\n                }\n            }\n\n            typeFlow.typeCheck(this.statements);\n            return this;\n        }\n    }\n\n    export class Jump extends Statement {\n        public target: string = null;\n        public hasExplicitTarget() { return (this.target); }\n        public resolvedTarget: Statement = null;\n\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n        }\n\n        public setResolvedTarget(parser: Parser, stmt: Statement): bool {\n            if (stmt.isLoop()) {\n                this.resolvedTarget = stmt;\n                return true;\n            }\n            if (this.nodeType === NodeType.Continue) {\n                parser.reportParseError("continue statement applies only to loops");\n                return false;\n            }\n            else {\n                if ((stmt.nodeType == NodeType.Switch) || this.hasExplicitTarget()) {\n                    this.resolvedTarget = stmt;\n                    return true;\n                }\n                else {\n                    parser.reportParseError("break statement with no label can apply only to a loop or switch statement");\n                    return false;\n                }\n            }\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            context.unconditionalBranch(this.resolvedTarget, (this.nodeType == NodeType.Continue));\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, s';
var v27680 = v27681 + 'tartLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.nodeType == NodeType.Break) {\n                emitter.writeToOutput("break");\n            }\n            else {\n                emitter.writeToOutput("continue");\n            }\n            if (this.hasExplicitTarget()) {\n                emitter.writeToOutput(" " + this.target);\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.writeToOutput(";");\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class WhileStatement extends Statement {\n        public body: AST = null;\n\n        constructor (public cond: AST) {\n            super(NodeType.While);\n        }\n\n        public isLoop() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput("while(");\n            emitter.emitJavascript(this.cond, TokenID.While, false);\n            emitter.writeToOutput(")");\n            emitter.emitJavascriptStatements(this.body, false);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckWhile(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            context.addContent(this.cond);\n            var condBlock = context.current;\n            var targetInfo: ITargetInfo = null;\n            if (this.body) {\n                context.current = new BasicBlock();\n                condBlock.addSuccessor(context.current);\n                context.pushStatement(this, loopStart, afterLoop);\n                context.walk(this.body, this);\n                targetInfo = context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopEnd = context.current;\n                loopEnd.addSuccessor(loopStart);\n            }\n            context.current = afterLoop;\n            condBlock.addSuccessor(afterLoop);\n            // TODO: check for while (true) and then only continue if afterLoop has predecessors\n            context.noContinuation = false;\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class DoWhileStatement extends Statement {\n        public body: AST = null;\n        public whileAST: AST = null;\n        public cond: AST = null;\n        public isLoop() { return true; }\n\n        constructor () {\n            super(NodeType.DoWhile);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput("do");\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.recordSourceMappingStart(this.whileAST);\n            emitter.writeToOutput("while");\n            emitter.recordSourceMappingEnd(this.whileAST);\n            emitter.writeToOutput(\'(\');\n            emitter.emitJavascript(this.cond, TokenID.CloseParen, false);\n            emitter.writeToOutput(")");\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.writeToOutput(";");\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckDoWhile(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            var targetInfo: ITargetInfo = null;\n            if (this.body) {\n                context.pushStatement(this, loopStart, afterLoop);\n                context.walk(this.body, this);\n                targetInfo = context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopEnd = context.current;\n                loopEnd.addSuccessor(loopStart);\n                context.addContent(this.cond);\n                // TODO: check for while (true) \n                context.current = afterLoop;\n                loopEnd.addSuccessor(afterLoop);\n            }\n            else {\n                context.addUnreachable(t';
var v27679 = v27680 + 'his.cond);\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class IfStatement extends Statement {\n        public thenBod: AST;\n        public elseBod: AST = null;\n        public statement: ASTSpan = new ASTSpan();\n\n        constructor (public cond: AST) {\n            super(NodeType.If);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("if(");\n            emitter.emitJavascript(this.cond, TokenID.If, false);\n            emitter.writeToOutput(")");\n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.emitJavascriptStatements(this.thenBod, true);\n            if (this.elseBod) {\n                if (this.elseBod.nodeType === NodeType.If) {\n                    emitter.writeToOutput(" else ");\n                    this.elseBod.emit(emitter, tokenId, /*startLine:*/ false);\n                }\n                else {\n                    emitter.writeToOutput(" else");\n                    emitter.emitJavascriptStatements(this.elseBod, true);\n                }\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckIf(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            this.cond.addToControlFlow(context);\n            var afterIf = new BasicBlock();\n            var beforeIf = context.current;\n            context.pushStatement(this, beforeIf, afterIf);\n            var hasContinuation = false;\n            context.current = new BasicBlock();\n            beforeIf.addSuccessor(context.current);\n            context.walk(this.thenBod, this);\n            if (!context.noContinuation) {\n                hasContinuation = true;\n                context.current.addSuccessor(afterIf);\n            }\n            if (this.elseBod) {\n                // current block will be thenBod\n                context.current = new BasicBlock();\n                context.noContinuation = false;\n                beforeIf.addSuccessor(context.current);\n                context.walk(this.elseBod, this);\n                if (!context.noContinuation) {\n                    hasContinuation = true;\n                    context.current.addSuccessor(afterIf);\n                }\n                else {\n                    // thenBod created continuation for if statement\n                    if (hasContinuation) {\n                        context.noContinuation = false;\n                    }\n                }\n            }\n            else {\n                beforeIf.addSuccessor(afterIf);\n                context.noContinuation = false;\n                hasContinuation = true;\n            }\n            var targetInfo = context.popStatement();\n            if (afterIf.predecessors.length > 0) {\n                context.noContinuation = false;\n                hasContinuation = true;\n            }\n            if (hasContinuation) {\n                context.current = afterIf;\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class ReturnStatement extends Statement {\n        public returnExpression: AST = null;\n\n        constructor () {\n            super(NodeType.Return);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            if (this.returnExpression) {\n                emitter.writeToOutput("return ");\n                emitter.emitJavascript(this.returnExpression, TokenID.Semicolon, false);\n\n                if (this.returnExpression.nodeType === NodeType.FuncDecl) {\n                    emitter.writeToOutput(";");\n                }\n            }\n            else {\n                emitter.writeToOutput("return;");\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            context.returnStmt();\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckReturn(this);\n        }\n    }\n\n    export class EndCode extends AST {\n        constructor () {\n            super(NodeType.EndCode);\n        }\n    }\n\n    export class ForInStatement extends Statement {\n        constructor ';
var v27678 = v27679 + '(public lval: AST, public obj: AST) {\n            super(NodeType.ForIn);\n            if (this.lval && (this.lval.nodeType == NodeType.VarDecl)) {\n                (<BoundDecl>this.lval).varFlags |= VarFlags.AutoInit;\n            }\n        }\n        public statement: ASTSpan = new ASTSpan();\n        public body: AST;\n\n        public isLoop() { return true; }\n\n        public isFiltered() {\n            if (this.body) {\n                var singleItem: AST = null;\n                if (this.body.nodeType == NodeType.List) {\n                    var stmts = <ASTList>this.body;\n                    if (stmts.members.length == 1) {\n                        singleItem = stmts.members[0];\n                    }\n                }\n                else {\n                    singleItem = this.body;\n                }\n                // match template for filtering \'own\' properties from obj\n                if (singleItem !== null) {\n                    if (singleItem.nodeType == NodeType.Block) {\n                        var block = <Block>singleItem;\n                        if ((block.statements !== null) && (block.statements.members.length == 1)) {\n                            singleItem = block.statements.members[0];\n                        }\n                    }\n                    if (singleItem.nodeType == NodeType.If) {\n                        var cond = (<IfStatement>singleItem).cond;\n                        if (cond.nodeType == NodeType.Call) {\n                            var target = (<CallExpression>cond).target;\n                            if (target.nodeType == NodeType.Dot) {\n                                var binex = <BinaryExpression>target;\n                                if ((binex.operand1.nodeType == NodeType.Name) &&\n                                    (this.obj.nodeType == NodeType.Name) &&\n                                    ((<Identifier>binex.operand1).actualText == (<Identifier>this.obj).actualText)) {\n                                    var prop = <Identifier>binex.operand2;\n                                    if (prop.actualText == "hasOwnProperty") {\n                                        var args = (<CallExpression>cond).arguments;\n                                        if ((args !== null) && (args.members.length == 1)) {\n                                            var arg = args.members[0];\n                                            if ((arg.nodeType == NodeType.Name) &&\n                                                 (this.lval.nodeType == NodeType.Name)) {\n                                                if (((<Identifier>this.lval).actualText) == (<Identifier>arg).actualText) {\n                                                    return true;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("for(");\n            emitter.emitJavascript(this.lval, TokenID.For, false);\n            emitter.writeToOutput(" in ");\n            emitter.emitJavascript(this.obj, TokenID.For, false);\n            emitter.writeToOutput(")");\n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            if (typeFlow.checker.styleSettings.forin) {\n                if (!this.isFiltered()) {\n                    typeFlow.checker.errorReporter.styleError(this, "no hasOwnProperty filter");\n                }\n            }\n            return typeFlow.typeCheckForIn(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            if (this.lval) {\n                context.addContent(this.lval);\n            }\n            if (this.obj) {\n                context.addContent(this.obj);\n            }\n\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            if (this.body) {\n                context.pushStatement(this, loopStart, afterLoop);\n                context.walk(this.body, this);\n                context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopE';
var v27677 = v27678 + 'nd = context.current;\n                loopEnd.addSuccessor(loopStart);\n            }\n            context.current = afterLoop;\n            context.noContinuation = false;\n            loopHeader.addSuccessor(afterLoop);\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class ForStatement extends Statement {\n        public cond: AST;\n        public body: AST;\n        public incr: AST;\n\n        constructor (public init: AST) {\n            super(NodeType.For);\n        }\n\n        public isLoop() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput("for(");\n            if (this.init) {\n                if (this.init.nodeType != NodeType.List) {\n                    emitter.emitJavascript(this.init, TokenID.For, false);\n                }\n                else {\n                    emitter.setInVarBlock((<ASTList>this.init).members.length); \n                    emitter.emitJavascriptList(this.init, null, TokenID.For, false, false, false);\n                }\n            }\n            emitter.writeToOutput("; ");\n            emitter.emitJavascript(this.cond, TokenID.For, false);\n            emitter.writeToOutput("; ");\n            emitter.emitJavascript(this.incr, TokenID.For, false);\n            emitter.writeToOutput(")");\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckFor(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            if (this.init) {\n                context.addContent(this.init);\n            }\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            var condBlock: BasicBlock = null;\n            var continueTarget = loopStart;\n            var incrBB: BasicBlock = null;\n            if (this.incr) {\n                incrBB = new BasicBlock();\n                continueTarget = incrBB;\n            }\n            if (this.cond) {\n                condBlock = context.current;\n                context.addContent(this.cond);\n                context.current = new BasicBlock();\n                condBlock.addSuccessor(context.current);\n            }\n            var targetInfo: ITargetInfo = null;\n            if (this.body) {\n                context.pushStatement(this, continueTarget, afterLoop);\n                context.walk(this.body, this);\n                targetInfo = context.popStatement();\n            }\n            if (this.incr) {\n                if (context.noContinuation) {\n                    if (incrBB.predecessors.length == 0) {\n                        context.addUnreachable(this.incr);\n                    }\n                }\n                else {\n                    context.current.addSuccessor(incrBB);\n                    context.current = incrBB;\n                    context.addContent(this.incr);\n                }\n            }\n            var loopEnd = context.current;\n            if (!(context.noContinuation)) {\n                loopEnd.addSuccessor(loopStart);\n\n            }\n            if (condBlock) {\n                condBlock.addSuccessor(afterLoop);\n                context.noContinuation = false;\n            }\n            if (afterLoop.predecessors.length > 0) {\n                context.noContinuation = false;\n                context.current = afterLoop;\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class WithStatement extends Statement {\n        public body: AST;\n\n        public isCompoundStatement() { return true; }\n\n        public withSym: WithSymbol = null;\n\n        constructor (public expr: AST) {\n            super(NodeType.With);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput("with (");\n            if (this.expr) {\n                emitter.emitJavascript(this.expr, TokenID.With, false);\n            }\n\n            emitter.writeToOutput(")");\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckWith(this);\n        }\n    }\n\n    export class SwitchStatement extends Statement {\n        public caseList:';
var v27676 = v27677 + ' ASTList;\n        public defaultCase: CaseStatement = null;\n        public statement: ASTSpan = new ASTSpan();\n\n        constructor (public val: AST) {\n            super(NodeType.Switch);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("switch(");\n            emitter.emitJavascript(this.val, TokenID.Identifier, false);\n            emitter.writeToOutput(")"); \n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.writeLineToOutput(" {");\n            emitter.indenter.increaseIndent();\n            var casesLen = this.caseList.members.length;\n            for (var i = 0; i < casesLen; i++) {\n                var caseExpr = this.caseList.members[i];\n                emitter.emitJavascript(caseExpr, TokenID.Case, true);\n            }\n            emitter.indenter.decreaseIndent();\n            emitter.emitIndent();\n            emitter.writeToOutput("}");\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var len = this.caseList.members.length;\n            this.val = typeFlow.typeCheck(this.val);\n            for (var i = 0; i < len; i++) {\n                this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]);\n            }\n            this.defaultCase = <CaseStatement>typeFlow.typeCheck(this.defaultCase);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        // if there are break statements that match this switch, then just link cond block with block after switch\n        public addToControlFlow(context: ControlFlowContext) {\n            var condBlock = context.current;\n            context.addContent(this.val);\n            var execBlock = new BasicBlock();\n            var afterSwitch = new BasicBlock();\n\n            condBlock.addSuccessor(execBlock);\n            context.pushSwitch(execBlock);\n            context.current = execBlock;\n            context.pushStatement(this, execBlock, afterSwitch);\n            context.walk(this.caseList, this);\n            context.popSwitch();\n            var targetInfo = context.popStatement();\n            var hasCondContinuation = (this.defaultCase == null);\n            if (this.defaultCase == null) {\n                condBlock.addSuccessor(afterSwitch);\n            }\n            if (afterSwitch.predecessors.length > 0) {\n                context.noContinuation = false;\n                context.current = afterSwitch;\n            }\n            else {\n                context.noContinuation = true;\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class CaseStatement extends Statement {\n        public expr: AST = null;\n        public body: ASTList;\n\n        constructor () {\n            super(NodeType.Case);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.expr) {\n                emitter.writeToOutput("case ");\n                emitter.emitJavascript(this.expr, TokenID.Identifier, false);\n            }\n            else {\n                emitter.writeToOutput("default");\n            }\n            emitter.writeToOutput(":");\n            if (this.body.members.length == 1 && this.body.members[0].nodeType == NodeType.Block) {\n                // The case statement was written with curly braces, so emit it with the appropriate formatting\n                emitter.emitJavascriptStatements(this.body, false);\n            }\n            else {\n                // No curly braces. Format in the expected way\n                emitter.writeLineToOutput("");\n                emitter.indenter.increaseIndent();\n                emitter.emitBareJavascriptStatements(this.body);\n                emitter.indenter.decreaseIndent();\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.expr = typeFlow.typeCheck(this.expr);\n            typeFlow.typeCheck(this.body);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        // TODO: more reasoning about unreachable cases (such as duplicate literals as case expressions)\n        // for now, assume all cases are reachable, regardless of whether some cases fall through\n        public addToControlFlow(context: ControlFlowContext) {\n            var execBlock = new BasicBlock();\n            v';
var v27675 = v27676 + 'ar sw = context.currentSwitch[context.currentSwitch.length - 1];\n            // TODO: fall-through from previous (+ to end of switch)\n            if (this.expr) {\n                var exprBlock = new BasicBlock();\n                context.current = exprBlock;\n                sw.addSuccessor(exprBlock);\n                context.addContent(this.expr);\n                exprBlock.addSuccessor(execBlock);\n            }\n            else {\n                sw.addSuccessor(execBlock);\n            }\n            context.current = execBlock;\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.noContinuation = false;\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class TypeReference extends AST {\n        constructor (public term: AST, public arrayCount: number) {\n            super(NodeType.TypeRef);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            throw new Error("should not emit a type ref");\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var prevInTCTR = typeFlow.inTypeRefTypeCheck;\n            typeFlow.inTypeRefTypeCheck = true;\n            var typeLink = getTypeLink(this, typeFlow.checker, true);\n            typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false);\n\n            if (this.term) {\n                typeFlow.typeCheck(this.term);\n            }\n\n            typeFlow.checkForVoidConstructor(typeLink.type, this);\n\n            this.type = typeLink.type;\n\n            // in error recovery cases, there may not be a term\n            if (this.term) {\n                this.term.type = this.type;\n            }\n\n            typeFlow.inTypeRefTypeCheck = prevInTCTR;\n            return this;\n        }\n    }\n\n    export class TryFinally extends Statement {\n        constructor (public tryNode: AST, public finallyNode: Finally) {\n            super(NodeType.TryFinally);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.tryNode, TokenID.Try, false);\n            emitter.emitJavascript(this.finallyNode, TokenID.Finally, false);\n            emitter.recordSourceMappingEnd(this);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.tryNode = typeFlow.typeCheck(this.tryNode);\n            this.finallyNode = <Finally>typeFlow.typeCheck(this.finallyNode);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var afterFinally = new BasicBlock();\n            context.walk(this.tryNode, this);\n            var finBlock = new BasicBlock();\n            if (context.current) {\n                context.current.addSuccessor(finBlock);\n            }\n            context.current = finBlock;\n            context.pushStatement(this, null, afterFinally);\n            context.walk(this.finallyNode, this);\n            if (!context.noContinuation && context.current) {\n                context.current.addSuccessor(afterFinally);\n            }\n            if (afterFinally.predecessors.length > 0) {\n                context.current = afterFinally;\n            }\n            else {\n                context.noContinuation = true;\n            }\n            context.popStatement();\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class TryCatch extends Statement {\n        constructor (public tryNode: Try, public catchNode: Catch) {\n            super(NodeType.TryCatch);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.tryNode, TokenID.Try, false);\n            emitter.emitJavascript(this.catchNode, TokenID.Catch, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var beforeTry = context.current;\n            var tryBlock = new BasicBlock();\n            beforeTry.addSuccessor(tryBlock);\n            context.current = tryBlock;\n            var afterTryCatch = new BasicBlock();\n            context.pushStatement(this, null, afterTryCatch);\n            context.walk(this.tryNode, this);\n            if (!context.noContinuation) {\n                if (context.current) {\n                    context.current.addSuccessor(afterTryCatch);\n                }\n            }\n            context.current = new BasicBlock();\n            beforeTry.addSuccessor(context.current);\n            context.walk(this.catchNode, this);\n            context.popStatement();\n            if (!context.noContinuation)';
var v27674 = v27675 + ' {\n                if (context.current) {\n                    context.current.addSuccessor(afterTryCatch);\n                }\n            }\n            context.current = afterTryCatch;\n            context.walker.options.goChildren = false;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.tryNode = <Try>typeFlow.typeCheck(this.tryNode);\n            this.catchNode = <Catch>typeFlow.typeCheck(this.catchNode);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n    }\n\n    export class Try extends Statement {\n        constructor (public body: AST) {\n            super(NodeType.Try);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput("try ");\n            emitter.emitJavascript(this.body, TokenID.Try, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.body = typeFlow.typeCheck(this.body);\n            return this;\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.walker.options.goChildren = false;\n            context.noContinuation = false;\n        }\n    }\n\n    export class Catch extends Statement {\n        constructor (public param: VarDecl, public body: AST) {\n            super(NodeType.Catch);\n            if (this.param) {\n                this.param.varFlags |= VarFlags.AutoInit;\n            }\n        }\n        public statement: ASTSpan = new ASTSpan();\n        public containedScope: SymbolScope = null;\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(" ");\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("catch (");\n            emitter.emitJavascript(this.param, TokenID.OpenParen, false);\n            emitter.writeToOutput(")");\n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.emitJavascript(this.body, TokenID.Catch, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            if (this.param) {\n                context.addContent(this.param);\n                var bodBlock = new BasicBlock();\n                context.current.addSuccessor(bodBlock);\n                context.current = bodBlock;\n            }\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.noContinuation = false;\n            context.walker.options.goChildren = false;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var prevScope = typeFlow.scope;\n            typeFlow.scope = this.containedScope;\n            this.param = <VarDecl>typeFlow.typeCheck(this.param);\n            var exceptVar = new ValueLocation();\n            var varSym = new VariableSymbol((<VarDecl>this.param).id.text,\n                                          this.param.minChar,\n                                          typeFlow.checker.locationInfo.unitIndex,\n                                          exceptVar);\n            exceptVar.symbol = varSym;\n            exceptVar.typeLink = new TypeLink();\n            // var type for now (add syntax for type annotation)\n            exceptVar.typeLink.type = typeFlow.anyType;\n            var thisFnc = typeFlow.thisFnc;\n            if (thisFnc && thisFnc.type) {\n                exceptVar.symbol.container = thisFnc.type.symbol;\n            }\n            else {\n                exceptVar.symbol.container = null;\n            }\n            this.param.sym = exceptVar.symbol;\n            typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol,\n                                 typeFlow.checker.errorReporter, false, false, false);\n            this.body = typeFlow.typeCheck(this.body);\n\n            // if we\'re in provisional typecheck mode, clean up the symbol entry\n            // REVIEW: This is obviously bad form, since we\'re counting on the internal\n            // layout of the symbol table, but this is also the only place where we insert\n            // symbols during typecheck\n            if (typeFlow.checker.inProvisionalTypecheckMode()) {\n                var table = typeFlow.scope.getTable();\n                (<any>table).secondaryTable.table[exceptVar.symbol.name] = undefined;\n            }\n            this.type = typeFlow.voidType;\n            typeFlow.scope = prevScope;\n            return this;\n        }\n    }\n\n    export class Finally extends Statement ';
var v27673 = v27674 + '{\n        constructor (public body: AST) {\n            super(NodeType.Finally);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput("finally");\n            emitter.emitJavascript(this.body, TokenID.Finally, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.walker.options.goChildren = false;\n            context.noContinuation = false;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.body = typeFlow.typeCheck(this.body);\n            return this;\n        }\n    }\n\n    export class Comment extends AST {\n\n        public text: string[] = null;\n        public minLine: number;\n        public limLine: number;\n        private docCommentText: string = null;\n\n        constructor (public content: string, public isBlockComment: bool, public endsLine) {\n            super(NodeType.Comment);\n        }\n\n        public getText(): string[] {\n            if (this.text == null) {\n                if (this.isBlockComment) {\n                    this.text = this.content.split("\\n");\n                    for (var i = 0; i < this.text.length; i++) {\n                        this.text[i] = this.text[i].replace(/^\\s+|\\s+$/g, \'\');\n                    }\n                }\n                else {\n                    this.text = [(this.content.replace(/^\\s+|\\s+$/g, \'\'))];\n                }\n            }\n\n            return this.text;\n        }\n\n        public isDocComment() {\n            if (this.isBlockComment) {\n                return this.content.charAt(2) == "*";\n            }\n\n            return false;\n        }\n\n        public getDocCommentText() {\n            if (this.docCommentText == null) {\n                this.docCommentText = Comment.cleanJSDocComment(this.content);\n            }\n\n            return this.docCommentText;\n        }\n\n        static consumeLeadingSpace(line: string, startIndex: number, maxSpacesToRemove?: number) {\n            var endIndex = line.length;\n            if (maxSpacesToRemove != undefined) {\n                endIndex = min(startIndex + maxSpacesToRemove, endIndex);\n            }\n\n            for (; startIndex < endIndex; startIndex++) {\n                var charCode = line.charCodeAt(startIndex);\n                if (charCode != LexCodeSpace && charCode != LexCodeTAB) {\n                    return startIndex;\n                }\n            }\n            \n            if (endIndex != line.length) {\n                return endIndex;\n            }\n\n            return -1;\n        }\n\n        static isSpaceChar(line: string, index: number) {\n            var length = line.length;\n            if (index < length) {\n                var charCode = line.charCodeAt(index);\n                // If the character is space\n                return charCode == LexCodeSpace || charCode == LexCodeTAB;\n            }\n\n            // If the index is end of the line it is space\n            return index == length;\n        }\n\n        static cleanDocCommentLine(line: string, jsDocStyleComment: bool, jsDocLineSpaceToRemove?: number) {\n            var nonSpaceIndex = Comment.consumeLeadingSpace(line, 0);\n            if (nonSpaceIndex != -1) {\n                var jsDocSpacesRemoved = nonSpaceIndex;\n                if (jsDocStyleComment && line.charAt(nonSpaceIndex) == \'*\') { // remove leading * in case of jsDocComment\n                    var startIndex = nonSpaceIndex + 1;\n                    nonSpaceIndex = Comment.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);\n\n                    if (nonSpaceIndex != -1) {\n                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;\n                    } else {\n                        return null;\n                    }\n                }\n\n                return {\n                    minChar: nonSpaceIndex,\n                    limChar: line.charAt(line.length - 1) == "\\r" ? line.length - 1 : line.length,\n                    jsDocSpacesRemoved: jsDocSpacesRemoved\n                };\n            }\n\n            return null;\n        }\n\n        static cleanJSDocComment(content: string, spacesToRemove?: number) {\n            var docCommentLines: string[] = [];\n            content = content.replace("/**", ""); // remove /**\n            if (content.length >= 2 && content.charAt(content.length - 1) == "/" && content.charAt(content.length - 2) == "*") {\n                content = content.substring(0, content.length - 2); // remove last */\n            }\n            var lines = content.split("\\n");\n            var inParamTag = false;\n            for (var l = 0; l < lines.length; l++) {\n                var line = lines[l];\n                var clean';
var v27672 = v27673 + 'LinePos = Comment.cleanDocCommentLine(line, true, spacesToRemove);\n                if (!cleanLinePos) {\n                    // Whole line empty, read next line\n                    continue;\n                }\n\n                var docCommentText = "";\n                var prevPos = cleanLinePos.minChar;\n                for (var i = line.indexOf("@", cleanLinePos.minChar); 0 <= i && i < cleanLinePos.limChar; i = line.indexOf("@", i + 1)) {\n                    // We have encoutered @. \n                    // If we were omitting param comment, we dont have to do anything\n                    // other wise the content of the text till @ tag goes as doc comment\n                    var wasInParamtag = inParamTag;\n\n                    // Parse contents next to @\n                    if (line.indexOf("param", i + 1) == i + 1 && Comment.isSpaceChar(line, i + 6)) {\n                        // It is param tag. \n\n                        // If we were not in param tag earlier, push the contents from prev pos of the tag this tag start as docComment\n                        if (!wasInParamtag) {\n                            docCommentText += line.substring(prevPos, i);\n                        }\n\n                        // New start of contents \n                        prevPos = i;\n                        inParamTag = true;\n                    } else if (wasInParamtag) {\n                        // Non param tag start\n                        prevPos = i;\n                        inParamTag = false;\n                    }\n                }\n\n                if (!inParamTag) {\n                    docCommentText += line.substring(prevPos, cleanLinePos.limChar);\n                }\n\n                // Add line to comment text if it is not only white space line\n                var newCleanPos = Comment.cleanDocCommentLine(docCommentText, false);\n                if (newCleanPos) {\n                    if (spacesToRemove == undefined) {\n                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;\n                    }\n                    docCommentLines.push(docCommentText);\n                }\n            }\n            \n            return docCommentLines.join("\\n");\n        }\n\n        static getDocCommentText(comments: Comment[]) {\n            var docCommentText: string[] = [];\n            for (var c = 0 ; c < comments.length; c++) {\n                var commentText = comments[c].getDocCommentText();\n                if (commentText != "") {\n                    docCommentText.push(commentText);\n                }\n            }\n            return docCommentText.join("\\n");\n        }\n\n        static getParameterDocCommentText(param: string, fncDocComments: Comment[]) {\n            if (fncDocComments.length == 0 || !fncDocComments[0].isBlockComment) {\n                // there were no fnc doc comments and the comment is not block comment then it cannot have \n                // @param comment that can be parsed\n                return "";\n            }\n            \n            for (var i = 0; i < fncDocComments.length; i++) {\n                var commentContents = fncDocComments[i].content;\n                for (var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {\n                    j += 6;\n                    if (!Comment.isSpaceChar(commentContents, j)) {\n                        // This is not param tag but a tag line @paramxxxxx\n                        continue;\n                    }\n\n                    // This is param tag. Check if it is what we are looking for\n                    j = Comment.consumeLeadingSpace(commentContents, j);\n                    if (j == -1) {\n                        break;\n                    }\n                    \n                    // Ignore the type expression\n                    if (commentContents.charCodeAt(j) == LexCodeLC) {\n                        j++;\n                        // Consume the type\n                        var charCode = 0;\n                        for (var curlies = 1; j < commentContents.length; j++) {\n                            charCode = commentContents.charCodeAt(j);\n                            // { character means we need to find another } to match the found one\n                            if (charCode == LexCodeLC) {\n                                curlies++;\n                                continue;\n                            }\n\n                            // } char\n                            if (charCode == LexCodeRC) {\n                                curlies--;\n                                if (curlies == 0) {\n                                    // We do not have any more } to match the type expression is ignored completely\n                                    break;\n                                } else {\n                                    // there are more { to be matched with }\n                                    continue;\n                                }\n                            }\n\n                            // Found start';
var v27671 = v27672 + ' of another tag\n                            if (charCode == LexCodeAtSign) {\n                                break;\n                            }\n                        }\n\n                        // End of the comment\n                        if (j == commentContents.length) {\n                            break;\n                        }\n\n                        // End of the tag, go onto looking for next tag\n                        if (charCode == LexCodeAtSign) {\n                            continue;\n                        }\n\n                        j = Comment.consumeLeadingSpace(commentContents, j + 1);\n                        if (j == -1) {\n                            break;\n                        }\n                    }\n\n                    // Parameter name\n                    if (param != commentContents.substr(j, param.length) || !Comment.isSpaceChar(commentContents, j + param.length)) {\n                        // this is not the parameter we are looking for\n                        continue;\n                    }\n\n                    // Found the parameter we were looking for\n                    j = Comment.consumeLeadingSpace(commentContents, j + param.length);\n                    if (j == -1) {\n                        return "";\n                    }\n                    \n                    var endOfParam = commentContents.indexOf("@", j);\n                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);\n\n                    // Find alignement spaces to remove\n                    var paramSpacesToRemove: number = undefined;\n                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\\n") + 1;\n                    if (paramLineIndex != 0) {\n                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) == "\\r") {\n                            paramLineIndex++;\n                        }\n                    }\n                    var startSpaceRemovalIndex = Comment.consumeLeadingSpace(commentContents, paramLineIndex);\n                    if (startSpaceRemovalIndex != j && commentContents.charAt(startSpaceRemovalIndex) == "*") {\n                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;\n                    }\n\n                    // Clean jsDocComment and return\n                    return Comment.cleanJSDocComment(paramHelpString, paramSpacesToRemove);\n                }\n            }\n\n            return "";\n        }\n\n        static getDocCommentTextOfSignatures(signatures: Signature[]) {\n            var comments: string[] = [];\n            for (var i = 0; i < signatures.length; i++) {\n                var signatureDocComment = TypeScript.Comment.getDocCommentText(signatures[i].declAST.getDocComments());\n                if (signatureDocComment != "") {\n                    comments.push(signatureDocComment);\n                }\n            }\n\n            return comments.join("\\n");\n        }\n    }\n\n    export class DebuggerStatement extends Statement {\n        constructor () {\n            super(NodeType.Debugger);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeLineToOutput("debugger;");\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript.AstWalkerWithDetailCallback {\n    export interface AstWalkerDetailCallback {\n        EmptyCallback? (pre, ast: AST): bool;\n        EmptyExprCallback? (pre, ast: AST): bool;\n        TrueCallback? (pre, ast: AST): bool;\n        FalseCallback? (pre, ast: AST): bool;\n        ThisCallback? (pre, ast: AST): bool;\n        SuperCallback? (pre, ast: AST): bool;\n        QStringCallback? (pre, ast: AST): bool;\n        RegexCallback? (pre, ast: AST): bool;\n        NullCallback? (pre, ast: AST): bool;\n        ArrayLitCallback? (pre, ast: AST): bool;\n        ObjectLitCallback? (pre, ast: AST): bool;\n        VoidCallback? (pre, ast: AST): bool;\n        CommaCallback? (pre, ast: AST): bool;\n        PosCallback? (pre, ast: AST): bool;\n        NegCallback? (pre, ast: AST): bool;\n        DeleteCallback? (pre, ast: AST): bool;\n        AwaitCal';
var v27670 = v27671 + "lback? (pre, ast: AST): bool;\n        InCallback? (pre, ast: AST): bool;\n        DotCallback? (pre, ast: AST): bool;\n        FromCallback? (pre, ast: AST): bool;\n        IsCallback? (pre, ast: AST): bool;\n        InstOfCallback? (pre, ast: AST): bool;\n        TypeofCallback? (pre, ast: AST): bool;\n        NumberLitCallback? (pre, ast: AST): bool;\n        NameCallback? (pre, identifierAst: Identifier): bool;\n        TypeRefCallback? (pre, ast: AST): bool;\n        IndexCallback? (pre, ast: AST): bool;\n        CallCallback? (pre, ast: AST): bool;\n        NewCallback? (pre, ast: AST): bool;\n        AsgCallback? (pre, ast: AST): bool;\n        AsgAddCallback? (pre, ast: AST): bool;\n        AsgSubCallback? (pre, ast: AST): bool;\n        AsgDivCallback? (pre, ast: AST): bool;\n        AsgMulCallback? (pre, ast: AST): bool;\n        AsgModCallback? (pre, ast: AST): bool;\n        AsgAndCallback? (pre, ast: AST): bool;\n        AsgXorCallback? (pre, ast: AST): bool;\n        AsgOrCallback? (pre, ast: AST): bool;\n        AsgLshCallback? (pre, ast: AST): bool;\n        AsgRshCallback? (pre, ast: AST): bool;\n        AsgRs2Callback? (pre, ast: AST): bool;\n        QMarkCallback? (pre, ast: AST): bool;\n        LogOrCallback? (pre, ast: AST): bool;\n        LogAndCallback? (pre, ast: AST): bool;\n        OrCallback? (pre, ast: AST): bool;\n        XorCallback? (pre, ast: AST): bool;\n        AndCallback? (pre, ast: AST): bool;\n        EqCallback? (pre, ast: AST): bool;\n        NeCallback? (pre, ast: AST): bool;\n        EqvCallback? (pre, ast: AST): bool;\n        NEqvCallback? (pre, ast: AST): bool;\n        LtCallback? (pre, ast: AST): bool;\n        LeCallback? (pre, ast: AST): bool;\n        GtCallback? (pre, ast: AST): bool;\n        GeCallback? (pre, ast: AST): bool;\n        AddCallback? (pre, ast: AST): bool;\n        SubCallback? (pre, ast: AST): bool;\n        MulCallback? (pre, ast: AST): bool;\n        DivCallback? (pre, ast: AST): bool;\n        ModCallback? (pre, ast: AST): bool;\n        LshCallback? (pre, ast: AST): bool;\n        RshCallback? (pre, ast: AST): bool;\n        Rs2Callback? (pre, ast: AST): bool;\n        NotCallback? (pre, ast: AST): bool;\n        LogNotCallback? (pre, ast: AST): bool;\n        IncPreCallback? (pre, ast: AST): bool;\n        DecPreCallback? (pre, ast: AST): bool;\n        IncPostCallback? (pre, ast: AST): bool;\n        DecPostCallback? (pre, ast: AST): bool;\n        TypeAssertionCallback? (pre, ast: AST): bool;\n        FuncDeclCallback? (pre, funcDecl: FuncDecl): bool;\n        MemberCallback? (pre, ast: AST): bool;\n        VarDeclCallback? (pre, varDecl: VarDecl): bool;\n        ArgDeclCallback? (pre, ast: AST): bool;\n        ReturnCallback? (pre, ast: AST): bool;\n        BreakCallback? (pre, ast: AST): bool;\n        ContinueCallback? (pre, ast: AST): bool;\n        ThrowCallback? (pre, ast: AST): bool;\n        ForCallback? (pre, ast: AST): bool;\n        ForInCallback? (pre, ast: AST): bool;\n        IfCallback? (pre, ast: AST): bool;\n        WhileCallback? (pre, ast: AST): bool;\n        DoWhileCallback? (pre, ast: AST): bool;\n        BlockCallback? (pre, block: Block): bool;\n        CaseCallback? (pre, ast: AST): bool;\n        SwitchCallback? (pre, ast: AST): bool;\n        TryCallback? (pre, ast: AST): bool;\n        TryCatchCallback? (pre, ast: AST): bool;\n        TryFinallyCallback? (pre, ast: AST): bool;\n        FinallyCallback? (pre, ast: AST): bool;\n        CatchCallback? (pre, ast: AST): bool;\n        ListCallback? (pre, astList: ASTList): bool;\n        ScriptCallback? (pre, script: Script): bool;\n        ClassDeclarationCallback? (pre, ast: AST): bool;\n        InterfaceDeclarationCallback? (pre, interfaceDecl: InterfaceDeclaration): bool;\n        ModuleDeclarationCallback? (pre, moduleDecl: ModuleDeclaration): bool;\n        ImportDeclarationCallback? (pre, ast: AST): bool;\n        WithCallback? (pre, ast: AST): bool;\n        LabelCallback? (pre, labelAST: AST): bool;\n        LabeledStatementCallback? (pre, ast: AST): bool;\n        EBStartCallback? (pre, ast: AST): bool;\n        GotoEBCallback? (pre, ast: AST): bool;\n        EndCodeCallback? (pre, ast: AST): bool;\n        ErrorCallback? (pre, ast: AST): bool;\n        CommentCallback? (pre, ast: AST): bool;\n        DebuggerCallback? (pre, ast: AST): bool;\n        DefaultCallback? (pre, ast: AST): bool;\n    }\n\n    export function walk(script: Script, callback: AstWalkerDetailCallback): void {\n        var pre = (cur: AST, parent: AST) => {\n            walker.options.goChildren = AstWalkerCallback(true, cur, callback);\n            return cur;\n        }\n\n        var post = (cur: AST, parent: AST) => {\n            AstWalkerCallback(false, cur, callback);\n            return cur;\n        }\n\n        var walker = TypeScript.getAstWalkerFactory().getWalker(pre, post);\n        walker.walk(script, null);\n    }\n\n    function AstWalkerCallback(pre: bool, ast: AST, callback: AstWalkerDetailCallback): bool {\n        // See if the Callback needs to be handled using spe";
var v27669 = v27670 + 'cific one or default one\n        var nodeType = ast.nodeType;\n        var callbackString = (<any>NodeType)._map[nodeType] + "Callback";\n        if (callback[callbackString]) {\n            return callback[callbackString](pre, ast);\n        }\n\n        if (callback.DefaultCallback) {\n            return callback.DefaultCallback(pre, ast);\n        }\n\n        return true;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export interface IAstWalker {\n        walk(ast: AST, parent: AST): AST;\n        options: AstWalkOptions;\n        state: any; // user state object\n    }\n\n    export class AstWalkOptions {\n        public goChildren = true;\n        public goNextSibling = true;\n        public reverseSiblings = false; // visit siblings in reverse execution order\n\n        public stopWalk(stop:bool = true) {\n            this.goChildren = !stop;\n            this.goNextSibling = !stop;\n        }\n    }\n\n    export interface IAstWalkCallback {\n        (ast: AST, parent: AST, walker: IAstWalker): AST;\n    }\n\n    export interface IAstWalkChildren {\n        (preAst: AST, parent: AST, walker: IAstWalker): void;\n    }\n\n    class AstWalker implements IAstWalker {\n        constructor (\n            private childrenWalkers: IAstWalkChildren[],\n            private pre: IAstWalkCallback,\n            private post: IAstWalkCallback,\n            public options: AstWalkOptions,\n            public state: any) {\n        }\n\n        public walk(ast: AST, parent: AST): AST {\n            var preAst = this.pre(ast, parent, this);\n            if (preAst === undefined) {\n                preAst = ast;\n            }\n            if (this.options.goChildren) {\n                var svGoSib = this.options.goNextSibling;\n                this.options.goNextSibling = true;\n                // Call the "walkChildren" function corresponding to "nodeType".\n                this.childrenWalkers[ast.nodeType](ast, parent, this);\n                this.options.goNextSibling = svGoSib;\n            }\n            else {\n                // no go only applies to children of node issuing it\n                this.options.goChildren = true;\n            }\n            if (this.post) {\n                var postAst = this.post(preAst, parent, this);\n                if (postAst === undefined) {\n                    postAst = preAst;\n                }\n                return postAst;\n            }\n            else {\n                return preAst;\n            }\n        }\n    }\n\n    export class AstWalkerFactory {\n        private childrenWalkers: IAstWalkChildren[] = [];\n\n        constructor () {\n            this.initChildrenWalkers();\n        }\n\n        public walk(ast: AST, pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): AST {\n            return this.getWalker(pre, post, options, state).walk(ast, null)\n        }\n\n        public getWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {\n            return this.getSlowWalker(pre, post, options, state);\n        }\n\n        private getSlowWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {\n            if (!options) {\n                options = new AstWalkOptions();\n            }\n\n            return new AstWalker(this.childrenWalkers, pre, post, options, state);\n        }\n\n        private initChildrenWalkers(): void {\n            this.childrenWalkers[NodeType.None] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Empty] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.EmptyExpr] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.True] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.False] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.This] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Super] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.QString] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Regex] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Null] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.ArrayLit] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.ObjectLit] = ChildrenWalkers.walkUnaryExpressionChild';
var v27668 = v27669 + "ren;\n            this.childrenWalkers[NodeType.Void] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Comma] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Pos] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Neg] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Delete] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Await] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.In] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Dot] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.From] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Is] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.InstOf] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Typeof] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.NumberLit] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Name] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.TypeRef] = ChildrenWalkers.walkTypeReferenceChildren;\n            this.childrenWalkers[NodeType.Index] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Call] = ChildrenWalkers.walkCallExpressionChildren;\n            this.childrenWalkers[NodeType.New] = ChildrenWalkers.walkCallExpressionChildren;\n            this.childrenWalkers[NodeType.Asg] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgAdd] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgSub] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgDiv] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgMul] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgMod] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgAnd] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgXor] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgOr] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgLsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgRsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgRs2] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.ConditionalExpression] = ChildrenWalkers.walkTrinaryExpressionChildren;\n            this.childrenWalkers[NodeType.LogOr] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.LogAnd] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Or] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Xor] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.And] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Eq] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Ne] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Eqv] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.NEqv] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Lt] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Le] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Gt] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Ge] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Add] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Sub] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Mul] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Div] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Mod] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Lsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Rsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Rs2] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalker";
var v27667 = v27668 + 's[NodeType.Not] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.LogNot] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.IncPre] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.DecPre] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.IncPost] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.DecPost] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.TypeAssertion] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.FuncDecl] = ChildrenWalkers.walkFuncDeclChildren;\n            this.childrenWalkers[NodeType.Member] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.VarDecl] = ChildrenWalkers.walkBoundDeclChildren;\n            this.childrenWalkers[NodeType.ArgDecl] = ChildrenWalkers.walkBoundDeclChildren;\n            this.childrenWalkers[NodeType.Return] = ChildrenWalkers.walkReturnStatementChildren;\n            this.childrenWalkers[NodeType.Break] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Continue] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Throw] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.For] = ChildrenWalkers.walkForStatementChildren;\n            this.childrenWalkers[NodeType.ForIn] = ChildrenWalkers.walkForInStatementChildren;\n            this.childrenWalkers[NodeType.If] = ChildrenWalkers.walkIfStatementChildren;\n            this.childrenWalkers[NodeType.While] = ChildrenWalkers.walkWhileStatementChildren;\n            this.childrenWalkers[NodeType.DoWhile] = ChildrenWalkers.walkDoWhileStatementChildren;\n            this.childrenWalkers[NodeType.Block] = ChildrenWalkers.walkBlockChildren;\n            this.childrenWalkers[NodeType.Case] = ChildrenWalkers.walkCaseStatementChildren;\n            this.childrenWalkers[NodeType.Switch] = ChildrenWalkers.walkSwitchStatementChildren;\n            this.childrenWalkers[NodeType.Try] = ChildrenWalkers.walkTryChildren;\n            this.childrenWalkers[NodeType.TryCatch] = ChildrenWalkers.walkTryCatchChildren;\n            this.childrenWalkers[NodeType.TryFinally] = ChildrenWalkers.walkTryFinallyChildren;\n            this.childrenWalkers[NodeType.Finally] = ChildrenWalkers.walkFinallyChildren;\n            this.childrenWalkers[NodeType.Catch] = ChildrenWalkers.walkCatchChildren;\n            this.childrenWalkers[NodeType.List] = ChildrenWalkers.walkListChildren;\n            this.childrenWalkers[NodeType.Script] = ChildrenWalkers.walkScriptChildren;\n            this.childrenWalkers[NodeType.ClassDeclaration] = ChildrenWalkers.walkClassDeclChildren;\n            this.childrenWalkers[NodeType.InterfaceDeclaration] = ChildrenWalkers.walkTypeDeclChildren;\n            this.childrenWalkers[NodeType.ModuleDeclaration] = ChildrenWalkers.walkModuleDeclChildren;\n            this.childrenWalkers[NodeType.ImportDeclaration] = ChildrenWalkers.walkImportDeclChildren;\n            this.childrenWalkers[NodeType.With] = ChildrenWalkers.walkWithStatementChildren;\n            this.childrenWalkers[NodeType.Label] = ChildrenWalkers.walkLabelChildren;\n            this.childrenWalkers[NodeType.LabeledStatement] = ChildrenWalkers.walkLabeledStatementChildren;\n            this.childrenWalkers[NodeType.EBStart] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.GotoEB] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.EndCode] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Error] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Comment] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Debugger] = ChildrenWalkers.walkNone;\n\n            // Verify the code is up to date with the enum\n            for (var e in (<any>NodeType)._map) {\n                if ((<any>this.childrenWalkers)[e] === undefined) {\n                    throw new Error("initWalkers function is not up to date with enum content!");\n                }\n            }\n        }\n    }\n\n    var globalAstWalkerFactory: AstWalkerFactory;\n\n    export function getAstWalkerFactory(): AstWalkerFactory {\n        if (!globalAstWalkerFactory) {\n            globalAstWalkerFactory = new AstWalkerFactory();\n        }\n        return globalAstWalkerFactory;\n    }\n\n    module ChildrenWalkers {\n        export function walkNone(preAst: ASTList, parent: AST, walker: IAstWalker): void {\n            // Nothing to do\n        }\n\n        export function walkListChildren(preAst: ASTList, parent: AST, walker: IAstWalker): void {\n            var len = preAst.members.length;\n            if (walker.options.reverseSiblings) {\n                for (var i = len - 1; i >= 0; i--) {\n                    if (walker.options.goNextSibling) {\n                        preAst.m';
var v27666 = v27667 + "embers[i] = walker.walk(preAst.members[i], preAst);\n                    }\n                }\n            }\n            else {\n                for (var i = 0; i < len; i++) {\n                    if (walker.options.goNextSibling) {\n                        preAst.members[i] = walker.walk(preAst.members[i], preAst);\n                    }\n                }\n            }\n        }\n\n        export function walkUnaryExpressionChildren(preAst: UnaryExpression, parent: AST, walker: IAstWalker): void {\n            if (preAst.castTerm) {\n                preAst.castTerm = walker.walk(preAst.castTerm, preAst);\n            }\n            if (preAst.operand) {\n                preAst.operand = walker.walk(preAst.operand, preAst);\n            }\n        }\n\n        export function walkBinaryExpressionChildren(preAst: BinaryExpression, parent: AST, walker: IAstWalker): void {\n            if (walker.options.reverseSiblings) {\n                if (preAst.operand2) {\n                    preAst.operand2 = walker.walk(preAst.operand2, preAst);\n                }\n                if ((preAst.operand1) && (walker.options.goNextSibling)) {\n                    preAst.operand1 = walker.walk(preAst.operand1, preAst);\n                }\n            } else {\n                if (preAst.operand1) {\n                    preAst.operand1 = walker.walk(preAst.operand1, preAst);\n                }\n                if ((preAst.operand2) && (walker.options.goNextSibling)) {\n                    preAst.operand2 = walker.walk(preAst.operand2, preAst);\n                }\n            }\n        }\n\n        export function walkTypeReferenceChildren(preAst: TypeReference, parent: AST, walker: IAstWalker): void {\n            if (preAst.term) {\n                preAst.term = walker.walk(preAst.term, preAst);\n            }\n        }\n\n        export function walkCallExpressionChildren(preAst: CallExpression, parent: AST, walker: IAstWalker): void {\n            if (!walker.options.reverseSiblings) {\n                preAst.target = walker.walk(preAst.target, preAst);\n            }\n            if (preAst.arguments && (walker.options.goNextSibling)) {\n                preAst.arguments = <ASTList> walker.walk(preAst.arguments, preAst);\n            }\n            if ((walker.options.reverseSiblings) && (walker.options.goNextSibling)) {\n                preAst.target = walker.walk(preAst.target, preAst);\n            }\n        }\n\n        export function walkTrinaryExpressionChildren(preAst: ConditionalExpression, parent: AST, walker: IAstWalker): void {\n            if (preAst.operand1) {\n                preAst.operand1 = walker.walk(preAst.operand1, preAst);\n            }\n            if (preAst.operand2 && (walker.options.goNextSibling)) {\n                preAst.operand2 = walker.walk(preAst.operand2, preAst);\n            }\n            if (preAst.operand3 && (walker.options.goNextSibling)) {\n                preAst.operand3 = walker.walk(preAst.operand3, preAst);\n            }\n        }\n\n        export function walkFuncDeclChildren(preAst: FuncDecl, parent: AST, walker: IAstWalker): void {\n            if (preAst.name) {\n                preAst.name = <Identifier>walker.walk(preAst.name, preAst);\n            }\n            if (preAst.arguments && (preAst.arguments.members.length > 0) && (walker.options.goNextSibling)) {\n                preAst.arguments = <ASTList>walker.walk(preAst.arguments, preAst);\n            }\n            if (preAst.returnTypeAnnotation && (walker.options.goNextSibling)) {\n                preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst);\n            }\n            if (preAst.bod && (preAst.bod.members.length > 0) && (walker.options.goNextSibling)) {\n                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);\n            }\n        }\n\n        export function walkBoundDeclChildren(preAst: BoundDecl, parent: AST, walker: IAstWalker): void {\n            if (preAst.id) {\n                preAst.id = <Identifier>walker.walk(preAst.id, preAst);\n            }\n            if (preAst.init) {\n                preAst.init = walker.walk(preAst.init, preAst);\n            }\n            if ((preAst.typeExpr) && (walker.options.goNextSibling)) {\n                preAst.typeExpr = walker.walk(preAst.typeExpr, preAst);\n            }\n        }\n\n        export function walkReturnStatementChildren(preAst: ReturnStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.returnExpression) {\n                preAst.returnExpression = walker.walk(preAst.returnExpression, preAst);\n            }\n        }\n\n        export function walkForStatementChildren(preAst: ForStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.init) {\n                preAst.init = walker.walk(preAst.init, preAst);\n            }\n\n            if (preAst.cond && walker.options.goNextSibling) {\n                preAst.cond = walker.walk(preAst.cond, preAst);\n            }\n\n            if (preAst.incr && walker.options.goNextSibling) {\n                pr";
var v27665 = v27666 + "eAst.incr = walker.walk(preAst.incr, preAst);\n            }\n\n            if (preAst.body && walker.options.goNextSibling) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkForInStatementChildren(preAst: ForInStatement, parent: AST, walker: IAstWalker): void {\n            preAst.lval = walker.walk(preAst.lval, preAst);\n            if (walker.options.goNextSibling) {\n                preAst.obj = walker.walk(preAst.obj, preAst);\n            }\n            if (preAst.body && (walker.options.goNextSibling)) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkIfStatementChildren(preAst: IfStatement, parent: AST, walker: IAstWalker): void {\n            preAst.cond = walker.walk(preAst.cond, preAst);\n            if (preAst.thenBod && (walker.options.goNextSibling)) {\n                preAst.thenBod = walker.walk(preAst.thenBod, preAst);\n            }\n            if (preAst.elseBod && (walker.options.goNextSibling)) {\n                preAst.elseBod = walker.walk(preAst.elseBod, preAst);\n            }\n        }\n\n        export function walkWhileStatementChildren(preAst: WhileStatement, parent: AST, walker: IAstWalker): void {\n            preAst.cond = walker.walk(preAst.cond, preAst);\n            if (preAst.body && (walker.options.goNextSibling)) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkDoWhileStatementChildren(preAst: DoWhileStatement, parent: AST, walker: IAstWalker): void {\n            preAst.cond = walker.walk(preAst.cond, preAst);\n            if (preAst.body && (walker.options.goNextSibling)) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkBlockChildren(preAst: Block, parent: AST, walker: IAstWalker): void {\n            if (preAst.statements) {\n                preAst.statements = <ASTList>walker.walk(preAst.statements, preAst);\n            }\n        }\n\n        export function walkCaseStatementChildren(preAst: CaseStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.expr) {\n                preAst.expr = walker.walk(preAst.expr, preAst);\n            }\n\n            if (preAst.body && walker.options.goNextSibling) {\n                preAst.body = <ASTList>walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkSwitchStatementChildren(preAst: SwitchStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.val) {\n                preAst.val = walker.walk(preAst.val, preAst);\n            }\n\n            if ((preAst.caseList) && walker.options.goNextSibling) {\n                preAst.caseList = <ASTList>walker.walk(preAst.caseList, preAst);\n            }\n        }\n\n        export function walkTryChildren(preAst: Try, parent: AST, walker: IAstWalker): void {\n            if (preAst.body) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkTryCatchChildren(preAst: TryCatch, parent: AST, walker: IAstWalker): void {\n            if (preAst.tryNode) {\n                preAst.tryNode = <Try>walker.walk(preAst.tryNode, preAst);\n            }\n\n            if ((preAst.catchNode) && walker.options.goNextSibling) {\n                preAst.catchNode = <Catch>walker.walk(preAst.catchNode, preAst);\n            }\n        }\n\n        export function walkTryFinallyChildren(preAst: TryFinally, parent: AST, walker: IAstWalker): void {\n            if (preAst.tryNode) {\n                preAst.tryNode = walker.walk(preAst.tryNode, preAst);\n            }\n\n            if (preAst.finallyNode && walker.options.goNextSibling) {\n                preAst.finallyNode = <Finally>walker.walk(preAst.finallyNode, preAst);\n            }\n        }\n\n        export function walkFinallyChildren(preAst: Finally, parent: AST, walker: IAstWalker): void {\n            if (preAst.body) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkCatchChildren(preAst: Catch, parent: AST, walker: IAstWalker): void {\n            if (preAst.param) {\n                preAst.param = <VarDecl>walker.walk(preAst.param, preAst);\n            }\n\n            if ((preAst.body) && walker.options.goNextSibling) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkRecordChildren(preAst: NamedDeclaration, parent: AST, walker: IAstWalker): void {\n            preAst.name = <Identifier>walker.walk(preAst.name, preAst);\n            if (walker.options.goNextSibling && preAst.members) {\n                preAst.members = <ASTList>walker.walk(preAst.members, preAst);\n            }\n\n        }\n\n        export function walkNamedTypeChildren(preAst: TypeDeclaration, parent: AST, walker: IAstWalker): void {\n            walkRecordChildren(preAst, parent, walker);\n        }\n";
var v27664 = v27665 + '\n        export function walkClassDeclChildren(preAst: ClassDeclaration, parent: AST, walker: IAstWalker): void {\n            walkNamedTypeChildren(preAst, parent, walker);\n\n            if (walker.options.goNextSibling && preAst.extendsList) {\n                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);\n            }\n\n            if (walker.options.goNextSibling && preAst.implementsList) {\n                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);\n            }\n        }\n\n        export function walkScriptChildren(preAst: Script, parent: AST, walker: IAstWalker): void {\n            if (preAst.bod) {\n                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);\n            }\n        }\n\n        export function walkTypeDeclChildren(preAst: InterfaceDeclaration, parent: AST, walker: IAstWalker): void {\n            walkNamedTypeChildren(preAst, parent, walker);\n\n            // walked arguments as part of members\n            if (walker.options.goNextSibling && preAst.extendsList) {\n                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);\n            }\n\n            if (walker.options.goNextSibling && preAst.implementsList) {\n                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);\n            }\n        }\n\n        export function walkModuleDeclChildren(preAst: ModuleDeclaration, parent: AST, walker: IAstWalker): void {\n            walkRecordChildren(preAst, parent, walker);\n        }\n\n        export function walkImportDeclChildren(preAst: ImportDeclaration, parent: AST, walker: IAstWalker): void {\n            if (preAst.id) {\n                preAst.id = <Identifier>walker.walk(preAst.id, preAst);\n            }\n            if (preAst.alias) {\n                preAst.alias = walker.walk(preAst.alias, preAst);\n            }\n        }\n\n        export function walkWithStatementChildren(preAst: WithStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.expr) {\n                preAst.expr = walker.walk(preAst.expr, preAst);\n            }\n\n            if (preAst.body && walker.options.goNextSibling) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkLabelChildren(preAst: Label, parent: AST, walker: IAstWalker): void {\n            //TODO: Walk "id"?\n        }\n\n        export function walkLabeledStatementChildren(preAst: LabeledStatement, parent: AST, walker: IAstWalker): void {\n            preAst.labels = <ASTList>walker.walk(preAst.labels, preAst);\n            if (walker.options.goNextSibling) {\n                preAst.stmt = walker.walk(preAst.stmt, preAst);\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nmodule TypeScript {\n    class Base64Format {\n        static encodedValues = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n        static encode(inValue: number) {\n            if (inValue < 64) {\n                return encodedValues.charAt(inValue);\n            }\n            throw TypeError(inValue + ": not a 64 based value");\n        }\n\n        static decodeChar(inChar: string) {\n            if (inChar.length === 1) {\n                return encodedValues.indexOf(inChar);\n            } else {\n                throw TypeError(\'"\' + inChar + \'" must have length 1\');\n            }\n        }\n    }\n\n    export class Base64VLQFormat {\n        static encode(inValue: number) {\n            // Add a new least significant bit that has the sign of the value.\n            // if negative number the least significant bit that gets added to the number has value 1\n            // else least significant bit value that gets added is 0\n            // eg. -1 changes to binary : 01 [1] => 3\n            //     +1 changes to binary : 01 [0] => 2\n            if (inValue < 0) {\n                inValue = ((-inValue) << 1) + 1;\n            }\n            else {\n                inValue = inValue << 1;\n            }\n\n            // Encode 5 bits at a time starting from least significant bits\n            var encodedStr = "";\n            do {\n                var currentDigit = inValue & 31; // 11111\n                inValue = inValue >> 5;\n                if (inValue > 0) {\n                    // There are still more digits to decode, set the msb (6th bit)\n                    currentDigit = currentDigit | 32; \n               ';
var v27663 = v27664 + ' }\n                encodedStr = encodedStr + Base64Format.encode(currentDigit);\n            } while (inValue > 0);\n\n            return encodedStr;\n        }\n\n        static decode(inString: string) {\n            var result = 0;\n            var negative = false;\n\n            var shift = 0;\n            for (var i = 0; i < inString.length; i++) {\n                var byte = Base64Format.decodeChar(inString[i]);\n                if (i === 0) {\n                    // Sign bit appears in the LSBit of the first value\n                    if ((byte & 1) === 1) {\n                        negative = true;\n                    }\n                    result = (byte >> 1) & 15; // 1111x\n                } else {\n                    result = result | ((byte & 31) << shift); // 11111\n                }\n\n                shift += (i == 0) ? 4 : 5;\n\n                if ((byte & 32) === 32) {\n                    // Continue\n                } else {\n                    return { value: negative ? -(result) : result, rest: inString.substr(i + 1) };\n                }\n            }\n\n            throw new Error(\'Base64 value "\' + inString + \'" finished with a continuation bit\');\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class Binder {\n        constructor(public checker: TypeChecker) { }\n        \n        public resolveBaseTypeLinks(typeLinks: TypeLink[], scope: SymbolScope) {\n            var extendsList: Type[] = null;\n            if (typeLinks) {\n                extendsList = new Type[];\n                for (var i = 0, len = typeLinks.length; i < len; i++) {\n                    extendsList[i] = this.checker.resolveBaseTypeLink(typeLinks[i], scope);\n                }\n            }\n            return extendsList;\n        }\n\n        public resolveBases(scope: SymbolScope, type: Type) {\n            type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope);\n\n            var i = 0, len = type.extendsList.length;\n            var derivedIsClass = type.isClassInstance();\n            for (; i < len; i++) {\n                var baseIsClass = type.extendsList[i].isClassInstance();\n                if (type.extendsList[i] != this.checker.anyType) {\n                    var baseRef = type.extendsTypeLinks[i].ast;\n                    if (derivedIsClass) {\n                        if (!baseIsClass) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "A class may only extend other classes, " + type.extendsList[i].symbol.fullName() + " is not a class.");\n                        }\n                    }\n                    else {\n                        if (baseIsClass) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName() + " is a class.");\n                        }\n                    }\n                }\n            }\n\n            type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope);\n\n            if (type.implementsList) {\n                for (i = 0, len = type.implementsList.length; i < len; i++) {\n                    var iface = type.implementsList[i];\n                    var baseRef = type.implementsTypeLinks[i].ast;\n                    if (iface.isClassInstance()) {\n                        if (derivedIsClass) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "A class may only implement an interface; " + iface.symbol.fullName() + " is a class.");\n                        }\n                    }\n                }\n            }\n        }\n\n        public resolveSignatureGroup(signatureGroup: SignatureGroup, scope: SymbolScope, instanceType: Type) {\n            var supplyVar = !(signatureGroup.hasImplementation);\n            for (var i = 0, len = signatureGroup.signatures.length; i < len; i++) {\n                var signature = signatureGroup.signatures[i];\n                if (instanceType) {\n                    signature.returnType.type = instanceType;\n                }\n                else {\n                    this.checker.resolveTypeLink(scope, signature.returnType, supplyVar);\n               ';
var v27662 = v27663 + ' }\n                var paramLen = signature.parameters.length;\n                for (var j = 0; j < paramLen; j++) {\n                    this.bindSymbol(scope, signature.parameters[j]);\n                }\n                if (signature.hasVariableArgList) {\n                    // check that last parameter has an array type\n                    var lastParam = <ParameterSymbol>signature.parameters[paramLen - 1];\n                    lastParam.argsOffset = paramLen - 1;\n                    if (!lastParam.getType().isArray()) {\n                        this.checker.errorReporter.simpleErrorFromSym(lastParam,\n                                                                 "... parameter must have array type");\n                        lastParam.parameter.typeLink.type = this.checker.makeArrayType(lastParam.parameter.typeLink.type);\n                    }\n                }\n            }\n        }\n\n        public bindType(scope: SymbolScope, type: Type, instanceType: Type): void {\n            if (instanceType) {\n                this.bindType(scope, instanceType, null);\n            }\n            if (type.hasMembers()) {\n                var members = type.members;\n                var ambientMembers = type.ambientMembers;\n                var typeMembers = type.getAllEnclosedTypes(); // REVIEW: Should only be getting exported types?\n                var ambientTypeMembers = type.getAllAmbientEnclosedTypes(); // REVIEW: Should only be getting exported types?\n                var memberScope = new SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol);\n                var agg = new SymbolAggregateScope(type.symbol);\n                var prevCurrentModDecl = this.checker.currentModDecl;\n                var prevBindStatus = this.checker.inBind;\n                agg.addParentScope(memberScope);\n                agg.addParentScope(scope);\n                if (type.isModuleType()) {\n                    this.checker.currentModDecl = <ModuleDeclaration>type.symbol.declAST;\n                    this.checker.inBind = true;\n                }\n                if (members) {\n                    this.bind(agg, type.members.allMembers); // REVIEW: Should only be getting exported types?\n                }\n                if (typeMembers) {\n                    this.bind(agg, typeMembers.allMembers);\n                }\n                if (ambientMembers) {\n                    this.bind(agg, ambientMembers.allMembers);\n                }\n                if (ambientTypeMembers) {\n                    this.bind(agg, ambientTypeMembers.allMembers);\n                }\n                this.checker.currentModDecl = prevCurrentModDecl;\n                this.checker.inBind = prevBindStatus;\n            }\n            if (type.extendsTypeLinks) {\n                this.resolveBases(scope, type);\n            }\n            if (type.construct) {\n                this.resolveSignatureGroup(type.construct, scope, instanceType);\n            }\n            if (type.call) {\n                this.resolveSignatureGroup(type.call, scope, null);\n            }\n            if (type.index) {\n                this.resolveSignatureGroup(type.index, scope, null);\n            }\n            if (type.elementType) {\n                this.bindType(scope, type.elementType, null);\n            }\n        }\n\n        public bindSymbol(scope: SymbolScope, symbol: Symbol) {\n            if (!symbol.bound) {\n                var prevLocationInfo = this.checker.locationInfo;\n                if ((this.checker.units) && (symbol.unitIndex >= 0) && (symbol.unitIndex < this.checker.units.length)) {\n                    this.checker.locationInfo = this.checker.units[symbol.unitIndex];\n                }\n                switch (symbol.kind()) {\n                    case SymbolKind.Type:\n\n                        if (symbol.flags & SymbolFlags.Bound) {\n                            break;\n                        }\n\n                        var typeSymbol = <TypeSymbol>symbol;\n                        typeSymbol.flags |= SymbolFlags.Bound;\n\n                        // Since type collection happens out of order, a dynamic module referenced by an import statement\n                        // may not yet be in scope when the import symbol is created.  In that case, we need to search\n                        // out the module symbol now\n                        // Note that we\'ll also want to do this in resolveTypeMembers, in case the symbol is set outside the\n                        // context of a given module  (E.g., an outer import statement)\n                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name) {\n                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;\n                            var modSym = this.checker.findSymbolForDynamicModule(modPath, this.checker.locationInfo.filename, (id) => scope.find(id, false, true));\n                            if (modSym) {\n                                typeSymb';
var v27661 = v27662 + 'ol.type = modSym.getType();\n                            }\n                        }\n\n                        if (typeSymbol.type && typeSymbol.type != this.checker.gloModType) {\n                            this.bindType(scope, typeSymbol.type, typeSymbol.instanceType);\n\n                            // bind expansions on the parent type symbol\n                            if (typeSymbol.type.isModuleType()) {\n                                for (var i = 0; i < typeSymbol.expansions.length; i++) {\n                                    this.bindType(scope, typeSymbol.expansions[i], typeSymbol.instanceType);\n                                }\n                            }\n                        }\n                        break;\n                    case SymbolKind.Field:\n                        this.checker.resolveTypeLink(scope, (<FieldSymbol>symbol).field.typeLink,\n                                                false);\n                        break;\n                    case SymbolKind.Parameter:\n                        this.checker.resolveTypeLink(scope,\n                                                (<ParameterSymbol>symbol).parameter.typeLink,\n                                                true);\n                        break;\n                }\n                this.checker.locationInfo = prevLocationInfo;\n            }\n            symbol.bound = true;\n        }\n\n        public bind(scope: SymbolScope, table: IHashTable) {\n            table.map(\n                (key, sym, binder) => {\n                    binder.bindSymbol(scope, sym);\n                },\n                this);\n        }\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class DeclFileWriter {\n        public onNewLine = true;\n        constructor(private declFile: ITextWriter) {\n        }\n\n        public Write(s: string) {\n            this.declFile.Write(s);\n            this.onNewLine = false;\n        }\n\n        public WriteLine(s: string) {\n            this.declFile.WriteLine(s);\n            this.onNewLine = true;\n        }\n\n        public Close() {\n            this.declFile.Close();\n        }\n    }\n\n    export class DeclarationEmitter implements AstWalkerWithDetailCallback.AstWalkerDetailCallback {\n        private declFile: DeclFileWriter = null;\n        private indenter = new Indenter();\n        private declarationContainerStack: AST[] = [];\n        private isDottedModuleName: bool[] = [];\n        private dottedModuleEmit: string;\n        private ignoreCallbackAst: AST = null;\n        private singleDeclFile: DeclFileWriter = null;\n        private varListCount: number = 0;\n\n        private getAstDeclarationContainer() {\n            return this.declarationContainerStack[this.declarationContainerStack.length - 1];\n        }\n\n        private emitDottedModuleName() {\n            return (this.isDottedModuleName.length == 0) ? false : this.isDottedModuleName[this.isDottedModuleName.length - 1];\n        }\n\n        constructor (public checker: TypeChecker, public emitOptions: EmitOptions, public errorReporter: ErrorReporter) {\n        }\n\n        public setDeclarationFile(file: ITextWriter) {\n            this.declFile = new DeclFileWriter(file);\n        }\n\n        public Close() {\n            try {\n                // Closing files could result in exceptions, report them if they occur\n                this.declFile.Close();\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n\n        public emitDeclarations(script: TypeScript.Script): void {\n            AstWalkerWithDetailCallback.walk(script, this);\n        }\n\n        private getIndentString(declIndent? = false) {\n            if (this.emitOptions.minWhitespace) {\n                return "";\n            }\n            else {\n                return this.indenter.getIndent();\n            }\n        }\n\n        private emitIndent() {\n            this.declFile.Write(this.getIndentString());\n        }\n\n        private canEmitSignature(declFlags: DeclFlags, canEmitGlobalAmbientDecl?: bool = true, useDeclarationContainerTop?: bool = true) {\n            var container: AST;\n            if (useDeclarationContainerTop) {\n                container = this.getAstDeclarationContainer();\n            } else {\n                container = this.declarationContainerStack[this.declarationContainerStack.length - 2];\n            }\n';
var v27660 = v27661 + '\n            if (container.nodeType == NodeType.ModuleDeclaration && !hasFlag(declFlags, DeclFlags.Exported)) {\n                return false;\n            }\n\n            if (!canEmitGlobalAmbientDecl && container.nodeType == NodeType.Script && hasFlag(declFlags, DeclFlags.Ambient)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        private canEmitPrePostAstSignature(declFlags: DeclFlags, astWithPrePostCallback: AST, preCallback: bool) {\n            if (this.ignoreCallbackAst) {\n                CompilerDiagnostics.assert(this.ignoreCallbackAst != astWithPrePostCallback, "Ignore Callback AST mismatch");\n                this.ignoreCallbackAst = null;\n                return false;\n            } else if (preCallback &&\n                !this.canEmitSignature(declFlags, true, preCallback)) {\n                this.ignoreCallbackAst = astWithPrePostCallback;\n                return false;\n            }\n\n            return true;\n        }\n\n        private getDeclFlagsString(declFlags: DeclFlags, typeString: string) {\n            var result = this.getIndentString();\n\n            // Accessor strings\n            var accessorString = "";\n            if (hasFlag(declFlags, DeclFlags.GetAccessor)) {\n                accessorString = "get ";\n            }\n            else if (hasFlag(declFlags, DeclFlags.SetAccessor)) {\n                accessorString = "set ";\n            }\n\n            // Emit export only for global export statements. The container for this would be dynamic module which is whole file\n            var container = this.getAstDeclarationContainer();\n            if (container.nodeType == NodeType.ModuleDeclaration &&\n                hasFlag((<ModuleDeclaration>container).modFlags, ModuleFlags.IsWholeFile) &&\n                hasFlag(declFlags, DeclFlags.Exported)) {\n                result += "export ";\n            }\n\n            // Static/public/private/global declare\n            if (hasFlag(declFlags, DeclFlags.LocalStatic) || hasFlag(declFlags, DeclFlags.Static)) {\n                result += "static " + accessorString;\n            }\n            else {\n                if (hasFlag(declFlags, DeclFlags.Private)) {\n                    result += "private " + accessorString;\n                }\n                else if (hasFlag(declFlags, DeclFlags.Public)) {\n                    result += "public " + accessorString;\n                }\n                else {\n                    if (accessorString == "") {\n                        result += typeString + " ";\n                    } else {\n                        result += accessorString;\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        private emitDeclFlags(declFlags: DeclFlags, typeString: string) {\n            this.declFile.Write(this.getDeclFlagsString(declFlags, typeString));\n        }\n\n        private canEmitTypeAnnotationSignature(declFlag: DeclFlags = DeclFlags.None) {\n            // Private declaration, shouldnt emit type any time.\n            return !hasFlag(declFlag, DeclFlags.Private);\n        }\n\n        private pushDeclarationContainer(ast: AST) {\n            this.declarationContainerStack.push(ast);\n        }\n\n        private popDeclarationContainer(ast: AST) {\n            CompilerDiagnostics.assert(ast != this.getAstDeclarationContainer(), \'Declaration container mismatch\');\n            this.declarationContainerStack.pop();\n        }\n\n        private emitTypeNamesMember(memberName: MemberName, emitIndent? : bool = false) {\n            if (memberName.prefix == "{ ") {\n                if (emitIndent) {\n                    this.emitIndent();\n                }\n                this.declFile.WriteLine("{");\n                this.indenter.increaseIndent();\n                emitIndent = true;\n            } else if (memberName.prefix != "") {\n                if (emitIndent) {\n                    this.emitIndent();\n                }\n                this.declFile.Write(memberName.prefix);\n                emitIndent = false;\n            }\n\n            if (memberName.isString()) {\n                if (emitIndent) {\n                    this.emitIndent();\n                }\n                this.declFile.Write((<MemberNameString>memberName).text);\n            } else {\n                var ar = <MemberNameArray>memberName;\n                for (var index = 0; index < ar.entries.length; index++) {\n                    this.emitTypeNamesMember(ar.entries[index], emitIndent);\n                    if (ar.delim == "; ") {\n                        this.declFile.WriteLine(";");\n                    }\n                }\n            }\n\n            if (memberName.suffix == "}") {\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.declFile.Write(memberName.suffix);\n            } else {\n                this.declFile.Write(memberName.suffix);\n            }\n        }\n\n        private emitTypeSignature(type: Type) {\n            var containingScope: SymbolScope = null';
var v27659 = v27660 + ';\n            var declarationContainerAst = this.getAstDeclarationContainer();\n            switch (declarationContainerAst.nodeType) {\n                case NodeType.ModuleDeclaration:\n                case NodeType.InterfaceDeclaration:\n                case NodeType.FuncDecl:\n                    if (declarationContainerAst.type) {\n                        containingScope = declarationContainerAst.type.containedScope;\n                    }\n                    break;\n\n                case NodeType.Script:\n                    var script = <Script>declarationContainerAst;\n                    if (script.bod) {\n                        containingScope = script.bod.enclosingScope;\n                    }\n                    break;\n\n                case NodeType.ClassDeclaration:\n                    if (declarationContainerAst.type) {\n                        containingScope = declarationContainerAst.type.instanceType.containedScope;\n                    }\n                    break;\n\n                default:\n                    CompilerDiagnostics.debugPrint("Unknown containing scope");\n            }\n\n            var typeNameMembers = type.getScopedTypeNameEx(containingScope);\n            this.emitTypeNamesMember(typeNameMembers);\n        }\n\n        private emitComment(comment: Comment) {\n            var text = comment.getText();\n            if (this.declFile.onNewLine) {\n                this.emitIndent();\n            } else if (!comment.isBlockComment) {\n                this.declFile.WriteLine("");\n                this.emitIndent();\n            }\n            \n            this.declFile.Write(text[0]);\n\n            for (var i = 1; i < text.length; i++) {\n                this.declFile.WriteLine("");\n                this.emitIndent();\n                this.declFile.Write(text[i]);\n            }\n\n            if (comment.endsLine || !comment.isBlockComment) {\n                this.declFile.WriteLine("");\n            } else {\n                this.declFile.Write(" ");\n            }\n        }\n\n        private emitDeclarationComments(ast: AST, endLine?: bool);\n        private emitDeclarationComments(symbol: Symbol, endLine?: bool);\n        private emitDeclarationComments(astOrSymbol, endLine = true) {\n            if (!this.emitOptions.emitComments) {\n                return;\n            }\n\n            var declComments = <Comment[]>astOrSymbol.getDocComments();\n            if (declComments.length > 0) {\n                for (var i = 0; i < declComments.length; i++) {\n                    this.emitComment(declComments[i]);\n                }\n\n                if (endLine) {\n                    if (!this.declFile.onNewLine) {\n                        this.declFile.WriteLine("");\n                    }\n                } else {\n                    if (this.declFile.onNewLine) {\n                        this.emitIndent();\n                    }\n                }\n            }\n        }\n\n        public VarDeclCallback(pre: bool, varDecl: VarDecl): bool {\n            if (pre && this.canEmitSignature(ToDeclFlags(varDecl.varFlags), false)) {\n                var interfaceMember = (this.getAstDeclarationContainer().nodeType == NodeType.InterfaceDeclaration);\n                this.emitDeclarationComments(varDecl);\n                if (!interfaceMember) {\n                    // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var\n                    // If it is var list of form  var a = varList count will be 0\n                    if (this.varListCount >= 0) {\n                        this.emitDeclFlags(ToDeclFlags(varDecl.varFlags), "var");\n                        this.varListCount = -this.varListCount;\n                    }\n                    this.declFile.Write(varDecl.id.text);\n                } else {\n                    this.emitIndent();\n                    this.declFile.Write(varDecl.id.text);\n                    if (hasFlag(varDecl.id.flags, ASTFlags.OptionalName)) {\n                        this.declFile.Write("?");\n                    }\n                }\n\n                var type: Type = null;\n                if (varDecl.typeExpr && varDecl.typeExpr.type) {\n                    type = varDecl.typeExpr.type;\n                }\n                else if (varDecl.sym) {\n                    type = (<FieldSymbol>varDecl.sym).getType();\n                    // Dont emit inferred any\n                    if (type == this.checker.anyType) {\n                        type = null;\n                    }\n                }\n\n                if (type && this.canEmitTypeAnnotationSignature(ToDeclFlags(varDecl.varFlags))) {\n                    this.declFile.Write(": ");\n                    this.emitTypeSignature(type);\n                }\n               \n                // emitted one var decl\n                if (this.varListCount > 0) { this.varListCount--; } else if (this.varListCount < 0) { this.varListCount++; }\n\n                // Write ; or ,\n                if (this.varListCount < 0) {\n                    this.declF';
var v27658 = v27659 + 'ile.Write(", ");\n                } else {\n                    this.declFile.WriteLine(";");\n                }\n            }\n            return false;\n        }\n\n        public BlockCallback(pre: bool, block: Block): bool {\n            if (!block.isStatementBlock) {\n                if (pre) {\n                    this.varListCount = block.statements.members.length;\n                } else {\n                    this.varListCount = 0;\n                }\n                return true;\n            }\n            return false;\n        }\n\n        private emitArgDecl(argDecl: ArgDecl, funcDecl: FuncDecl) {\n            this.emitDeclarationComments(argDecl, false);\n            this.declFile.Write(argDecl.id.text);\n            if (argDecl.isOptionalArg()) {\n                this.declFile.Write("?");\n            }\n            if ((argDecl.typeExpr || argDecl.type != this.checker.anyType) &&\n                this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {\n                this.declFile.Write(": ");\n                this.emitTypeSignature(argDecl.type);\n            }\n        }\n\n        public FuncDeclCallback(pre: bool, funcDecl: FuncDecl): bool {\n            if (!pre) {\n                return false;\n            }\n\n            if (funcDecl.isAccessor()) {\n                return this.emitPropertyAccessorSignature(funcDecl);\n            }\n\n            var isInterfaceMember = (this.getAstDeclarationContainer().nodeType == NodeType.InterfaceDeclaration);\n            if (funcDecl.bod) {\n                if (funcDecl.isConstructor) {\n                    if (funcDecl.type.construct && funcDecl.type.construct.signatures.length > 1) {\n                        return false;\n                    }\n                } else {\n                    if (funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {\n                        // This means its implementation of overload signature. do not emit\n                        return false;\n                    }\n                }\n            } else if (!isInterfaceMember && hasFlag(funcDecl.fncFlags, FncFlags.Private) && funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {\n                // Print only first overload of private function\n                var signatures = funcDecl.type.call.signatures;\n                var firstSignature = signatures[0].declAST;\n                if (firstSignature.bod) {\n                    // Its a implementation, use next one\n                    firstSignature = signatures[1].declAST;\n                }\n\n                if (firstSignature != funcDecl) {\n                    return false;\n                }\n            }\n\n            if (!this.canEmitSignature(ToDeclFlags(funcDecl.fncFlags), false)) {\n                return false;\n            }\n\n            this.emitDeclarationComments(funcDecl);\n            if (funcDecl.isConstructor) {\n                this.emitIndent();\n                this.declFile.Write("constructor");\n            }\n            else {\n                var id = funcDecl.getNameText();\n                if (!isInterfaceMember) {\n                    this.emitDeclFlags(ToDeclFlags(funcDecl.fncFlags), "function");\n                    this.declFile.Write(id);\n                } else {\n                    this.emitIndent();\n                    if (funcDecl.isConstructMember()) {\n                        this.declFile.Write("new");\n                    } else if (!funcDecl.isCallMember() && !funcDecl.isIndexerMember()) {\n                        this.declFile.Write(id);\n                        if (hasFlag(funcDecl.name.flags, ASTFlags.OptionalName)) {\n                            this.declFile.Write("? ");\n                        }\n                    }\n                }\n            }\n\n            if (!funcDecl.isIndexerMember()) {\n                this.declFile.Write("(");\n            } else {\n                this.declFile.Write("[");\n            }\n\n            this.indenter.increaseIndent();\n\n            if (funcDecl.arguments) {\n                var argsLen = funcDecl.arguments.members.length;\n                if (funcDecl.variableArgList) {\n                    argsLen--;\n                }\n                for (var i = 0; i < argsLen; i++) {\n                    var argDecl = <ArgDecl>funcDecl.arguments.members[i];\n                    this.emitArgDecl(argDecl, funcDecl);\n                    if (i < (argsLen - 1)) {\n                        this.declFile.Write(", ");\n                    }\n                }\n            }\n\n            if (funcDecl.variableArgList) {\n                var lastArg = <ArgDecl>funcDecl.arguments.members[funcDecl.arguments.members.length - 1];\n                if (funcDecl.arguments.members.length > 1) {\n                    this.declFile.Write(", ...");\n                }\n                else {\n                    this.declFile.Write("...");\n                }\n                this.emitArgDecl(lastArg, funcDecl);\n            }\n\n            this.indenter.decreaseIndent();\n\n            if (!funcDecl.isIndexerMember(';
var v27657 = v27658 + ')) {\n                this.declFile.Write(")");\n            } else {\n                this.declFile.Write("]");\n            }\n\n            if (!funcDecl.isConstructor &&\n                (funcDecl.returnTypeAnnotation || funcDecl.signature.returnType.type != this.checker.anyType) &&\n                this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {\n                this.declFile.Write(": ");\n                this.emitTypeSignature(funcDecl.signature.returnType.type);\n            }\n\n            this.declFile.WriteLine(";");\n\n            return false;\n        }\n\n        private emitBaseList(bases: ASTList, qual: string) {\n            if (bases && (bases.members.length > 0)) {\n                this.declFile.Write(" " + qual + " ");\n                var basesLen = bases.members.length;\n                for (var i = 0; i < basesLen; i++) {\n                    var baseExpr = bases.members[i];\n                    var baseSymbol = baseExpr.type.symbol;\n                    var baseType = baseExpr.type;\n                    if (i > 0) {\n                        this.declFile.Write(", ");\n                    }\n                    this.emitTypeSignature(baseType);\n                }\n            }\n        }\n\n        private emitPropertyAccessorSignature(funcDecl: FuncDecl) {\n            var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;\n            if (accessorSymbol.getter && accessorSymbol.getter.declAST != funcDecl) {\n                // Setter is being used to emit the type info. \n                return false;\n            }\n\n            this.emitDeclarationComments(accessorSymbol);\n            this.emitDeclFlags(ToDeclFlags(accessorSymbol.flags), "var");\n            this.declFile.Write(funcDecl.name.text);\n            var propertyType = accessorSymbol.getType();\n            if (this.canEmitTypeAnnotationSignature(ToDeclFlags(accessorSymbol.flags))) {\n                this.declFile.Write(" : ");\n                this.emitTypeSignature(propertyType);\n            }\n            this.declFile.WriteLine(";");\n\n            return false;\n        }\n\n        private emitClassMembersFromConstructorDefinition(funcDecl: FuncDecl) {\n            if (funcDecl.arguments) {\n                var argsLen = funcDecl.arguments.members.length; if (funcDecl.variableArgList) { argsLen--; }\n\n                for (var i = 0; i < argsLen; i++) {\n                    var argDecl = <ArgDecl>funcDecl.arguments.members[i];\n                    if (hasFlag(argDecl.varFlags, VarFlags.Property)) {\n                        this.emitDeclarationComments(argDecl);\n                        this.emitDeclFlags(ToDeclFlags(argDecl.varFlags), "var");\n                        this.declFile.Write(argDecl.id.text);\n\n                        if (argDecl.typeExpr && this.canEmitTypeAnnotationSignature(ToDeclFlags(argDecl.varFlags))) {\n                            this.declFile.Write(": ");\n                            this.emitTypeSignature(argDecl.type);\n                        }\n                        this.declFile.WriteLine(";");\n                    }\n                }\n            }\n        }\n\n        public ClassDeclarationCallback(pre: bool, classDecl: ClassDeclaration): bool {\n            if (!this.canEmitPrePostAstSignature(ToDeclFlags(classDecl.varFlags), classDecl, pre)) {\n                return false;\n            }\n\n            if (pre) {\n                var className = classDecl.name.text;\n                this.emitDeclarationComments(classDecl);\n                this.emitDeclFlags(ToDeclFlags(classDecl.varFlags), "class");\n                this.declFile.Write(className);\n                this.emitBaseList(classDecl.extendsList, "extends");\n                this.emitBaseList(classDecl.implementsList, "implements");\n                this.declFile.WriteLine(" {");\n\n                this.pushDeclarationContainer(classDecl);\n                this.indenter.increaseIndent();\n                if (classDecl.constructorDecl) {\n                    this.emitClassMembersFromConstructorDefinition(classDecl.constructorDecl);\n                }\n            } else {\n                this.indenter.decreaseIndent();\n                this.popDeclarationContainer(classDecl);\n\n                this.emitIndent();\n                this.declFile.WriteLine("}");\n            }\n\n            return true;\n        }\n\n        public InterfaceDeclarationCallback(pre: bool, interfaceDecl: InterfaceDeclaration): bool {\n            if (!this.canEmitPrePostAstSignature(ToDeclFlags(interfaceDecl.varFlags), interfaceDecl, pre)) {\n                return false;\n            }\n\n            if (pre) {\n                var interfaceName = interfaceDecl.name.text;\n                this.emitDeclarationComments(interfaceDecl);\n                this.emitDeclFlags(ToDeclFlags(interfaceDecl.varFlags), "interface");\n                this.declFile.Write(interfaceName);\n                this.emitBaseList(interfaceDecl.extendsList, "extends");\n                this.declFile.WriteLine(" {");\n\n                this.indenter';
var v27656 = v27657 + '.increaseIndent();\n                this.pushDeclarationContainer(interfaceDecl);\n            } else {\n                this.indenter.decreaseIndent();\n                this.popDeclarationContainer(interfaceDecl);\n\n                this.emitIndent();\n                this.declFile.WriteLine("}");\n            }\n\n            return true;\n        }\n\n        public ImportDeclarationCallback(pre: bool, importDecl: ImportDeclaration): bool {\n            if (pre) {\n                if ((<Script>this.declarationContainerStack[0]).isExternallyVisibleSymbol(importDecl.id.sym)) {\n                    this.emitDeclarationComments(importDecl);\n                    this.emitIndent();\n                    this.declFile.Write("import ");\n\n                    this.declFile.Write(importDecl.id.text + " = ");\n                    if (importDecl.isDynamicImport) {\n                        this.declFile.WriteLine("module (" + importDecl.getAliasName() + ");");\n                    } else {\n                        this.declFile.WriteLine(importDecl.getAliasName() + ";");\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        private emitEnumSignature(moduleDecl: ModuleDeclaration) {\n            if (!this.canEmitSignature(ToDeclFlags(moduleDecl.modFlags))) {\n                return false;\n            }\n\n            this.emitDeclarationComments(moduleDecl);\n            this.emitDeclFlags(ToDeclFlags(moduleDecl.modFlags), "enum");\n            this.declFile.WriteLine(moduleDecl.name.text + " {");\n\n            this.indenter.increaseIndent();\n            var membersLen = moduleDecl.members.members.length;\n            for (var j = 1; j < membersLen; j++) {\n                var memberDecl: AST = moduleDecl.members.members[j];\n                if (memberDecl.nodeType == NodeType.VarDecl) {\n                    this.emitDeclarationComments(memberDecl);\n                    this.emitIndent();\n                    this.declFile.WriteLine((<VarDecl>memberDecl).id.text + ",");\n                } else {\n                    CompilerDiagnostics.assert(memberDecl.nodeType != NodeType.Asg, "We want to catch this");\n                }\n            }\n            this.indenter.decreaseIndent();\n\n            this.emitIndent();\n            this.declFile.WriteLine("}");\n\n            return false;\n        }\n\n        public ModuleDeclarationCallback(pre: bool, moduleDecl: ModuleDeclaration): bool {\n            if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile)) {\n                // This is dynamic modules and we are going to outputing single file, \n                // we need to change the declFile because dynamic modules are always emitted to their corresponding .d.ts\n                if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic)) {\n                    if (pre) {\n                        if (!this.emitOptions.outputMany) {\n                            this.singleDeclFile = this.declFile;\n                            CompilerDiagnostics.assert(this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file");\n                            // Create new file\n                            var declareFileName = this.emitOptions.mapOutputFileName(stripQuotes(moduleDecl.name.sym.name), TypeScriptCompiler.mapToDTSFileName);\n                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);\n                            try {\n                                // Creating files can cause exceptions, report them.   \n                                this.declFile = new DeclFileWriter(this.emitOptions.ioHost.createFile(declareFileName, useUTF8InOutputfile));\n                            } catch (ex) {\n                                this.errorReporter.emitterError(null, ex.message);\n                            }\n                        }\n                        this.pushDeclarationContainer(moduleDecl);\n                    } else {\n                        if (!this.emitOptions.outputMany) {\n                            CompilerDiagnostics.assert(this.singleDeclFile != this.declFile, "singleDeclFile cannot be null as we are going to revert back to it");\n                            CompilerDiagnostics.assert(this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file");\n                            try {\n                                // Closing files could result in exceptions, report them if they occur\n                                this.declFile.Close();\n                            } catch (ex) {\n                                this.errorReporter.emitterError(null, ex.message);\n                            }\n                            this.declFile = this.singleDeclFile;\n                        }\n                        this.popDeclarationContainer(moduleDecl);\n                    }\n                }\n\n                return true;\n            }\n\n            if (moduleDecl.isEnum()) {\n                if (pre) {\n           ';
var v27655 = v27656 + '         this.emitEnumSignature(moduleDecl);\n                }\n                return false;\n            }\n\n            if (!this.canEmitPrePostAstSignature(ToDeclFlags(moduleDecl.modFlags), moduleDecl, pre)) {\n                return false;\n            }\n\n            if (pre) {\n                if (this.emitDottedModuleName()) {\n                    this.dottedModuleEmit += ".";\n                } else {\n                    this.dottedModuleEmit = this.getDeclFlagsString(ToDeclFlags(moduleDecl.modFlags), "module");\n                }\n                this.dottedModuleEmit += moduleDecl.name.text;\n\n                var isCurrentModuleDotted = (moduleDecl.members.members.length == 1 &&\n                    moduleDecl.members.members[0].nodeType == NodeType.ModuleDeclaration &&\n                    !(<ModuleDeclaration>moduleDecl.members.members[0]).isEnum() &&\n                    hasFlag((<ModuleDeclaration>moduleDecl.members.members[0]).modFlags, ModuleFlags.Exported));\n\n                // Module is dotted only if it does not have doc comments for it\n                var moduleDeclComments = moduleDecl.getDocComments();\n                isCurrentModuleDotted = isCurrentModuleDotted && (moduleDeclComments == null || moduleDeclComments.length == 0);\n\n                this.isDottedModuleName.push(isCurrentModuleDotted);\n                this.pushDeclarationContainer(moduleDecl);\n\n                if (!isCurrentModuleDotted) {\n                    this.emitDeclarationComments(moduleDecl);\n                    this.declFile.Write(this.dottedModuleEmit);\n                    this.declFile.WriteLine(" {");\n                    this.indenter.increaseIndent();\n                }\n            } else {\n                if (!this.emitDottedModuleName()) {\n                    this.indenter.decreaseIndent();\n                    this.emitIndent();\n                    this.declFile.WriteLine("}");\n                }\n                this.popDeclarationContainer(moduleDecl);\n                this.isDottedModuleName.pop();\n            }\n\n            return true;\n        }\n\n        public ScriptCallback(pre: bool, script: Script): bool {\n            if (pre) {\n                if (this.emitOptions.outputMany) {\n                    for (var i = 0; i < script.referencedFiles.length; i++) {\n                        var referencePath = script.referencedFiles[i].path;\n                        var declareFileName: string;\n                        if (isRooted(referencePath)) {\n                            declareFileName = this.emitOptions.mapOutputFileName(referencePath, TypeScriptCompiler.mapToDTSFileName)\n                        } else {\n                            declareFileName = getDeclareFilePath(script.referencedFiles[i].path);\n                        }\n                        this.declFile.WriteLine(\'/// <reference path="\' + declareFileName + \'" />\');\n                    }\n                }\n                this.pushDeclarationContainer(script);\n            }\n            else {\n                this.popDeclarationContainer(script);\n            }\n            return true;\n        }\n\n        public DefaultCallback(pre: bool, ast: AST): bool {\n            return !hasFlag(ast.flags, ASTFlags.IsStatement);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export module CompilerDiagnostics {\n        export var debug = false;\n        export interface IDiagnosticWriter {\n            Alert(output: string): void;\n        }\n\n        export var diagnosticWriter: IDiagnosticWriter = null;\n\n        export var analysisPass: number = 0;\n\n        export function Alert(output: string) {\n            if (diagnosticWriter) {\n                diagnosticWriter.Alert(output);\n            }\n        }\n\n        export function debugPrint(s: string) {\n            if (debug) {\n                Alert(s);\n            }\n        }\n\n        export function assert(condition: bool, s: string) {\n            if (debug) {\n                if (!condition) {\n                    Alert(s);\n                }\n            }\n        }\n\n    }\n\n    export interface ILogger {\n        information(): bool;\n        debug(): bool;\n        warning(): bool;\n        error(): bool;\n        fatal(): bool;\n        log(s: string): void;\n    }\n\n    export class NullLogger implements ILogger {\n        public information(): bool { return false; }\n        public debug(): bool { r';
var v27654 = v27655 + 'eturn false; }\n        public warning(): bool { return false; }\n        public error(): bool { return false; }\n        public fatal(): bool { return false; }\n        public log(s: string): void {\n        }\n    }\n\n    export class LoggerAdapter implements ILogger {\n        private _information: bool;\n        private _debug: bool;\n        private _warning: bool;\n        private _error: bool;\n        private _fatal: bool;\n\n        constructor (public logger: ILogger) { \n            this._information = this.logger.information();\n            this._debug = this.logger.debug();\n            this._warning = this.logger.warning();\n            this._error = this.logger.error();\n            this._fatal = this.logger.fatal();\n        }\n\n\n        public information(): bool { return this._information; }\n        public debug(): bool { return this._debug; }\n        public warning(): bool { return this._warning; }\n        public error(): bool { return this._error; }\n        public fatal(): bool { return this._fatal; }\n        public log(s: string): void {\n            this.logger.log(s);\n        }\n    }\n\n    export class BufferedLogger implements ILogger {\n        public logContents = [];\n\n        public information(): bool { return false; }\n        public debug(): bool { return false; }\n        public warning(): bool { return false; }\n        public error(): bool { return false; }\n        public fatal(): bool { return false; }\n        public log(s: string): void {\n            this.logContents.push(s);\n        }\n    }\n\n    export function timeFunction(logger: ILogger, funcDescription: string, func: () =>any): any {\n        var start = +new Date();\n        var result = func();\n        var end = +new Date();\n        logger.log(funcDescription + " completed in " + (end - start) + " msec");\n        return result;\n    }\n\n    export function stringToLiteral(value: string, length: number): string {\n        var result = "";\n\n        var addChar = (index: number) => {\n            var ch = value.charCodeAt(index);\n            switch (ch) {\n                case 0x09: // tab\n                    result += "\\\\t";\n                    break;\n                case 0x0a: // line feed\n                    result += "\\\\n";\n                    break;\n                case 0x0b: // vertical tab\n                    result += "\\\\v";\n                    break;\n                case 0x0c: // form feed\n                    result += "\\\\f";\n                    break;\n                case 0x0d: // carriage return\n                    result += "\\\\r";\n                    break;\n                case 0x22:  // double quote\n                    result += "\\\\\\"";\n                    break;\n                case 0x27: // single quote\n                    result += "\\\\\\\'";\n                    break;\n                case 0x5c: // Backslash\n                    result += "\\\\";\n                    break;\n                default:\n                    result += value.charAt(index);\n            }\n        }\n\n        var tooLong = (value.length > length);\n        if (tooLong) {\n            var mid = length >> 1;\n            for (var i = 0; i < mid; i++) addChar(i);\n            result += "(...)";\n            for (var i = value.length - mid; i < value.length; i++) addChar(i);\n        }\n        else {\n            length = value.length;\n            for (var i = 0; i < length; i++) addChar(i);\n        }\n        return result;\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum EmitContainer {\n        Prog,\n        Module,\n        DynamicModule,\n        Class,\n        Constructor,\n        Function,\n        Args,\n        Interface,\n    }\n\n    export class EmitState {\n        public column: number;\n        public line: number;\n        public pretty: bool;\n        public inObjectLiteral: bool;\n        public container: EmitContainer;\n\n        constructor () {\n            this.column = 0;\n            this.line = 0;\n            this.pretty = false;\n            this.inObjectLiteral = false;\n            this.container = EmitContainer.Prog;\n        }\n    }\n\n    export class EmitOptions {\n        public minWhitespace: bool;\n        public propagateConstants: bool;\n        public emitComments: bool;\n        public outputOption: string;\n        public ioHost: EmitterIOHost = null;\n        public outputMany: bool = true;\n        public commonDirectoryPath';
var v27653 = v27654 + ' = "";\n\n        constructor(settings: CompilationSettings) {\n            this.minWhitespace = settings.minWhitespace;\n            this.propagateConstants = settings.propagateConstants;\n            this.emitComments = settings.emitComments;\n            this.outputOption = settings.outputOption;\n        }\n\n        public mapOutputFileName(fileName: string, extensionChanger: (fname: string, wholeFileNameReplaced: bool) => string) {\n            if (this.outputMany) {\n                var updatedFileName = fileName;\n                if (this.outputOption != "") {\n                    // Replace the common directory path with the option specified\n                    updatedFileName = fileName.replace(this.commonDirectoryPath, "");\n                    updatedFileName = this.outputOption + updatedFileName;\n                }\n                return extensionChanger(updatedFileName, false);\n            } else {\n                return extensionChanger(this.outputOption, true);\n            }\n        }\n    }\n\n    export class Indenter {\n        static indentStep : number = 4;\n        static indentStepString : string = "    ";\n        static indentStrings: string[] = [];\n        public indentAmt: number = 0;\n\n        public increaseIndent() {\n            this.indentAmt += Indenter.indentStep;\n        }\n\n        public decreaseIndent() {\n            this.indentAmt -= Indenter.indentStep;\n        }\n\n        public getIndent() {\n            var indentString = Indenter.indentStrings[this.indentAmt];\n            if (indentString === undefined) {\n                indentString = "";\n                for (var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {\n                    indentString += Indenter.indentStepString;\n                }\n                Indenter.indentStrings[this.indentAmt] = indentString;\n            }\n            return indentString;\n        }\n    }\n\n    export class Emitter {\n        public prologueEmitted = false;\n        public thisClassNode: TypeDeclaration = null;\n        public thisFnc: FuncDecl = null;\n        public moduleDeclList: ModuleDeclaration[] = [];\n        public moduleName = "";\n        public emitState = new EmitState();\n        public indenter = new Indenter();\n        public ambientModule = false;\n        public modAliasId: string = null;\n        public firstModAlias: string = null;\n        public allSourceMappers: SourceMapper[] = [];\n        public sourceMapper: SourceMapper = null;\n        public captureThisStmtString = "var _this = this;";\n        private varListCountStack: number[] = [0]; \n\n        constructor(public checker: TypeChecker, public emittingFileName: string, public outfile: ITextWriter, public emitOptions: EmitOptions, public errorReporter: ErrorReporter) {\n        }\n\n        public setSourceMappings(mapper: SourceMapper) {\n            this.allSourceMappers.push(mapper);\n            this.sourceMapper = mapper;\n        }\n\n        public writeToOutput(s: string) {\n            this.outfile.Write(s);\n            // TODO: check s for newline\n            this.emitState.column += s.length;\n        }\n\n        public writeToOutputTrimmable(s: string) {\n            if (this.emitOptions.minWhitespace) {\n                s = s.replace(/[\\s]*/g, \'\');\n            }\n            this.writeToOutput(s);\n        }\n\n        public writeLineToOutput(s: string) {\n            if (this.emitOptions.minWhitespace) {\n                this.writeToOutput(s);\n                var c = s.charCodeAt(s.length - 1);\n                if (!((c == LexCodeSpace) || (c == LexCodeSMC) || (c == LexCodeLBR))) {\n                    this.writeToOutput(\' \');\n                }\n            }\n            else {\n                this.outfile.WriteLine(s);\n                this.emitState.column = 0\n                this.emitState.line++;\n            }\n        }\n\n        public writeCaptureThisStatement(ast: AST) {\n            this.emitIndent();\n            this.recordSourceMappingStart(ast);\n            this.writeToOutput(this.captureThisStmtString);\n            this.recordSourceMappingEnd(ast);\n            this.writeLineToOutput("");\n        }\n\n        public setInVarBlock(count: number) {\n            this.varListCountStack[this.varListCountStack.length - 1] = count;\n        }\n\n        public setInObjectLiteral(val: bool): bool {\n            var temp = this.emitState.inObjectLiteral;\n            this.emitState.inObjectLiteral = val;\n            return temp;\n        }\n\n        public setContainer(c: number): number {\n            var temp = this.emitState.container;\n            this.emitState.container = c;\n            return temp;\n        }\n\n        private getIndentString() {\n            if (this.emitOptions.minWhitespace) {\n                return "";\n            }\n            else {\n                return this.indenter.getIndent();\n            }\n        }\n\n        public emitIndent() {\n            this.writeToOutput(this.getIndentString());\n        }\n\n        public emitCommentInPlace(comment: Comment) {\n            var tex';
var v27652 = v27653 + 't = comment.getText();\n            var hadNewLine = false;\n\n            if (comment.isBlockComment) {\n                if (this.emitState.column == 0) {\n                    this.emitIndent();\n                }\n                this.recordSourceMappingStart(comment);\n                this.writeToOutput(text[0]);\n\n                if (text.length > 1 || comment.endsLine) {\n                    for (var i = 1; i < text.length; i++) {\n                        this.writeLineToOutput("");\n                        this.emitIndent();\n                        this.writeToOutput(text[i]);\n                    }\n                    this.recordSourceMappingEnd(comment);\n                    this.writeLineToOutput("");\n                    hadNewLine = true;\n                } else {\n                    this.recordSourceMappingEnd(comment);\n                }\n            }\n            else {\n                if (this.emitState.column == 0) {\n                    this.emitIndent();\n                }\n                this.recordSourceMappingStart(comment);\n                this.writeToOutput(text[0]);\n                this.recordSourceMappingEnd(comment);\n                this.writeLineToOutput("");\n                hadNewLine = true;\n            }\n\n            if (hadNewLine) {\n                this.emitIndent();\n            }\n            else {\n                this.writeToOutput(" ");\n            }\n        }\n\n        public emitParensAndCommentsInPlace(ast: AST, pre: bool) {\n            var comments = pre ? ast.preComments : ast.postComments;\n\n            // comments should be printed before the LParen, but after the RParen\n            if (ast.isParenthesized && !pre) {\n                this.writeToOutput(")");\n            }\n            if (this.emitOptions.emitComments && comments && comments.length != 0) {\n                for (var i = 0; i < comments.length; i++) {\n                    this.emitCommentInPlace(comments[i]);\n                }\n            }\n            if (ast.isParenthesized && pre) {\n                this.writeToOutput("(");\n            }\n        }\n\n        // TODO: emit accessor pattern\n        public emitObjectLiteral(content: ASTList) {\n            this.writeLineToOutput("{");\n            this.indenter.increaseIndent();\n            var inObjectLiteral = this.setInObjectLiteral(true);\n            this.emitJavascriptList(content, ",", TokenID.Comma, true, false, false);\n            this.setInObjectLiteral(inObjectLiteral);\n            this.indenter.decreaseIndent();\n            this.emitIndent();\n            this.writeToOutput("}");\n        }\n\n        public emitArrayLiteral(content: ASTList) {\n            this.writeToOutput("[");\n            if (content) {\n                this.writeLineToOutput("");\n                this.indenter.increaseIndent();\n                this.emitJavascriptList(content, ", ", TokenID.Comma, true, false, false);\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n            }\n            this.writeToOutput("]");\n        }\n\n        public emitNew(target: AST, args: ASTList) {\n            this.writeToOutput("new ");\n            if (target.nodeType == NodeType.TypeRef) {\n                var typeRef = <TypeReference>target;\n                if (typeRef.arrayCount) {\n                    this.writeToOutput("Array()");\n                }\n                else {\n                    this.emitJavascript(typeRef.term, TokenID.Tilde, false);\n                    this.writeToOutput("()");\n                }\n            }\n            else {\n                this.emitJavascript(target, TokenID.Tilde, false);\n                this.recordSourceMappingStart(args);\n                this.writeToOutput("(");\n                this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);\n                this.writeToOutput(")");\n                this.recordSourceMappingEnd(args);\n            }\n        }\n\n        public tryEmitConstant(dotExpr: BinaryExpression) {\n            if (!this.emitOptions.propagateConstants) {\n                return false;\n            }\n            var propertyName = <Identifier>dotExpr.operand2;\n            if (propertyName && propertyName.sym && propertyName.sym.isVariable()) {\n                if (hasFlag(propertyName.sym.flags, SymbolFlags.Constant)) {\n                    if (propertyName.sym.declAST) {\n                        var boundDecl = <BoundDecl>propertyName.sym.declAST;\n                        if (boundDecl.init && (boundDecl.init.nodeType == NodeType.NumberLit)) {\n                            var numLit = <NumberLiteral>boundDecl.init;\n                            this.writeToOutput(numLit.value.toString());\n                            var comment = " /* ";\n                            comment += propertyName.actualText;\n                            comment += " */ ";\n                            this.writeToOutput(comment);\n                            return true;\n                        }\n                    }\n                }\n            }\n            ret';
var v27651 = v27652 + 'urn false;\n        }\n\n        public emitCall(callNode: CallExpression, target: AST, args: ASTList) {\n            if (!this.emitSuperCall(callNode)) {\n                if (!hasFlag(callNode.flags, ASTFlags.ClassBaseConstructorCall)) {\n                    if (target.nodeType == NodeType.FuncDecl && !target.isParenthesized) {\n                        this.writeToOutput("(");\n                    }\n                    if (callNode.target.nodeType == NodeType.Super && this.emitState.container == EmitContainer.Constructor) {\n                        this.writeToOutput("_super.call");\n                    }\n                    else {\n                        this.emitJavascript(target, TokenID.OpenParen, false);\n                    }\n                    if (target.nodeType == NodeType.FuncDecl && !target.isParenthesized) {\n                        this.writeToOutput(")");\n                    }\n                    this.recordSourceMappingStart(args);\n                    this.writeToOutput("(");\n                    if (callNode.target.nodeType == NodeType.Super && this.emitState.container == EmitContainer.Constructor) {\n                        this.writeToOutput("this");\n                        if (args && args.members.length) {\n                            this.writeToOutput(", ");\n                        }\n                    }\n                    this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);\n                    this.writeToOutput(")");\n                    this.recordSourceMappingEnd(args);\n                }\n                else {\n                    this.indenter.decreaseIndent();\n                    this.indenter.decreaseIndent();\n                    var constructorCall = new ASTList();\n                    constructorCall.members[0] = callNode;\n                    this.emitConstructorCalls(constructorCall, this.thisClassNode);\n                    this.indenter.increaseIndent();\n                    this.indenter.increaseIndent();\n                }\n            }\n        }\n\n        public emitConstructorCalls(bases: ASTList, classDecl: TypeDeclaration) {\n            if (bases == null) {\n                return;\n            }\n            var basesLen = bases.members.length;\n            this.recordSourceMappingStart(classDecl);\n            for (var i = 0; i < basesLen; i++) {\n                var baseExpr = bases.members[i];\n                var baseSymbol: Symbol = null;\n                if (baseExpr.nodeType == NodeType.Call) {\n                    baseSymbol = (<CallExpression>baseExpr).target.type.symbol;\n                }\n                else {\n                    baseSymbol = baseExpr.type.symbol;\n                }\n                var baseName = baseSymbol.name;\n                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {\n                    baseName = baseSymbol.fullName();\n                }\n                if (baseExpr.nodeType == NodeType.Call) {\n                    this.emitIndent();\n                    this.writeToOutput("_super.call(this");\n                    var args = (<CallExpression>baseExpr).arguments;\n                    if (args && (args.members.length > 0)) {\n                        this.writeToOutput(", ");\n                        this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);\n                    }\n                    this.writeToOutput(")");\n                }\n                else {\n                    if (baseExpr.type && (baseExpr.type.isClassInstance())) {\n                        // parameterless constructor call;\n                        this.emitIndent();\n                        this.writeToOutput(classDecl.name.actualText + "._super.constructor");\n                        //emitJavascript(baseExpr,TokenID.LParen,false);\n                        this.writeToOutput(".call(this)");\n                    }\n                }\n            }\n            this.recordSourceMappingEnd(classDecl);\n        }\n\n        public emitInnerFunction(funcDecl: FuncDecl, printName: bool, isMember: bool,\n            bases: ASTList, hasSelfRef: bool, classDecl: TypeDeclaration) {\n            /// REVIEW: The code below causes functions to get pushed to a newline in cases where they shouldn\'t\n            /// such as: \n            ///     Foo.prototype.bar = \n            ///         function() {\n            ///         };\n            /// Once we start emitting comments, we should pull this code out to place on the outer context where the function\n            /// is used.\n            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {\n            //    this.writeLineToOutput("");\n            //    this.increaseIndent();\n            //    emitIndent();\n            //}\n\n            var isClassConstructor = funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod);\n            var hasNonObjectBaseType = isClassConstructor && hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeFlags.HasBaseType) && !hasFlag(this.thisClassNode.';
var v27650 = v27651 + 'type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);\n            var classPropertiesMustComeAfterSuperCall = hasNonObjectBaseType && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);\n\n            // We have no way of knowing if the current function is used as an expression or a statement, so as to enusre that the emitted\n            // JavaScript is always valid, add an extra parentheses for unparenthesized function expressions\n            var shouldParenthesize = hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) && !funcDecl.isParenthesized && !funcDecl.isAccessor() && (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon));\n\n            this.emitParensAndCommentsInPlace(funcDecl, true);\n            if (shouldParenthesize) {\n                this.writeToOutput("(");\n            }\n            this.recordSourceMappingStart(funcDecl);\n            if (!(funcDecl.isAccessor() && (<FieldSymbol>funcDecl.accessorSymbol).isObjectLitField)) {\n                this.writeToOutput("function ");\n            }\n            if (printName) {\n                var id = funcDecl.getNameText();\n                if (id && !funcDecl.isAccessor()) {\n                    if (funcDecl.name) {\n                        this.recordSourceMappingStart(funcDecl.name);\n                    }\n                    this.writeToOutput(id);\n                    if (funcDecl.name) {\n                        this.recordSourceMappingEnd(funcDecl.name);\n                    }\n                }\n            }\n\n            this.writeToOutput("(");\n            var argsLen = 0;\n            var i = 0;\n            var arg: ArgDecl;\n            var defaultArgs: ArgDecl[] = [];\n            if (funcDecl.arguments) {\n                var tempContainer = this.setContainer(EmitContainer.Args);\n                argsLen = funcDecl.arguments.members.length;\n                var printLen = argsLen;\n                if (funcDecl.variableArgList) {\n                    printLen--;\n                }\n                for (i = 0; i < printLen; i++) {\n                    arg = <ArgDecl>funcDecl.arguments.members[i];\n                    if (arg.init) {\n                        defaultArgs.push(arg);\n                    }\n                    this.emitJavascript(arg, TokenID.OpenParen, false);\n                    if (i < (printLen - 1)) {\n                        this.writeToOutput(", ");\n                    }\n                }\n                this.setContainer(tempContainer);\n            }\n            this.writeLineToOutput(") {");\n\n            if (funcDecl.isConstructor) {\n                this.recordSourceMappingNameStart("constructor");\n            } else if (funcDecl.isGetAccessor()) {\n                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());\n            } else if (funcDecl.isSetAccessor()) {\n                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());\n            } else {\n                this.recordSourceMappingNameStart(funcDecl.getNameText());\n            }\n            this.indenter.increaseIndent();\n\n            // set default args first\n            for (i = 0; i < defaultArgs.length; i++) {\n                var arg = defaultArgs[i];\n                this.emitIndent();\n                this.recordSourceMappingStart(arg);\n                this.writeToOutput("if (typeof " + arg.id.actualText + " === \\"undefined\\") { ");//\n                this.recordSourceMappingStart(arg.id);\n                this.writeToOutput(arg.id.actualText);\n                this.recordSourceMappingEnd(arg.id);\n                this.writeToOutput(" = ");\n                this.emitJavascript(arg.init, TokenID.OpenParen, false);\n                this.writeLineToOutput("; }")\n                this.recordSourceMappingEnd(arg);\n            }\n\n            if (funcDecl.isConstructor && ((<ClassDeclaration>funcDecl.classDecl).varFlags & VarFlags.MustCaptureThis)) {\n                this.writeCaptureThisStatement(funcDecl);\n            }\n\n            if (funcDecl.isConstructor && !classPropertiesMustComeAfterSuperCall) {\n                if (funcDecl.arguments) {\n                    argsLen = funcDecl.arguments.members.length;\n                    for (i = 0; i < argsLen; i++) {\n                        arg = <ArgDecl>funcDecl.arguments.members[i];\n                        if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {\n                            this.emitIndent();\n                            this.recordSourceMappingStart(arg);\n                            this.recordSourceMappingStart(arg.id);\n                            this.writeToOutput("this." + arg.id.actualText);\n                            this.recordSourceMappingEnd(arg.id);\n                            this.writeToOutput(" = ");\n                            this.recordSourceMappingStart(arg.id);\n                            this.writeToOutput(arg.id.actualText);\n                            this.re';
var v27649 = v27650 + 'cordSourceMappingEnd(arg.id);\n                            this.writeLineToOutput(";");\n                            this.recordSourceMappingEnd(arg);\n                        }\n                    }\n                }\n\n                // For classes, the constructor needs to be explicitly called\n                if (!hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n                    this.emitConstructorCalls(bases, classDecl);\n                }\n            }\n            if (hasSelfRef) {\n                this.writeCaptureThisStatement(funcDecl);\n            }\n            if (funcDecl.variableArgList) {\n                argsLen = funcDecl.arguments.members.length;\n                var lastArg = <ArgDecl>funcDecl.arguments.members[argsLen - 1];\n                this.emitIndent();\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("var ");\n                this.recordSourceMappingStart(lastArg.id);\n                this.writeToOutput(lastArg.id.actualText);\n                this.recordSourceMappingEnd(lastArg.id);\n                this.writeLineToOutput(" = [];");\n                this.recordSourceMappingEnd(lastArg);\n                this.emitIndent();\n                this.writeToOutput("for (")\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("var _i = 0;");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeToOutput(" ");\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("_i < (arguments.length - " + (argsLen - 1) + ")");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeToOutput("; ");\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("_i++");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeLineToOutput(") {");\n                this.indenter.increaseIndent();\n                this.emitIndent();\n\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput(lastArg.id.actualText + "[_i] = arguments[_i + " + (argsLen - 1) + "];");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeLineToOutput("");\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput("}");\n            }\n\n            // if it\'s a class, emit the uninitializedMembers, first emit the non-proto class body members\n            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod) && !classPropertiesMustComeAfterSuperCall) {\n\n                var nProps = (<ASTList>this.thisClassNode.members).members.length;\n\n                for (var i = 0; i < nProps; i++) {\n                    if ((<ASTList>this.thisClassNode.members).members[i].nodeType == NodeType.VarDecl) {\n                        var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[i];\n                        if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                            this.emitIndent();\n                            this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                            this.writeLineToOutput("");\n                        }\n                    }\n                }\n                //this.writeLineToOutput("");\n            }\n\n            this.emitBareJavascriptStatements(funcDecl.bod, classPropertiesMustComeAfterSuperCall);\n\n            this.indenter.decreaseIndent();\n            this.emitIndent();\n            this.recordSourceMappingStart(funcDecl.endingToken);\n            this.writeToOutput("}");\n\n            this.recordSourceMappingNameEnd();\n            this.recordSourceMappingEnd(funcDecl.endingToken);\n            this.recordSourceMappingEnd(funcDecl);\n\n            if (shouldParenthesize) {\n                this.writeToOutput(")");\n            }\n\n            // The extra call is to make sure the caller\'s funcDecl end is recorded, since caller wont be able to record it\n            this.recordSourceMappingEnd(funcDecl);\n\n            this.emitParensAndCommentsInPlace(funcDecl, false);\n\n            if (!isMember &&\n                //funcDecl.name != null &&\n                !hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) &&\n                (hasFlag(funcDecl.fncFlags, FncFlags.Definition) || funcDecl.isConstructor)) {\n                this.writeLineToOutput("");\n            } else if (hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression)) {\n                if (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon)) {\n                    // If either of these two flags are set, then the function expression is a statement. Terminate it.\n                    this.writeLineToOutput(";");\n                }\n            }\n            /// TODO: See the other part of this at the beginning of function\n            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {\n  ';
var v27648 = v27649 + '          //    this.decreaseIndent();\n            //}           \n        }\n\n        public emitJavascriptModule(moduleDecl: ModuleDeclaration) {\n            var modName = moduleDecl.name.actualText;\n            if (isTSFile(modName)) {\n                moduleDecl.name.setText(modName.substring(0, modName.length - 3));\n            }\n            else if (isSTRFile(modName)) {\n                moduleDecl.name.setText(modName.substring(0, modName.length - 4));\n            }\n\n            if (!hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient)) {\n                var isDynamicMod = hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic);\n                var prevOutFile = this.outfile;\n                var prevOutFileName = this.emittingFileName;\n                var prevAllSourceMappers = this.allSourceMappers;\n                var prevSourceMapper = this.sourceMapper;\n                var prevColumn = this.emitState.column;\n                var prevLine = this.emitState.line;\n                var temp = this.setContainer(EmitContainer.Module);\n                var svModuleName = this.moduleName;\n                var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);\n                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl;\n                var isWholeFile = hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile);\n                this.moduleName = moduleDecl.name.actualText;\n\n                // prologue\n                if (isDynamicMod) {\n                    // create the new outfile for this module\n                    var tsModFileName = stripQuotes(moduleDecl.name.actualText);\n                    var modFilePath = trimModName(tsModFileName) + ".js";\n                    modFilePath = this.emitOptions.mapOutputFileName(modFilePath, TypeScriptCompiler.mapToJSFileName);\n\n                    if (this.emitOptions.ioHost) {\n                        // Ensure that the slashes are normalized so that the comparison is fair\n                        // REVIEW: Note that modFilePath is normalized to forward slashes in Parser.parse, so the \n                        // first call to switchToForwardSlashes is technically a no-op, but it will prevent us from\n                        // regressing if the parser changes\n                        if (switchToForwardSlashes(modFilePath) != switchToForwardSlashes(this.emittingFileName)) {\n                            this.emittingFileName = modFilePath;\n                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);\n                            this.outfile = this.createFile(this.emittingFileName, useUTF8InOutputfile);\n                            if (prevSourceMapper != null) {\n                                this.allSourceMappers = [];\n                                var sourceMappingFile = this.createFile(this.emittingFileName + SourceMapper.MapFileExtension, false);\n                                this.setSourceMappings(new TypeScript.SourceMapper(tsModFileName, this.emittingFileName, this.outfile, sourceMappingFile, this.errorReporter));\n                                this.emitState.column = 0;\n                                this.emitState.line = 0;\n                            }\n                        } else {\n                            CompilerDiagnostics.assert(this.emitOptions.outputMany, "Cannot have dynamic modules compiling into single file");\n                        }\n                    }\n\n                    this.setContainer(EmitContainer.DynamicModule); // discard the previous \'Module\' container\n\n                    this.recordSourceMappingStart(moduleDecl);\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD\n                        var dependencyList = "[\\"require\\", \\"exports\\"";\n                        var importList = "require, exports";\n                        var importStatement: ImportDeclaration = null;\n\n                        // all dependencies are quoted\n                        for (var i = 0; i < (<ModuleType>moduleDecl.mod).importedModules.length; i++) {\n                            importStatement = (<ModuleType>moduleDecl.mod).importedModules[i]\n\n                            // if the imported module is only used in a type position, do not add it as a requirement\n                            if (importStatement.id.sym &&\n                                !(<TypeSymbol>importStatement.id.sym).onlyReferencedAsTypeRef) {\n                                if (i <= (<ModuleType>moduleDecl.mod).importedModules.length - 1) {\n                                    dependencyList += ", ";\n                                    importList += ", ";\n                                }\n\n                                importList += "__" + importStatement.id.actualText + "__";\n                                dependencyList += importStatement.firstAliasedModToString();\n                            }\n                        }\n\n                 ';
var v27647 = v27648 + '       // emit any potential amd dependencies\n                        for (var i = 0; i < moduleDecl.amdDependencies.length; i++) {\n                            dependencyList += ", \\"" + moduleDecl.amdDependencies[i] + "\\"";\n                        }\n\n                        dependencyList += "]";\n\n                        this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");\n                    }\n                    else { // Node\n\n                    }\n                }\n                else {\n\n                    if (!isExported) {\n                        this.recordSourceMappingStart(moduleDecl);\n                        this.writeToOutput("var ");\n                        this.recordSourceMappingStart(moduleDecl.name);\n                        this.writeToOutput(this.moduleName);\n                        this.recordSourceMappingEnd(moduleDecl.name);\n                        this.writeLineToOutput(";");\n                        this.recordSourceMappingEnd(moduleDecl);\n                        this.emitIndent();\n                    }\n\n                    this.writeToOutput("(");\n                    this.recordSourceMappingStart(moduleDecl);\n                    this.writeToOutput("function (");\n                    this.recordSourceMappingStart(moduleDecl.name);\n                    this.writeToOutput(this.moduleName);\n                    this.recordSourceMappingEnd(moduleDecl.name);\n                    this.writeLineToOutput(") {");\n                }\n\n                if (!isWholeFile) {\n                    this.recordSourceMappingNameStart(this.moduleName);\n                }\n\n                // body - don\'t indent for Node\n                if (!isDynamicMod || moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                    this.indenter.increaseIndent();\n                }\n\n                if (moduleDecl.modFlags & ModuleFlags.MustCaptureThis) {\n                    this.writeCaptureThisStatement(moduleDecl);\n                }\n\n                this.emitJavascriptList(moduleDecl.members, null, TokenID.Semicolon, true, false, false);\n                if (!isDynamicMod || moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                    this.indenter.decreaseIndent();\n                }\n                this.emitIndent();\n\n                // epilogue\n                if (isDynamicMod) {\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD\n                        this.writeLineToOutput("})");\n                    }\n                    else { // Node\n                    }\n                    if (!isWholeFile) {\n                        this.recordSourceMappingNameEnd();\n                    }\n                    this.recordSourceMappingEnd(moduleDecl);\n\n                    // close the module outfile, and restore the old one\n                    if (this.outfile != prevOutFile) {\n                        this.Close();\n                        if (prevSourceMapper != null) {\n                            this.allSourceMappers = prevAllSourceMappers;\n                            this.sourceMapper = prevSourceMapper;\n                            this.emitState.column = prevColumn;\n                            this.emitState.line = prevLine;\n                        }\n                        this.outfile = prevOutFile;\n                        this.emittingFileName = prevOutFileName;\n                    }\n                }\n                else {\n                    var containingMod: ModuleDeclaration = null;\n                    if (moduleDecl.type && moduleDecl.type.symbol.container && moduleDecl.type.symbol.container.declAST) {\n                        containingMod = <ModuleDeclaration>moduleDecl.type.symbol.container.declAST;\n                    }\n                    var parentIsDynamic = containingMod && hasFlag(containingMod.modFlags, ModuleFlags.IsDynamic);\n\n                    this.recordSourceMappingStart(moduleDecl.endingToken);\n                    if (temp == EmitContainer.Prog && isExported) {\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");\n                    }\n                    else if (isExported || temp == EmitContainer.Prog) {\n                        var dotMod = svModuleName != "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {})';
var v27646 = v27647 + ');");\n                    }\n                    else if (!isExported && temp != EmitContainer.Prog) {\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");\n                    }\n                    else {\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")();");\n                    }\n                    this.recordSourceMappingEnd(moduleDecl);\n                    this.writeLineToOutput("");\n                    if (temp != EmitContainer.Prog && isExported) {\n                        this.emitIndent();\n                        this.recordSourceMappingStart(moduleDecl);\n                        if (parentIsDynamic) {\n                            this.writeLineToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");\n                        } else {\n                            this.writeLineToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");\n                        }\n                        this.recordSourceMappingEnd(moduleDecl);\n                    }\n                }\n\n                this.setContainer(temp);\n                this.moduleName = svModuleName;\n                this.moduleDeclList.length--;\n            }\n        }\n\n        public emitIndex(operand1: AST, operand2: AST) {\n            var temp = this.setInObjectLiteral(false);\n            this.emitJavascript(operand1, TokenID.Tilde, false);\n            this.writeToOutput("[");\n            this.emitJavascriptList(operand2, ", ", TokenID.Comma, false, false, false);\n            this.writeToOutput("]");\n            this.setInObjectLiteral(temp);\n        }\n\n        public emitStringLiteral(text: string) {\n            // should preserve escape etc.\n            // TODO: simplify object literal simple name\n            this.writeToOutput(text);\n        }\n\n        public emitJavascriptFunction(funcDecl: FuncDecl) {\n            if (hasFlag(funcDecl.fncFlags, FncFlags.Signature) || funcDecl.isOverload) {\n                return;\n            }\n            var temp: number;\n            var tempFnc = this.thisFnc;\n            this.thisFnc = funcDecl;\n\n            if (funcDecl.isConstructor) {\n                temp = this.setContainer(EmitContainer.Constructor);\n            }\n            else {\n                temp = this.setContainer(EmitContainer.Function);\n            }\n\n            var bases: ASTList = null;\n            var hasSelfRef = false;\n            var funcName = funcDecl.getNameText();\n\n            if ((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) &&\n                ((temp != EmitContainer.Constructor) ||\n                ((funcDecl.fncFlags & FncFlags.Method) == FncFlags.None))) {\n                var tempLit = this.setInObjectLiteral(false);\n                if (this.thisClassNode) {\n                    bases = this.thisClassNode.extendsList;\n                }\n                hasSelfRef = Emitter.shouldCaptureThis(funcDecl);\n                this.recordSourceMappingStart(funcDecl);\n                if (hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported) && funcDecl.type.symbol.container == this.checker.gloMod && !funcDecl.isConstructor) {\n                    this.writeToOutput("this." + funcName + " = ");\n                    this.emitInnerFunction(funcDecl, false, false, bases, hasSelfRef, this.thisClassNode);\n                }\n                else {\n                    this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()), false, bases, hasSelfRef, this.thisClassNode);\n                }\n                this.setInObjectLiteral(tempLit);\n            }\n            this.setContainer(temp);\n            this.thisFnc = tempFnc;\n\n            if (hasFlag(funcDecl.fncFlags, FncFlags.Definition)) {\n                if (hasFlag(funcDecl.fncFlags, FncFlags.Static)) {\n                    if (this.thisClassNode) {\n                        if (funcDecl.isAccessor()) {\n                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);\n                        }\n                        else {\n                            this.emitIndent();\n                            this.recordSourceMappingStart(funcDecl);\n                            this.writeLineToOutput(this.thisClassNode.name.actualText + "." + funcName +\n                                          " = " + funcName + ";");\n                            this.recordSourceMappingEnd(funcDecl);\n                     ';
var v27645 = v27646 + '   }\n                    }\n                }\n                else if ((this.emitState.container == EmitContainer.Module || this.emitState.container == EmitContainer.DynamicModule) && hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported)) {\n                    this.emitIndent();\n                    var modName = this.emitState.container == EmitContainer.Module ? this.moduleName : "exports";\n                    this.recordSourceMappingStart(funcDecl);\n                    this.writeLineToOutput(modName + "." + funcName +\n                                      " = " + funcName + ";");\n                    this.recordSourceMappingEnd(funcDecl);\n                }\n            }\n        }\n\n        public emitAmbientVarDecl(varDecl: VarDecl) {\n            if (varDecl.init) {\n                this.emitParensAndCommentsInPlace(varDecl, true);\n                this.recordSourceMappingStart(varDecl);\n                this.recordSourceMappingStart(varDecl.id);\n                this.writeToOutput(varDecl.id.actualText);\n                this.recordSourceMappingEnd(varDecl.id);\n                this.writeToOutput(" = ");\n                this.emitJavascript(varDecl.init, TokenID.Comma, false);\n                this.recordSourceMappingEnd(varDecl);\n                this.writeToOutput(";");\n                this.emitParensAndCommentsInPlace(varDecl, false);\n            }\n        }\n\n        private varListCount(): number {\n            return this.varListCountStack[this.varListCountStack.length - 1];\n        }\n\n        // Emits "var " if it is allowed\n        private emitVarDeclVar() {\n            // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var\n            // If it is var list of form  var a = varList count will be 0\n            if (this.varListCount() >= 0) {\n                this.writeToOutput("var ");\n                this.setInVarBlock(-this.varListCount());\n            }\n            return true;\n        }\n\n        private onEmitVar() {\n            if (this.varListCount() > 0) {\n                this.setInVarBlock(this.varListCount() - 1);\n            }\n            else if (this.varListCount() < 0) {\n                this.setInVarBlock(this.varListCount() + 1);\n            }\n        }\n\n        public emitJavascriptVarDecl(varDecl: VarDecl, tokenId: TokenID) {\n            if ((varDecl.varFlags & VarFlags.Ambient) == VarFlags.Ambient) {\n                this.emitAmbientVarDecl(varDecl);\n                this.onEmitVar();\n            }\n            else {\n                var sym = varDecl.sym;\n                var hasInitializer = (varDecl.init != null);\n                this.emitParensAndCommentsInPlace(varDecl, true);\n                this.recordSourceMappingStart(varDecl);\n                if (sym && sym.isMember() && sym.container &&\n                    (sym.container.kind() == SymbolKind.Type)) {\n                    var type = (<TypeSymbol>sym.container).type;\n                    if (type.isClass() && (!hasFlag(sym.flags, SymbolFlags.ModuleMember))) {\n                        // class\n                        if (this.emitState.container != EmitContainer.Args) {\n                            if (hasFlag(sym.flags, SymbolFlags.Static)) {\n                                this.writeToOutput(sym.container.name + ".");\n                            }\n                            else {\n                                this.writeToOutput("this.");\n                            }\n                        }\n                    }\n                    else if (type.hasImplementation()) {\n                        // module\n                        if (!hasFlag(sym.flags, SymbolFlags.Exported) && (sym.container == this.checker.gloMod || !hasFlag(sym.flags, SymbolFlags.Property))) {\n                            this.emitVarDeclVar();\n                        }\n                        else if (hasFlag(varDecl.varFlags, VarFlags.LocalStatic)) {\n                            this.writeToOutput(".");\n                        }\n                        else {\n                            if (this.emitState.container == EmitContainer.DynamicModule) {\n                                this.writeToOutput("exports.");\n                            }\n                            else {\n                                this.writeToOutput(this.moduleName + ".");\n                            }\n                        }\n                    }\n                    else {\n                        // function, constructor, method etc.\n                        if (tokenId != TokenID.OpenParen) {\n                            if (hasFlag(sym.flags, SymbolFlags.Exported) && sym.container == this.checker.gloMod) {\n                                this.writeToOutput("this.");\n                            }\n                            else {\n                                this.emitVarDeclVar();\n                            }\n                        }\n                    }\n                }\n                else {\n            ';
var v27644 = v27645 + '        if (tokenId != TokenID.OpenParen) {\n                        this.emitVarDeclVar();\n                    }\n                }\n                this.recordSourceMappingStart(varDecl.id);\n                this.writeToOutput(varDecl.id.actualText);\n                this.recordSourceMappingEnd(varDecl.id);\n                if (hasInitializer) {\n                    this.writeToOutputTrimmable(" = ");\n\n                    // Ensure we have a fresh var list count when recursing into the variable \n                    // initializer.  We don\'t want our current list of variables to affect how we\n                    // emit nested variable lists.\n                    this.varListCountStack.push(0);\n                    this.emitJavascript(varDecl.init, TokenID.Comma, false);\n                    this.varListCountStack.pop();\n                }\n                this.onEmitVar();\n                if ((tokenId != TokenID.OpenParen)) {\n                    if (this.varListCount() < 0) {\n                        this.writeToOutput(", ");\n                    } else if (tokenId != TokenID.For) {\n                        this.writeToOutputTrimmable(";");\n                    }\n                }\n                this.recordSourceMappingEnd(varDecl);\n                this.emitParensAndCommentsInPlace(varDecl, false);\n            }\n        }\n\n        public declEnclosed(moduleDecl: ModuleDeclaration): bool {\n            if (moduleDecl == null) {\n                return true;\n            }\n            for (var i = 0, len = this.moduleDeclList.length; i < len; i++) {\n                if (this.moduleDeclList[i] == moduleDecl) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public emitJavascriptName(name: Identifier, addThis: bool) {\n            var sym = name.sym;\n            this.emitParensAndCommentsInPlace(name, true);\n            this.recordSourceMappingStart(name);\n            if (!name.isMissing()) {\n                if (addThis && (this.emitState.container != EmitContainer.Args) && sym) {\n                    // TODO: flag global module with marker other than string name\n                    if (sym.container && (sym.container.name != globalId)) {\n                        if (hasFlag(sym.flags, SymbolFlags.Static) && (hasFlag(sym.flags, SymbolFlags.Property))) {\n                            if (sym.declModule && hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {\n                                this.writeToOutput("exports.");\n                            }\n                            else {\n                                this.writeToOutput(sym.container.name + ".");\n                            }\n                        }\n                        else if (sym.kind() == SymbolKind.Field) {\n                            var fieldSym = <FieldSymbol>sym;\n                            if (hasFlag(fieldSym.flags, SymbolFlags.ModuleMember)) {\n                                if ((sym.container != this.checker.gloMod) && ((hasFlag(sym.flags, SymbolFlags.Property)) || hasFlag(sym.flags, SymbolFlags.Exported))) {\n                                    if (hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {\n                                        this.writeToOutput("exports.");\n                                    }\n                                    else {\n                                        this.writeToOutput(sym.container.name + ".");\n                                    }\n                                }\n                            }\n                            else {\n                                if (sym.isInstanceProperty()) {\n                                    this.emitThis();\n                                    this.writeToOutput(".");\n                                }\n                            }\n                        }\n                        else if (sym.kind() == SymbolKind.Type) {\n                            if (sym.isInstanceProperty()) {\n                                var typeSym = <TypeSymbol>sym;\n                                var type = typeSym.type;\n                                if (type.call && !hasFlag(sym.flags, SymbolFlags.ModuleMember)) {\n                                    this.emitThis();\n                                    this.writeToOutput(".");\n                                }\n                            }\n                            else if ((sym.unitIndex != this.checker.locationInfo.unitIndex) || (!this.declEnclosed(sym.declModule))) {\n                                this.writeToOutput(sym.container.name + ".")\n                            }\n                        }\n                    }\n                    else if (sym.container == this.checker.gloMod &&\n                                hasFlag(sym.flags, SymbolFlags.Exported) &&\n                                !hasFlag(sym.flags, SymbolFlags.Ambient) &&\n                                // check that it\'s a not a member of an ambient module...\n                                !((sym.isType()';
var v27643 = v27644 + ' || sym.isMember()) &&\n                                    sym.declModule &&\n                                    hasFlag(sym.declModule.modFlags, ModuleFlags.Ambient)) &&\n                                this.emitState.container == EmitContainer.Prog &&\n                                sym.declAST.nodeType != NodeType.FuncDecl) {\n                        this.writeToOutput("this.");\n                    }\n                }\n\n                // If it\'s a dynamic module, we need to print the "require" invocation\n                if (sym &&\n                    sym.declAST &&\n                    sym.declAST.nodeType == NodeType.ModuleDeclaration &&\n                    (hasFlag((<ModuleDeclaration>sym.declAST).modFlags, ModuleFlags.IsDynamic))) {\n                    var moduleDecl: ModuleDeclaration = <ModuleDeclaration>sym.declAST;\n\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                        this.writeLineToOutput("__" + this.modAliasId + "__;");\n                    }\n                    else {\n                        var modPath = name.actualText;//(<ModuleDecl>moduleDecl.mod.symbol.declAST).name.actualText;\n                        var isAmbient = moduleDecl.mod.symbol.declAST && hasFlag((<ModuleDeclaration>moduleDecl.mod.symbol.declAST).modFlags, ModuleFlags.Ambient);\n                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : quoteBaseName(modPath);\n                        modPath = isAmbient ? modPath : (!isRelative(stripQuotes(modPath)) ? quoteStr("./" + stripQuotes(modPath)) : modPath);\n                        this.writeToOutput("require(" + modPath + ")");\n                    }\n                }\n                else {\n                    this.writeToOutput(name.actualText);\n                }\n            }\n            this.recordSourceMappingEnd(name);\n            this.emitParensAndCommentsInPlace(name, false);\n        }\n\n        public emitJavascriptStatements(stmts: AST, emitEmptyBod: bool) {\n            if (stmts) {\n                if (stmts.nodeType != NodeType.Block) {\n                    var hasContents = (stmts && (stmts.nodeType != NodeType.List || ((<ASTList>stmts).members.length > 0)));\n                    if (emitEmptyBod || hasContents) {\n                        var hasOnlyBlockStatement = ((stmts.nodeType == NodeType.Block) ||\n                            ((stmts.nodeType == NodeType.List) && ((<ASTList>stmts).members.length == 1) && ((<ASTList>stmts).members[0].nodeType == NodeType.Block)));\n\n                        this.recordSourceMappingStart(stmts);\n                        if (!hasOnlyBlockStatement) {\n                            this.writeLineToOutput(" {");\n                            this.indenter.increaseIndent();\n                        }\n                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, false);\n                        if (!hasOnlyBlockStatement) {\n                            this.writeLineToOutput("");\n                            this.indenter.decreaseIndent();\n                            this.emitIndent();\n                            this.writeToOutput("}");\n                        }\n                        this.recordSourceMappingEnd(stmts);\n                    }\n                }\n                else {\n                    this.emitJavascript(stmts, TokenID.Semicolon, true);\n                }\n            }\n            else if (emitEmptyBod) {\n                this.writeToOutput("{ }");\n            }\n        }\n\n        public emitBareJavascriptStatements(stmts: AST, emitClassPropertiesAfterSuperCall: bool = false) {\n            // just the statements without enclosing curly braces\n            if (stmts.nodeType != NodeType.Block) {\n                if (stmts.nodeType == NodeType.List) {\n                    var stmtList = <ASTList>stmts;\n                    if ((stmtList.members.length == 2) &&\n                        (stmtList.members[0].nodeType == NodeType.Block) &&\n                        (stmtList.members[1].nodeType == NodeType.EndCode)) {\n                        this.emitJavascript(stmtList.members[0], TokenID.Semicolon, true);\n                        this.writeLineToOutput("");\n                    }\n                    else {\n                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, emitClassPropertiesAfterSuperCall);\n                    }\n                }\n                else {\n                    this.emitJavascript(stmts, TokenID.Semicolon, true);\n                }\n            }\n            else {\n                this.emitJavascript(stmts, TokenID.Semicolon, true);\n            }\n        }\n\n        public recordSourceMappingNameStart(name: string) {\n            if (this.sourceMapper) {\n                var finalName = name;\n                if (!name) {\n                    finalName = "";\n                } else if (this.sourceMapper.currentNameIndex.length > 0) {\n                    finalName = this.sourceMapper.names[this.source';
var v27642 = v27643 + "Mapper.currentNameIndex.length - 1] + \".\" + name;\n                }\n\n                // We are currently not looking for duplicate but that is possible.\n                this.sourceMapper.names.push(finalName);\n                this.sourceMapper.currentNameIndex.push(this.sourceMapper.names.length - 1);\n            }\n        }\n\n        public recordSourceMappingNameEnd() {\n            if (this.sourceMapper) {\n                this.sourceMapper.currentNameIndex.pop();\n            }\n        }\n\n        public recordSourceMappingStart(ast: ASTSpan) {\n            if (this.sourceMapper && isValidAstNode(ast)) {\n                var lineCol = { line: -1, col: -1 };\n                var sourceMapping = new SourceMapping();\n                sourceMapping.start.emittedColumn = this.emitState.column;\n                sourceMapping.start.emittedLine = this.emitState.line;\n                // REVIEW: check time consumed by this binary search (about two per leaf statement)\n                getSourceLineColFromMap(lineCol, ast.minChar, this.checker.locationInfo.lineMap);\n                sourceMapping.start.sourceColumn = lineCol.col;\n                sourceMapping.start.sourceLine = lineCol.line;\n                getSourceLineColFromMap(lineCol, ast.limChar, this.checker.locationInfo.lineMap);\n                sourceMapping.end.sourceColumn = lineCol.col;\n                sourceMapping.end.sourceLine = lineCol.line;\n                if (this.sourceMapper.currentNameIndex.length > 0) {\n                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];\n                }\n                // Set parent and child relationship\n                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];\n                siblings.push(sourceMapping);\n                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);\n            }\n        }\n\n        public recordSourceMappingEnd(ast: ASTSpan) {\n            if (this.sourceMapper && isValidAstNode(ast)) {\n                // Pop source mapping childs\n                this.sourceMapper.currentMappings.pop();\n\n                // Get the last source mapping from sibling list = which is the one we are recording end for\n                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];\n                var sourceMapping = siblings[siblings.length - 1];\n\n                sourceMapping.end.emittedColumn = this.emitState.column;\n                sourceMapping.end.emittedLine = this.emitState.line;\n            }\n        }\n\n        public Close() {\n            if (this.sourceMapper != null) {\n                SourceMapper.EmitSourceMapping(this.allSourceMappers);\n            }\n            try {\n                // Closing files could result in exceptions, report them if they occur\n                this.outfile.Close();\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n\n        public emitJavascriptList(ast: AST, delimiter: string, tokenId: TokenID, startLine: bool, onlyStatics: bool, emitClassPropertiesAfterSuperCall: bool = false, emitPrologue? = false, requiresExtendsBlock?: bool) {\n            if (ast == null) {\n                return;\n            }\n            else if (ast.nodeType != NodeType.List) {\n                this.emitPrologue(emitPrologue);\n                this.emitJavascript(ast, tokenId, startLine);\n            }\n            else {\n                var list = <ASTList>ast;\n                if (list.members.length == 0) {\n                    return;\n                }\n\n                this.emitParensAndCommentsInPlace(ast, true);\n                var len = list.members.length;\n                for (var i = 0; i < len; i++) {\n                    if (emitPrologue) {\n                        // If the list has Strict mode flags, emit prologue after first statement\n                        // otherwise emit before first statement\n                        if (i == 1 || !hasFlag(list.flags, ASTFlags.StrictMode)) {\n                            this.emitPrologue(requiresExtendsBlock);\n                            emitPrologue = false;\n                        }\n                    }\n\n                    // In some circumstances, class property initializers must be emitted immediately after the 'super' constructor\n                    // call which, in these cases, must be the first statement in the constructor body\n                    if (i == 1 && emitClassPropertiesAfterSuperCall) {\n\n                        // emit any parameter properties first\n                        var constructorDecl = (<ClassDeclaration>this.thisClassNode).constructorDecl;\n\n                        if (constructorDecl && constructorDecl.arguments) {\n                            var argsLen = constructorDecl.arguments.members.length;\n                            for (var iArg = 0; iArg < argsLen; iArg++) {\n                     ";
var v27641 = v27642 + '           var arg = <BoundDecl>constructorDecl.arguments.members[iArg];\n                                if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {\n                                    this.emitIndent();\n                                    this.recordSourceMappingStart(arg);\n                                    this.recordSourceMappingStart(arg.id);\n                                    this.writeToOutput("this." + arg.id.actualText);\n                                    this.recordSourceMappingEnd(arg.id);\n                                    this.writeToOutput(" = ");\n                                    this.recordSourceMappingStart(arg.id);\n                                    this.writeToOutput(arg.id.actualText);\n                                    this.recordSourceMappingEnd(arg.id);\n                                    this.writeLineToOutput(";");\n                                    this.recordSourceMappingEnd(arg);\n                                }\n                            }\n                        }\n\n                        var nProps = (<ASTList>this.thisClassNode.members).members.length;\n\n                        for (var iMember = 0; iMember < nProps; iMember++) {\n                            if ((<ASTList>this.thisClassNode.members).members[iMember].nodeType == NodeType.VarDecl) {\n                                var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[iMember];\n                                if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                                    this.emitIndent();\n                                    this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                                    this.writeLineToOutput("");\n                                }\n                            }\n                        }\n                    }\n\n                    var emitNode = list.members[i];\n\n                    var isStaticDecl =\n                                (emitNode.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>emitNode).fncFlags, FncFlags.Static)) ||\n                                (emitNode.nodeType == NodeType.VarDecl && hasFlag((<VarDecl>emitNode).varFlags, VarFlags.Static))\n\n                    if (onlyStatics ? !isStaticDecl : isStaticDecl) {\n                        continue;\n                    }\n                    this.emitJavascript(emitNode, tokenId, startLine);\n\n                    if (delimiter && (i < (len - 1))) {\n                        if (startLine) {\n                            this.writeLineToOutput(delimiter);\n                        }\n                        else {\n                            this.writeToOutput(delimiter);\n                        }\n                    }\n                    else if (startLine &&\n                             (emitNode.nodeType != NodeType.ModuleDeclaration) &&\n                             (emitNode.nodeType != NodeType.InterfaceDeclaration) &&\n                             (!((emitNode.nodeType == NodeType.VarDecl) &&\n                                ((((<VarDecl>emitNode).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&\n                                (((<VarDecl>emitNode).init) == null)) && this.varListCount() >= 0) &&\n                             (emitNode.nodeType != NodeType.Block || (<Block>emitNode).isStatementBlock) &&\n                             (emitNode.nodeType != NodeType.EndCode) &&\n                             (emitNode.nodeType != NodeType.FuncDecl)) {\n                        this.writeLineToOutput("");\n                    }\n                }\n                this.emitParensAndCommentsInPlace(ast, false);\n            }\n        }\n\n        // tokenId is the id the preceding token\n        public emitJavascript(ast: AST, tokenId: TokenID, startLine: bool) {\n            if (ast == null) {\n                return;\n            }\n\n            // REVIEW: simplify rules for indenting\n            if (startLine && (this.indenter.indentAmt > 0) && (ast.nodeType != NodeType.List) &&\n                (ast.nodeType != NodeType.Block)) {\n                if ((ast.nodeType != NodeType.InterfaceDeclaration) &&\n                    (!((ast.nodeType == NodeType.VarDecl) &&\n                       ((((<VarDecl>ast).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&\n                       (((<VarDecl>ast).init) == null)) && this.varListCount() >= 0) &&\n                    (ast.nodeType != NodeType.EndCode) &&\n                    ((ast.nodeType != NodeType.FuncDecl) ||\n                     (this.emitState.container != EmitContainer.Constructor))) {\n                    this.emitIndent();\n                }\n            }\n\n            ast.emit(this, tokenId, startLine);\n\n            if ((tokenId == TokenID.Semicolon) && (ast.nodeType < NodeType.GeneralNode)) {\n                this.writeToOutput(";");\n            }\n        }\n\n        public emitPropertyAccessor(funcDecl: FuncDecl, className: string, isProto: bool) {\n            if (!(<FieldSymbol>funcDecl.accessorSymbol).h';
var v27640 = v27641 + 'asBeenEmitted) {\n                var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;\n                this.emitIndent();\n                this.recordSourceMappingStart(funcDecl);\n                this.writeLineToOutput("Object.defineProperty(" + className + (isProto ? ".prototype, \\"" : ", \\"") + funcDecl.name.actualText + "\\"" + ", {");\n                this.indenter.increaseIndent();\n\n                if (accessorSymbol.getter) {\n                    var getter: FuncDecl = <FuncDecl>accessorSymbol.getter.declAST;\n\n                    this.emitIndent();\n                    this.recordSourceMappingStart(getter);\n                    this.writeToOutput("get: ");\n                    this.emitInnerFunction(getter, false, isProto, null, Emitter.shouldCaptureThis(getter), null);\n                    this.writeLineToOutput(",");\n                }\n\n                if (accessorSymbol.setter) {\n                    var setter: FuncDecl = <FuncDecl>accessorSymbol.setter.declAST;\n\n                    this.emitIndent();\n                    this.recordSourceMappingStart(setter);\n                    this.writeToOutput("set: ");\n                    this.emitInnerFunction(setter, false, isProto, null, Emitter.shouldCaptureThis(setter), null);\n                    this.writeLineToOutput(",");\n                }\n\n                this.emitIndent();\n                this.writeLineToOutput("enumerable: true,");\n                this.emitIndent();\n                this.writeLineToOutput("configurable: true");\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput("});");\n                this.recordSourceMappingEnd(funcDecl);\n\n                accessorSymbol.hasBeenEmitted = true;\n            }\n        }\n\n        public emitPrototypeMember(member: AST, className: string) {\n            if (member.nodeType == NodeType.FuncDecl) {\n                var funcDecl = <FuncDecl>member;\n                if (funcDecl.isAccessor()) {\n                    this.emitPropertyAccessor(funcDecl, className, true);\n                }\n                else {\n                    this.emitIndent();\n                    this.recordSourceMappingStart(funcDecl);\n                    this.writeToOutput(className + ".prototype." + funcDecl.getNameText() + " = ");\n                    this.emitInnerFunction(funcDecl, false, true, null, Emitter.shouldCaptureThis(funcDecl), null);\n                    this.writeLineToOutput(";");\n                }\n            }\n            else if (member.nodeType == NodeType.VarDecl) {\n                var varDecl = <VarDecl>member;\n\n                if (varDecl.init) {\n                    this.emitIndent();\n                    this.recordSourceMappingStart(varDecl);\n                    this.recordSourceMappingStart(varDecl.id);\n                    this.writeToOutput(className + ".prototype." + varDecl.id.actualText);\n                    this.recordSourceMappingEnd(varDecl.id);\n                    this.writeToOutput(" = ");\n                    this.emitJavascript(varDecl.init, TokenID.Equals, false);\n                    this.recordSourceMappingEnd(varDecl);\n                    this.writeLineToOutput(";");\n                }\n            }\n        }\n\n        public emitAddBaseMethods(className: string, base: Type, classDecl: TypeDeclaration): void {\n            if (base.members) {\n                var baseSymbol = base.symbol;\n                var baseName = baseSymbol.name;\n                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {\n                    baseName = baseSymbol.fullName();\n                }\n                base.members.allMembers.map(function(key, s, c) {\n                    var sym = <Symbol>s;\n                    if ((sym.kind() == SymbolKind.Type) && (<TypeSymbol>sym).type.call) {\n                        this.recordSourceMappingStart(sym.declAST);\n                        this.writeLineToOutput(className + ".prototype." + sym.name + " = " +\n                                          baseName + ".prototype." + sym.name + ";");\n                        this.recordSourceMappingEnd(sym.declAST);\n                    }\n                }, null);\n            }\n            if (base.extendsList) {\n                for (var i = 0, len = base.extendsList.length; i < len; i++) {\n                    this.emitAddBaseMethods(className, base.extendsList[i], classDecl);\n                }\n            }\n        }\n\n        public emitJavascriptClass(classDecl: ClassDeclaration) {\n            if (!hasFlag(classDecl.varFlags, VarFlags.Ambient)) {\n                var svClassNode = this.thisClassNode;\n                var i = 0;\n                this.thisClassNode = classDecl;\n                var className = classDecl.name.actualText;\n                this.emitParensAndCommentsInPlace(classDecl, true);\n                var temp = this.setContainer(EmitContainer.Class);\n\n                this.recordSourceMappingStart(classDecl);\n                if (hasFlag(classDecl.varFlags, VarF';
var v27639 = v27640 + 'lags.Exported) && classDecl.type.symbol.container == this.checker.gloMod) {\n                    this.writeToOutput("this." + className);\n                }\n                else {\n                    this.writeToOutput("var " + className);\n                }\n\n                //if (hasFlag(classDecl.varFlags, VarFlags.Exported) && (temp == EmitContainer.Module || temp == EmitContainer.DynamicModule)) {\n                //    var modName = temp == EmitContainer.Module ? this.moduleName : "exports";\n                //    this.writeToOutput(" = " + modName + "." + className);\n                //}\n\n                var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;\n                var baseNameDecl: AST = null;\n                var baseName: AST = null;\n\n                if (hasBaseClass) {\n                    this.writeLineToOutput(" = (function (_super) {");\n                } else {\n                    this.writeLineToOutput(" = (function () {");\n                }\n\n                this.recordSourceMappingNameStart(className);\n                this.indenter.increaseIndent();\n\n                if (hasBaseClass) {\n                    baseNameDecl = classDecl.extendsList.members[0];\n                    baseName = baseNameDecl.nodeType == NodeType.Call ? (<CallExpression>baseNameDecl).target : baseNameDecl;\n                    this.emitIndent();\n                    this.writeLineToOutput("__extends(" + className + ", _super);");\n                }\n\n                this.emitIndent();\n\n                var constrDecl = classDecl.constructorDecl;\n\n                // output constructor\n                if (constrDecl) {\n                    // declared constructor\n                    this.emitJavascript(classDecl.constructorDecl, TokenID.OpenParen, false);\n\n                }\n                else {\n                    var wroteProps = 0;\n\n                    this.recordSourceMappingStart(classDecl);\n                    // default constructor\n                    this.indenter.increaseIndent();\n                    this.writeToOutput("function " + classDecl.name.actualText + "() {");\n                    this.recordSourceMappingNameStart("constructor");\n                    if (hasBaseClass) {\n                        this.writeLineToOutput("");\n                        this.emitIndent();\n                        this.writeLineToOutput("_super.apply(this, arguments);");\n                        wroteProps++;\n                    }\n\n                    if (classDecl.varFlags & VarFlags.MustCaptureThis) {\n                        this.writeCaptureThisStatement(classDecl);\n                    }\n\n                    var members = (<ASTList>this.thisClassNode.members).members\n\n                    // output initialized properties\n                    for (var i = 0; i < members.length; i++) {\n                        if (members[i].nodeType == NodeType.VarDecl) {\n                            var varDecl = <VarDecl>members[i];\n                            if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                                this.writeLineToOutput("");\n                                this.emitIndent();\n                                this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                                wroteProps++;\n                            }\n                        }\n                    }\n                    if (wroteProps) {\n                        this.writeLineToOutput("");\n                        this.indenter.decreaseIndent();\n                        this.emitIndent();\n                        this.writeLineToOutput("}");\n                    }\n                    else {\n                        this.writeLineToOutput(" }");\n                        this.indenter.decreaseIndent();\n                    }\n                    this.recordSourceMappingNameEnd();\n                    this.recordSourceMappingEnd(classDecl);\n                }\n\n                var membersLen = classDecl.members.members.length;\n                for (var j = 0; j < membersLen; j++) {\n\n                    var memberDecl: AST = classDecl.members.members[j];\n\n                    if (memberDecl.nodeType == NodeType.FuncDecl) {\n                        var fn = <FuncDecl>memberDecl;\n\n                        if (hasFlag(fn.fncFlags, FncFlags.Method) && !fn.isSignature()) {\n                            if (!hasFlag(fn.fncFlags, FncFlags.Static)) {\n                                this.emitPrototypeMember(fn, className);\n                            }\n                            else { // static functions\n                                if (fn.isAccessor()) {\n                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.actualText, false);\n                                }\n                                else {\n                                    this.emitIndent();\n                                    this.recordSourceMappingStart(fn)\n                                    this.writeToOutput(classD';
var v27638 = v27639 + 'ecl.name.actualText + "." + fn.name.actualText + " = ");\n                                    this.emitInnerFunction(fn, (fn.name && !fn.name.isMissing()), true,\n                                            null, Emitter.shouldCaptureThis(fn), null);\n                                    this.writeLineToOutput(";");\n                                }\n                            }\n                        }\n                    }\n                    else if (memberDecl.nodeType == NodeType.VarDecl) {\n                        var varDecl = <VarDecl>memberDecl;\n                        if (hasFlag(varDecl.varFlags, VarFlags.Static)) {\n\n                            if (varDecl.init) {\n                                // EMITREVIEW\n                                this.emitIndent();\n                                this.recordSourceMappingStart(varDecl);\n                                this.writeToOutput(classDecl.name.actualText + "." + varDecl.id.actualText + " = ");\n                                this.emitJavascript(varDecl.init, TokenID.Equals, false);\n                                // EMITREVIEW\n\n                                this.writeLineToOutput(";");\n                                this.recordSourceMappingEnd(varDecl);\n                            }\n                        }\n                    }\n                    else {\n                        throw Error("We want to catch this");\n                    }\n                }\n\n                this.emitIndent();\n                this.recordSourceMappingStart(classDecl.endingToken);\n                this.writeLineToOutput("return " + className + ";");\n                this.recordSourceMappingEnd(classDecl.endingToken);\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.recordSourceMappingStart(classDecl.endingToken);\n                this.writeToOutput("}");\n                this.recordSourceMappingNameEnd();\n                this.recordSourceMappingEnd(classDecl.endingToken);\n                this.recordSourceMappingStart(classDecl);\n                this.writeToOutput(")(");\n                if (hasBaseClass)\n                    this.emitJavascript(baseName, TokenID.Tilde, false);\n                this.writeToOutput(");");\n                this.recordSourceMappingEnd(classDecl);\n\n                if ((temp == EmitContainer.Module || temp == EmitContainer.DynamicModule) && hasFlag(classDecl.varFlags, VarFlags.Exported)) {\n                    this.writeLineToOutput("");\n                    this.emitIndent();\n                    var modName = temp == EmitContainer.Module ? this.moduleName : "exports";\n                    this.recordSourceMappingStart(classDecl);\n                    this.writeToOutput(modName + "." + className + " = " + className + ";");\n                    this.recordSourceMappingEnd(classDecl);\n                }\n\n                this.emitIndent();\n                this.recordSourceMappingEnd(classDecl);\n                this.emitParensAndCommentsInPlace(classDecl, false);\n                this.setContainer(temp);\n                this.thisClassNode = svClassNode;\n            }\n        }\n\n        public emitPrologue(reqInherits: bool) {\n            if (!this.prologueEmitted) {\n                if (reqInherits) {\n                    this.prologueEmitted = true;\n                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");\n                    this.writeLineToOutput("    function __() { this.constructor = d; }");\n                    this.writeLineToOutput("    __.prototype = b.prototype;");\n                    this.writeLineToOutput("    d.prototype = new __();");\n                    this.writeLineToOutput("};");\n                }\n                if (this.checker.mustCaptureGlobalThis) {\n                    this.prologueEmitted = true;\n                    this.writeLineToOutput(this.captureThisStmtString);\n                }\n            }\n        }\n\n        public emitSuperReference() {\n            this.writeToOutput("_super.prototype");\n        }\n\n        public emitSuperCall(callEx: CallExpression): bool {\n            if (callEx.target.nodeType == NodeType.Dot) {\n                var dotNode = <BinaryExpression>callEx.target;\n                if (dotNode.operand1.nodeType == NodeType.Super) {\n                    this.emitJavascript(dotNode, TokenID.OpenParen, false);\n                    this.writeToOutput(".call(");\n                    this.emitThis();\n                    if (callEx.arguments && callEx.arguments.members.length > 0) {\n                        this.writeToOutput(", ");\n                        this.emitJavascriptList(callEx.arguments, ", ", TokenID.Comma, false, false, false);\n                    }\n                    this.writeToOutput(")");\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public emitThis() {\n            if (this.thisFnc && !this.thisFnc.isMethod() && (!this.thisFnc.isConstructor)) {\n          ';
var v27637 = v27638 + '      this.writeToOutput("_this");\n            }\n            else {\n                this.writeToOutput("this");\n            }\n        }\n\n        private static shouldCaptureThis(func: FuncDecl): bool {\n            // Super calls use \'this\' reference. If super call is in a lambda, \'this\' value needs to be captured in the parent.\n            return func.hasSelfReference() || func.hasSuperReferenceInFatArrowFunction();\n        }\n\n        private createFile(fileName: string, useUTF8: bool): ITextWriter {\n            try {\n                return this.emitOptions.ioHost.createFile(fileName, useUTF8);\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export interface ILineCol {\n        line: number;\n        col: number;\n    }\n\n    export class ErrorReporter {\n        public parser: Parser = null;\n        public checker: TypeChecker = null;\n        public lineCol = { line: 0, col: 0 };\n        public emitAsComments = true;\n        public hasErrors = false;\n        public pushToErrorSink = false;\n        public errorSink: string[] = [];\n\n        constructor (public outfile: ITextWriter) { }\n\n        public getCapturedErrors() { return this.errorSink; }\n        public freeCapturedErrors() { this.errorSink = []; }\n        public captureError(emsg: string) { this.errorSink[this.errorSink.length] = emsg; }\n\n        public setErrOut(outerr) {\n            this.outfile = outerr;\n            this.emitAsComments = false;\n        }\n\n        public emitPrefix() {\n            if (this.emitAsComments) {\n                this.outfile.Write("// ");\n            }\n            this.outfile.Write(this.checker.locationInfo.filename + "(" + this.lineCol.line + "," + this.lineCol.col + "): ");\n        }\n\n        public writePrefix(ast: AST): void {\n            if (ast) {\n                this.setError(ast);\n            }\n            else {\n                this.lineCol.line = 0;\n                this.lineCol.col = 0;\n            }\n            this.emitPrefix();\n        }\n\n        public writePrefixFromSym(symbol: Symbol): void {\n            if (symbol && this.checker.locationInfo.lineMap) {\n                getSourceLineColFromMap(this.lineCol, symbol.location,\n                                        this.checker.locationInfo.lineMap);\n            }\n            else {\n                this.lineCol.line = -1;\n                this.lineCol.col = -1;\n            }\n            this.emitPrefix();\n        }\n\n        public setError(ast: AST) {\n            if (ast) {\n                ast.flags |= ASTFlags.Error;\n                if (this.checker.locationInfo.lineMap) {\n                    getSourceLineColFromMap(this.lineCol, ast.minChar, this.checker.locationInfo.lineMap);\n                }\n            }\n        }\n\n        public reportError(ast: AST, message: string) {\n            if (this.pushToErrorSink) {\n                this.captureError(message);\n                return;\n            }\n\n            this.hasErrors = true;\n            if (ast && this.parser.errorRecovery && this.parser.errorCallback) {\n                var len = (ast.limChar - ast.minChar);\n                this.parser.errorCallback(ast.minChar, len, message, this.checker.locationInfo.unitIndex);\n            }\n            else {\n                this.writePrefix(ast);\n                this.outfile.WriteLine(message); // Right after the semi-colon\n            }\n        }\n\n        public reportErrorFromSym(symbol: Symbol, message: string) {\n            if (this.pushToErrorSink) {\n                this.captureError(message);\n                return;\n            }\n\n            this.hasErrors = true;\n            if (this.parser.errorRecovery && this.parser.errorCallback) {\n                this.parser.errorCallback(symbol.location, symbol.length, message, this.checker.locationInfo.unitIndex);\n            }\n            else {\n                this.writePrefixFromSym(symbol);\n                this.outfile.WriteLine(message);\n            }\n        }\n\n        public emitterError(ast: AST, message: string) {\n            this.reportError(ast, message);\n            // Emitter errors are not recoverable, stop immediately\n            throw Error("EmitError");\n        }\n\n        public duplicateIdentifier(ast: AST, name: string) {\n            this.reportError(';
var v27636 = v27637 + 'ast, "Duplicate identifier \'" + name + "\'");\n        }\n\n        public showRef(ast: AST, text: string, symbol: Symbol) {\n            var defLineCol = { line: -1, col: -1 };\n            // TODO: multiple def locations\n            this.parser.getSourceLineCol(defLineCol, symbol.location);\n            this.reportError(ast, "symbol " + text + " defined at (" + defLineCol.line + "," +\n                              defLineCol.col + ")");\n        }\n\n        public unresolvedSymbol(ast: AST, name: string) {\n            this.reportError(ast, "The name \'" + name + "\' does not exist in the current scope");\n        }\n\n        public symbolDoesNotReferToAValue(ast: AST, name: string): void {\n            this.reportError(ast, "The name \'" + name + "\' does not refer to a value");\n        }\n\n        public styleError(ast: AST, msg: string): void {\n            var bkThrow = this.pushToErrorSink;\n            this.pushToErrorSink = false;\n            this.reportError(ast, "STYLE: " + msg);\n            this.pushToErrorSink = bkThrow;\n        }\n\n        public simpleError(ast: AST, msg: string): void {\n            this.reportError(ast, msg);\n        }\n\n        public simpleErrorFromSym(sym: Symbol, msg: string): void {\n            this.reportErrorFromSym(sym, msg);\n        }\n\n        public invalidSuperReference(ast: AST) {\n            this.simpleError(ast, "Keyword \'super\' can only be used inside a class instance method");\n        }\n\n        public valueCannotBeModified(ast: AST) {\n            this.simpleError(ast, "The left-hand side of an assignment expression must be a variable, property or indexer");\n        }\n\n        public invalidCall(ast: CallExpression, nodeType: number, scope: SymbolScope): void {\n            var targetType = ast.target.type;\n            var typeName = targetType.getScopedTypeName(scope);\n            if (targetType.construct && (nodeType == NodeType.Call)) {\n                this.reportError(ast, "Value of type \'" + typeName + "\' is not callable.  Did you mean to include \'new\'?");\n            } else {\n                var catString = (nodeType == NodeType.Call) ? "callable" : "newable";\n\n                this.reportError(ast, "Value of type \'" + typeName + "\' is not " + catString);\n            }\n        }\n\n        public indexLHS(ast: BinaryExpression, scope: SymbolScope): void {\n            var targetType = ast.operand1.type.getScopedTypeName(scope);\n            var indexType = ast.operand2.type.getScopedTypeName(scope);\n            this.simpleError(ast, "Value of type \'" + targetType + "\' is not indexable by type \'" + indexType + "\'");\n        }\n\n        public incompatibleTypes(ast: AST, t1: Type, t2: Type, op: string, scope: SymbolScope, comparisonInfo?:TypeComparisonInfo) {\n            if (!t1) {\n                t1 = this.checker.anyType;\n            }\n            if (!t2) {\n                t2 = this.checker.anyType;\n            }\n\n            var reason = comparisonInfo ? comparisonInfo.message : "";\n            if (op) {\n                this.reportError(ast, "Operator \'" + op + "\' cannot be applied to types \'" + t1.getScopedTypeName(scope) +\n                                  "\' and \'" + t2.getScopedTypeName(scope) + "\'" + (reason ? ": " + reason : ""));\n            }\n            else {\n                this.reportError(ast, "Cannot convert \'" + t1.getScopedTypeName(scope) +\n                                  "\' to \'" + t2.getScopedTypeName(scope) + "\'" + (reason ? ": " + reason : ""));\n            }\n        }\n\n        public expectedClassOrInterface(ast: AST): void {\n            this.simpleError(ast, "Expected var, class, interface, or module");\n        }\n\n        public unaryOperatorTypeError(ast: AST, op: string, type: Type) {\n            this.reportError(ast, "Operator \'" + op + "\' cannot be applied to type \'" + type.getTypeName() + "\'");\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export function hasFlag(val: number, flag: number) {\n        return (val & flag) != 0;\n    }\n\n    export enum ErrorRecoverySet {\n        None = 0,\n        Comma = 1, // Comma\n        SColon = 1 << 1, // SColon\n        Asg = 1 << 2, // Asg\n        BinOp = 1 << 3, // Lsh, Rsh, Rs2, Le, Ge, INSTANCEOF, EQ, NE, Eqv, NEqv, LogAnd, LogOr, AsgMul, AsgDiv\n        // AsgMod, AsgAdd, AsgSub, AsgLsh, AsgRsh, AsgRs2, AsgAnd, AsgXor, AsgOr, QMark, Mult, Div, \n        // Pct, GT, LT, ';
var v27635 = v27636 + "And, Xor, Or\n        RBrack = 1 << 4, // RBrack\n        RCurly = 1 << 5, // RCurly\n        RParen = 1 << 6, // RParen\n        Dot = 1 << 7, // Dot\n        Colon = 1 << 8, // Colon\n        PrimType = 1 << 9, // number, string, bool\n        AddOp = 1 << 10, // Add, Sub\n        LCurly = 1 << 11, // LCurly\n        PreOp = 1 << 12, // Tilde, Bang, Inc, Dec\n        RegExp = 1 << 13, // RegExp\n        LParen = 1 << 14, // LParen\n        LBrack = 1 << 15, // LBrack\n        Scope = 1 << 16, // Scope\n        In = 1 << 17, // IN\n        SCase = 1 << 18, // CASE, DEFAULT\n        Else = 1 << 19, // ELSE\n        Catch = 1 << 20, // CATCH, FINALLY\n        Var = 1 << 21, // \n        Stmt = 1 << 22, // BREAK, RETURN, THROW, DEBUGGER, FOR, SWITCH, DO, IF, TRY, WITH\n        While = 1 << 23, // WHILE\n        ID = 1 << 24, // ID\n        Prefix = 1 << 25, // VOID, DELETE, TYPEOF, AWAIT\n        Literal = 1 << 26, // IntCon, FltCon, StrCon\n        RLit = 1 << 27, // THIS, TRUE, FALSE, NULL\n        Func = 1 << 28, // FUNCTION\n        EOF = 1 << 29, // EOF\n\n        // REVIEW: Name this something clearer.\n        TypeScriptS = 1 << 30, // PROPERTY, PRIVATE, STATIC, INTERFACE, CLASS, MODULE, EXPORT, IMPORT\n        ExprStart = SColon | AddOp | LCurly | PreOp | RegExp | LParen | LBrack | ID | Prefix | RLit | Func | Literal,\n        StmtStart = ExprStart | SColon | Var | Stmt | While | TypeScriptS,\n        Postfix = Dot | LParen | LBrack,\n    }\n\n    export enum AllowedElements {\n        None = 0,\n        ModuleDeclarations = 1 << 2,\n        ClassDeclarations = 1 << 3,\n        InterfaceDeclarations = 1 << 4,\n        AmbientDeclarations = 1 << 10,\n        Properties = 1 << 11,\n\n        Global = ModuleDeclarations | ClassDeclarations | InterfaceDeclarations | AmbientDeclarations,\n        QuickParse = Global | Properties,\n    }\n\n    export enum Modifiers {\n        None = 0,\n        Private = 1,\n        Public = 1 << 1,\n        Readonly = 1 << 2,\n        Ambient = 1 << 3,\n        Exported = 1 << 4,\n        Getter = 1 << 5,\n        Setter = 1 << 6,\n        Static = 1 << 7,\n    }\n\n    export enum ASTFlags {\n        None = 0,\n        ExplicitSemicolon = 1, // statment terminated by an explicit semicolon\n        AutomaticSemicolon = 1 << 1, // statment terminated by an automatic semicolon\n        Writeable = 1 << 2,  // node is lhs that can be modified\n        Error = 1 << 3, // node has an error\n        DotLHSPartial = 1 << 4, // node is the lhs of an incomplete dot expr at cursor\n        DotLHS = 1 << 5, // node is the lhs of a dot expr\n        IsStatement = 1 << 6, // node is a statement\n        StrictMode = 1 << 7, // node is in the strict mode environment\n        PossibleOptionalParameter = 1 << 8,\n        ClassBaseConstructorCall = 1 << 9,\n        OptionalName = 1 << 10,\n        // REVIEW: This flag is to mark lambda nodes to note that the LParen of an expression has already been matched in the lambda header.\n        //         The flag is used to communicate this piece of information to the calling parseTerm, which intern will remove it.\n        //         Once we have a better way to associate information with nodes, this flag should not be used.\n        SkipNextRParen = 1 << 11, \n    }\n\n    export enum DeclFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n    }\n\n    export enum ModuleFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        IsEnum = 1 << 8,\n        ShouldEmitModuleDecl = 1 << 9,\n        IsWholeFile = 1 << 10,\n        IsDynamic = 1 << 11,\n        MustCaptureThis = 1 << 12,\n    }\n\n    export enum SymbolFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        Property = 1 << 8,\n        Readonly = 1 << 9,\n        ModuleMember = 1 << 10,\n        InterfaceMember = 1 << 11,\n        ClassMember = 1 << 12,\n        BuiltIn = 1 << 13,\n        TypeSetDuringScopeAssignment = 1 << 14,\n        Constant = 1 << 15,\n        Optional = 1 << 16,\n        RecursivelyReferenced = 1 << 17,\n        Bound = 1 << 18,\n        CompilerGenerated = 1 << 19,\n    }\n\n    export enum VarFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        AutoInit = 1 << 8,\n        Property = 1 << 9,\n        Readonly = 1 << 10,\n        Class = 1 << 11,\n        ClassProperty = 1 << 12,\n        ClassBodyProperty = 1 << 13,";
var v27634 = v27635 + '\n        ClassConstructorProperty = 1 << 14,\n        ClassSuperMustBeFirstCallInConstructor = 1 << 15,\n        Constant = 1 << 16,\n        MustCaptureThis = 1 << 17,\n    }\n\n    export enum FncFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        Definition = 1 << 8,\n        Signature = 1 << 9,\n        Method = 1 << 10,\n        HasReturnExpression = 1 << 11,\n        CallMember = 1 << 12,\n        ConstructMember = 1 << 13,\n        HasSelfReference = 1 << 14,\n        IsFatArrowFunction = 1 << 15,\n        IndexerMember = 1 << 16,\n        IsFunctionExpression = 1 << 17,\n        ClassMethod = 1 << 18,\n        ClassPropertyMethodExported = 1 << 19,\n        HasSuperReferenceInFatArrowFunction = 1 << 20,\n        IsPropertyBound = 1 << 21,\n    }\n\n    export enum SignatureFlags {\n        None = 0,\n        IsIndexer = 1,\n        IsStringIndexer = 1 << 1,\n        IsNumberIndexer = 1 << 2,\n    }\n\n    export function ToDeclFlags(fncFlags: FncFlags) : DeclFlags;\n    export function ToDeclFlags(varFlags: VarFlags) : DeclFlags;\n    export function ToDeclFlags(symFlags: SymbolFlags): DeclFlags;\n    export function ToDeclFlags(moduleFlags: ModuleFlags): DeclFlags;\n    export function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags: any) {\n        return <DeclFlags>fncOrVarOrSymbolOrModuleFlags;\n    }\n\n    export enum TypeFlags {\n        None = 0,\n        HasImplementation = 1,\n        HasSelfReference = 1 << 1,\n        MergeResult = 1 << 2,\n        IsEnum = 1 << 3,\n        BuildingName = 1 << 4,\n        HasBaseType = 1 << 5,\n        HasBaseTypeOfObject = 1 << 6,\n        IsClass = 1 << 7,\n    }\n\n    export enum TypeRelationshipFlags {\n        SuccessfulComparison = 0,\n        SourceIsNullTargetIsVoidOrUndefined = 1,\n        RequiredPropertyIsMissing = 1 << 1,\n        IncompatibleSignatures = 1 << 2,\n        SourceSignatureHasTooManyParameters = 3,\n        IncompatibleReturnTypes = 1 << 4,\n        IncompatiblePropertyTypes = 1 << 5,\n        IncompatibleParameterTypes = 1 << 6,\n    }\n\n    export enum CodeGenTarget {\n        ES3 = 0,\n        ES5 = 1,\n    }\n\n    export enum ModuleGenTarget {\n        Synchronous = 0,\n        Asynchronous = 1,\n        Local = 1 << 1,\n    }\n\n    // Compiler defaults to generating ES5-compliant code for\n    //  - getters and setters\n    export var codeGenTarget: CodeGenTarget = CodeGenTarget.ES3;\n\n    export var moduleGenTarget: ModuleGenTarget = ModuleGenTarget.Synchronous;\n\n    export var optimizeModuleCodeGen = true;\n\n    export function flagsToString(e, flags: number): string {\n        var builder = "";\n        for (var i = 1; i < (1 << 31) ; i = i << 1) {\n            if ((flags & i) != 0) {\n                for (var k in e) {\n                    if (e[k] == i) {\n                        if (builder.length > 0) {\n                            builder += "|";\n                        }\n                        builder += k;\n                        break;\n                    }\n                }\n            }\n        }\n        return builder;\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export class BlockIntrinsics {\n        public prototype = undefined;\n        public toString = undefined;\n        public toLocaleString = undefined;\n        public valueOf = undefined;\n        public hasOwnProperty = undefined;\n        public propertyIsEnumerable = undefined;\n        public isPrototypeOf = undefined;\n\n        constructor () {\n            // initialize the \'constructor\' field\n            this["constructor"] = undefined;\n        }\n    }\n\n    export interface IHashTable {\n        getAllKeys(): string[];\n        add(key: string, data): bool;\n        addOrUpdate(key: string, data): bool;\n        map(fn: (k: string, v, c) => void , context): void;\n        every(fn: (k: string, v, c) => bool, context): bool;\n        some(fn: (k: string, v, c) => bool, context): bool;\n        count(): number;\n        lookup(key: string): any;\n    }\n\n    export class StringHashTable implements IHashTable {\n        public itemCount = 0;\n        public table = <any>(<any> new BlockIntrinsics());\n\n        public getAllKeys(): string[]{\n            var result: string[] = [];\n            for (var k in this.table) {\n ';
var v27633 = v27634 + "               if (this.table[k] != undefined) {\n                    result[result.length] = k;\n                }\n            }\n            return result;\n        }\n\n        public add(key: string, data): bool {\n            if (this.table[key] != undefined) {\n                return false;\n            }\n            this.table[key] = data;\n            this.itemCount++;\n            return true;\n        }\n\n        public addOrUpdate(key: string, data): bool {\n            if (this.table[key] != undefined) {\n                this.table[key] = data;\n                return false;\n            }\n            this.table[key] = data;\n            this.itemCount++;\n            return true;\n        }\n\n        public map(fn: (k: string, v, c) => void , context) {\n            for (var k in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    fn(k, this.table[k], context);\n                }\n            }\n        }\n\n        public every(fn: (k: string, v, c) => bool, context) {\n            for (var k in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    if (!fn(k, this.table[k], context)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        public some(fn: (k: string, v, c) => bool, context) {\n            for (var k in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    if (fn(k, this.table[k], context)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        public count(): number { return this.itemCount; }\n\n        public lookup(key: string) {\n            var data = this.table[key];\n            if (data != undefined) {\n                return data;\n            }\n            else {\n                return (null);\n            }\n        }\n    }\n\n    // The resident table is expected to reference the same table object, whereas the \n    // transientTable may reference different objects over time\n    // REVIEW:  WARNING:  For performance reasons, neither the primary nor secondary table may be null\n    export class DualStringHashTable implements IHashTable {\n\n        public insertPrimary = true;\n\n        constructor (public primaryTable: IHashTable,\n                                        public secondaryTable: IHashTable) { }\n\n        public getAllKeys(): string[]{\n            return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys());\n        }\n\n        public add(key: string, data): bool {\n            if (this.insertPrimary) {\n                return this.primaryTable.add(key, data);\n            }\n            else {\n                return this.secondaryTable.add(key, data);\n            }\n        }\n\n        public addOrUpdate(key: string, data): bool {\n            if (this.insertPrimary) {\n                return this.primaryTable.addOrUpdate(key, data);\n            }\n            else {\n                return this.secondaryTable.addOrUpdate(key, data);\n            }\n        }\n\n        public map(fn: (k: string, v, c) => void , context) {\n            this.primaryTable.map(fn, context);\n            this.secondaryTable.map(fn, context);\n        }\n\n        public every(fn: (k: string, v, c) => bool, context) {\n            return this.primaryTable.every(fn, context) && this.secondaryTable.every(fn, context);\n        }\n\n        public some(fn: (k: string, v, c) => bool, context) {\n            return this.primaryTable.some(fn, context) || this.secondaryTable.some(fn, context);\n        }\n\n        public count() {\n            return this.primaryTable.count() + this.secondaryTable.count();\n        }\n\n        public lookup(key: string) {\n            var data = this.primaryTable.lookup(key);\n            if (data != undefined) {\n                return data;\n            }\n            else {\n                return this.secondaryTable.lookup(key);\n            }\n        }\n    }\n\n    export function numberHashFn(key: number): number {\n        var c2 = 0x27d4eb2d; // a prime or an odd constant\n        key = (key ^ 61) ^ (key >>> 16);\n        key = key + (key << 3);\n        key = key ^ (key >>> 4);\n        key = key * c2;\n        key = key ^ (key >>> 15);\n        return key;\n    }\n\n    export function combineHashes(key1: number, key2: number) {\n        return key2 ^ ((key1 >> 5) + key1);\n    }\n\n    export class HashEntry {\n        public next: HashEntry;\n\n        constructor (public key, public data) { }\n    }\n\n    export class HashTable {\n        public itemCount: number = 0;\n        public table = new HashEntry[];\n\n        constructor (public size: number, public hashFn: (key) =>number,\n                    public equalsFn: (key1, key2) =>bool) {\n            for (var i: number = 0; i < this.size; i++) {\n                this.table[i] = null;\n            }\n        }\n\n        publi";
var v27632 = v27633 + 'c add(key, data): bool {\n            var current: HashEntry;\n            var entry: HashEntry = new HashEntry(key, data);\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    return false;\n                }\n            }\n            entry.next = this.table[val];\n            this.table[val] = entry;\n            this.itemCount++;\n            return true;\n        }\n\n        public remove(key) {\n            var current: HashEntry;\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n            var result = null;\n            var prevEntry: HashEntry = null;\n\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    result = current.data;\n                    this.itemCount--;\n                    if (prevEntry) {\n                        prevEntry.next = current.next;\n                    }\n                    else {\n                        this.table[val] = current.next;\n                    }\n                    break;\n                }\n                prevEntry = current;\n            }\n            return result;\n        }\n\n        public count(): number { return this.itemCount; }\n\n        public lookup(key) {\n            var current: HashEntry;\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    return (current.data);\n                }\n            }\n            return (null);\n        }\n    }\n\n    // Simple Hash table with list of keys and values matching each other at the given index\n    export class SimpleHashTable {\n        private keys = [];\n        private values = [];\n\n        public lookup(key, findValue?: bool) {\n            var searchArray = this.keys;\n            if (findValue) {\n                searchArray = this.values;\n            }\n\n            for (var i = 0; i < searchArray.length; i++) {\n                if (searchArray[i] == key) {\n                    return {\n                        key: this.keys[i],\n                        data: this.values[i],\n                    };\n                }\n            }\n            return null;\n        }\n\n        public add(key, data): bool {\n            var lookupData = this.lookup(key);\n            if (lookupData) {\n                return false;\n            }\n\n            this.keys[this.keys.length] = key;\n            this.values[this.values.length] = data;\n\n            return true;\n        }\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export class IncrementalParser {\n        \n        private astLogger: AstLogger;\n\n        constructor (private logger: TypeScript.ILogger) {\n            this.astLogger = new AstLogger(this.logger);\n        }\n\n        //\n        // Return "null" if "editRange" cannot be safely determined to be inside a single scope.\n        //\n        public getEnclosingScopeContextIfSingleScopeEdit(previousScript: Script, scriptId: string, newSourceText: ISourceText, editRange: ScriptEditRange): EnclosingScopeContext {\n            this.logger.log("checkEditsInsideSingleScope(\\"" + scriptId + "\\")");\n\n            if (editRange === null) {\n                throw new Error("editRange should be valid");\n            }\n\n            if (editRange.isUnknown()) {\n                this.logger.log("  Bailing out because edit range is unknown");\n                return null;\n            }\n\n            var scope1 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.minChar, false/*isMemberCompletion*/);\n            var scope2 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.limChar, false/*isMemberCompletion*/);\n            if (scope1 == null || scope2 == null) {\n                this.logger.log("  Bailing out because containing scopes cannot be determined");\n                return null;\n            }\n\n            // We only support changes within a single containing scope\n            if (scope1.scopeStartAST !== scope2.scopeStartAST) {\n      ';
var v27631 = v27632 + '          this.logger.log("  Bailing out because edit overlaps 2 disctint scopes");\n                return null;\n            }\n\n            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;\n            if (newScopeLength <= 0) {\n                this.logger.log("  Bailing out because scope has been entirely removed from new source text");\n                return null;\n            }\n\n            return scope1;\n        }\n\n        public attemptIncrementalUpdateUnit(previousScript: Script, scriptId: string, newSourceText: ISourceText, editRange: ScriptEditRange): UpdateUnitResult {\n            this.logger.log("attemptIncrementalUpdateUnit(\\"" + scriptId + "\\")");\n\n            if (editRange === null) {\n                throw new Error("editRange should be valid");\n            }\n\n            var scope1 = this.getEnclosingScopeContextIfSingleScopeEdit(previousScript, scriptId, newSourceText, editRange);\n            if (scope1 === null) {\n                return null;\n            }\n\n            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;\n\n            // Heuristic: if the range to reparse is too big, bail out. \n            // This is because a full parse will be faster than an incremental parse followed by all the necessary fix-ups \n            if (newScopeLength >= newSourceText.getLength() / 2) {\n                this.logger.log("  Bailing out because range of scope to reparse (" + newScopeLength + " characters) is greater than half the size of the source text");\n                return null;\n            }\n\n            // Capture parsing errors so that they are part of "updateResult"\n            var parseErrors: TypeScript.ErrorEntry[] = [];\n            var errorCapture = function(minChar: number, charLen: number, message: string, unitIndex: number): void {\n                parseErrors.push(new TypeScript.ErrorEntry(unitIndex, minChar, minChar + charLen, message));\n            };\n\n            var quickParseResult = TypeScript.quickParse(this.logger, scope1.scopeStartAST, newSourceText, scope1.scopeStartAST.minChar, scope1.scopeStartAST.minChar + newScopeLength, errorCapture);\n            if (quickParseResult.endLexState != TypeScript.LexState.Start) {\n                this.logger.log("  Bailing out because scope contains unterminated comment");\n                return null;\n            }\n\n            var scriptFragment = quickParseResult.Script;\n            if (scriptFragment.vars.members.length !== 0) {\n                this.logger.log("  Bailing out because new source text defines variables");\n                return null;\n            }\n\n            //if (scriptFragment.scopes.members.length !== 1) {\n            //    logger.log("  Bailing out because new source text defines more than one scope (or none)");\n            //    return null;\n            //}\n\n            // This detects adding close curlies, since they have the side effect of having the parser \n            // parse more members in the scope range.\n            if (scriptFragment.bod.members.length !== 1) {\n                this.logger.log("  Bailing out because new source text defines more than one scope (or none)");\n                return null;\n            }\n\n            var oldScope = scope1.scopeStartAST;\n            var newScope = scriptFragment.bod.members[0];\n\n            if (oldScope.nodeType != newScope.nodeType) {\n                this.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope");\n                return null;\n            }\n\n            if (!(<any>oldScope).leftCurlyCount || !(<any>oldScope).rightCurlyCount) {\n                this.logger.log("  Bailing out because sopce doesn\'t have left/right curly count");\n                return null;\n            }\n\n            if ((<any>oldScope).leftCurlyCount !== (<any>newScope).leftCurlyCount) {\n                this.logger.log("  Bailing out because new source text contains more (or fewer) left curly braces");\n                return null;\n            }\n\n            if ((<any>oldScope).rightCurlyCount !== (<any>newScope).rightCurlyCount) {\n                this.logger.log("  Bailing out because new source text contains more (or fewer) right curly braces");\n                return null;\n            }\n\n            if (newScope.minChar !== 0) {\n                this.logger.log("  Bailing out because new function declaration does not start at position 0");\n                return null;\n            }\n\n            if (newScope.limChar !== newScopeLength) {\n                this.logger.log("  Bailing out because new function declaration does not end at the new end position");\n                return null;\n            }\n\n            return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript, scriptFragment, oldScope, newScope, editRange, parseErrors);\n        }\n\n        public mergeTrees(updateResult: UpdateUnitResult): void {\n            TypeScript.timeF';
var v27630 = v27631 + 'unction(this.logger, "mergeTrees()", () => {\n                var editRange = new ScriptEditRange(updateResult.scope1.minChar, updateResult.scope1.limChar, updateResult.editRange.delta);\n                // Update positions in current ast\n                this.applyDeltaPosition(updateResult.script1, editRange.limChar, editRange.delta);\n                // Update positions in new (partial) ast\n                this.applyDeltaPosition(updateResult.script2, 0, editRange.minChar);\n                // Merge linemaps\n                this.mergeLocationInfo(updateResult.script1, updateResult.script2, editRange);\n                //  Replace old AST for scope with new one\n                this.replaceAST(updateResult.script1, updateResult.scope1, updateResult.scope2);\n            });\n        }\n\n        private replaceAST(script: TypeScript.AST, oldAst: TypeScript.AST, newAst: TypeScript.AST) {\n            var pre = (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) => {\n                if (cur === oldAst) {\n                    // Transfer comments ownership to new AST. We need this because when "quick parsing" the\n                    // new AST, we don\'t take into account the text before and after the "minChar/limChar" pair\n                    // of the scope, which don\'t include pre/post-comments.\n                    newAst.preComments = cur.preComments;\n                    newAst.postComments = cur.postComments;\n\n                    this.logger.log("replaced old AST node with new one in script AST");\n                    walker.options.stopWalk();\n                    return newAst;\n                }\n\n                // Avoid visiting sub-trees outside of the edit range\n                if (TypeScript.isValidAstNode(cur)) {\n                    if (cur.limChar < oldAst.minChar || cur.minChar > oldAst.limChar) {\n                        walker.options.goChildren = false;\n                    }\n                }\n                return cur;\n            }\n\n            TypeScript.getAstWalkerFactory().walk(script, pre);\n        }\n\n        private mergeLocationInfo(script: TypeScript.Script, partial: TypeScript.Script, editRange: ScriptEditRange) {\n            // Don\'t merger these fields, as the original script has the right values\n            //script.locationInfo.unitIndex = partial.locationInfo.unitIndex;\n            //script.locationInfo.filename = partial.locationInfo.filename;\n\n            var lineMap1 = script.locationInfo.lineMap;\n            var lineMap2 = partial.locationInfo.lineMap;\n\n            if (this.logger.information()) {\n                this.logger.log("lineMap1 (before):");\n                this.astLogger.logLinemap(lineMap1);\n                this.logger.log("lineMap2 (quick parse):");\n                this.astLogger.logLinemap(lineMap2);\n                this.logger.log("EditRange=" + editRange);\n            }\n\n            // Skip entries < minChar\n            var i1 = 2; // lineMap[0] is always undefined, lineMap[1] is always 0.\n            var i2 = 2; // lineMap[0] is always undefined, lineMap[1] is always 0.\n            var len1 = lineMap1.length;\n            var len2 = lineMap2.length;\n            while (i1 < len1) {\n                if (lineMap1[i1] <= editRange.minChar) {\n                    // Nothing to do for this entry, since it\'s before the range of the change\n                    i1++;\n                } else if (lineMap1[i1] >= editRange.limChar) {\n                    // Apply delta to this entry, since it\'s outside the range of the change\n                    lineMap1[i1] += editRange.delta;\n                    i1++;\n                }\n                else {\n                    if (i2 < len2) {\n                        // Add a new entry to lineMap1 corresponding to lineMap2 in new range\n                        lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);\n                        i1++;\n                        len1++;\n                        i2++;\n                    }\n                    else { /* i2 >= len 2 */\n                        // Remove this entry, since there is no corresponding entry in the new map\n                        lineMap1.splice(i1, 1);\n                        len1--;\n                    }\n                }\n            }\n            // Merge the remaining entries in lineMap2 while maintaing the constraint that a lineMap is sorted\n            if (i2 < len2) {\n                // i1 >= len1 && i2 < len2 \n                if (lineMap1[len1 - 1] >= (lineMap2[i2] + editRange.minChar)) {\n                    // lineMap2 needs to be merged within lineMap1\n                    i1 = 2;\n                    while (i1 < len1 && i2 < len2) {\n                        if (lineMap1[i1] < (lineMap2[i2] + editRange.minChar)) {\n                            i1++;\n                        }\n                        else {\n                            lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);\n                            i1++;\n                            len1++;\n  ';
var v27629 = v27630 + '                          i2++;\n                        }\n                    }\n                }\n\n                // Append all the remaining entries in lineMap2 to the end of lineMap1\n                for (; i2 < len2; i2++) {\n                    lineMap1.push(lineMap2[i2] + editRange.minChar);\n                }\n            }\n\n            if (this.logger.information()) {\n                this.logger.log("lineMap1 (after merge):");\n                this.astLogger.logLinemap(lineMap1);\n            }\n        }\n\n        private applyDeltaPosition(ast: TypeScript.AST, start: number, delta: number) {\n            var applyDelta = (ast: TypeScript.AST) => {\n                if (ast.minChar !== -1 && ast.minChar >= start) {\n                    ast.minChar += delta;\n                }\n                if (ast.limChar !== -1 && ast.limChar >= start) {\n                    ast.limChar += delta;\n                }\n            }\n\n            var applyDeltaToComments = (comments: TypeScript.Comment[]) => {\n                if (comments && comments.length > 0) {\n                    for (var i = 0; i < comments.length; i++) {\n                        applyDelta(comments[i]);\n                    }\n                }\n            }\n\n            var pre = function(cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {\n                // *Before* applying delta to this, check if we need to go to children\n                if (cur.limChar !== -1 && cur.limChar < start) {\n                    walker.options.goChildren = false; // Done with applying Delta for this sub-tree\n                }\n\n                // Apply delta to this node\n                applyDelta(cur);\n                applyDeltaToComments(cur.preComments);\n                applyDeltaToComments(cur.postComments);\n\n                return cur;\n            }\n\n            TypeScript.getAstWalkerFactory().walk(ast, pre);\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\ninterface IResolvedFile {\n    content: string;\n    path: string;\n}\n\ninterface IFileWatcher {\n    close(): void;\n}\n\ninterface IIO {\n    readFile(path: string): string;\n    writeFile(path: string, contents: string): void;\n    createFile(path: string, useUTF8?: bool): ITextWriter;\n    deleteFile(path: string): void;\n    dir(path: string, re?: RegExp, options?: { recursive?: bool; }): string[];\n    fileExists(path: string): bool;\n    directoryExists(path: string): bool;\n    createDirectory(path: string): void;\n    resolvePath(path: string): string;\n    dirName(path: string): string;\n    findFile(rootPath: string, partialFilePath: string): IResolvedFile;\n    print(str: string): void;\n    printLine(str: string): void;\n    arguments: string[];\n    stderr: ITextWriter;\n    stdout: ITextWriter;\n    watchFile(filename: string, callback: (string) => void ): IFileWatcher;\n    run(source: string, filename: string): void;\n    getExecutingFilePath(): string;\n    quit(exitCode?: number);\n}\n\nmodule IOUtils {\n    // Creates the directory including its parent if not already present\n    function createDirectoryStructure(ioHost: IIO, dirName: string) {\n        if (ioHost.directoryExists(dirName)) {\n            return;\n        }\n\n        var parentDirectory = ioHost.dirName(dirName);\n        if (parentDirectory != "") {\n            createDirectoryStructure(ioHost, parentDirectory);\n        }\n        ioHost.createDirectory(dirName);\n    }\n\n    // Creates a file including its directory structure if not already present\n    export function createFileAndFolderStructure(ioHost: IIO, fileName: string, useUTF8?: bool) {\n        var path = ioHost.resolvePath(fileName);\n        var dirName = ioHost.dirName(path);\n        createDirectoryStructure(ioHost, dirName);\n        return ioHost.createFile(path, useUTF8);\n    }\n\n    export function throwIOError(message: string, error: Error) {\n        var errorMessage = message;\n        if (error && error.message) {\n            errorMessage += (" " + error.message);\n        }\n        throw new Error(errorMessage);\n    }\n}\n\n// Declare dependencies needed for all supported hosts\ndeclare class Enumerator {\n    public atEnd(): bool;\n    public moveNext();\n    public item(): any;\n    constructor (o: any);\n}\ndeclare function setTimeout(callback: () =>void , ms?: number);\ndeclare var require: any;\ndeclare module process {\n    export var argv: string[];\n    export var platform: string;\n    export function on(event: st';
var v27628 = v27629 + 'ring, handler: (any) => void ): void;\n    export module stdout {\n        export function write(str: string);\n    }\n    export module stderr {\n        export function write(str: string);\n    }\n    export module mainModule {\n        export var filename: string;\n    }\n    export function exit(exitCode?: number);\n}\n\nvar IO = (function() {\n\n    // Create an IO object for use inside WindowsScriptHost hosts\n    // Depends on WSCript and FileSystemObject\n    function getWindowsScriptHostIO(): IIO {\n        var fso = new ActiveXObject("Scripting.FileSystemObject");\n        var streamObjectPool = [];\n\n        function getStreamObject(): any { \n            if (streamObjectPool.length > 0) {\n                return streamObjectPool.pop();\n            }  else {\n                return new ActiveXObject("ADODB.Stream");\n            }\n        }\n\n        function releaseStreamObject(obj: any) { \n            streamObjectPool.push(obj);\n        }\n\n        var args = [];\n        for (var i = 0; i < WScript.Arguments.length; i++) {\n            args[i] = WScript.Arguments.Item(i);\n        }\n\n        return {\n            readFile: function(path) {\n                try {\n                    var streamObj = getStreamObject();\n                    streamObj.Open();\n                    streamObj.Type = 2; // Text data\n                    streamObj.Charset = \'x-ansi\'; // Assume we are reading ansi text\n                    streamObj.LoadFromFile(path);\n                    var bomChar = streamObj.ReadText(2); // Read the BOM char\n                    streamObj.Position = 0; // Position has to be at 0 before changing the encoding\n                    if ((bomChar.charCodeAt(0) == 0xFE && bomChar.charCodeAt(1) == 0xFF)\n                        || (bomChar.charCodeAt(0) == 0xFF && bomChar.charCodeAt(1) == 0xFE)) {\n                        streamObj.Charset = \'unicode\';\n                    } else if (bomChar.charCodeAt(0) == 0xEF && bomChar.charCodeAt(1) == 0xBB) {\n                        streamObj.Charset = \'utf-8\'; \n                    }\n\n                    // Read the whole file\n                    var str = streamObj.ReadText(-1 /* read from the current position to EOS */);\n                    streamObj.Close();\n                    releaseStreamObject(streamObj);\n                    return <string>str;\n                }\n                catch (err) {\n                    IOUtils.throwIOError("Error reading file \\"" + path + "\\".", err);\n                }\n            },\n\n            writeFile: function(path, contents) {\n                var file = this.createFile(path);\n                file.Write(contents);\n                file.Close();\n            },\n\n            fileExists: function(path: string): bool {\n                return fso.FileExists(path);\n            },\n\n            resolvePath: function(path: string): string {\n                return fso.GetAbsolutePathName(path);\n            },\n\n            dirName: function(path: string): string {\n                return fso.GetParentFolderName(path);\n            },\n\n            findFile: function(rootPath: string, partialFilePath: string): IResolvedFile {\n                var path = fso.GetAbsolutePathName(rootPath) + "/" + partialFilePath;\n\n                while (true) {\n                    if (fso.FileExists(path)) {\n                        try {\n                            var content = this.readFile(path);\n                            return { content: content, path: path };\n                        }\n                        catch (err) {\n                            //Tools.CompilerDiagnostics.debugPrint("Could not find " + path + ", trying parent");\n                        }\n                    }\n                    else {\n                        rootPath = fso.GetParentFolderName(fso.GetAbsolutePathName(rootPath));\n\n                        if (rootPath == "") {\n                            return null;\n                        }\n                        else {\n                            path = fso.BuildPath(rootPath, partialFilePath);\n                        }\n                    }\n                }\n            },\n\n            deleteFile: function(path: string): void {\n                try {\n                    if (fso.FileExists(path)) {\n                        fso.DeleteFile(path, true); // true: delete read-only files\n                    }\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t delete file \'" + path + "\'.", e);\n                }\n            },\n\n            createFile: function (path, useUTF8?) {\n                try {\n                    var streamObj = getStreamObject();\n                    streamObj.Charset = useUTF8 ? \'utf-8\' : \'x-ansi\';\n                    streamObj.Open();\n                    return {\n                        Write: function (str) { streamObj.WriteText(str, 0); },\n                        WriteLine: function (str) { streamObj.WriteText(str, 1); },\n                        Close: function() {\n                            try {\n            ';
var v27627 = v27628 + '                    streamObj.SaveToFile(path, 2);\n                            } catch (saveError) {\n                                IOUtils.throwIOError("Couldn\'t write to file \'" + path + "\'.", saveError);\n                            }\n                            finally {\n                                if (streamObj.State != 0 /*adStateClosed*/) {\n                                    streamObj.Close();\n                                }\n                                releaseStreamObject(streamObj);\n                            }\n                        }\n                    };\n                } catch (creationError) {\n                    IOUtils.throwIOError("Couldn\'t write to file \'" + path + "\'.", creationError);\n                }\n            },\n\n            directoryExists: function(path) {\n                return <bool>fso.FolderExists(path);\n            },\n\n            createDirectory: function(path) {\n                try {\n                    if (!this.directoryExists(path)) {\n                        fso.CreateFolder(path);\n                    }\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t create directory \'" + path + "\'.", e);\n                }\n            },\n\n            dir: function(path, spec?, options?) {\n                options = options || <{ recursive?: bool; }>{};\n                function filesInFolder(folder, root): string[]{\n                    var paths = [];\n                    var fc: Enumerator;\n\n                    if (options.recursive) {\n                        fc = new Enumerator(folder.subfolders);\n\n                        for (; !fc.atEnd() ; fc.moveNext()) {\n                            paths = paths.concat(filesInFolder(fc.item(), root + "/" + fc.item().Name));\n                        }\n                    }\n\n                    fc = new Enumerator(folder.files);\n\n                    for (; !fc.atEnd() ; fc.moveNext()) {\n                        if (!spec || fc.item().Name.match(spec)) {\n                            paths.push(root + "/" + fc.item().Name);\n                        }\n                    }\n\n                    return paths;\n                }\n\n                var folder = fso.GetFolder(path);\n                var paths = [];\n\n                return filesInFolder(folder, path);\n            },\n\n            print: function(str) {\n                WScript.StdOut.Write(str);\n            },\n\n            printLine: function(str) {\n                WScript.Echo(str);\n            },\n\n            arguments: <string[]>args,\n            stderr: WScript.StdErr,\n            stdout: WScript.StdOut,\n            watchFile: null,\n            run: function(source, filename) {\n                try {\n                    eval(source);\n                } catch (e) {\n                    IOUtils.throwIOError("Error while executing file \'" + filename + "\'.", e);\n                }\n            },\n            getExecutingFilePath: function () {\n                return WScript.ScriptFullName;\n            },\n            quit: function (exitCode? : number = 0) {\n                try {\n                    WScript.Quit(exitCode);\n                } catch (e) {\n                }\n            }\n        }\n\n    };\n\n    // Create an IO object for use inside Node.js hosts\n    // Depends on \'fs\' and \'path\' modules\n    function getNodeIO(): IIO {\n\n        var _fs = require(\'fs\');\n        var _path = require(\'path\');\n        var _module = require(\'module\');\n\n        return {\n            readFile: function(file) {\n                try {\n                    var buffer = _fs.readFileSync(file);\n                    switch (buffer[0]) {\n                        case 0xFE:\n                            if (buffer[1] == 0xFF) {\n                                // utf16-be. Reading the buffer as big endian is not supported, so convert it to \n                                // Little Endian first\n                                var i = 0;\n                                while ((i + 1) < buffer.length) {\n                                    var temp = buffer[i]\n                                    buffer[i] = buffer[i + 1];\n                                    buffer[i + 1] = temp;\n                                    i += 2;\n                                }\n                                return buffer.toString("ucs2", 2);\n                            }\n                            break;\n                        case 0xFF:\n                            if (buffer[1] == 0xFE) {\n                                // utf16-le \n                                return buffer.toString("ucs2", 2);\n                            }\n                            break;\n                        case 0xEF:\n                            if (buffer[1] == 0xBB) {\n                                // utf-8\n                                return buffer.toString("utf8", 3);\n                            }\n                    }\n                    // Default behaviour\n                    return buffer.toString();\n                } catch ';
var v27626 = v27627 + '(e) {\n                    IOUtils.throwIOError("Error reading file \\"" + file + "\\".", e);\n                }\n            },\n            writeFile: <(path: string, contents: string) => void >_fs.writeFileSync,\n            deleteFile: function(path) {\n                try {\n                    _fs.unlinkSync(path);\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t delete file \'" + path + "\'.", e);\n                }\n            },\n            fileExists: function(path): bool {\n                return _fs.existsSync(path);\n            },\n            createFile: function(path, useUTF8?) {\n                function mkdirRecursiveSync(path) {\n                    var stats = _fs.statSync(path);\n                    if (stats.isFile()) {\n                        IOUtils.throwIOError("\\"" + path + "\\" exists but isn\'t a directory.", null);\n                    } else if (stats.isDirectory()) {\n                        return;\n                    } else {\n                        mkdirRecursiveSync(_path.dirname(path));\n                        _fs.mkdirSync(path, 0775);\n                    }\n                }\n\n                mkdirRecursiveSync(_path.dirname(path));\n\n                try {\n                    var fd = _fs.openSync(path, \'w\');\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t write to file \'" + path + "\'.", e);\n                }\n                return {\n                    Write: function(str) { _fs.writeSync(fd, str); },\n                    WriteLine: function(str) { _fs.writeSync(fd, str + \'\\r\\n\'); },\n                    Close: function() { _fs.closeSync(fd); fd = null; }\n                };\n            },\n            dir: function dir(path, spec?, options?) {\n                options = options || <{ recursive?: bool; }>{};\n\n                function filesInFolder(folder: string): string[]{\n                    var paths = [];\n\n                    var files = _fs.readdirSync(folder);\n                    for (var i = 0; i < files.length; i++) {\n                        var stat = _fs.statSync(folder + "/" + files[i]);\n                        if (options.recursive && stat.isDirectory()) {\n                            paths = paths.concat(filesInFolder(folder + "/" + files[i]));\n                        } else if (stat.isFile() && (!spec || files[i].match(spec))) {\n                            paths.push(folder + "/" + files[i]);\n                        }\n                    }\n\n                    return paths;\n                }\n\n                return filesInFolder(path);\n            },\n            createDirectory: function(path: string): void {\n                try {\n                    if (!this.directoryExists(path)) {\n                        _fs.mkdirSync(path);\n                    }\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t create directory \'" + path + "\'.", e);\n                }\n            },\n\n            directoryExists: function(path: string): bool {\n                return _fs.existsSync(path) && _fs.lstatSync(path).isDirectory();\n            },\n            resolvePath: function(path: string): string {\n                return _path.resolve(path);\n            },\n            dirName: function(path: string): string {\n                return _path.dirname(path);\n            },\n            findFile: function(rootPath: string, partialFilePath): IResolvedFile {\n                var path = rootPath + "/" + partialFilePath;\n\n                while (true) {\n                    if (_fs.existsSync(path)) {\n                        try {\n                            var content = this.readFile(path);\n                            return { content: content, path: path };\n                        } catch (err) {\n                            //Tools.CompilerDiagnostics.debugPrint(("Could not find " + path) + ", trying parent");\n                        }\n                    }\n                    else {\n                        var parentPath = _path.resolve(rootPath, "..");\n\n                        // Node will just continue to repeat the root path, rather than return null\n                        if (rootPath === parentPath) {\n                            return null;\n                        }\n                        else {\n                            rootPath = parentPath;\n                            path = _path.resolve(rootPath, partialFilePath);\n                        }\n                    }\n                }\n            },\n            print: function(str) { process.stdout.write(str) },\n            printLine: function(str) { process.stdout.write(str + \'\\n\') },\n            arguments: process.argv.slice(2),\n            stderr: {\n                Write: function(str) { process.stderr.write(str); },\n                WriteLine: function(str) { process.stderr.write(str + \'\\n\'); },\n                Close: function() { }\n            },\n            stdout: {\n                Write: function(str) { process.stdout.write(str); },\n                Write';
var v27625 = v27626 + 'Line: function(str) { process.stdout.write(str + \'\\n\'); },\n                Close: function() { }\n            },\n            watchFile: function(filename: string, callback: (string) => void ): IFileWatcher {\n                var firstRun = true;\n                var processingChange = false;\n\n                var fileChanged: any = function(curr, prev) {\n                    if (!firstRun) {\n                        if (curr.mtime < prev.mtime) {\n                            return;\n                        }\n\n                        _fs.unwatchFile(filename, fileChanged);\n                        if (!processingChange) {\n                            processingChange = true;\n                            callback(filename);\n                            setTimeout(function() { processingChange = false; }, 100);\n                        }\n                    }\n                    firstRun = false;\n                    _fs.watchFile(filename, { persistent: true, interval: 500 }, fileChanged);\n                };\n\n                fileChanged();\n                return {\n                    filename: filename,\n                    close: function() {\n                        _fs.unwatchFile(filename, fileChanged);\n                    }\n                };\n            },\n            run: function(source, filename) {\n                require.main.filename = filename;\n                require.main.paths = _module._nodeModulePaths(_path.dirname(_fs.realpathSync(filename)));\n                require.main._compile(source, filename);\n            }, \n            getExecutingFilePath: function () {\n                return process.mainModule.filename;\n            },\n            quit: process.exit\n        }\n    };\n\n    if (typeof ActiveXObject === "function")\n        return getWindowsScriptHostIO();\n    else if (typeof require === "function")\n        return getNodeIO();\n    else\n        return null; // Unsupported host\n})();\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    // Note: Any addition to the NodeType should also be supported with addition to AstWalkerDetailCallback\n    export enum NodeType {\n        None,\n        Empty,\n        EmptyExpr,\n        True,\n        False,\n        This,\n        Super,\n        QString,\n        Regex,\n        Null,\n        ArrayLit,\n        ObjectLit,\n        Void,\n        Comma,\n        Pos,\n        Neg,\n        Delete,\n        Await,\n        In,\n        Dot,\n        From,\n        Is,\n        InstOf,\n        Typeof,\n        NumberLit,\n        Name,\n        TypeRef,\n        Index,\n        Call,\n        New,\n        Asg,\n        AsgAdd,\n        AsgSub,\n        AsgDiv,\n        AsgMul,\n        AsgMod,\n        AsgAnd,\n        AsgXor,\n        AsgOr,\n        AsgLsh,\n        AsgRsh,\n        AsgRs2,\n        ConditionalExpression,\n        LogOr,\n        LogAnd,\n        Or,\n        Xor,\n        And,\n        Eq,\n        Ne,\n        Eqv,\n        NEqv,\n        Lt,\n        Le,\n        Gt,\n        Ge,\n        Add,\n        Sub,\n        Mul,\n        Div,\n        Mod,\n        Lsh,\n        Rsh,\n        Rs2,\n        Not,\n        LogNot,\n        IncPre,\n        DecPre,\n        IncPost,\n        DecPost,\n        TypeAssertion,\n        FuncDecl,\n        Member,\n        VarDecl,\n        ArgDecl,\n        Return,\n        Break,\n        Continue,\n        Throw,\n        For,\n        ForIn,\n        If,\n        While,\n        DoWhile,\n        Block,\n        Case,\n        Switch,\n        Try,\n        TryCatch,\n        TryFinally,\n        Finally,\n        Catch,\n        List,\n        Script,\n        ClassDeclaration,\n        InterfaceDeclaration,\n        ModuleDeclaration,\n        ImportDeclaration,\n        With,\n        Label,\n        LabeledStatement,\n        EBStart,\n        GotoEB,\n        EndCode,\n        Error,\n        Comment,\n        Debugger,\n        GeneralNode = FuncDecl,\n        LastAsg = AsgRs2,\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.';
var v27624 = v27625 + '\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path="io.ts" />\n\ninterface IOptions {\n    name?: string;\n    flag?: bool;\n    short?: string;\n    usage?: string;\n    set?: (s: string) => void;\n    type?: string;\n    experimental?: bool;\n}\n\nclass OptionsParser {\n    private DEFAULT_SHORT_FLAG = "-";\n    private DEFAULT_LONG_FLAG = "--";\n\n    // Find the option record for the given string. Returns null if not found.\n    private findOption(arg: string) {\n\n        for (var i = 0; i < this.options.length; i++) {\n\n            if (arg === this.options[i].short || arg === this.options[i].name) {\n                return this.options[i];\n            }\n        }\n\n        return null;\n    }\n\n    public unnamed: string[] = [];\n\n    public options: IOptions[] = [];\n\n    constructor (public host: IIO) {\n    }\n\n    public printUsage() {\n        this.host.printLine("Syntax:   tsc [options] [file ..]");\n        this.host.printLine("");\n        this.host.printLine("Examples: tsc hello.ts");\n        this.host.printLine("          tsc --out foo.js foo.ts");\n        this.host.printLine("          tsc @args.txt");\n        this.host.printLine("");\n        this.host.printLine("Options:");\n\n        var output = [];\n        var maxLength = 0;\n\n        this.options = this.options.sort(function(a, b) {\n            var aName = a.name.toLowerCase();\n            var bName = b.name.toLowerCase();\n\n            if (aName > bName) {\n                return 1;\n            } else if (aName < bName) {\n                return -1;\n            } else {\n                return 0;\n            }\n        });\n\n        // Build up output array\n        for (var i = 0; i < this.options.length; i++) {\n            var option = this.options[i];\n\n            if (option.experimental) {\n                continue;\n            }\n\n            if (!option.usage) {\n                break;\n            }\n\n            var usageString = "  ";\n            var type = option.type ? " " + option.type.toUpperCase() : "";\n\n            if (option.short) {\n                usageString += this.DEFAULT_SHORT_FLAG + option.short + type + ", ";\n            }\n\n            usageString += this.DEFAULT_LONG_FLAG + option.name + type;\n\n            output.push([usageString, option.usage]);\n\n            if (usageString.length > maxLength) {\n                maxLength = usageString.length;\n            }\n        }\n\n        output.push(["  @<file>", "Insert command line options and files from a file."]);\n\n        // Print padded output\n        for (var i = 0; i < output.length; i++) {\n            this.host.printLine(output[i][0] + (new Array(maxLength - output[i][0].length + 3)).join(" ") + output[i][1]);\n        }\n    }\n\n    public option(name: string, config: IOptions, short?: string) {\n        if (!config) {\n            config = <any>short;\n            short = null;\n        }\n\n        config.name = name;\n        config.short = short;\n        config.flag = false;\n\n        this.options.push(config);\n    }\n\n    public flag(name: string, config: IOptions, short?: string) {\n        if (!config) {\n            config = <any>short;\n            short = null;\n        }\n\n        config.name = name;\n        config.short = short;\n        config.flag = true\n\n        this.options.push(config);\n    }\n\n    // Parse an arguments string\n    public parseString(argString: string) {\n        var position = 0;\n        var tokens = argString.match(/\\s+|"|[^\\s"]+/g);\n\n        function peek() {\n            return tokens[position];\n        }\n\n        function consume() {\n            return tokens[position++];\n        }\n\n        function consumeQuotedString() {\n            var value = \'\';\n            consume(); // skip opening quote.\n\n            var token = peek();\n\n            while (token && token !== \'"\') {\n                consume();\n\n                value += token;\n\n                token = peek();\n            }\n\n            consume(); // skip ending quote;\n\n            return value;\n        }\n\n        var args: string[] = [];\n        var currentArg = \'\';\n\n        while (position < tokens.length) {\n            var token = peek();\n\n            if (token === \'"\') {\n                currentArg += consumeQuotedString();\n            } else if (token.match(/\\s/)) {\n                if (currentArg.length > 0) {\n                    args.push(currentArg);\n                    currentArg = \'\';\n                }\n\n                consume();\n            } else {\n                consume();\n                currentArg += token;\n            }\n        }\n\n        if (currentArg.length > 0) {\n            args.push(currentArg);\n        }\n\n        this.parse(args);\n    }\n\n    // Parse arguments as they come from the platform: split into arguments.\n    public parse(args: string[]) {\n        var position = 0;\n\n        function consume() {\n            return args[position++];\n        }\n\n        while (position < args.length) {\n            var current = consume();\n           ';
var v27623 = v27624 + ' var match = current.match(/^(--?|@)(.*)/);\n            var value = null;\n\n            if (match) {\n                if (match[1] === \'@\') {\n                    this.parseString(this.host.readFile(match[2]));\n                } else {\n                    var arg = match[2];\n                    var option = this.findOption(arg);\n\n                    if (option === null) {\n                        this.host.printLine("Unknown option \'" + arg +"\'");\n                        this.host.printLine("Use the \'--help\' flag to see options");\n                    } else {\n                        if (!option.flag)\n                            value = consume();\n\n                        option.set(value);\n                    }\n                }\n            } else {\n                this.unnamed.push(current);\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum TypeContext {\n        NoTypes = 0,\n        ArraySuffix = 1,\n        Primitive = 2,\n        Named = 4,\n        AllSimpleTypes = Primitive | Named,\n        AllTypes = Primitive | Named | ArraySuffix,\n    }\n\n    export enum ParseState {\n        None,\n        StartScript,\n        StartStatementList,\n        StartStatement,\n        StartFncDecl,\n        FncDeclName,\n        FncDeclArgs,\n        FncDeclReturnType,\n        ForInit,\n        ForInitAfterVar,\n        ForCondStart,\n        EndStmtList,\n        EndScript,\n    }\n\n    export interface IStatementInfo {\n        stmt: Statement;\n        labels: ASTList;\n    }\n\n    export interface ILambdaArgumentContext {\n        preProcessedLambdaArgs: AST;\n    }\n\n    export class QuickParseResult {\n        constructor (public Script: Script, public endLexState: LexState) { }\n    }\n\n    export class Parser {\n        private varLists: ASTList[] = [];\n        private scopeLists: ASTList[] = [];\n        private staticsLists: ASTList[] = [];\n\n        private scanner: IScanner = new Scanner();\n        private currentToken: Token = null;\n\n        private needTerminator = false;\n\n        // TODO: consolidate these\n        private inFunction = false;\n        private inInterfaceDecl = false;\n        public currentClassDecl: NamedDeclaration = null;\n\n        private inFncDecl = false;  // this is only for FuncDecls - not constructors, like inFnc\n        private anonId = new Identifier("_anonymous");\n        public style_requireSemi = false;\n        public style_funcInLoop = true;\n        private incremental = false;\n        public errorRecovery = false;\n        public outfile: ITextWriter = undefined;\n        public errorCallback: (minChar: number, charLen: number, message: string, unit: number) =>void = null;\n        private state: ParseState = ParseState.StartStatementList;\n        private ambientModule = false;\n        private ambientClass = false;\n        private topLevel = true;\n        private allowImportDeclaration = true;\n        private currentUnitIndex = (-1);\n        private prevIDTok: Token = null;\n        private statementInfoStack: IStatementInfo[] = new IStatementInfo[];\n        private hasTopLevelImportOrExport = false; // for imports, only true if it\'s a dynamic module\n        private strictMode = false;\n        private nestingLevel = 0;\n        private prevExpr: AST = null;\n        private currentClassDefinition: ClassDeclaration = null;\n        private parsingClassConstructorDefinition = false;\n        private parsingDeclareFile = false;\n        private amdDependencies: string[] = [];\n        public inferPropertiesFromThisAssignment = false;\n        public requiresExtendsBlock = false;\n\n        private resetStmtStack() {\n            this.statementInfoStack = new IStatementInfo[];\n        }\n\n        private inLoop() {\n            for (var j = this.statementInfoStack.length - 1; j >= 0; j--) {\n                if (this.statementInfoStack[j].stmt.isLoop()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private pushStmt(stmt: Statement, labels: ASTList) {\n            // allocate here to avoid always storing this information in statements\n            var info = { stmt: stmt, labels: labels };\n            this.statementInfoStack.push(info);\n        }\n\n        private popStmt(): IStatementInfo {\n            return this.statementInfoStack.pop();\n        }\n\n        private resolveJumpTarget(jump: Jump): void {';
var v27622 = v27623 + '\n            var resolvedTarget = AST.getResolvedIdentifierName(jump.target);\n            var len = this.statementInfoStack.length;\n            for (var i = len - 1; i >= 0; i--) {\n                var info = this.statementInfoStack[i];\n                if (jump.target) {\n                    if (info.labels && (info.labels.members.length > 0)) {\n                        for (var j = 0, labLen = info.labels.members.length; j < labLen; j++) {\n                            var label = <Label>info.labels.members[j];\n                            if (label.id.text == resolvedTarget) {\n                                jump.setResolvedTarget(this, info.stmt);\n                                return;\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (info.stmt.isLoop()) {\n                        jump.setResolvedTarget(this, info.stmt);\n                        return;\n                    }\n                    else if ((info.stmt.nodeType == NodeType.Switch) && (jump.nodeType == NodeType.Break)) {\n                        jump.setResolvedTarget(this, info.stmt);\n                        return;\n                    }\n                }\n            }\n            // no luck\n            if (jump.target) {\n                this.reportParseError("could not find enclosing statement with label " + jump.target);\n            }\n            else {\n                if (jump.nodeType == NodeType.Break) {\n                    this.reportParseError("break statement requires enclosing loop or switch");\n                }\n                else {\n                    this.reportParseError("continue statement requires enclosing loop");\n                }\n            }\n        }\n\n        public setErrorRecovery(outfile: ITextWriter) {\n            this.outfile = outfile;\n            this.errorRecovery = true;\n        }\n\n        public getSourceLineCol(lineCol: ILineCol, minChar: number): void {\n            getSourceLineColFromMap(lineCol, minChar, this.scanner.lineMap);\n        }\n\n        private createRef(text: string, hasEscapeSequence: bool, minChar: number): Identifier {\n            var id = new Identifier(text, hasEscapeSequence);\n            id.minChar = minChar;\n            return id;\n        }\n\n        private reportParseStyleError(message: string) {\n            this.reportParseError("STYLE: " + message);\n        }\n\n        public reportParseError(message: string, startPos = this.scanner.startPos, pos = this.scanner.pos) {\n            var len = Math.max(1, pos - startPos);\n            if (this.errorCallback) {\n                this.errorCallback(startPos, len, message, this.currentUnitIndex);\n            }\n            else if (this.errorRecovery) {\n                var lineCol = { line: -1, col: -1 };\n                this.getSourceLineCol(lineCol, startPos);\n                if (this.outfile) {\n                    this.outfile.WriteLine("// " + this.fname + " (" + lineCol.line + "," + lineCol.col + "): " + message);\n                }\n            }\n            else {\n                throw new SyntaxError(this.fname + " (" + this.scanner.line + "," + this.scanner.col + "): " + message);\n            }\n        }\n\n        private checkNextToken(tokenId: TokenID, errorRecoverySet: ErrorRecoverySet, errorText: string = null): void {\n            this.currentToken = this.scanner.scan();\n            this.checkCurrentToken(tokenId, errorRecoverySet, errorText);\n        }\n\n        private skip(errorRecoverySet: ErrorRecoverySet) {\n            errorRecoverySet |= ErrorRecoverySet.EOF;\n            var ersTok = ErrorRecoverySet.None;\n            var tokenInfo = lookupToken(this.currentToken.tokenId);\n            if (tokenInfo != undefined) {\n                ersTok = tokenInfo.ers;\n            }\n            var pendingRightCurlies = 0;\n            while (((ersTok & errorRecoverySet) == ErrorRecoverySet.None) ||\n                   (this.currentToken.tokenId == TokenID.CloseBrace) && (pendingRightCurlies > 0)) {\n                if (this.currentToken.tokenId == TokenID.OpenBrace) {\n                    pendingRightCurlies++;\n                }\n                else if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                    pendingRightCurlies--;\n                }\n                this.currentToken = this.scanner.scan();\n                ersTok = ErrorRecoverySet.None;\n                tokenInfo = lookupToken(this.currentToken.tokenId);\n                if (tokenInfo != undefined) {\n                    ersTok = tokenInfo.ers;\n                }\n                // TODO: regex rescan \n            }\n        }\n\n        private checkCurrentToken(tokenId: TokenID, errorRecoverySet: ErrorRecoverySet, errorText: string = null): void {\n            if (this.currentToken.tokenId != tokenId) {\n                errorText = errorText == null ? ("Expected \'" + tokenTable[tokenId].text + "\'") : errorText;\n                this.reportParseError(errorText);\n                if (this.errorRecove';
var v27621 = v27622 + 'ry) {\n                    this.skip(errorRecoverySet);\n                }\n            }\n            else {\n                this.currentToken = this.scanner.scan();\n            }\n        }\n\n        private pushDeclLists() {\n            this.staticsLists.push(new ASTList());\n            this.varLists.push(new ASTList());\n            this.scopeLists.push(new ASTList());\n        }\n\n        private popDeclLists() {\n            this.staticsLists.pop();\n            this.varLists.pop();\n            this.scopeLists.pop();\n        }\n\n        private topVarList() {\n            return this.varLists[this.varLists.length - 1];\n        }\n\n        private topScopeList() {\n            return this.scopeLists[this.scopeLists.length - 1];\n        }\n\n        private topStaticsList() {\n            return this.staticsLists[this.staticsLists.length - 1];\n        }\n\n        private parseComment(comment: CommentToken) {\n            if (comment) {\n                var c: Comment = new Comment(comment.value, comment.isBlock, comment.endsLine);\n                c.minChar = comment.startPos;\n                c.limChar = comment.startPos + comment.value.length;\n                var lineCol = { line: -1, col: -1 };\n                this.getSourceLineCol(lineCol, c.minChar);\n                c.minLine = lineCol.line;\n                this.getSourceLineCol(lineCol, c.limChar);\n                c.limLine = lineCol.line;\n\n                if (!comment.isBlock && comment.value.length > 3 && comment.value.substring(0, 3) == "///") {\n                    var dependencyPath = getAdditionalDependencyPath(comment.value);\n\n                    if (dependencyPath) {\n                        this.amdDependencies.push(dependencyPath);\n                    }\n\n                    if (getImplicitImport(comment.value)) {\n                        this.hasTopLevelImportOrExport = true;\n                    }\n                }\n\n                return c;\n            }\n            else {\n                return null;\n            }\n        }\n\n        private parseCommentsInner(comments: CommentToken[]) {\n            if (comments) {\n                var commentASTs: Comment[] = new Comment[];\n                for (var i = 0; i < comments.length; i++) {\n                    commentASTs.push(this.parseComment(comments[i]));\n                }\n                return commentASTs;\n            } else {\n                return null;\n            }\n        }\n\n        private parseComments() {\n            var comments = this.scanner.getComments();\n            return this.parseCommentsInner(comments);\n        }\n\n        private parseCommentsForLine(line: number) {\n            var comments = this.scanner.getCommentsForLine(line);\n\n            return this.parseCommentsInner(comments);\n        }\n\n        private combineComments(comment1: Comment[], comment2: Comment[]) {\n            if (comment1 == null) {\n                return comment2;\n            }\n            else if (comment2 == null) {\n                return comment1;\n            }\n            else {\n                return comment1.concat(comment2);\n            }\n        }\n\n        private parseEnumDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ModuleDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var name: Identifier = null;\n            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n            }\n            else {\n                this.reportParseError("Enum declaration requires identifier");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.startPos;\n                    name.limChar = this.scanner.startPos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var membersMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.ID);\n            this.pushDeclLists();\n            var members = new ASTList();\n            members.minChar = membersMinChar;\n            var mapDecl = new VarDecl(new Identifier("_map"), 0);\n            mapDecl.varFlags |= VarFlags.Exported;\n            mapDecl.varFlags |= VarFlags.Private;\n\n            // REVIEW: Is this still necessary?\n            mapDecl.varFlags |= (VarFlags.Property | VarFlags.Public);\n            mapDecl.init = new UnaryExpression(NodeType.ArrayLit, null);\n            members.append(mapDecl);\n            var lastValue: NumberLiteral = null;\n            for (; ;) {\n                var minChar = this.scanner.startPos;\n                var limChar;\n                var memberName: Identifier = null;\n';
var v27620 = v27621 + '                var memberValue: AST = null;\n                var preComments = null;\n                var postComments = null;\n\n                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {\n                    memberName = Identifier.fromToken(this.currentToken);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                    break;\n                }\n                else {\n                    this.reportParseError("Expected identifer of enum member");\n                    if (this.errorRecovery) {\n                        memberName = new MissingIdentifier();\n                        memberName.minChar = this.scanner.startPos;\n                        memberName.limChar = this.scanner.startPos;\n                        memberName.flags |= ASTFlags.Error;\n                    }\n                }\n\n                limChar = this.scanner.pos;\n                preComments = this.parseComments();\n                this.currentToken = this.scanner.scan();\n                postComments = this.parseComments();\n\n                if (this.currentToken.tokenId == TokenID.Equals) {\n                    this.currentToken = this.scanner.scan();\n                    memberValue = this.parseExpr(errorRecoverySet, OperatorPrecedence.Comma, true,\n                                          TypeContext.NoTypes);\n                    lastValue = <NumberLiteral>memberValue;\n                    limChar = memberValue.limChar;\n                }\n                else {\n                    if (lastValue == null) {\n                        memberValue = new NumberLiteral(0);\n                        lastValue = <NumberLiteral>memberValue;\n                    }\n                    else {\n                        memberValue = new NumberLiteral(lastValue.value + 1);\n                        lastValue = <NumberLiteral>memberValue;\n                    }\n                    var map: BinaryExpression =\n                        new BinaryExpression(NodeType.Asg,\n                                             new BinaryExpression(NodeType.Index,\n                                                                  new Identifier("_map"),\n                                                                  memberValue),\n                                             new StringLiteral(\'"\' + memberName.actualText + \'"\'));\n                    members.append(map);\n                }\n                var member = new VarDecl(memberName, this.nestingLevel);\n                member.minChar = minChar;\n                member.limChar = limChar;\n                member.init = memberValue;\n                // Note: Leave minChar, limChar as "-1" on typeExpr as this is a parsing artifact.\n                member.typeExpr = new TypeReference(this.createRef(name.actualText, name.hasEscapeSequence, -1), 0);\n                member.varFlags |= (VarFlags.Readonly | VarFlags.Property);\n                if (memberValue.nodeType == NodeType.NumberLit) {\n                    member.varFlags |= VarFlags.Constant;\n                }\n                member.preComments = preComments;\n                members.append(member);\n                member.postComments = postComments;\n                // all enum members are exported\n                member.varFlags |= VarFlags.Exported;\n\n                if (this.currentToken.tokenId == TokenID.Comma) {\n                    this.currentToken = this.scanner.scan();\n                    member.postComments = this.combineComments(member.postComments, this.parseCommentsForLine(this.scanner.prevLine));\n                    if ((this.currentToken.tokenId == TokenID.Identifier) || (convertTokToIDName(this.currentToken))) {\n                        continue;\n                    }\n                }\n                break;\n            }\n            var endingToken = new ASTSpan();\n            endingToken.minChar = this.scanner.startPos;\n            endingToken.limChar = this.scanner.pos;\n\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n            members.limChar = this.scanner.lastTokenLimChar();\n            var modDecl = new ModuleDeclaration(name, members, this.topVarList(), this.topScopeList(), endingToken);\n            modDecl.modFlags |= ModuleFlags.IsEnum;\n            this.popDeclLists();\n\n            modDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            modDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return modDecl;\n        }\n\n        private parseDottedName(enclosedList: AST[]): void {\n            this.currentToken = this.scanner.scan();\n            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                var id = Identifier.fromToken(this.currentToken);\n                id.preComments = this.parseCom';
var v27619 = v27620 + "ments();\n                enclosedList[enclosedList.length] = id;\n                id.minChar = this.scanner.startPos;\n                id.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n                if (this.currentToken.tokenId == TokenID.Dot) {\n                    this.parseDottedName(enclosedList);\n                }\n            }\n            else {\n                this.reportParseError(\"need identifier after '.'\");\n            }\n        }\n\n        // REVIEW: This is much more lenient than the spec - we're basically just checking to see if the\n        // path is rooted or contains an extension, not if it could potentially be a bogus file path\n        private isValidImportPath(importPath: string) {\n            importPath = stripQuotes(importPath);\n\n            if (!importPath ||\n                importPath.indexOf(':') != -1 || \n                importPath.indexOf('\\\\') != -1 ||\n                //(importPath.indexOf('.') != -1 && importPath.charAt(0) != '.') ||\n                importPath.charAt(0) == '/') {\n                return false;\n            }\n            return true;\n        }\n\n        private parseImportDeclaration(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ImportDeclaration {\n\n            var name: Identifier = null;\n            var alias: AST = null;\n            var importDecl: ImportDeclaration = null;\n            var minChar = this.scanner.startPos;\n            var isDynamicImport = false;\n\n            this.currentToken = this.scanner.scan();\n\n            if (this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {\n                name = Identifier.fromToken(this.currentToken);\n            }\n            else {\n                this.reportParseError(\"Expected identifer after 'import'\");\n                name = new MissingIdentifier();\n            }\n\n            name.minChar = this.scanner.startPos;\n            name.limChar = this.scanner.pos;\n\n            this.currentToken = this.scanner.scan();\n\n            this.checkCurrentToken(TokenID.Equals, errorRecoverySet | ErrorRecoverySet.ID);\n\n            var aliasPreComments = this.parseComments();\n\n            var limChar;\n            if (this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {\n\n                if (this.currentToken.tokenId == TokenID.Module) {\n                    limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                    if (this.currentToken.tokenId == TokenID.OpenParen) {\n                        this.currentToken = this.scanner.scan();\n\n                        if (this.currentToken.tokenId == TokenID.StringLiteral || this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {\n\n                            if (this.currentToken.tokenId == TokenID.StringLiteral) {\n\n                                if (this.topLevel) {\n                                    this.hasTopLevelImportOrExport = true;\n                                } else if (!this.allowImportDeclaration) {\n                                    this.reportParseError(\"Import declaration of external module is permitted only in global or top level dynamic modules\");\n                                }\n\n                                var aliasText = this.currentToken.getText();\n                                alias = Identifier.fromToken(this.currentToken);\n                                alias.minChar = this.scanner.startPos;\n                                alias.limChar = this.scanner.pos;\n\n                                if (!this.isValidImportPath((<Identifier>alias).text)) {\n                                    this.reportParseError(\"Invalid import path\");\n                                }\n\n                                isDynamicImport = true;\n                                this.currentToken = this.scanner.scan();\n                                    \n                                alias.preComments = aliasPreComments;\n                            }\n                            else {\n                                alias = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                            OperatorPrecedence.Assignment, true,\n                                            TypeContext.NoTypes);\n                                    \n                                alias.preComments = aliasPreComments;\n                            }\n                        }\n\n                        limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.ID);\n\n                        if (alias) {\n                            alias.postComments = this.parseComments();\n                        }\n                    }\n                }\n                else {\n                    alias = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                 ";
var v27618 = v27619 + '                           OperatorPrecedence.Assignment, true,\n                                            TypeContext.NoTypes);\n                    limChar = this.scanner.pos; // Include semicolon if needed\n                }\n            }\n            else {\n                this.reportParseError("Expected module name");\n                alias = new MissingIdentifier();\n                alias.minChar = this.scanner.startPos;\n                if (this.currentToken.tokenId == TokenID.Semicolon) {\n                    alias.limChar = this.scanner.startPos;\n                } else {\n                    alias.limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                }\n                alias.flags |= ASTFlags.Error;\n                limChar = alias.limChar;\n            }\n\n            importDecl = new ImportDeclaration(name, alias);\n            importDecl.isDynamicImport = isDynamicImport;\n\n            importDecl.minChar = minChar;\n            importDecl.limChar = limChar;\n\n            return importDecl;\n        }\n\n        private parseModuleDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers, preComments: Comment[]): ModuleDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var svAmbient = this.ambientModule;\n            var svTopLevel = this.topLevel;\n            this.topLevel = false;\n            if (this.parsingDeclareFile || svAmbient || hasFlag(modifiers, Modifiers.Ambient)) {\n                this.ambientModule = true;\n            }\n\n            this.currentToken = this.scanner.scan();\n            var name: AST = null;\n            var enclosedList: AST[] = null;\n            this.pushDeclLists();\n            var minChar = this.scanner.startPos;\n            var isDynamicMod = false;\n\n            if ((this.currentToken.tokenId == TokenID.Identifier) || (this.currentToken.tokenId == TokenID.StringLiteral) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode))) {\n                var nameText = this.currentToken.getText();\n\n                if (this.currentToken.tokenId == TokenID.StringLiteral) {\n                    isDynamicMod = true;\n                    if (!this.ambientModule) {\n                        this.reportParseError("Only ambient dynamic modules may have string literal names");\n                    }\n\n                    if (!svTopLevel) {\n                        this.reportParseError("Dynamic modules may not be nested within other modules");\n                    }\n                }\n\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n\n                this.currentToken = this.scanner.scan();\n            }\n            else if (this.currentToken.tokenId == TokenID.OpenBrace) {\n                this.reportParseError("Module name missing");\n                name = new Identifier("");\n                // "fake" position of where the ID would be\n                name.minChar = minChar;\n                name.limChar = minChar;\n            }\n\n            if (this.currentToken.tokenId == TokenID.Dot) {\n                enclosedList = new AST[];\n                this.parseDottedName(enclosedList);\n            }\n\n            if (name == null) {\n                name = new MissingIdentifier();\n            }\n\n            var moduleBody = new ASTList();\n            var bodyMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.ID);\n\n            if (svTopLevel && isDynamicMod) {\n                this.allowImportDeclaration = true;\n            } else {\n                this.allowImportDeclaration = false;\n            }\n            this.parseStatementList(\n                errorRecoverySet | ErrorRecoverySet.RCurly, moduleBody,\n                /*sourceElements:*/ true, /*noLeadingCase:*/ true, AllowedElements.Global, modifiers);\n            moduleBody.minChar = bodyMinChar;\n            moduleBody.limChar = this.scanner.pos;\n\n            var endingToken = new ASTSpan();\n            endingToken.minChar = this.scanner.startPos;\n            endingToken.limChar = this.scanner.pos;\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n            var limChar = this.scanner.lastTokenLimChar();\n            var moduleDecl: ModuleDeclaration;\n\n            this.allowImportDeclaration = svTopLevel;\n\n            if (enclosedList && (enclosedList.length > 0)) {\n                var len = enclosedList.length;\n                var innerName = <Identifier>enclosedList[len - 1];\n                var innerDecl = new ModuleDeclaration(innerName, moduleBody, this.topVarList(),\n                                                this.topScopeList(), endingToken);\n                innerDecl.preComments = preComments;\n\n                if (this.parsingDeclareFile || hasFl';
var v27617 = v27618 + 'ag(modifiers, Modifiers.Ambient)) {\n                    innerDecl.modFlags |= ModuleFlags.Ambient;\n                }\n\n                innerDecl.modFlags |= ModuleFlags.Exported;\n\n                // REVIEW: will also possibly need to re-parent comments as well\n                innerDecl.minChar = minChar;\n                innerDecl.limChar = limChar;\n\n                this.popDeclLists();\n                var outerModBod: ASTList;\n                for (var i = len - 2; i >= 0; i--) {\n                    outerModBod = new ASTList();\n                    outerModBod.append(innerDecl);\n                    innerName = <Identifier>enclosedList[i];\n                    innerDecl = new ModuleDeclaration(innerName, outerModBod, new ASTList(),\n                                                new ASTList(), endingToken);\n                    outerModBod.minChar = innerDecl.minChar = minChar;\n                    outerModBod.limChar = innerDecl.limChar = limChar;\n\n                    if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                        innerDecl.modFlags |= ModuleFlags.Ambient;\n                    }\n\n                    innerDecl.modFlags |= ModuleFlags.Exported;\n                }\n                outerModBod = new ASTList();\n                outerModBod.append(innerDecl);\n                outerModBod.minChar = minChar;\n                outerModBod.limChar = limChar;\n                moduleDecl = new ModuleDeclaration(<Identifier>name, outerModBod, new ASTList(),\n                                            new ASTList(), endingToken);\n            }\n            else {\n                moduleDecl = new ModuleDeclaration(<Identifier>name, moduleBody, this.topVarList(), this.topScopeList(), endingToken);\n                moduleDecl.preComments = preComments;\n                this.popDeclLists();\n            }\n\n            if (this.parsingDeclareFile || svAmbient || hasFlag(modifiers, Modifiers.Ambient)) {\n                moduleDecl.modFlags |= ModuleFlags.Ambient;\n            }\n            if (svAmbient || hasFlag(modifiers, Modifiers.Exported)) {\n                moduleDecl.modFlags |= ModuleFlags.Exported;\n            }\n            if (isDynamicMod) {\n                moduleDecl.modFlags |= ModuleFlags.IsDynamic;\n            }\n\n            this.ambientModule = svAmbient;\n\n            this.topLevel = svTopLevel;\n            moduleDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            moduleDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            moduleDecl.limChar = moduleBody.limChar;\n            return moduleDecl;\n        }\n\n        private parseTypeReferenceTail(errorRecoverySet: ErrorRecoverySet, minChar: number, term: AST): TypeReference {\n            var result = new TypeReference(term, 0);\n            result.minChar = minChar;\n            while (this.currentToken.tokenId == TokenID.OpenBracket) {\n                this.currentToken = this.scanner.scan();\n                result.arrayCount++;\n                this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet | ErrorRecoverySet.LBrack);\n            }\n            result.limChar = this.scanner.lastTokenLimChar();\n            return result;\n        }\n\n        // REVIEW: Consider renaming to parseTypeName.\n        private parseNamedType(errorRecoverySet: ErrorRecoverySet, minChar: number, term: AST, tail: bool): AST {\n            this.currentToken = this.scanner.scan();\n            if (this.currentToken.tokenId == TokenID.Dot) {\n                var curpos = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n                // Don\'t allow reserved words if immediately after a new line and error recovery is enabled\n                if ((this.currentToken.tokenId == TokenID.Identifier) || ((!this.errorRecovery || !this.scanner.lastTokenHadNewline()) && convertTokToID(this.currentToken, this.strictMode))) {\n                    var op2 = Identifier.fromToken(this.currentToken);\n                    op2.minChar = this.scanner.startPos;\n                    op2.limChar = this.scanner.pos;\n                    var dotNode = new BinaryExpression(NodeType.Dot, term, op2);\n                    dotNode.minChar = term.minChar;\n                    dotNode.limChar = op2.limChar;\n                    return this.parseNamedType(errorRecoverySet, minChar,\n                                            dotNode, tail);\n                }\n                else {\n                    this.reportParseError("need identifier after \'.\'");\n                    if (this.errorRecovery) {\n                        term.flags |= ASTFlags.DotLHS;\n                        // We set "limChar" to be slightly innacurate for completion list behavior\n                        // (last AST node from "quickParse" will match DotLHS and be at end of file position)\n                        // This is to match the behavior of TokenId.Dot processing in parsePostfixOperators.\n                        term.limChar = this.scanner.las';
var v27616 = v27617 + 'tTokenLimChar();\n                        return term;\n                    }\n                    else {\n                        var eop2 = new MissingIdentifier();\n                        eop2.minChar = this.scanner.pos;\n                        eop2.limChar = this.scanner.pos;\n                        var edotNode = new BinaryExpression(NodeType.Dot, term, eop2);\n                        edotNode.flags |= ASTFlags.Error;\n                        edotNode.minChar = term.minChar;\n                        edotNode.limChar = eop2.limChar;\n                        return this.parseNamedType(errorRecoverySet, minChar,\n                                                edotNode, tail);\n                    }\n                }\n            }\n            else {\n                if (tail) {\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, term);\n                }\n                else {\n                    return term;\n                }\n            }\n        }\n\n        // REVIEW: Reconsider renaming this to parseType to match the grammar.\n        private parseTypeReference(errorRecoverySet: ErrorRecoverySet, allowVoid: bool): AST {\n            var minChar = this.scanner.startPos;\n            var isConstructorMember = false;\n\n            switch (this.currentToken.tokenId) {\n                case TokenID.Void:\n                    if (!allowVoid) {\n                        this.reportParseError("void not a valid type in this context");\n                    }\n                // Intentional fall-through\n                case TokenID.Any:\n                case TokenID.Number:\n                case TokenID.Bool:\n                case TokenID.String: {\n                    var text = tokenTable[this.currentToken.tokenId].text;\n                    var predefinedIdentifier = new Identifier(text);\n                    predefinedIdentifier.minChar = minChar;\n                    predefinedIdentifier.limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, predefinedIdentifier);\n                }\n\n                case TokenID.Identifier:\n                    var ident = this.createRef(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence, minChar);\n                    ident.limChar = this.scanner.pos;\n                    return this.parseNamedType(errorRecoverySet, minChar, ident, true);\n\n                case TokenID.OpenBrace:\n                    return this.parseObjectType(minChar, errorRecoverySet);\n\n                case TokenID.New:\n                    this.currentToken = this.scanner.scan();\n                    // can\'t use chkCurrentTok, since we don\'t want to advance the token\n                    if (this.currentToken.tokenId != TokenID.OpenParen) {\n                        this.reportParseError("Expected \'(\'");\n                    }\n                    else {\n                        isConstructorMember = true;\n                        // fall through...\n                    }\n\n                case TokenID.OpenParen: {\n                    // ( formals ) => type\n                    var formals = new ASTList();\n                    var variableArgList =\n                        this.parseFormalParameterList(errorRecoverySet | ErrorRecoverySet.RParen,\n                                            formals, false, true, false, false, false, false, null, true);\n                    this.checkCurrentToken(TokenID.EqualsGreaterThan, errorRecoverySet);\n                    var returnType = this.parseTypeReference(errorRecoverySet, true);\n                    var funcDecl = new FuncDecl(null, null, false, formals, null, null, null,\n                                                NodeType.FuncDecl);\n                    funcDecl.returnTypeAnnotation = returnType;\n                    funcDecl.variableArgList = variableArgList;\n                    funcDecl.fncFlags |= FncFlags.Signature;\n\n                    if (isConstructorMember) {\n                        funcDecl.fncFlags |= FncFlags.ConstructMember;\n                        funcDecl.hint = "_construct";\n                        funcDecl.classDecl = null;\n                    }\n                    funcDecl.minChar = minChar;\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, funcDecl);\n                }\n\n                default:\n                    this.reportParseError("Expected type name");\n                    var etr = new TypeReference(null, 0);\n                    etr.flags |= ASTFlags.Error;\n                    etr.minChar = this.scanner.pos;\n                    etr.limChar = this.scanner.pos;\n                    return etr;\n            }\n        }\n\n        private parseObjectType(minChar: number, errorRecoverySet: ErrorRecoverySet): TypeReference {\n            this.currentToken = this.scanner.scan();\n\n            var members = new ASTList();\n            members.minChar = minChar;\n\n            var prevInInter';
var v27615 = v27616 + 'faceDecl = this.inInterfaceDecl;\n            this.inInterfaceDecl = true;\n            this.parseTypeMemberList(errorRecoverySet | ErrorRecoverySet.RCurly, members);\n            this.inInterfaceDecl = prevInInterfaceDecl;\n\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n            // REVIEW: We\'re parsing an ObjectType, but we give a NodeType of Interface here.\n            var interfaceDecl = new InterfaceDeclaration(\n                this.anonId, members, /*extends:*/ null, /*implementsL*/ null);\n\n            interfaceDecl.minChar = minChar;\n            interfaceDecl.limChar = members.limChar;    // "}"\n\n            return this.parseTypeReferenceTail(errorRecoverySet, minChar, interfaceDecl);\n        }\n\n        private parseFunctionBlock(errorRecoverySet: ErrorRecoverySet,\n                                   allowedElements: AllowedElements,\n                                   parentModifiers: Modifiers,\n                                   bod: ASTList,\n                                   bodMinChar: number): void {\n            this.state = ParseState.StartStatementList;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.StmtStart);\n            var savedInFunction = this.inFunction;\n            this.inFunction = true;\n            this.parseStatementList(\n                errorRecoverySet | ErrorRecoverySet.RCurly | ErrorRecoverySet.StmtStart,\n                bod, /*sourceElements:*/ true, /*noLeadingCase:*/ false, allowedElements, parentModifiers);\n            bod.minChar = bodMinChar;\n            bod.limChar = this.scanner.pos;\n            this.inFunction = savedInFunction;\n            var ec = new EndCode();\n            ec.minChar = bod.limChar;\n            ec.limChar = ec.minChar;\n            bod.append(ec);\n        }\n\n        private parseFunctionStatements(errorRecoverySet: ErrorRecoverySet,\n                                        name: Identifier,\n                                        isConstructor: bool,\n                                        isMethod: bool,\n                                        args: ASTList,\n                                        allowedElements: AllowedElements,\n                                        minChar: number,\n                                        requiresSignature: bool,\n                                        parentModifiers: Modifiers) {\n\n            this.pushDeclLists();\n            // start new statement stack\n            var svStmtStack = this.statementInfoStack;\n            this.resetStmtStack();\n\n            var bod: ASTList = null;\n            var wasShorthand = false;\n            var isAnonLambda = false;\n            var limChar: number;\n\n            if (requiresSignature) {\n                // If we require a signature, but they provided a block, then give an error, but\n                // still consume the block.\n                limChar = this.scanner.pos;\n                if (this.currentToken.tokenId === TokenID.OpenBrace) {\n                    this.reportParseError("Function declarations are not permitted within interfaces, ambient modules or classes")\n                    bod = new ASTList();\n                    var bodMinChar = this.scanner.startPos;\n\n                    this.parseFunctionBlock(errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar);\n                    this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n                    // If there\'s also a semicolon, then just skip over it.  We don\'t want to report an \n                    // additional error here.\n                    if (this.currentToken.tokenId === TokenID.Semicolon) {\n                        this.currentToken = this.scanner.scan();\n                    }\n                }\n                else {\n                    this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet, "Expected \';\'");\n                }\n            }\n            else {\n                bod = new ASTList();\n                var bodMinChar = this.scanner.startPos;\n                if (this.currentToken.tokenId == TokenID.EqualsGreaterThan) {\n                    if (isMethod) {\n                        this.reportParseError("\'=>\' may not be used for class methods");\n                    }\n                    wasShorthand = true;\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (wasShorthand && this.currentToken.tokenId != TokenID.OpenBrace) {\n                    var retExpr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                            OperatorPrecedence.Assignment, true,\n                                            TypeContext.NoTypes);\n                    var retStmt = new ReturnStatement();\n                    retStmt.returnExpression = retExpr;\n                    retStmt.minChar = retExpr.minChar;\n                    retStmt.limChar = retExpr.limChar;\n                    bod.minChar = bodMinChar;\n                    bod.append(retStmt);\n ';
var v27614 = v27615 + '               }\n                else {\n                    isAnonLambda = wasShorthand;\n                    this.parseFunctionBlock(errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar);\n                }\n\n                limChar = this.scanner.pos;\n            }\n\n            var funcDecl = new FuncDecl(name, bod, isConstructor, args, this.topVarList(),\n                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);\n            this.popDeclLists();\n            var scopeList = this.topScopeList();\n            scopeList.append(funcDecl);\n            var staticFuncDecl = false;\n\n            if (!requiresSignature) {\n                if (!wasShorthand || isAnonLambda) {\n                    funcDecl.endingToken = new ASTSpan();\n                    funcDecl.endingToken.minChar = this.scanner.startPos;\n                    funcDecl.endingToken.limChar = this.scanner.pos;\n                    this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n                    if (isAnonLambda) {\n                        funcDecl.fncFlags |= FncFlags.IsFatArrowFunction;\n                    }\n                }\n                else {\n                    funcDecl.fncFlags |= FncFlags.IsFatArrowFunction;\n                    funcDecl.endingToken = new ASTSpan();\n\n                    funcDecl.endingToken.minChar = bod.members[0].minChar;\n                    funcDecl.endingToken.limChar = bod.members[0].limChar;\n                }\n            }\n            funcDecl.minChar = minChar;\n            funcDecl.limChar = limChar;\n\n            if (!requiresSignature) {\n                funcDecl.fncFlags |= FncFlags.Definition;\n            }\n\n            this.statementInfoStack = svStmtStack;\n            return funcDecl;\n        }\n\n        private transformAnonymousArgsIntoFormals(formals: ASTList, argList: AST) : bool {\n\n            var translateBinExOperand = (operand: AST) : bool => {\n                if (operand.nodeType == NodeType.Comma) {\n                    return this.transformAnonymousArgsIntoFormals(formals, operand);\n                }\n                else if (operand.nodeType == NodeType.Name || operand.nodeType == NodeType.Asg) {\n                    var opArg = operand.nodeType == NodeType.Asg ? (<BinaryExpression>operand).operand1 : operand;\n\n                    var arg = new ArgDecl(<Identifier>opArg);\n                    arg.preComments = opArg.preComments;\n                    arg.postComments = opArg.postComments;\n                    arg.minChar = operand.minChar;\n                    arg.limChar = operand.limChar;\n\n                    if (hasFlag(opArg.flags, ASTFlags.PossibleOptionalParameter)) {\n                        arg.isOptional = true;\n                    }\n\n                    if (operand.nodeType == NodeType.Asg) {\n                        arg.init = (<BinaryExpression>operand).operand2;\n                    }\n\n                    formals.append(arg);\n\n                    return arg.isOptional || arg.init;\n                }\n                else {\n                    this.reportParseError("Invalid lambda argument");\n                }\n                return false;\n            }\n\n            if (argList) {\n                if (argList.nodeType == NodeType.Comma) {\n                    var commaList = <BinaryExpression> argList;\n                    if (commaList.operand1.isParenthesized) { \n                        this.reportParseError("Invalid lambda argument", commaList.operand1.minChar, commaList.operand1.limChar);\n                    }\n                    if (commaList.operand2.isParenthesized) { \n                        this.reportParseError("Invalid lambda argument", commaList.operand2.minChar, commaList.operand2.limChar);\n                    }\n                    var isOptional = translateBinExOperand(commaList.operand1);\n                    isOptional = translateBinExOperand(commaList.operand2) || isOptional;\n                    return isOptional;\n                }\n                else {\n                    return translateBinExOperand(argList);\n                }\n            }\n        }\n\n        private parseFormalParameterList(errorRecoverySet: ErrorRecoverySet,\n                                            formals: ASTList,\n                                            isClassConstr: bool,\n                                            isSig: bool,\n                                            isIndexer: bool,\n                                            isGetter: bool,\n                                            isSetter: bool,\n                                            isLambda: bool,\n                                            preProcessedLambdaArgs: AST,\n                                            expectClosingRParen: bool): bool \n        {\n\n            formals.minChar = this.scanner.startPos; // \'(\' or \'[\'\n            if (isIndexer) {\n                this.currentToken = this.scanner.scan();\n            }\n            else if (!isLambda) {\n                this.ch';
var v27613 = v27614 + 'eckCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.RParen);\n            }\n            var sawEllipsis = false;\n            var firstArg = true;\n            var hasOptional = false;\n            var haveFirstArgID = false;\n\n            // if preProcessedLambdaArgs is "true", we either have a typeless argument list, or we have\n            // a single identifier node and the current token is the \':\' before a typereference\n            if (isLambda && preProcessedLambdaArgs && preProcessedLambdaArgs.nodeType != NodeType.EmptyExpr) {\n                hasOptional = this.transformAnonymousArgsIntoFormals(formals, preProcessedLambdaArgs);\n                haveFirstArgID = true;\n            }\n\n            while (true) {\n                var munchedArg = false;\n                var argFlags = VarFlags.None;\n                var argMinChar = this.scanner.startPos;\n\n                if (this.inferPropertiesFromThisAssignment && this.currentToken.tokenId == TokenID.This) {\n                    if (!isClassConstr) {\n                        this.reportParseError("Instance property declarations using \'this\' may only be used in class constructors");\n                    }\n                    this.currentToken = this.scanner.scan(); // consume the \'.\'\n\n                    argFlags |= (VarFlags.Public | VarFlags.Property);\n                    if (this.currentClassDefinition) {\n                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                    }\n                }\n                if (this.currentToken.tokenId == TokenID.Public) {\n                    argFlags |= (VarFlags.Public | VarFlags.Property);\n\n                    if (this.currentClassDefinition) {\n                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.Private) {\n                    argFlags |= (VarFlags.Private | VarFlags.Property);\n\n                    if (this.currentClassDefinition) {\n                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.Static && isClassConstr) {\n                    this.reportParseError("Static properties can not be declared as parameter properties");\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (argFlags != VarFlags.None) {\n                    if (!isClassConstr) {\n                        this.reportParseError("only constructor parameters can be properties");\n                    }\n                    this.currentToken = this.scanner.scan();\n\n                    if (isModifier(this.currentToken)) { \n                        this.reportParseError("Multiple modifiers may not be applied to parameters");\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.inferPropertiesFromThisAssignment && this.currentToken.tokenId == TokenID.This) {\n                        if (!isClassConstr) {\n                            this.reportParseError("Instance property declarations using \'this\' may only be used in class constructors");\n                        }\n                        this.currentToken = this.scanner.scan(); // consume the \'.\'\n                        this.currentToken = this.scanner.scan();\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.DotDotDot) {\n                    sawEllipsis = true;\n                    this.currentToken = this.scanner.scan();\n\n                    if (!(this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                        this.reportParseError("\'...\' parameters require both a parameter name and an array type annotation to be specified");\n                        sawEllipsis = false; // Do not treat this parameter as vararg\n                    }\n                }\n\n                var argId: Identifier = null;\n\n                if (!haveFirstArgID && (this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                    argId = Identifier.fromToken(this.currentToken);\n                    argId.minChar = this.scanner.startPos;\n                    argId.limChar = this.scanner.pos;\n                }\n\n                if (haveFirstArgID || argId) {\n                    munchedArg = true;\n                    var type: AST = null;\n                    var arg: ArgDecl = null;\n\n                    if (haveFirstArgID && formals.members.length) {\n                        arg = <ArgDecl>formals.members[formals.members.length - 1];\n\n                        if (arg.isOptional) {\n                            hasOptional = true;\n                        }\n                    }\n         ';
var v27612 = v27613 + '           else {\n                        arg = new ArgDecl(argId);\n\n                        if (isGetter) {\n                            this.reportParseError("Property getters may not take any arguments");\n                        }\n\n                        if (isSetter && !firstArg) {\n                            this.reportParseError("Property setters may only take one argument");\n                        }\n\n                        arg.minChar = argMinChar;\n                        arg.preComments = this.parseComments();\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.currentToken.tokenId == TokenID.Question) {\n                        arg.isOptional = true;\n                        hasOptional = true;\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.currentToken.tokenId == TokenID.Colon) {\n                        this.currentToken = this.scanner.scan();\n                        type = this.parseTypeReference(errorRecoverySet, false);\n                    }\n\n                    // check for default parameter\n                    // REVIEW: In the case of a typed reference, assume that parseTypeReference or one\n                    // of its children in the call graph advanced tok\n                    if (this.currentToken.tokenId == TokenID.Equals) {\n                        if (isSig) {\n                            this.reportParseError("Arguments in signatures may not have default values");\n                        }\n\n                        hasOptional = true;\n                        this.currentToken = this.scanner.scan();\n                        arg.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                            OperatorPrecedence.Comma, false,\n                                            TypeContext.NoTypes);\n\n                    }\n\n                    if (hasOptional && !arg.isOptionalArg() && !sawEllipsis) {\n                        this.reportParseError("Optional parameters may only be followed by other optional parameters");\n                    }\n\n                    if (sawEllipsis && arg.isOptionalArg()) {\n                        this.reportParseError("Varargs may not be optional or have default parameters");\n                    }\n\n                    if (sawEllipsis && !type) {\n                        // Ellipsis is missing a type definition\n                        this.reportParseError("\'...\' parameters require both a parameter name and an array type annotation to be specified");\n                    }\n\n                    // REVIEW: Ok for lambdas?\n                    arg.postComments = this.parseComments();\n                    arg.typeExpr = type;\n                    arg.limChar = this.scanner.lastTokenLimChar();\n                    arg.varFlags |= argFlags;\n                    if (!haveFirstArgID) {\n                        formals.append(arg);\n                    }\n                    else {\n                        haveFirstArgID = false;\n                    }\n                }\n                firstArg = false;\n                if (this.currentToken.tokenId == TokenID.Comma) {\n                    if ((munchedArg) && (!sawEllipsis)) {\n                        this.currentToken = this.scanner.scan();\n                        continue;\n                    }\n                    else {\n                        this.reportParseError("Unexpected \',\' in argument list");\n                        if (this.errorRecovery) {\n                            this.currentToken = this.scanner.scan();\n                            continue;\n                        }\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n\n            if (isIndexer) {\n                this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet | ErrorRecoverySet.LCurly | ErrorRecoverySet.SColon);\n            }\n            else if (expectClosingRParen) {\n                this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly | ErrorRecoverySet.SColon);\n            }\n            formals.limChar = this.scanner.lastTokenLimChar(); // \')\' or \']\'\n            return sawEllipsis;\n        }\n\n        private parseFncDecl(errorRecoverySet: ErrorRecoverySet,\n                             isDecl: bool,\n                             requiresSignature: bool,\n                             isMethod: bool,\n                             methodName: Identifier,\n                             indexer: bool,\n                             isStatic: bool,\n                             markedAsAmbient: bool,\n                             modifiers: Modifiers,\n                             lambdaArgContext: ILambdaArgumentContext,\n                             expectClosingRParen: bool): AST {\n\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyC';
var v27611 = v27612 + 'ount;\n\n            var prevInConstr = this.parsingClassConstructorDefinition;\n            this.parsingClassConstructorDefinition = false;\n\n            var name: Identifier = null;\n            var fnMin = this.scanner.startPos;\n            var minChar = this.scanner.pos;\n            var prevNestingLevel = this.nestingLevel;\n            var preComments = this.parseComments();\n            var isLambda = !!lambdaArgContext;\n            this.nestingLevel = 0;\n            if ((!this.style_funcInLoop) && this.inLoop()) {\n                this.reportParseStyleError("function declaration in loop");\n            }\n            if (!isMethod && !isStatic && !indexer && !lambdaArgContext) {\n                // past function keyword\n                this.currentToken = this.scanner.scan();\n                this.state = ParseState.StartFncDecl;\n                if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToID(this.currentToken, this.strictMode))) {\n                    if (isDecl) {\n                        this.reportParseError("Function declaration must include identifier");\n\n                        this.nestingLevel = prevNestingLevel;\n                        return new IncompleteAST(fnMin, this.scanner.pos);\n                    }\n                }\n                else {\n                    name = Identifier.fromToken(this.currentToken);\n                    name.minChar = this.scanner.startPos;\n                    name.limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n            else {\n                if (methodName) {\n                    name = methodName;\n                }\n            }\n\n            this.state = ParseState.FncDeclName;\n            var args: ASTList = new ASTList();\n            var variableArgList = false;\n            var isOverload = false;\n            var isGetter = hasFlag(modifiers, Modifiers.Getter);\n            var isSetter = hasFlag(modifiers, Modifiers.Setter);\n            if ((this.currentToken.tokenId == TokenID.OpenParen) || (indexer && (this.currentToken.tokenId == TokenID.OpenBracket)) || (lambdaArgContext && (lambdaArgContext.preProcessedLambdaArgs || this.currentToken.tokenId == TokenID.DotDotDot))) {\n                // arg list\n                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, false, requiresSignature, indexer, isGetter, isSetter, isLambda, lambdaArgContext ? lambdaArgContext.preProcessedLambdaArgs : null, expectClosingRParen);\n            }\n            this.state = ParseState.FncDeclArgs;\n            var returnType: AST = null;\n            if (this.currentToken.tokenId == TokenID.Colon) {\n                this.currentToken = this.scanner.scan();\n                if (hasFlag(modifiers, Modifiers.Setter)) {\n                    this.reportParseError("Property setters may not declare a return type");\n                }\n                returnType = this.parseTypeReference(errorRecoverySet, true);\n            }\n\n            if (indexer && args.members.length == 0) {\n                this.reportParseError("Index signatures require a parameter type to be specified");\n            }\n            this.state = ParseState.FncDeclReturnType;\n\n            if (isLambda && this.currentToken.tokenId != TokenID.EqualsGreaterThan) {\n                this.reportParseError("Expected \'=>\'");\n            }\n\n            // REVIEW:\n            // Currently, it\'s imperative that ambient functions *not* be marked as overloads.  At some point, we may\n            // want to unify the two concepts internally\n            if (isDecl && !(this.parsingDeclareFile || markedAsAmbient) && (!isMethod || !(this.ambientModule || this.ambientClass || this.inInterfaceDecl)) && this.currentToken.tokenId == TokenID.Semicolon) {\n                isOverload = true;\n                isDecl = false;\n                requiresSignature = true;\n            }\n            var svInFncDecl = this.inFncDecl;\n            this.inFncDecl = true;\n            var funcDecl: FuncDecl =\n                this.parseFunctionStatements(\n                errorRecoverySet | ErrorRecoverySet.RCurly,\n                name, /*isConstructor:*/ false, isMethod, args, AllowedElements.None,\n                minChar, requiresSignature, Modifiers.None);\n\n            this.inFncDecl = svInFncDecl;\n            funcDecl.variableArgList = variableArgList;\n            funcDecl.isOverload = isOverload;\n\n            if (!requiresSignature) { // REVIEW: What\'s the point of this?  Why not just use \'Signature\' instead of \'Definition\'?\n                funcDecl.fncFlags |= FncFlags.Definition;\n            }\n\n            if (isStatic) {\n                funcDecl.fncFlags |= FncFlags.Static;\n            }\n\n            if (requiresSignature) {\n                funcDecl.fncFlags |= FncFlags.Signature;\n            }\n            if (indexer) {\n                funcDecl.fncFlags |= FncFlags.IndexerMember;\n            }\n            funcDecl.returnTypeAnnotation = returnType;';
var v27610 = v27611 + '\n            if (isMethod) {\n                funcDecl.fncFlags |= FncFlags.Method;\n                // all class property methods are currently exported\n                funcDecl.fncFlags |= FncFlags.ClassPropertyMethodExported;\n            }\n            funcDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            funcDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n\n            this.nestingLevel = prevNestingLevel;\n            this.parsingClassConstructorDefinition = prevInConstr;\n            funcDecl.preComments = preComments;\n            return funcDecl;\n        }\n\n        private convertToTypeReference(ast: AST): TypeReference {\n            var result: TypeReference;\n            switch (ast.nodeType) {\n                case NodeType.TypeRef:\n                    return <TypeReference>ast;\n                case NodeType.Name:\n                    result = new TypeReference(ast, 0);\n                    result.minChar = ast.minChar;\n                    result.limChar = ast.limChar;\n                    return result;\n                case NodeType.Index: {\n                    var expr = <BinaryExpression>ast;\n                    result = this.convertToTypeReference(expr.operand1);\n                    if (result) {\n                        result.arrayCount++;\n                        result.minChar = expr.minChar;\n                        result.limChar = expr.limChar;\n                        return result;\n                    }\n                    else {\n                        var etr = <TypeReference>new AST(NodeType.Error);\n                        return etr;\n                    }\n                }\n            }\n            return null;\n        }\n\n        private parseArgList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var args: ASTList = new ASTList();\n            args.minChar = this.scanner.startPos;\n\n            // skip left paren\n            this.currentToken = this.scanner.scan();\n\n            if (this.currentToken.tokenId !== TokenID.CloseParen) {\n                while (true) {\n                    if (args.members.length > 0xffff) {\n                        this.reportParseError("max number of args exceeded");\n                        break;\n                    }\n\n                    var arg = this.parseExpr(\n                        ErrorRecoverySet.Comma | errorRecoverySet,\n                        OperatorPrecedence.Comma, \n                        /*allowIn:*/ true,\n                        TypeContext.NoTypes);\n\n                    args.append(arg);\n                    if (this.currentToken.tokenId != TokenID.Comma) {\n                        break;\n                    }\n\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n\n            args.limChar = this.scanner.pos;\n            return args;\n        }\n\n        private parseBaseList(extendsList: ASTList,\n                              implementsList: ASTList,\n                              errorRecoverySet: ErrorRecoverySet,\n                              isClass: bool): void {\n            var keyword = true;\n            var currentList = extendsList;\n            for (; ;) {\n                if (keyword) {\n                    if (this.currentToken.tokenId === TokenID.Implements) {\n                        currentList = implementsList;\n                    }\n                    else if (this.currentToken.tokenId == TokenID.Extends && !this.requiresExtendsBlock) {\n                        this.requiresExtendsBlock = isClass;\n                    }\n                    this.currentToken = this.scanner.scan();\n                    keyword = false;\n                }\n                var baseName: Identifier = null;\n                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                    var minChar = this.scanner.startPos;\n                    baseName = Identifier.fromToken(this.currentToken);\n                    baseName.minChar = minChar;\n                    baseName.limChar = this.scanner.pos;\n                    baseName = <Identifier>this.parseNamedType(errorRecoverySet | ErrorRecoverySet.LCurly,\n                                            minChar, baseName, false);\n                }\n                else {\n                    this.reportParseError("Expected base name");\n                    if (this.errorRecovery) {\n                        baseName = new MissingIdentifier();\n                        baseName.minChar = this.scanner.pos;\n                        baseName.limChar = this.scanner.pos;\n                        baseName.flags |= ASTFlags.Error;\n                    }\n                }\n                if (this.currentToken.tokenId == TokenID.OpenParen) {\n                    if (isClass) {\n                        this.reportParseError("Base classes may only be initialized via a \'super\' call within the constructor body");\n                    }\n                    else {\n                        th';
var v27609 = v27610 + 'is.reportParseError("Interfaces may not be extended with a call expression");\n                    }\n                }\n                else {\n                    currentList.append(baseName);\n                }\n\n                if (isClass && currentList == extendsList && extendsList.members.length > 1) {\n                    this.reportParseError("A class may only extend one other class");\n                }\n\n                if (this.currentToken.tokenId == TokenID.Comma) {\n                    this.currentToken = this.scanner.scan();\n                    continue;\n                }\n\n                else if ((this.currentToken.tokenId == TokenID.Extends) ||\n                         (this.currentToken.tokenId == TokenID.Implements)) {\n\n                    if (this.currentToken.tokenId == TokenID.Extends && !this.requiresExtendsBlock) {\n                        this.requiresExtendsBlock = isClass;\n                    }\n\n                    currentList = extendsList;\n                    keyword = true;\n                    continue;\n                }\n\n                break;\n            }\n        }\n\n        private parseClassDecl(errorRecoverySet: ErrorRecoverySet, minChar: number, modifiers: Modifiers): ClassDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            if ((modifiers & Modifiers.Readonly) != Modifiers.None) {\n                this.reportParseError("const modifier is implicit for class");\n            }\n\n            // mark the class as ambient, as necessary\n            if (this.parsingDeclareFile || this.ambientModule) {\n                modifiers |= Modifiers.Ambient;\n                modifiers |= Modifiers.Exported;\n            }\n            var classIsMarkedAsAmbient = this.parsingDeclareFile || (modifiers & Modifiers.Ambient) != Modifiers.None;\n            var svAmbientClass = this.ambientClass;\n            this.ambientClass = classIsMarkedAsAmbient;\n\n            // grab the class\'s name\n            this.currentToken = this.scanner.scan();\n            var name: Identifier = null;\n            if ((this.currentToken.tokenId == TokenID.Identifier) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode)) ) {\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n            }\n            else {\n                this.reportParseError("class missing name");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.pos;\n                    name.limChar = this.scanner.pos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var extendsList: ASTList = null;\n            var implementsList: ASTList = null;\n            var requiresSignature = false;\n\n            if ((this.currentToken.tokenId == TokenID.Extends) ||\n                (this.currentToken.tokenId == TokenID.Implements)) {\n                extendsList = new ASTList();\n                implementsList = new ASTList();\n                this.parseBaseList(extendsList, implementsList, errorRecoverySet, /*isClass:*/ true);\n            }\n\n            // REVIEW: Note that we don\'t set this as the current class decl\n            var classDecl = new ClassDeclaration(name, new ASTList(), extendsList, implementsList);\n\n            this.currentClassDefinition = classDecl;\n\n            // parse the classes members\n            this.parseClassElements(classDecl, errorRecoverySet, modifiers);\n\n            if (this.ambientModule || this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Exported)) {\n                classDecl.varFlags |= VarFlags.Exported;\n            }\n\n            if (this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                classDecl.varFlags |= VarFlags.Ambient;\n            }\n\n            classDecl.varFlags |= VarFlags.Class;\n\n            this.ambientClass = svAmbientClass;\n            classDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            classDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return classDecl;\n        }\n\n        private parseClassElements(classDecl: ClassDeclaration, errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers) {\n            var modifiers = parentModifiers;\n            var resetModifiers = false;\n\n            var membersMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet);\n\n            this.nestingLevel++;\n\n            var currentMemberMinChar = this.scanner.startPos;\n            var wasGetOrSetId = false;\n\n            while (!(this.currentToken.tokenId == TokenID.CloseBrace || this.currentToken.tokenId == TokenID.EndOfFile)) {\n                var scanNext = true;';
var v27608 = v27609 + '\n                var publicOrPrivateFlags = Modifiers.Public | Modifiers.Private;\n\n                // modifiers\n                if (this.currentToken.tokenId == TokenID.Get) {\n                    if (modifiers & Modifiers.Getter) {\n                        this.reportParseError("Duplicate \'get\' declaration in class body");\n                    }\n                    if (modifiers & Modifiers.Setter) {\n                        this.reportParseError("Getter already marked as a setter");\n                    }\n                    modifiers |= Modifiers.Getter;\n                }\n                else if (this.currentToken.tokenId == TokenID.Set) {\n                    if (modifiers & Modifiers.Setter) {\n                        this.reportParseError("Duplicate \'set\' declaration in class body");\n                    }\n                    if (modifiers & Modifiers.Getter) {\n                        this.reportParseError("Setter already marked as a getter");\n                    }\n                    modifiers |= Modifiers.Setter;\n\n                }\n                else if (this.currentToken.tokenId == TokenID.Private) {\n                    if (modifiers & publicOrPrivateFlags) {\n                        this.reportParseError("Multiple modifiers may not be applied to class members");\n                    }\n                    modifiers |= Modifiers.Private;\n                }\n                else if (this.currentToken.tokenId == TokenID.Public) {\n                    if (modifiers & publicOrPrivateFlags) {\n                        this.reportParseError("Multiple modifiers may not be applied to class members");\n                    }\n                    modifiers |= Modifiers.Public;\n                }\n                else if (this.currentToken.tokenId == TokenID.Static) {\n                    if (modifiers & Modifiers.Static) { // only check for double instances of static\n                        this.reportParseError("Multiple modifiers may not be applied to class members");\n                    }\n                    modifiers |= Modifiers.Static;\n                }  // constructors\n                else if (this.currentToken.tokenId == TokenID.Constructor) {\n\n                    if (modifiers != parentModifiers) {\n                        this.reportParseError("Constructors may not have modifiers");\n                    }\n\n                    this.parseClassConstructorDeclaration(currentMemberMinChar, errorRecoverySet, modifiers);\n                    scanNext = false; // parsing functions advances the token for us\n                    resetModifiers = true;\n                }  // member declarations\n                else if (wasGetOrSetId || this.currentToken.tokenId == TokenID.Identifier || convertTokToIDName(this.currentToken)) {\n\n                    var idText = wasGetOrSetId ? ((modifiers & Modifiers.Getter) ? "get" : "set") : this.currentToken.getText();\n                    var id = wasGetOrSetId ? new Identifier(idText) : Identifier.fromToken(this.currentToken);\n                    id.minChar = this.scanner.startPos;\n                    id.limChar = this.scanner.pos;\n\n                    // unset the get/set bit, if we\'re using it for an id\n                    if (wasGetOrSetId) {\n                        modifiers = modifiers ^ ((modifiers & Modifiers.Getter) ? Modifiers.Getter : Modifiers.Setter);\n                        wasGetOrSetId = false;\n                    }\n                    else {\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.currentToken.tokenId == TokenID.OpenParen) {\n                        this.parseClassMemberFunctionDeclaration(id, currentMemberMinChar, errorRecoverySet, modifiers);\n                        scanNext = false; // parsing functions advances the token for us\n                    }\n                    else {\n                        if (modifiers & Modifiers.Getter || modifiers & Modifiers.Setter) {\n                            this.reportParseError("Property accessors must be functions");\n                        }\n\n                        var varDecl = this.parseClassMemberVariableDeclaration(id, currentMemberMinChar, false, errorRecoverySet, modifiers);\n\n                        if (varDecl.init && varDecl.init.nodeType == NodeType.FuncDecl) {\n                            if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                                scanNext = false;\n                            }\n                        }\n                        else if (varDecl.init && varDecl.init.nodeType == NodeType.ObjectLit && this.currentToken.tokenId != TokenID.Semicolon) {\n                            scanNext = false;\n                            varDecl.init.flags |= ASTFlags.AutomaticSemicolon;\n                        }\n                        else if (this.currentToken.tokenId != TokenID.Semicolon) {\n                            this.reportParseError("Expected \';\'");\n                            scanNext = false;\n                        }';
var v27607 = v27608 + "\n                    }\n\n                    resetModifiers = true;\n                } // catch errant uses of 'super'\n                else if (this.currentToken.tokenId == TokenID.Super) {\n                    this.reportParseError(\"Base class initializers must be the first statement in a class definition\");\n                }\n                else if (!wasGetOrSetId && ((modifiers & Modifiers.Getter) || (modifiers & Modifiers.Setter)) &&\n                         ((this.currentToken.tokenId == TokenID.OpenParen) || (this.currentToken.tokenId == TokenID.Equals) ||\n                          (this.currentToken.tokenId == TokenID.Colon) || (this.currentToken.tokenId == TokenID.Semicolon))) {\n                             // catch a 'get' or 'set' used as an identifier\n                    wasGetOrSetId = true;\n                    scanNext = false;\n\n                }  // mark anything else as an error\n                else if (this.currentToken.tokenId != TokenID.Semicolon) { // jettison semicolons\n                    this.reportParseError(\"Unexpected '\" + this.currentToken.getText() + \"' in class definition\");\n                    resetModifiers = true;\n                }\n\n                if (scanNext) {\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (resetModifiers) {\n                    modifiers = parentModifiers;\n                    currentMemberMinChar = this.scanner.startPos;\n                    resetModifiers = false;\n                }\n            }\n\n            var membersLimChar = this.scanner.pos;\n            if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                classDecl.endingToken = new ASTSpan();\n                classDecl.endingToken.minChar = this.scanner.startPos;\n                classDecl.endingToken.limChar = this.scanner.pos;\n\n                // for a class with an empty body, consume any 'dangling' inner comments\n                if (!this.currentClassDefinition.members.members.length) {\n                    this.currentClassDefinition.preComments = this.parseComments();\n                }\n\n                this.currentToken = this.scanner.scan();\n            }\n\n            this.nestingLevel--;\n\n            this.currentClassDefinition.members.minChar = membersMinChar;\n            this.currentClassDefinition.members.limChar = membersLimChar;\n            this.currentClassDefinition.limChar = membersLimChar;\n            this.currentClassDefinition = null;\n        }\n\n        private parseClassConstructorDeclaration(minChar: number, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n            this.parsingClassConstructorDefinition = true;\n\n            var isAmbient = this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient);\n\n            var args: ASTList = new ASTList();\n            var variableArgList = false;\n            var preComments = this.parseComments();\n\n            this.currentToken = this.scanner.scan(); // scan past the 'constructor' token\n\n            if (this.currentToken.tokenId == TokenID.OpenParen) {\n                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, true, isAmbient, false, false, false, false, null, true);\n                if (args.members.length > 0) {\n                    var lastArg = args.members[args.members.length - 1];\n                }\n            }\n\n            var requiresSignature = isAmbient || this.currentToken.tokenId == TokenID.Semicolon;\n\n\n            if (requiresSignature) {\n                for (var i = 0; i < args.members.length; i++) {\n                    var arg = <ArgDecl> args.members[i];\n                    if (hasFlag(arg.varFlags, VarFlags.Property)) {\n                        this.reportParseError(\"Overload or ambient signatures may not specify parameter properties\", arg.minChar, arg.limChar);\n                    }\n                }\n            }\n\n            if (!requiresSignature) {\n                this.currentClassDefinition.constructorNestingLevel = this.nestingLevel + 1;\n            }\n\n            var constructorFuncDecl = this.parseFunctionStatements(\n                errorRecoverySet | ErrorRecoverySet.RCurly, this.currentClassDefinition.name, \n                /*isConstructor:*/ true, /*isMethod:*/ false, args, AllowedElements.Properties, \n                minChar, requiresSignature, modifiers);\n\n            constructorFuncDecl.preComments = preComments;\n\n            if (requiresSignature && !isAmbient) {\n                constructorFuncDecl.isOverload = true;\n            }\n\n            constructorFuncDecl.variableArgList = variableArgList;\n            this.currentClassDecl = null;\n            constructorFuncDecl.returnTypeAnnotation = this.convertToTypeReference(this.currentClassDefinition.name);\n            constructorFuncDecl.classDecl = this.currentClassDefinition;\n\n            if (isAmbient) {\n                constructorFuncDecl.fncFlags |= FncFlags.Ambient;\n            }\n\n            if (requiresSignature) {\n                constructorF";
var v27606 = v27607 + 'uncDecl.fncFlags |= FncFlags.Signature;\n            }\n\n            if (this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                constructorFuncDecl.fncFlags |= FncFlags.Exported;\n            }\n\n\n            if (this.currentClassDefinition.constructorDecl) {\n                if (!isAmbient && !this.currentClassDefinition.constructorDecl.isSignature() && !constructorFuncDecl.isSignature()) {\n                    this.reportParseError("Duplicate constructor definition");\n                }\n            }\n\n            if (isAmbient || !constructorFuncDecl.isSignature()) {\n                this.currentClassDefinition.constructorDecl = constructorFuncDecl;\n            }\n\n            // REVIEW: Should we have a separate flag for class constructors?  (Constructors are not methods)\n            constructorFuncDecl.fncFlags |= FncFlags.ClassMethod;\n\n            this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = constructorFuncDecl;\n\n            this.parsingClassConstructorDefinition = false;\n\n            return constructorFuncDecl;\n        }\n\n        private parseClassMemberVariableDeclaration(text: Identifier, minChar: number, isDeclaredInConstructor: bool, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n\n            var varDecl = new VarDecl(text, this.nestingLevel);\n            varDecl.minChar = minChar;\n            var isStatic = false;\n            varDecl.preComments = this.parseComments();\n\n            if (this.currentToken.tokenId == TokenID.Colon) {\n                this.currentToken = this.scanner.scan();\n                varDecl.typeExpr =\n                    this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg | ErrorRecoverySet.Comma, false);\n                if (varDecl.typeExpr && varDecl.typeExpr.nodeType == NodeType.TypeRef) {\n                    var typeExpr = (<TypeReference>varDecl.typeExpr);\n                    if (typeExpr.term && typeExpr.term.nodeType == NodeType.FuncDecl) {\n                        typeExpr.term.preComments = varDecl.preComments;\n                    }\n                }\n            }\n\n            if (this.currentToken.tokenId == TokenID.Equals) {\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    this.reportParseError("context does not permit variable initializer");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        varDecl.flags |= ASTFlags.Error;\n                        varDecl.limChar = this.scanner.lastTokenLimChar();\n                        return varDecl;\n                    }\n                }\n\n                // TODO: note assignment for language service\n                this.currentToken = this.scanner.scan();\n\n                varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                        OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n\n                varDecl.limChar = varDecl.init.limChar;\n\n                // member initializers on instance properties require that super be invoked as the first call within the constructor\n                if (!(modifiers & Modifiers.Static)) {\n                    this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                }\n            }\n            else {\n                varDecl.limChar = this.scanner.pos;\n            }\n\n            if (modifiers & Modifiers.Static) {\n                varDecl.varFlags |= VarFlags.Static;\n                isStatic = true;\n            }\n\n            if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                varDecl.varFlags |= VarFlags.Private;\n            }\n            else {\n                varDecl.varFlags |= VarFlags.Public;\n            }\n\n            varDecl.varFlags |= VarFlags.Property;\n\n            if (isDeclaredInConstructor) {\n                varDecl.varFlags |= VarFlags.ClassConstructorProperty;\n            }\n\n            if (!isDeclaredInConstructor && !isStatic) {\n                varDecl.varFlags |= VarFlags.ClassBodyProperty;\n            }\n\n            this.currentClassDefinition.knownMemberNames[text.actualText] = true;\n\n            if (!isDeclaredInConstructor) {\n                this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = varDecl;\n            }\n\n            varDecl.postComments = this.parseComments();\n            return varDecl;\n        }\n\n        private parseClassMemberFunctionDeclaration(methodName: Identifier, minChar: number, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n            var wasAccessorID = this.prevIDTok != null;\n            var isAccessor = hasFlag(modifiers, Modifiers.Getter) || hasFlag(modifiers, Modifiers.Setter);\n            var isStatic = hasFlag(modifiers, Modifiers.Static);\n\n            var isAmbient = this.ambientModule || hasFlag(modifiers, Modifiers.Ambient);\n\n            er';
var v27605 = v27606 + 'rorRecoverySet |= ErrorRecoverySet.RParen;\n\n            if (isAccessor && (modifiers & Modifiers.Ambient)) {\n                this.reportParseError("Property accessors may not be declared in ambient classes");\n            }\n\n            // REVIEW: Why bother passing in isAmbient for both requiresSignature and isAmbient?  Shouldn\'t just saying its ambient suffice?\n            var ast: AST = this.parseFncDecl(errorRecoverySet, true, isAmbient, true, methodName, false, isStatic, isAmbient, modifiers, null, true);\n            if (ast.nodeType == NodeType.Error) {\n                return ast;\n            }\n\n            var funcDecl = <FuncDecl>ast;\n\n            funcDecl.minChar = minChar;\n            if (funcDecl.bod !== null)\n                funcDecl.limChar = funcDecl.bod.limChar;\n\n            if (modifiers & Modifiers.Private) {\n                funcDecl.fncFlags |= FncFlags.Private;\n            }\n            else {\n                funcDecl.fncFlags |= FncFlags.Public;\n            }\n\n            if (isStatic) {\n                funcDecl.fncFlags |= FncFlags.Static;\n            }\n\n            if (isAccessor) {\n                // REVIEW: verify return-type annotations and arguments\n                if (hasFlag(modifiers, Modifiers.Getter)) {\n                    funcDecl.fncFlags |= FncFlags.GetAccessor;\n                    funcDecl.hint = "get" + funcDecl.name.actualText;\n                }\n                else {\n                    funcDecl.fncFlags |= FncFlags.SetAccessor;\n                    funcDecl.hint = "set" + funcDecl.name.actualText;\n                }\n                funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n                if (codeGenTarget < CodeGenTarget.ES5) {\n                    this.reportParseError("Property accessors are only available when targeting ES5 or greater", funcDecl.minChar, funcDecl.limChar);\n                }\n            }\n\n            funcDecl.fncFlags |= FncFlags.ClassMethod;\n\n            this.currentClassDefinition.knownMemberNames[methodName.actualText] = true;\n\n            this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = funcDecl;\n\n            return funcDecl;\n        }\n\n        private parseTypeMember(errorRecoverySet: ErrorRecoverySet): AST {\n            var minChar = this.scanner.startPos;\n\n            var propertyDecl = this.parsePropertyDeclaration(\n                errorRecoverySet, Modifiers.Public, /*requireSignature:*/ true, /*isStatic:*/ false);\n\n            if (propertyDecl) {\n                propertyDecl.minChar = minChar;\n\n                if (propertyDecl.nodeType == NodeType.VarDecl) {\n                     this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet);\n                }\n            }\n\n            return propertyDecl;\n        }\n\n        private parseTypeMemberList(errorRecoverySet: ErrorRecoverySet, members: ASTList) {\n            errorRecoverySet |= ErrorRecoverySet.TypeScriptS;\n            while (true) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.CloseBrace:\n                    case TokenID.EndOfFile:\n                        members.limChar = this.scanner.pos;\n                        return;\n                }\n\n                // REVIEW: This code looks suspect.  If parseTypeMember returns null, then \n                // won\'t we just infinite loop?\n                var element = this.parseTypeMember(errorRecoverySet);\n                if (element) {\n                    members.append(element);\n                }\n            }\n        }\n\n        private parseInterfaceDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): InterfaceDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            this.currentToken = this.scanner.scan();\n            var minChar = this.scanner.pos;\n            var name: Identifier = null;\n            if ((this.currentToken.tokenId == TokenID.Identifier) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode))) {\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n            }\n            else {\n                this.reportParseError("interface missing name");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.pos;\n                    name.limChar = this.scanner.pos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var extendsList: ASTList = null;\n            var implementsList: ASTList = null;\n            if (this.currentToken.tokenId === TokenID.Extends || this.currentToken.tokenId === TokenID.Implements) {\n                if (this.currentToken.tokenId === TokenID.Implements) {\n            ';
var v27604 = v27605 + '        this.reportParseError("Expected \'extends\'");\n                }\n\n                extendsList = new ASTList();\n                implementsList = new ASTList();\n                extendsList.minChar = this.scanner.startPos;\n                this.parseBaseList(extendsList, implementsList, errorRecoverySet, /*isClass:*/ false);\n            }\n\n            var membersMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.TypeScriptS);\n            var members = new ASTList();\n            members.minChar = membersMinChar;\n            var prevInInterfaceDecl = this.inInterfaceDecl;\n            this.inInterfaceDecl = true;\n            this.parseTypeMemberList(errorRecoverySet | ErrorRecoverySet.RCurly, members);\n            this.inInterfaceDecl = prevInInterfaceDecl;\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n            // REVIEW: According to the grammar, an interface declaration should actually just\n            // have an \'ObjectType\' and not a list of members.  We may want to consider making that\n            // change.  Note: it would mean breaking aparat TypeDecl into InterfaceDeclaration and \n            // ClassDeclaration.\n            var interfaceDecl = new InterfaceDeclaration(name, members, extendsList, null);\n            if (hasFlag(modifiers, Modifiers.Private)) {\n                interfaceDecl.varFlags |= VarFlags.Private;\n            }\n            if (hasFlag(modifiers, Modifiers.Public)) {\n                interfaceDecl.varFlags |= VarFlags.Public;\n            }\n            if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                interfaceDecl.varFlags |= VarFlags.Exported;\n            }\n\n            interfaceDecl.limChar = members.limChar;\n            interfaceDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            interfaceDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return interfaceDecl;\n        }\n\n        private makeVarDecl(id: Identifier, nest: number): VarDecl {\n            var varDecl = new VarDecl(id, nest);\n            var currentVarList = this.topVarList();\n            if (currentVarList) {\n                currentVarList.append(varDecl);\n            }\n            return varDecl;\n        }\n\n        private parsePropertyDeclaration(\n            errorRecoverySet: ErrorRecoverySet,\n            modifiers: Modifiers,\n            requireSignature: bool,\n            isStatic: bool): AST {\n\n            var text: Identifier = null;\n            var minChar = this.scanner.startPos;\n            var nameLimChar = minChar;\n            var isNew = false;\n            var isIndexer = false;\n            var wasAccessorID = this.prevIDTok != null;\n            var isAccessor = hasFlag(modifiers, Modifiers.Getter) || hasFlag(modifiers, Modifiers.Setter);\n\n            if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                requireSignature = true;\n            }\n\n            if (this.currentToken.tokenId == TokenID.OpenParen && !wasAccessorID) {\n                if (!requireSignature && !isStatic) {\n                    this.reportParseError("Expected identifier in property declaration");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        //REVIEW: Use something else than "Identifier"?\n                        text = new MissingIdentifier();\n                    }\n                }\n            }\n            else if (this.currentToken.tokenId == TokenID.New) {\n                if (requireSignature) {\n                    this.currentToken = this.scanner.scan();\n                    if (this.currentToken.tokenId == TokenID.OpenParen) {\n                        isNew = true;\n                    }\n                }\n\n                if (!isNew) {\n                    // is identifier\n                    if (!requireSignature) {\n                        this.currentToken = this.scanner.scan();\n                    }\n                    text = new Identifier("new");\n                    text.minChar = this.scanner.pos - 3;\n                    text.limChar = this.scanner.pos;\n                    nameLimChar = this.scanner.pos;\n                }\n            }\n            else if ((this.currentToken.tokenId == TokenID.OpenBracket) && requireSignature) {\n                // indexer signature\n                isIndexer = true;\n                //REVIEW: Should we use a special "compiler reserved" identifier node?\n                text = new Identifier("__item");\n            }\n            else if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToIDName(this.currentToken)) && !wasAccessorID) {\n                this.reportParseError("Expected identifier in property declaration");\n                if (this.errorRecovery) {\n                    var eminChar = this.scanner.startPos;\n             ';
var v27603 = v27604 + '       var curpos = this.scanner.pos;\n                    this.skip(errorRecoverySet & (~ErrorRecoverySet.Comma));\n                    if (this.scanner.pos == curpos) {\n                        // ensure progress\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    var epd = new VarDecl(new MissingIdentifier(), this.nestingLevel);\n                    epd.flags |= ASTFlags.Error;\n                    epd.minChar = eminChar;\n                    epd.limChar = this.scanner.lastTokenLimChar();\n                    return epd;\n                }\n            }\n            else {\n                if (wasAccessorID) {\n                    text = Identifier.fromToken(this.prevIDTok);\n                    text.minChar = this.scanner.lastTokenLimChar() - 3;\n                    text.limChar = this.scanner.lastTokenLimChar();\n                    nameLimChar = text.limChar;\n\n                    if (codeGenTarget < CodeGenTarget.ES5) {\n                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                    }\n\n                    // this block guards against \'get\' and \'set\' tokens that\n                    // were coerced into identifiers\n                    if (this.currentToken.getText() == text.actualText && this.currentToken != this.prevIDTok) {\n                        this.currentToken = this.scanner.scan();\n                    } // Otherwise, don\'t update the token - we\'re already at \'(\'\n\n                    // reset the previous ID Token\n                    this.prevIDTok = null;\n                }\n                else {\n                    text = Identifier.fromToken(this.currentToken);\n                    text.minChar = this.scanner.startPos;\n                    text.limChar = this.scanner.pos;\n                    nameLimChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n\n            if (this.currentToken.tokenId == TokenID.Question) {\n                if (this.inInterfaceDecl && text) {\n                    text.flags |= ASTFlags.OptionalName;\n                }\n                else {\n                    this.reportParseError("Optional properties may only be declared on interface or object types");\n                }\n                this.currentToken = this.scanner.scan();\n            }\n\n            if ((this.currentToken.tokenId == TokenID.OpenParen) ||\n                (isIndexer && (this.currentToken.tokenId == TokenID.OpenBracket))) {\n                var ers = errorRecoverySet | ErrorRecoverySet.RParen;\n                if (isIndexer) {\n                    ers = errorRecoverySet | ErrorRecoverySet.RBrack;\n                }\n                var ast = this.parseFncDecl(ers, true, requireSignature,\n                                       !this.inFncDecl, text, isIndexer, isStatic, (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)), modifiers, null, true);\n                var funcDecl: FuncDecl;\n                if (ast.nodeType == NodeType.Error) {\n                    return ast;\n                }\n                else {\n                    funcDecl = <FuncDecl>ast;\n                }\n                if (funcDecl.name) {\n                    funcDecl.name.minChar = minChar;\n                    funcDecl.name.limChar = nameLimChar;\n                }\n                if ((modifiers & Modifiers.Public) != Modifiers.None) {\n                    funcDecl.fncFlags |= FncFlags.Public;\n                }\n                if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                    funcDecl.fncFlags |= FncFlags.Private;\n                }\n                if (isStatic) {\n                    funcDecl.fncFlags |= FncFlags.Static;\n                }\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    funcDecl.fncFlags |= FncFlags.Ambient;\n                }\n                if (isAccessor) {\n                    // REVIEW: verify return-type annotations and arguments\n                    if (hasFlag(modifiers, Modifiers.Getter)) {\n                        funcDecl.fncFlags |= FncFlags.GetAccessor;\n                        funcDecl.hint = "get" + funcDecl.name.actualText;\n                    }\n                    else {\n                        funcDecl.fncFlags |= FncFlags.SetAccessor;\n                        funcDecl.hint = "set" + funcDecl.name.actualText;\n                    }\n                    funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n\n                    if (modifiers & Modifiers.Ambient) {\n                        this.reportParseError("Property accessors may not be declared in ambient types");\n                    }\n                }\n\n                if (text == null) {\n                    if (isNew) {\n                        funcDecl.fncFlags |= FncFlags.ConstructMember;\n                        funcDecl.hint = "_construct";\n                        funcDecl.classDecl = thi';
var v27602 = v27603 + 's.currentClassDecl;\n                    }\n                    else {\n                        funcDecl.hint = "_call";\n                        funcDecl.fncFlags |= FncFlags.CallMember;\n                    }\n                }\n                return funcDecl;\n            }\n            else {\n                var varDecl = new VarDecl(text, this.nestingLevel);\n                varDecl.preComments = this.parseComments();\n                varDecl.minChar = minChar;\n                if (this.currentToken.tokenId == TokenID.Colon) {\n                    this.currentToken = this.scanner.scan();\n                    varDecl.typeExpr =\n                        this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg |\n                                           ErrorRecoverySet.Comma, false);\n                    if (varDecl.typeExpr && varDecl.typeExpr.nodeType == NodeType.TypeRef) {\n                        var typeExpr = (<TypeReference>varDecl.typeExpr);\n                        if (typeExpr.term && typeExpr.term.nodeType == NodeType.FuncDecl) {\n                            typeExpr.term.preComments = varDecl.preComments;\n                        }\n                    }\n                }\n                if (this.currentToken.tokenId == TokenID.Equals) {\n                    if (requireSignature) {\n                        this.reportParseError("context does not permit variable initializer");\n                        if (this.errorRecovery) {\n                            this.skip(errorRecoverySet);\n                            varDecl.flags |= ASTFlags.Error;\n                            varDecl.limChar = this.scanner.lastTokenLimChar();\n                            return varDecl;\n                        }\n                    }\n                    // TODO: note assignment for language service\n                    this.currentToken = this.scanner.scan();\n                    varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                           OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n                    varDecl.limChar = varDecl.init.limChar;\n                    if (varDecl.init.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>varDecl.init;\n                        funcDecl.hint = varDecl.id.text;\n                        funcDecl.boundToProperty = varDecl;\n                    }\n                    else if (isAccessor) {\n                        this.reportParseError("Accessors may only be functions");\n                    }\n                }\n                else {\n                    varDecl.limChar = this.scanner.pos;\n                }\n                if ((modifiers & Modifiers.Readonly) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Readonly;\n                }\n                if (isStatic) {\n                    varDecl.varFlags |= VarFlags.Static;\n                }\n                if ((modifiers & Modifiers.Public) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Public;\n                }\n                if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Private;\n                }\n                varDecl.varFlags |= VarFlags.Property;\n                return varDecl;\n            }\n        }\n\n        private parseVariableDeclaration(\n            errorRecoverySet: ErrorRecoverySet,\n            modifiers: Modifiers,\n            allowIn: bool,\n            isStatic: bool): AST {\n\n            var isConst = hasFlag(modifiers, Modifiers.Readonly);\n            var minChar = this.scanner.startPos;\n            var varDecl: VarDecl = null;\n            var declList: ASTList = null;\n            var multivar = false;\n\n            this.currentToken = this.scanner.scan();\n            var varDeclPreComments = this.parseComments();\n\n            while (true) {\n                if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToID(this.currentToken, this.strictMode))) {\n                    this.reportParseError("Expected identifier in variable declaration");\n\n                    if (this.errorRecovery) {\n                        varDecl = new VarDecl(new MissingIdentifier(), this.nestingLevel);\n                        varDecl.minChar = minChar;\n                        this.skip(errorRecoverySet);\n                        varDecl.flags |= ASTFlags.Error;\n                        varDecl.limChar = this.scanner.lastTokenLimChar();\n                        return varDecl;\n                    }\n                }\n\n                var varDeclName = Identifier.fromToken(this.currentToken)\n                if (this.strictMode && (varDeclName.text == "eval")) {\n                    this.reportParseError("\'eval\' may not name a variable in strict mode");\n                }\n\n                varDecl = this.makeVarDecl(varDeclName, this.nestingLevel);\n                varDecl.id.minChar = this.scanner.startPos;\n                varDecl.id.limChar = this.scanner.pos;\n  ';
var v27601 = v27602 + '              varDecl.preComments = varDeclPreComments;\n\n                if (isStatic) {\n                    varDecl.varFlags |= VarFlags.Static;\n                }\n                if (hasFlag(modifiers, Modifiers.Readonly)) {\n                    varDecl.varFlags |= VarFlags.Readonly;\n                }\n                if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                    varDecl.varFlags |= VarFlags.Ambient;\n                }\n                if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                    varDecl.varFlags |= VarFlags.Exported;\n                }\n                varDecl.minChar = minChar;\n                if (declList) {\n                    declList.append(varDecl);\n                }\n\n                // move past ID; with error recovery need a test \n                this.currentToken = this.scanner.scan();\n                if (this.currentToken.tokenId == TokenID.Colon) {\n                    this.currentToken = this.scanner.scan();\n                    var prevInFncDecl = this.inFncDecl;\n                    this.inFncDecl = false;\n                    varDecl.typeExpr = this.parseTypeReference(\n                        errorRecoverySet | ErrorRecoverySet.Asg | ErrorRecoverySet.Comma, /*allowVoid:*/ false);\n                    this.inFncDecl = prevInFncDecl;\n                }\n\n                if (this.currentToken.tokenId == TokenID.Equals) {\n                    if (hasFlag(varDecl.varFlags, VarFlags.Ambient)) {\n                        this.reportParseError("Ambient variable can not have an initializer");\n                    }\n                    // TODO: note assignment for language service\n                    this.currentToken = this.scanner.scan();\n                    varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                           OperatorPrecedence.Comma, allowIn,\n                                           TypeContext.NoTypes);\n                    varDecl.limChar = varDecl.init.limChar;\n                    if (varDecl.init.nodeType == NodeType.FuncDecl) {\n                        // TODO: use \'as\' operator when can bootstrap\n                        var funcDecl = <FuncDecl>varDecl.init;\n                        funcDecl.hint = varDecl.id.actualText;\n                    }\n                }\n                else {\n                    if (isConst) {\n                        this.reportParseError("const declaration requires initializer");\n                    }\n                    varDecl.limChar = this.scanner.pos;\n                }\n                varDecl.postComments = this.parseCommentsForLine(this.scanner.line);\n\n                if (this.currentToken.tokenId != TokenID.Comma) {\n                    if (declList) {\n                        declList.limChar = varDecl.limChar;\n                        return declList;\n                    }\n                    else {\n                        return varDecl;\n                    }\n                }\n\n                if (!multivar) {\n                    declList = new ASTList();\n                    declList.minChar = varDecl.minChar;\n                    declList.append(varDecl);\n                    multivar = true;\n                }\n\n                this.currentToken = this.scanner.scan();\n                minChar = this.scanner.startPos;\n            }\n        }\n\n        private parseMemberList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var elements = new ASTList();\n            if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                return elements;\n            }\n\n            var idHint: string = null;\n            var memberName: AST = null;\n            var memberExpr: AST = null;\n            var member: BinaryExpression = null;\n            var minChar = this.scanner.startPos;\n            var isSet = false;\n            var skippedTokenForGetSetId = false;\n            var getSetTok: Token = null;\n            var getSetStartPos = 0;\n            var getSetPos = 0;\n\n            for (; ;) {\n                var accessorPattern = false;\n                if (this.currentToken.tokenId == TokenID.Get || this.currentToken.tokenId == TokenID.Set) {\n                    isSet = this.currentToken.tokenId == TokenID.Set;\n                    getSetTok = this.currentToken;\n                    getSetStartPos = this.scanner.startPos;\n                    getSetPos = this.scanner.pos;\n\n                    this.currentToken = this.scanner.scan();\n\n                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {\n                        idHint = isSet ? "set" : "get";\n                        idHint = idHint + this.currentToken.getText();\n                        memberName = Identifier.fromToken(this.currentToken);\n                        memberName.minChar = this.scanner.startPos;\n                        accessorPattern = true;\n                   ';
var v27600 = v27601 + '     if (codeGenTarget < CodeGenTarget.ES5) {\n                            this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                        }\n                    }\n                    else if (this.currentToken.tokenId != TokenID.Colon) {\n                        this.reportParseError("Expected identifier, string or number as accessor name");\n                    }\n                    else {\n                        skippedTokenForGetSetId = true;\n                        memberName = Identifier.fromToken(getSetTok);\n                        memberName.minChar = getSetStartPos;\n                        memberName.limChar = getSetPos;\n                    }\n                }\n                else if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {\n                    idHint = this.currentToken.getText();\n                    memberName = Identifier.fromToken(this.currentToken);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else if (this.currentToken.tokenId == TokenID.StringLiteral) {\n                    idHint = this.currentToken.getText();\n                    memberName = new StringLiteral(idHint);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                    // TODO: allow reserved words\n                else if (this.currentToken.tokenId == TokenID.NumberLiteral) {\n                    var ntok = <NumberLiteralToken>this.currentToken;\n                    idHint = ntok.value.toString();\n                    memberName = new StringLiteral(idHint);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else {\n                    this.reportParseError("Expected identifier, string or number as member name");\n                    if (this.errorRecovery) {\n                        memberName = new MissingIdentifier();\n                        memberName.minChar = this.scanner.startPos;\n                        memberName.flags |= ASTFlags.Error;\n                        this.skip(errorRecoverySet | ErrorRecoverySet.Comma);\n                        memberName.limChar = this.scanner.lastTokenLimChar();\n                    }\n                }\n\n                if (!skippedTokenForGetSetId) {\n                    this.currentToken = this.scanner.scan();\n                }\n                else {\n                    skippedTokenForGetSetId = false;\n                }\n\n                if (this.currentToken.tokenId == TokenID.Question) {\n                    memberName.flags |= ASTFlags.OptionalName;\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (accessorPattern) {\n                    var args = new ASTList();\n                    this.parseFormalParameterList(errorRecoverySet | ErrorRecoverySet.RParen,\n                                      args, false, true, false, !isSet, isSet, false, null, true);\n\n                    var funcDecl: FuncDecl =\n                        this.parseFunctionStatements(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                                <Identifier>memberName, false, true, args,\n                                                AllowedElements.None,\n                                                this.scanner.startPos, false, Modifiers.None);\n\n                    if (isSet && funcDecl.returnTypeAnnotation) {\n                        this.reportParseError("Property setters may not declare a return type");\n                    }\n\n                    funcDecl.fncFlags |= isSet ? FncFlags.SetAccessor : FncFlags.GetAccessor;\n                    funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n                    funcDecl.hint = idHint;\n                    memberExpr = funcDecl;\n                    member = new BinaryExpression(NodeType.Member, memberName, memberExpr);\n                    member.minChar = memberName.minChar;\n                    if (memberExpr.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>memberExpr;\n                        funcDecl.hint = idHint;\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.Colon) {\n                    this.currentToken = this.scanner.scan();\n                    memberExpr = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                         OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n                    // If the memberExpr is a type reference, we can be certain that it was an\n                    // array type declaraion that lacked a "new".  We can realistically only\n                    // expect call and name ASTs to be the result of this call to parseExpr.\n                   ';
var v27599 = v27600 + " // If it's a constructor without a \"new\", we'll flag it as an invalid\n                    // call site later on.\n                    if (memberExpr.nodeType == NodeType.TypeRef) {\n                        this.reportParseError(\"Expected 'new' on array declaration in member definition\")\n                    }\n                    member = new BinaryExpression(NodeType.Member, memberName, memberExpr);\n                    member.minChar = memberName.minChar;\n                    if (memberExpr.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>memberExpr;\n                        funcDecl.hint = idHint;\n                    }\n                }\n                else {\n                    this.reportParseError(\"Expected ':' in member definition\");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        elements.flags |= ASTFlags.Error;\n                        elements.minChar = minChar;\n                        elements.limChar = this.scanner.lastTokenLimChar();\n                        return elements;\n                    }\n                }\n                idHint = null;\n                elements.append(member);\n                member.limChar = this.scanner.lastTokenLimChar();\n                if (this.currentToken.tokenId != TokenID.Comma) {\n                    break;\n                }\n                else {\n                    // munch comma\n                    this.currentToken = this.scanner.scan();\n                }\n\n                // trailing comma allowed\n                if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                    break;\n                }\n            }\n\n            if (member) {\n                elements.limChar = member.limChar;\n            }\n            elements.minChar = minChar;\n            return elements;\n        }\n\n        private parseArrayList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var elements: ASTList = null;\n            if (this.currentToken.tokenId == TokenID.CloseBracket) {\n                return elements;\n            }\n            else {\n                elements = new ASTList();\n                elements.minChar = this.scanner.startPos;\n            }\n\n            var arg: AST;\n\n            for (; ;) {\n                if ((this.currentToken.tokenId == TokenID.Comma) ||\n                    (this.currentToken.tokenId == TokenID.CloseBracket)) {\n                    arg = new AST(NodeType.EmptyExpr);\n                }\n                else {\n                    arg = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                  OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n                }\n                elements.append(arg);\n                if (this.currentToken.tokenId != TokenID.Comma) {\n                    break;\n                }\n                this.currentToken = this.scanner.scan();\n            }\n            elements.limChar = this.scanner.lastTokenLimChar();\n            return elements;\n        }\n\n        private parseArrayLiteral(errorRecoverySet: ErrorRecoverySet): UnaryExpression {\n            var arrayLiteral: UnaryExpression = null;\n            arrayLiteral = new UnaryExpression(NodeType.ArrayLit,\n                                             this.parseArrayList(errorRecoverySet));\n            return arrayLiteral;\n        }\n\n        private parseTerm(errorRecoverySet: ErrorRecoverySet, allowCall: bool, typeContext: TypeContext, inCast: bool): AST {\n            var ast: AST = null;\n            var sawId = false;\n            var inNew = false;\n            var minChar = this.scanner.startPos;\n            var limChar = this.scanner.pos;\n            var parseAsLambda = false;\n            var expectlambdaRParen = false;\n\n            // keywords first\n            switch (this.currentToken.tokenId) {\n                case TokenID.Number:\n                case TokenID.Bool:\n                case TokenID.Any:\n                case TokenID.String:\n                    var tid = new Identifier(tokenTable[this.currentToken.tokenId].text);\n                    if (hasFlag(typeContext, TypeContext.Primitive)) {\n                        ast = new TypeReference(tid, 0);\n                        sawId = true;\n                    }\n                    else {\n                        ast = tid;\n                        sawId = true;\n                    }\n                    ast.minChar = minChar;\n                    this.currentToken = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.This:\n                    ast = new AST(NodeType.This);\n                    ast.minChar = minChar;\n                    this.currentToken = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.Super:\n                    ast = new AST(NodeType.Super);\n                    ast.minChar =";
var v27598 = v27599 + " minChar;\n                    this.currentToken = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.True:\n                    ast = new AST(NodeType.True);\n                    this.currentToken = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.False:\n                    ast = new AST(NodeType.False);\n                    this.currentToken = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.Null:\n                    ast = new AST(NodeType.Null);\n                    this.currentToken = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.New:\n                    minChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                    var target = this.parseTerm(errorRecoverySet, false, TypeContext.AllSimpleTypes, inCast);\n\n                    if (target.nodeType == NodeType.Error || (target.nodeType == NodeType.Index && (<BinaryExpression>target).operand1.nodeType == NodeType.TypeRef)) {\n                        this.reportParseError(\"Cannot invoke 'new' on this expression\");\n                    } else {\n                        ast = new CallExpression(NodeType.New, target, null);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        inNew = true;\n                    }\n                    break;\n                case TokenID.Function:\n                    minChar = this.scanner.pos;\n                    ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, null, true);\n                    (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n                    ast.minChar = minChar;\n                    limChar = this.scanner.lastTokenLimChar();\n                    ast.limChar = limChar;\n                    break;\n            }\n\n            if (ast == null) {\n                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n\n                    var idText = this.currentToken.getText();\n                    ast = this.createRef(idText, (<IdentifierToken>this.currentToken).hasEscapeSequence, minChar);\n                    sawId = true;\n \n                    ast.minChar = minChar;\n                    this.currentToken = this.scanner.scan();\n\n                    if (this.currentToken.tokenId == TokenID.Question) {\n                        ast.flags |= ASTFlags.PossibleOptionalParameter;\n                    }\n\n                    limChar = this.scanner.lastTokenLimChar();\n                }\n            }\n\n            if (inCast) {\n                this.checkCurrentToken(TokenID.GreaterThan, errorRecoverySet);\n            }\n\n            if (ast == null) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.OpenParen:\n                        minChar = this.scanner.pos;\n                        var prevTokId = this.scanner.previousToken().tokenId;\n                        this.currentToken = this.scanner.scan();\n\n                        var couldBeLambda = prevTokId == TokenID.OpenParen || // foo(()=>{});\n                                            prevTokId == TokenID.Comma || // foo(x,()=>{});\n                                            prevTokId == TokenID.EqualsEquals || // var foo = ()=>{};\n                                            prevTokId == TokenID.Colon;    // var x = { foo: ()=> {} };\n\n\n                        if (couldBeLambda && this.currentToken.tokenId == TokenID.CloseParen) {\n                            parseAsLambda = true;\n                            expectlambdaRParen = false;\n                            this.currentToken = this.scanner.scan();\n                        }\n                        else if (couldBeLambda && this.currentToken.tokenId == TokenID.DotDotDot) {\n                            parseAsLambda = true;\n                            expectlambdaRParen = true;\n                        }\n                        else {\n                            ast = this.parseExpr(errorRecoverySet | ErrorRecoverySet.RParen,\n                                          OperatorPrecedence.None, true, TypeContext.NoTypes, couldBeLambda);\n                            limChar = this.scanner.lastTokenLimChar();\n                            parseAsLambda = couldBeLambda && (ast.nodeType == NodeType.Name || ast.nodeType == NodeType.Comma) &&\n                                            (this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.Question);\n                            expectlambdaRParen = true;\n                        }\n\n                        // Check for the RParen if it's not an anonymous '=>' function\n                       ";
var v27597 = v27598 + " if ((ast && !parseAsLambda)) {\n                            if (hasFlag(ast.flags, ASTFlags.SkipNextRParen)) {\n                                // REVIEW: parseExpr resulted in a lambda node, the LParen scanned earlier, is the beginning of that node, and not of a parenthesized expression;\n                                //         do not look for a matching RParen for this node, but make sure to remove the flag, so that any enclosing parenthesis are matched correctly.\n                                ast.flags = ast.flags & (~(ASTFlags.SkipNextRParen)); \n                                break;\n                            }\n                            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);\n                            ast.isParenthesized = true;\n                        }\n\n                        break;\n                    case TokenID.NumberLiteral: {\n                        var numTok = <NumberLiteralToken>this.currentToken;\n                        this.currentToken = this.scanner.scan();\n                        ast = new NumberLiteral(numTok.value, numTok.hasEmptyFraction);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.StringLiteral:\n                        ast = new StringLiteral(this.currentToken.getText());\n                        this.currentToken = this.scanner.scan();\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    case TokenID.RegularExpressionLiteral: {\n                        var rtok = <RegularExpressionLiteralToken>this.currentToken;\n                        ast = new RegexLiteral(rtok.regex);\n                        this.currentToken = this.scanner.scan();\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.OpenBracket:\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        ast = this.parseArrayLiteral(ErrorRecoverySet.RBrack | errorRecoverySet);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.pos; // ']'\n                        this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet);\n                        break;\n                    // TODO: rescan regex for TokenID.Div and AsgDiv\n                        case TokenID.OpenBrace:\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var members = this.parseMemberList(ErrorRecoverySet.RCurly | errorRecoverySet)\n                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n                        ast = new UnaryExpression(NodeType.ObjectLit, members);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        members.minChar = minChar;\n                        members.limChar = limChar;\n                        break;\n\n                    case TokenID.LessThan:\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var term: AST = this.parseTypeReference(ErrorRecoverySet.BinOp, false);\n                        this.checkCurrentToken(TokenID.GreaterThan, errorRecoverySet);\n                        ast = new UnaryExpression(NodeType.TypeAssertion, this.parseExpr(errorRecoverySet, OperatorPrecedence.Unary, false, TypeContext.NoTypes));\n                        (<UnaryExpression>ast).castTerm = term;\n                        break;\n\n                    default:\n                        if (this.prevExpr && hasFlag(this.prevExpr.flags, ASTFlags.PossibleOptionalParameter)) {\n                            parseAsLambda = true;\n                            ast = this.prevExpr;\n                        }\n                        else {\n                            this.reportParseError(\"Check format of expression term\");\n                            if (this.errorRecovery) {\n                                var ident = new MissingIdentifier();\n                                ident.minChar = minChar;\n                                ident.flags |= ASTFlags.Error;\n                                this.skip(errorRecoverySet | ErrorRecoverySet.Postfix);\n                                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                    ident.setText(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence);\n                                    this.currentToken = this.scanner.scan();\n                       ";
var v27596 = v27597 + '             limChar = this.scanner.lastTokenLimChar();\n                                }\n                                else {\n                                    limChar = this.scanner.lastTokenLimChar();\n                                    //tok=scanner.scan();\n                                }\n\n                                // REVIEW: set sawId\n                                ast = ident;\n                            }\n                        }\n                }\n            }\n\n            if (parseAsLambda) {\n                // If the next token is an fat arrow or a colon, we either have a parameter list, or can rightly assume\n                // that we have a typed formal, so we proceed with the lambda parse\n                if (\n                    this.currentToken.tokenId == TokenID.Colon ||\n                    this.currentToken.tokenId == TokenID.Comma ||\n                    this.currentToken.tokenId == TokenID.CloseParen ||\n                    this.currentToken.tokenId == TokenID.DotDotDot) {\n\n                        // We won\'t scan in the \':\' case, since keeping the \':\' simplifies argument handling in parseFormalParameterList\n                        // Note that we don\'t set the minchar in this case\n                    ast = this.parseLambdaExpr(errorRecoverySet, ast, true /* skipNextRParen */, expectlambdaRParen);\n                    ast.minChar = minChar;\n                    limChar = this.scanner.lastTokenLimChar();\n                    ast.limChar = limChar;\n                }\n                else if (ast) {\n                    ast.isParenthesized = true;\n                }\n            }\n\n            if (sawId && (typeContext != TypeContext.NoTypes)) {\n                typeContext |= TypeContext.ArraySuffix;\n            }\n\n            var postFix = this.parsePostfixOperators(errorRecoverySet, ast, allowCall, inNew, typeContext, minChar, limChar);\n\n            // Defensive error check...\n            if (postFix) {\n                if (sawId && (postFix.nodeType == NodeType.Index)) {\n                    var binExpr = <BinaryExpression>postFix;\n                    if (binExpr.operand2 == null) {\n                        postFix = this.convertToTypeReference(postFix);\n                    }\n                }\n\n                ///////////////////////////////////////////////////////////\n                //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,\n                //      as they are sometimes not specific enough for each expression kind.\n                postFix.minChar = minChar;\n                // Only update "limChar" if it is not better than "lastTokenLimChar()"\n                postFix.limChar = max(postFix.limChar, this.scanner.lastTokenLimChar());\n                //\n                ///////////////////////////////////////////////////////////\n                return postFix;\n            }\n            else {\n                return new AST(NodeType.Error);\n            }\n\n        }\n\n        private parseLambdaExpr(errorRecoverySet: ErrorRecoverySet, lambdaArgs: AST, skipNextRParen: bool, expectClosingRParen: bool): AST {\n            // REVIEW: Parse the remainder of a lambda expression. The opening paren has been read already, if it existed. \n            //         skipNextRParen sets a flag on the resulting lambda node to tell the calling parseTerm that the LParen it scanned has been matched as part of parsing the formal parameter list\n            //         expectClosingRParen indicates that a closing RParen is expected, in the cases with optional parameter or more than one parameter.\n            var ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, { preProcessedLambdaArgs: lambdaArgs }, expectClosingRParen);\n            (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n            (<FuncDecl>ast).fncFlags |= FncFlags.IsFatArrowFunction;\n            if (!skipNextRParen) {\n                ast.flags |= ASTFlags.SkipNextRParen;\n            }\n            ast.limChar = this.scanner.lastTokenLimChar();;\n            return ast;\n        }\n\n        private parseExpr(errorRecoverySet: ErrorRecoverySet, minPrecedence: number, allowIn: bool,\n            typeContext: TypeContext, possiblyInLambda: bool = false): AST {\n            var ast: AST = null;\n            var tokenInfo = lookupToken(this.currentToken.tokenId);\n            var canAssign: bool = true;\n            var idHint: string = null;\n            var minChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            var exprIsAnonLambda = false;\n\n            if ((tokenInfo != undefined) && (tokenInfo.unopNodeType != NodeType.None)) {\n                canAssign = false;\n                this.currentToken = this.scanner.scan();\n                var tempExpr = this.parseExpr(ErrorRecoverySet.BinOp | errorRecoverySet,\n                                       tokenInfo.unopPrecedence, allowIn,\n                                       TypeCo';
var v27595 = v27596 + 'ntext.NoTypes);\n\n                // fold unary +- into constants\n                if ((tokenInfo.unopNodeType == NodeType.Pos) &&\n                    (tempExpr.nodeType == NodeType.NumberLit)) {\n                    ast = tempExpr;\n                }\n                else if ((tokenInfo.unopNodeType == NodeType.Neg) &&\n                         (tempExpr.nodeType == NodeType.NumberLit)) {\n                    var numLit = <NumberLiteral>tempExpr;\n                    numLit.value = (-numLit.value);\n                    if (numLit.value == 0) {\n                        numLit.isNegativeZero = true;\n                    }\n                    ast = tempExpr;\n                }\n                else {\n                    ast = new UnaryExpression(tokenInfo.unopNodeType, tempExpr);\n                    ast.limChar = tempExpr.limChar;\n                }\n                ast.minChar = minChar;\n            }\n            else {\n                ast = this.parseTerm(ErrorRecoverySet.BinOp | ErrorRecoverySet.AddOp |\n                              errorRecoverySet, true, typeContext, false);\n                var id: Identifier;\n                var temp: AST;\n                if (ast.nodeType == NodeType.Name) {\n                    id = <Identifier>ast;\n                    idHint = id.actualText;\n                }\n                else if (ast.nodeType == NodeType.Dot) {\n\n                    // If this is within a class declaration, and the circumstances are right, we need to\n                    // transform the dotted expression into a member declaration\n                    var subsumedExpr = false;\n\n                    if (this.inferPropertiesFromThisAssignment && \n                        (this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.Equals) &&\n                         this.parsingClassConstructorDefinition &&\n                         this.nestingLevel == this.currentClassDefinition.constructorNestingLevel && // this nesting level means we\'re at the top-level in the constructor\n                         (<BinaryExpression>ast).operand1.nodeType == NodeType.This) {\n\n                        if ((<BinaryExpression>ast).operand2.nodeType == NodeType.Name) {\n                            var op2ID: Identifier = (<Identifier>(<BinaryExpression>ast).operand2);\n\n                            if (!this.currentClassDefinition.knownMemberNames[op2ID.actualText]) {\n                                ast = this.parseClassMemberVariableDeclaration(op2ID, ast.minChar, true, errorRecoverySet, Modifiers.Public);\n                                subsumedExpr = true;\n                            }\n                        }\n                    }\n\n                    if (!subsumedExpr) {\n                        temp = ast;\n                        while (temp.nodeType == NodeType.Dot) {\n                            var binExpr = <BinaryExpression>temp;\n                            temp = binExpr.operand2;\n                        }\n                        if (temp.nodeType == NodeType.Name) {\n                             id = <Identifier>temp;\n                            idHint = id.actualText;\n                        }\n                    }\n                }\n                if ((!this.scanner.lastTokenHadNewline()) &&\n                    ((this.currentToken.tokenId == TokenID.PlusPlus) || (this.currentToken.tokenId == TokenID.MinusMinus))) {\n                    canAssign = false;\n                    var operand = ast;\n                    ast = new UnaryExpression((this.currentToken.tokenId == TokenID.PlusPlus) ? NodeType.IncPost : NodeType.DecPost, operand);\n                    ast.limChar = this.scanner.pos;\n                    ast.minChar = operand.minChar;\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n            for (; ;) {\n                tokenInfo = lookupToken(this.currentToken.tokenId);\n                if ((tokenInfo == undefined) || (tokenInfo.binopNodeType == NodeType.None)) {\n                    break;\n                }\n                if ((!allowIn) && (tokenInfo.binopNodeType == NodeType.In)) {\n                    break;\n                }\n                if (tokenInfo.binopPrecedence == OperatorPrecedence.Assignment) {\n                    if (tokenInfo.binopPrecedence < minPrecedence) {\n                        break;\n                    }\n                    if (!canAssign) {\n                        this.reportParseError("illegal assignment");\n                    }\n                }\n                else if (tokenInfo.binopPrecedence <= minPrecedence) {\n                    break;\n                }\n\n                if (possiblyInLambda && this.currentToken.tokenId == TokenID.Comma && this.scanner.getLookAheadToken().tokenId == TokenID.DotDotDot) {\n                    // The ellipsis can only exist in the formal list of a lambda expression, so do not attempt to parse the comma token as the comma binary operator\n                    // instead parse it as a lambda\n               ';
var v27594 = v27595 + '     exprIsAnonLambda = true;\n                    canAssign = false;\n                    ast = this.parseLambdaExpr(errorRecoverySet, ast, false, true);\n                    break;\n                }\n\n                // Precedence is high enough. Consume the operator token.\n                this.currentToken = this.scanner.scan();\n                canAssign = false;\n                if (tokenInfo.binopNodeType == NodeType.ConditionalExpression) {\n                    if (possiblyInLambda && \n                        ( this.currentToken.tokenId == TokenID.Equals || this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.CloseParen || this.currentToken.tokenId == TokenID.Comma)) {\n                        // The QMark is not a ternary expression, it is a marker for optional parameter in a lambda expression.\n                        exprIsAnonLambda = true;\n                        canAssign = true;\n                    }\n                    else {\n                        this.prevExpr = ast;\n                        var whenTrue = this.parseExpr(\n                            errorRecoverySet | ErrorRecoverySet.Colon, OperatorPrecedence.Assignment, allowIn, TypeContext.NoTypes);\n\n                        // Do not hold onto the prevExpr handle\n                        this.prevExpr = null;\n                        this.checkCurrentToken(TokenID.Colon, errorRecoverySet | ErrorRecoverySet.ExprStart);\n\n                        var whenFalse = this.parseExpr(\n                            errorRecoverySet | ErrorRecoverySet.BinOp, OperatorPrecedence.Assignment, allowIn, TypeContext.NoTypes)\n                        ast = new ConditionalExpression(ast, whenTrue, whenFalse);\n                    }\n                }\n                else {\n                    var tc = TypeContext.NoTypes;\n                    var binExpr2: BinaryExpression;\n\n                    binExpr2 = new BinaryExpression(tokenInfo.binopNodeType, ast,\n                                                    this.parseExpr(errorRecoverySet |\n                                                            ErrorRecoverySet.BinOp,\n                                                            tokenInfo.binopPrecedence,\n                                                            allowIn, TypeContext.NoTypes, possiblyInLambda));\n                    if (binExpr2.operand2.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>binExpr2.operand2;\n                        funcDecl.hint = idHint;\n                    }\n\n                    binExpr2.minChar = ast.minChar;\n                    binExpr2.limChar = this.scanner.lastTokenLimChar();\n                    idHint = null;\n                    ast = binExpr2;\n                }\n            }\n            if (canAssign) {\n                ast.flags |= ASTFlags.Writeable;\n            }\n            if (!exprIsAnonLambda) {\n                ///////////////////////////////////////////////////////////\n                //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,\n                //      as they are sometimes not specific enough for each statement kind.\n                ast.minChar = minChar;\n                // Only update "limChar" if it is not better than "lastTokenLimChar()"\n                ast.limChar = max(ast.limChar, this.scanner.lastTokenLimChar());\n                //\n                ///////////////////////////////////////////////////////////\n                ast.preComments = preComments;\n                ast.postComments = this.parseCommentsForLine(this.scanner.line);\n            }\n            return ast;\n        }\n\n        private parsePostfixOperators(errorRecoverySet: ErrorRecoverySet, ast: AST, allowCall: bool, inNew: bool,\n            typeContext: TypeContext, lhsMinChar: number, lhsLimChar: number): AST {\n            var count = 0;\n\n            if (!ast) {\n                ast = new AST(NodeType.EmptyExpr);\n                ast.isParenthesized = true;\n            }\n\n            ast.minChar = lhsMinChar;\n            ast.limChar = lhsLimChar;\n\n            for (; ;) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.OpenParen:\n                        if (inNew) {\n                            var callExpr = <CallExpression>ast;\n                            callExpr.arguments = this.parseArgList(errorRecoverySet);\n                            inNew = false;\n                        }\n                        else {\n                            if (!allowCall) {\n                                return ast;\n                            }\n                            ast = new CallExpression(NodeType.Call, ast,\n                                                   this.parseArgList(errorRecoverySet));\n                            ast.minChar = lhsMinChar;\n                        }\n                        ast.limChar = this.scanner.pos; // \')\'\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);\n              ';
var v27593 = v27594 + "          break;\n                    case TokenID.OpenBracket:\n                        this.currentToken = this.scanner.scan();\n                        if (this.currentToken.tokenId == TokenID.CloseBracket) {\n                            if (hasFlag(typeContext, TypeContext.ArraySuffix)) {\n                                this.currentToken = this.scanner.scan();\n                                if (ast.nodeType == NodeType.TypeRef) {\n                                    var typeRef = <TypeReference>ast;\n                                    typeRef.arrayCount++;\n                                }\n                                else {\n                                    ast = new BinaryExpression(NodeType.Index, ast, null);\n                                }\n                                ast.limChar = this.scanner.pos;\n                                break; // note early exit from case\n                            }\n                        }\n\n                        ast = new BinaryExpression(NodeType.Index, ast,\n                                                 this.parseExpr(errorRecoverySet | ErrorRecoverySet.RBrack,\n                                                           OperatorPrecedence.None, true,\n                                                           TypeContext.NoTypes));\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.pos; // ']'\n                        this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet);\n                        break;\n                    case TokenID.Dot: {\n                        var name: Identifier = null;\n                        var curpos = this.scanner.pos;\n                        this.currentToken = this.scanner.scan();\n                        // Don't allow reserved words if immediately after a new line and error recovery is enabled\n                        if ((this.currentToken.tokenId == TokenID.Identifier) || ((!this.errorRecovery || !this.scanner.lastTokenHadNewline()) && convertTokToIDName(this.currentToken))) {\n                            ast.flags |= ASTFlags.DotLHS;\n                            name = this.createRef(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence, this.scanner.startPos);\n                            name.limChar = this.scanner.pos;\n                            this.currentToken = this.scanner.scan();\n                        }\n                        else {\n                            this.reportParseError(\"Expected identifier following dot\");\n                            if (this.errorRecovery) {\n                                this.skip(errorRecoverySet);\n                                ast.flags |= (ASTFlags.Error | ASTFlags.DotLHS);\n                                return ast;\n                            }\n                            else {\n                                name = new MissingIdentifier();\n                            }\n                        }\n                        ast = new BinaryExpression(NodeType.Dot, ast, name);\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.EqualsGreaterThan:\n                        ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, { preProcessedLambdaArgs: ast }, false);\n                        (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    default:\n                        return ast;\n\n                }\n            }\n        }\n\n        private parseTry(tryNode: Try, errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Try {\n            var minChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            this.currentToken = this.scanner.scan();\n            if (this.currentToken.tokenId != TokenID.OpenBrace) {\n                this.reportParseError(\"Expected '{'\");\n                if (this.errorRecovery) {\n                    var etryNode = tryNode;\n                    etryNode.minChar = minChar;\n                    etryNode.limChar = this.scanner.lastTokenLimChar();\n                    etryNode.flags |= ASTFlags.Error;\n                    return etryNode;\n                }\n            }\n            tryNode.body = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers);\n            tryNode.minChar = minChar;\n            tryNode.limChar = tryNode.body.limChar;\n            tryNode.preComments = preComments;\n            tryNode.postComments = this.parseComments();\n            return tryNode;\n        }\n\n        private parseCatch(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Catch {\n            var catchMinChar = this.scanner.startPos;\n       ";
var v27592 = v27593 + '     var preComments = this.parseComments();\n            this.currentToken = this.scanner.scan();\n            this.checkCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n            if ((this.currentToken.tokenId != TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                this.reportParseError("Expected identifier in catch header");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n\n                    var ecatch = new Catch(new VarDecl(new MissingIdentifier(), this.nestingLevel),\n                                            new Statement(NodeType.Empty));\n                    ecatch.statement.minChar = catchMinChar;\n                    ecatch.statement.limChar = this.scanner.pos;\n                    ecatch.minChar = this.scanner.startPos;\n                    ecatch.limChar = this.scanner.pos;\n                    ecatch.flags |= ASTFlags.Error;\n                    return ecatch;\n                }\n            }\n            var param = new VarDecl(Identifier.fromToken(this.currentToken), this.nestingLevel);\n            param.id.minChar = this.scanner.startPos;\n            param.id.limChar = this.scanner.pos;\n            param.minChar = param.id.minChar;\n            param.limChar = param.id.limChar;\n            this.currentToken = this.scanner.scan();\n            var statementPos = this.scanner.pos;\n            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.StmtStart);\n            if (this.currentToken.tokenId != TokenID.OpenBrace) {\n                this.reportParseError("Expected \'{\' to start catch body");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n\n                    var ecatch = new Catch(new VarDecl(new MissingIdentifier(), this.nestingLevel),\n                                            new Statement(NodeType.Empty));\n                    ecatch.statement.minChar = catchMinChar;\n                    ecatch.statement.limChar = statementPos;\n                    ecatch.minChar = this.scanner.startPos;\n                    ecatch.limChar = this.scanner.pos;\n                    ecatch.flags |= ASTFlags.Error;\n                    return ecatch;\n                }\n            }\n\n            var catchStmt = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers);\n            var catchNode = new Catch(param, catchStmt);\n            catchNode.statement.minChar = catchMinChar;\n            catchNode.statement.limChar = statementPos;\n            catchNode.minChar = catchMinChar;\n            catchNode.limChar = catchStmt.limChar;\n            catchNode.preComments = preComments;\n            catchNode.postComments = this.parseComments();\n            return catchNode;\n        }\n\n        private parseFinally(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Finally {\n            var finMinChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            this.currentToken = this.scanner.scan();\n            if (this.currentToken.tokenId != TokenID.OpenBrace) {\n                this.reportParseError("Expected \'{\' to start body of finally statement");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n                    var efin = new Finally(new Statement(NodeType.Empty));\n                    efin.flags |= ASTFlags.Error;\n                    efin.minChar = this.scanner.startPos;\n                    efin.limChar = this.scanner.pos;\n                    return efin;\n                }\n            }\n\n            var finBody = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers)\n            var fin = new Finally(finBody);\n            fin.minChar = finMinChar;\n            fin.limChar = fin.body.limChar;\n            fin.preComments = preComments;\n            fin.postComments = this.parseComments();\n            return fin;\n        }\n\n        private parseTryCatchFinally(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers, labelList: ASTList): AST {\n            var tryPart: AST = new Try(null);\n            var tryMinChar = this.scanner.startPos;\n            this.pushStmt(<Statement>tryPart, labelList);\n            this.parseTry(<Try>tryPart, errorRecoverySet | ErrorRecoverySet.Catch, parentModifiers);\n            this.popStmt();\n            var tc: TryCatch = null;\n            var tf: TryFinally = null;\n\n            if (this.currentToken.tokenId == TokenID.Catch) {\n                var catchPart = this.parseCatch(errorRecoverySet | ErrorRecoverySet.Catch, parentModifiers);\n                tc = new TryCatch(<Try>tryPart, catchPart);\n                tc.minChar = tryPart.minChar;\n                tc.limChar = catchPart.limChar;\n            }\n\n            if (this.currentToken.tokenId != TokenID.Finally) {\n                if (tc == null) {\n                    this.reportParseError("try with neither catch nor finally");\n        ';
var v27591 = v27592 + '            if (this.errorRecovery) {\n                        var etf = new TryFinally(tryPart, new Finally(new AST(NodeType.Empty)));\n                        etf.flags |= ASTFlags.Error;\n                        etf.minChar = this.scanner.startPos;\n                        etf.limChar = this.scanner.pos;\n                        return etf;\n                    }\n                    return new TryFinally(tryPart, new Finally(new AST(NodeType.Empty)));\n                }\n                else {\n                    return tc;\n                }\n            }\n            else {\n                if (tc) {\n                    tryPart = tc;\n                }\n                var finallyPart = this.parseFinally(errorRecoverySet, parentModifiers)\n                tf = new TryFinally(tryPart, finallyPart);\n                tf.minChar = tryMinChar;\n                tf.limChar = finallyPart.limChar;\n                return tf;\n            }\n        }\n\n        private parseStatement(errorRecoverySet: ErrorRecoverySet, allowedElements: AllowedElements, parentModifiers: Modifiers): AST {\n            var ast: AST = null;\n            var labelList: ASTList = null;\n            var astList: ASTList = null;\n            var temp: AST;\n            var modifiers = Modifiers.None;\n            var minChar = this.scanner.startPos;\n            var forInOk = false;\n            var needTerminator = false;\n            var fnOrVar: AST = null;\n            var preComments = this.parseComments();\n            this.state = ParseState.StartStatement;\n\n            function isAmbient() {\n                return hasFlag(modifiers, Modifiers.Ambient) || hasFlag(parentModifiers, Modifiers.Ambient);\n            }\n\n            function mayNotBeExported() {\n                if (hasFlag(modifiers, Modifiers.Exported)) {\n                    this.reportError("Statement may not be exported");\n                }\n            }\n\n            for (; ;) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.EndOfFile:\n                        ast = new AST(NodeType.Error);\n                        ast.minChar = minChar;\n                        ast.limChar = this.scanner.pos;\n                        break;\n                    case TokenID.Function:\n                        if (this.parsingDeclareFile || isAmbient() || this.ambientModule) {\n                            this.currentToken = this.scanner.scan();\n                            fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                      modifiers, true, false);\n                            if (fnOrVar.nodeType == NodeType.VarDecl) {\n                                this.reportParseError("function keyword can only introduce function declaration");\n                            }\n                            else if ((fnOrVar.nodeType == NodeType.FuncDecl) && ((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                needTerminator = true;\n                            }\n                            ast = fnOrVar;\n                            if (this.parsingDeclareFile || this.ambientModule && ast.nodeType == NodeType.FuncDecl) {\n                                (<FuncDecl>ast).fncFlags |= FncFlags.Exported;\n                            }\n                        }\n                        else {\n                            ast = this.parseFncDecl(errorRecoverySet, true, false, false, null, false, false, isAmbient(), modifiers, null, true);\n                            if (hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                needTerminator = true;\n                            }\n                            if (this.ambientModule) {\n                                this.reportParseError("function declaration not permitted within ambient module");\n                            }\n                            if (hasFlag(modifiers, Modifiers.Exported)) {\n                                (<FuncDecl>ast).fncFlags |= FncFlags.Exported;\n                            }\n                        }\n                        break;\n                    case TokenID.Module:\n                        if ((allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None) {\n                            this.reportParseError("module not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseModuleDecl(errorRecoverySet, modifiers, preComments);\n                            preComments = null;\n                        }\n                        break;\n                    case TokenID.Import:\n                        if ((allowedElements & AllowedElement';
var v27590 = v27591 + 's.ModuleDeclarations) == AllowedElements.None) {\n                            this.reportParseError("module not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            if (hasFlag(modifiers, Modifiers.Exported)) {\n                                this.reportParseError("export keyword not permitted on import declaration");\n                            }\n                            ast = this.parseImportDeclaration(errorRecoverySet, modifiers);\n                            needTerminator = true;\n                        }\n                        break;\n                    case TokenID.Export:\n                        if ((allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None) {\n                            this.reportParseError("\'export\' statements are only allowed at the global and module levels");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        if (this.topLevel) {\n                            this.hasTopLevelImportOrExport = true;\n                        }\n                        modifiers |= Modifiers.Exported;\n                        this.currentToken = this.scanner.scan();\n                        break;\n                    case TokenID.Private:\n                        modifiers |= Modifiers.Private;\n\n                        this.currentToken = this.scanner.scan();\n\n                        if (this.parsingClassConstructorDefinition) {\n\n                            if (!this.inferPropertiesFromThisAssignment) {\n                                this.reportParseError("Property declarations are not permitted within constructor bodies");\n                            }\n\n                            minChar = this.scanner.pos;\n                            if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId != TokenID.This || (this.currentToken = this.scanner.scan()).tokenId != TokenID.Dot)) {\n                                this.reportParseError("Expected \'this.\' for property declaration");\n                                this.currentToken = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                this.currentToken = this.scanner.scan();\n\n                                var id = Identifier.fromToken(this.currentToken);\n                                id.minChar = this.scanner.startPos;\n                                id.limChar = this.scanner.pos;\n\n                                this.currentToken = this.scanner.scan();\n                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);\n                            }\n                        }\n                        else {\n                            if (this.currentToken.tokenId != TokenID.Interface) {\n                                if (this.currentToken.tokenId == TokenID.Get) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                        modifiers |= Modifiers.Getter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                else if (this.currentToken.tokenId == TokenID.Set) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMod';
var v27589 = v27590 + 'e)) {\n                                        modifiers |= Modifiers.Setter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                          modifiers, isAmbient(), false);\n                                if ((fnOrVar.nodeType == NodeType.VarDecl) ||\n                                    ((fnOrVar.nodeType == NodeType.FuncDecl) && (hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction)))) {\n                                    needTerminator = true;\n                                }\n                                ast = fnOrVar;\n                            }\n                        }\n                        break;\n                    case TokenID.Public:\n                        if (this.parsingClassConstructorDefinition) {\n\n                            if (!this.inferPropertiesFromThisAssignment) {\n                                this.reportParseError("Property declarations are not permitted within constructor bodies");\n                            }\n\n                            this.currentToken = this.scanner.scan(); \n                            minChar = this.scanner.pos;\n                            modifiers |= Modifiers.Public;\n                            if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId != TokenID.This || (this.currentToken = this.scanner.scan()).tokenId != TokenID.Dot)) {\n                                this.reportParseError("Expected \'this.\' for property declaration");\n                                this.currentToken = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                this.currentToken = this.scanner.scan();\n\n                                var id = Identifier.fromToken(this.currentToken);\n                                id.minChar = this.scanner.startPos;\n                                id.limChar = this.scanner.pos;\n\n                                this.currentToken = this.scanner.scan();\n                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);\n                            }\n                        }\n                        else {\n                            if ((allowedElements & AllowedElements.Properties) == AllowedElements.None) {\n                                this.reportParseError("\'property\' statements are only allowed within classes");\n                                this.currentToken = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                modifiers |= Modifiers.Public;\n                                this.currentToken = this.scanner.scan();\n                                if (this.currentToken.tokenId == TokenID.Get) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                        modifiers |= Modifiers.Getter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                else if (this.currentToken.tokenId == TokenID.Set) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                        modifiers |= Modifiers.Setter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n       ';
var v27588 = v27589 + '                         fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                            modifiers, isAmbient(), false);\n                                if ((fnOrVar.nodeType == NodeType.VarDecl) ||\n                                    ((fnOrVar.nodeType == NodeType.FuncDecl) && hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction))) {\n                                    needTerminator = true;\n                                }\n                                ast = fnOrVar;\n                            }\n                        }\n                        break;\n                    case TokenID.Declare:\n                        if (!(allowedElements & AllowedElements.AmbientDeclarations)) {\n                            this.reportParseError("Ambient declarations are only allowed at the top-level or module scopes")\n                        }\n                        if (!this.parsingDeclareFile && hasFlag(parentModifiers, Modifiers.Ambient)) {\n                            this.reportParseError("Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)")\n                        }\n                        modifiers |= Modifiers.Ambient;\n                        this.currentToken = this.scanner.scan();\n                        break;\n                    case TokenID.Class:\n                        if ((allowedElements & AllowedElements.ClassDeclarations) == AllowedElements.None) {\n                            this.reportParseError("class not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseClassDecl(errorRecoverySet, minChar, modifiers);\n                        }\n                        break;\n                    case TokenID.Interface:\n                        if ((allowedElements & AllowedElements.InterfaceDeclarations) == AllowedElements.None) {\n                            this.reportParseError("interface not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseInterfaceDecl(errorRecoverySet, modifiers);\n                        }\n                        break;\n                    case TokenID.Var:\n                        var declAst: AST = this.parseVariableDeclaration(errorRecoverySet | ErrorRecoverySet.StmtStart, modifiers,\n                                                     true, false);\n                        if (declAst.nodeType == NodeType.VarDecl) {\n                            ast = declAst;\n                        }\n                        else {\n                            ast = new Block(<ASTList>declAst, false);\n                        }\n                        needTerminator = true;\n                        break;\n                    case TokenID.Static:\n\n                        if (this.currentClassDecl == null) {\n                            this.reportParseError("Statics may only be class members");\n                        }\n\n                        mayNotBeExported();\n                        modifiers |= Modifiers.Public;\n                        this.currentToken = this.scanner.scan();\n                        if (this.currentToken.tokenId == TokenID.Get) {\n                            this.prevIDTok = this.currentToken;\n                            this.currentToken = this.scanner.scan();\n                            if (codeGenTarget < CodeGenTarget.ES5) {\n                                this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                            }\n                            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                modifiers |= Modifiers.Getter;\n                                this.prevIDTok = null;\n                            }\n                        }\n                        else if (this.currentToken.tokenId == TokenID.Set) {\n                            this.currentToken = this.scanner.scan();\n                            if (codeGenTarget < CodeGenTarget.ES5) {\n                                this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                            }\n                            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n             ';
var v27587 = v27588 + '                   modifiers |= Modifiers.Setter;\n                            }\n                        }\n                        if (isAmbient()) {\n                            modifiers |= Modifiers.Ambient;\n                        }\n                        fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                  modifiers, this.parsingDeclareFile || (modifiers & Modifiers.Ambient) != Modifiers.None, true);\n\n                        var staticsList = this.topStaticsList();\n                        if (staticsList && fnOrVar.nodeType == NodeType.VarDecl) {\n                            staticsList.append(fnOrVar);\n                        }\n\n                        if (fnOrVar.nodeType == NodeType.VarDecl || ((fnOrVar.nodeType == NodeType.FuncDecl) && hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction))) {\n                            needTerminator = true;\n                        }\n\n                        ast = fnOrVar;\n                        break;\n                    case TokenID.For:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("syntax error: for statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart | ErrorRecoverySet.Var);\n                        this.state = ParseState.ForInit;\n                        forInOk = true;\n                        switch (this.currentToken.tokenId) {\n                            case TokenID.Var:\n                                temp = this.parseVariableDeclaration(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                  ErrorRecoverySet.In, Modifiers.None, false, false);\n                                break;\n                            case TokenID.Semicolon:\n                                temp = null;\n                                this.state = ParseState.ForCondStart;\n                                break;\n                            default:\n                                temp = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                               ErrorRecoverySet.In, OperatorPrecedence.None, false,\n                                               TypeContext.NoTypes);\n                                break;\n                        }\n                        this.state = ParseState.ForInitAfterVar;\n                        if (this.currentToken.tokenId == TokenID.In) {\n                            if ((temp == null) || (!forInOk)) {\n                                this.reportParseError("malformed for statement");\n                                if (this.errorRecovery) {\n                                    this.skip(errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                    ast = new AST(NodeType.Empty);\n                                    ast.flags |= ASTFlags.Error;\n                                }\n                            }\n                            else {\n                                this.currentToken = this.scanner.scan();\n                                var forInStmt = new ForInStatement(temp,\n                                                                 this.parseExpr(ErrorRecoverySet.RParen |\n                                                                           errorRecoverySet,\n                                                                           OperatorPrecedence.Comma,\n                                                                           false,\n                                                                           TypeContext.NoTypes));\n\n                                forInStmt.limChar = this.scanner.pos;\n                                forInStmt.statement.minChar = minChar;\n                                forInStmt.statement.limChar = this.scanner.pos;\n                                this.checkCurrentToken(TokenID.CloseParen, ErrorRecoverySet.StmtStart | errorRecoverySet);\n                                this.pushStmt(forInStmt, labelList);\n                                forInStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                                this.popStmt();\n                                forInStmt.minChar = minChar;\n                                ast = forInStmt;\n                            }\n                        }\n                        else {\n                            var forStmt: ForStatement = new ForStatement(temp);\n                            forStmt.minChar = minChar;\n                            this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet);\n                            if (this.currentToken.tokenId == TokenID.Semicolon) {\n                                forStmt.cond = null;\n                 ';
var v27586 = v27587 + "           }\n                            else {\n                                forStmt.cond = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                       ErrorRecoverySet.RParen,\n                                                       OperatorPrecedence.None, true,\n                                                       TypeContext.NoTypes);\n                                if (this.currentToken.tokenId != TokenID.Semicolon) {\n                                    this.skip(errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                    ast = forStmt;\n                                    ast.flags |= ASTFlags.Error;\n                                }\n                            }\n                            this.currentToken = this.scanner.scan();\n                            if (this.currentToken.tokenId == TokenID.CloseParen) {\n                                forStmt.incr = null;\n                            }\n                            else {\n                                forStmt.incr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                       ErrorRecoverySet.RParen,\n                                                       OperatorPrecedence.None, true,\n                                                       TypeContext.NoTypes);\n                            }\n                            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);\n                            this.pushStmt(forStmt, labelList);\n                            forStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                            this.popStmt();\n                            forStmt.limChar = forStmt.body.limChar;\n                            ast = forStmt;\n                        }\n                        break;\n                    case TokenID.With: {\n                        if (codeGenTarget < CodeGenTarget.ES5) {\n                            this.reportParseError(\"'with' statements are only available in ES5 codegen mode or better\");\n                        }\n\n                        if (this.strictMode) {\n                            this.reportParseError(\"'with' statements are not available in strict mode\");\n                        }\n\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"'with' statement does not take modifiers\");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart | ErrorRecoverySet.Var);\n\n                        var expr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,\n                                                            OperatorPrecedence.None, true,\n                                                            TypeContext.NoTypes);\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);\n\n                        var withStmt = new WithStatement(expr);\n                        withStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                        withStmt.minChar = minChar;\n                        withStmt.limChar = withStmt.body.limChar;\n                        ast = withStmt;\n                    }\n                        break;\n                    case TokenID.Switch: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"'switch' statement does not take modifiers\");\n                        }\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n\n                        var switchStmt = new SwitchStatement(this.parseExpr(errorRecoverySet |\n                                                                     ErrorRecoverySet.RParen,\n                                                                     OperatorPrecedence.None,\n                                                                     true,\n                                                                     TypeContext.NoTypes));\n                        switchStmt.statement.minChar = minChar;\n                        switchStmt.statement.limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);\n                        var caseListMinChar = this.scanner.startPos;\n                         this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.SCase);\n                        switchStmt.defaultCase = null;\n                        switchStmt.caseList = new ASTList();\n                        var caseStmt: CaseStatement = null;\n                        this.push";
var v27585 = v27586 + 'Stmt(switchStmt, labelList);\n                        for (; ;) {\n                            if ((this.currentToken.tokenId == TokenID.Case) ||\n                                (this.currentToken.tokenId == TokenID.Default)) {\n                                var isDefault = (this.currentToken.tokenId == TokenID.Default);\n                                caseStmt = new CaseStatement();\n                                caseStmt.minChar = this.scanner.startPos;\n                                this.currentToken = this.scanner.scan();\n                                if (isDefault) {\n                                    switchStmt.defaultCase = caseStmt;\n                                }\n                                else {\n                                    caseStmt.expr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,\n                                                            OperatorPrecedence.None, true,\n                                                            TypeContext.NoTypes);\n                                }\n                                this.checkCurrentToken(TokenID.Colon, errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                caseStmt.body = new ASTList();\n                                this.parseStatementList(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                              caseStmt.body, false, true, allowedElements, modifiers);\n                                caseStmt.limChar = caseStmt.body.limChar;\n                                switchStmt.caseList.append(caseStmt);\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        // end of switch statement\n                        switchStmt.caseList.minChar = caseListMinChar;\n                        switchStmt.caseList.limChar = this.scanner.pos;\n                        switchStmt.limChar = switchStmt.caseList.limChar;\n                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n                        this.popStmt();\n                        ast = switchStmt;\n                        break;\n                    }\n                    case TokenID.While: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("\'while\' statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, ErrorRecoverySet.ExprStart |\n                                  errorRecoverySet);\n                        var whileStmt = new WhileStatement(this.parseExpr(errorRecoverySet |\n                                                                   ErrorRecoverySet.RParen,\n                                                                   OperatorPrecedence.None,\n                                                                   true, TypeContext.NoTypes));\n                        whileStmt.minChar = minChar;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet |\n                                  ErrorRecoverySet.StmtStart);\n                        this.pushStmt(whileStmt, labelList);\n                        whileStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                        whileStmt.limChar = whileStmt.body.limChar;\n                        this.popStmt();\n                        ast = whileStmt;\n                        break;\n                    }\n                    case TokenID.Do: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("\'do\' statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var doStmt = new DoWhileStatement();\n                        doStmt.minChar = minChar;\n                        this.pushStmt(doStmt, labelList);\n                        doStmt.body = this.parseStatement(errorRecoverySet | ErrorRecoverySet.While,\n                                                   allowedElements, parentModifiers);\n                        this.popStmt();\n                        doStmt.whileAST = new Identifier("while");\n                        doStmt.whileAST.minChar = this.scanner.startPos;\n                        this.checkCurrentToken(TokenID.While, errorRecoverySet | ErrorRecoverySet.LParen);\n                        doStmt.whileAST.limChar = doStmt.whileAST.minChar + 5;\n                        this.checkCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n                        doStmt.cond = this.parseExpr(errorRecoverySet | ErrorRecoverySet.RParen,\n                                           ';
var v27584 = v27585 + '   OperatorPrecedence.None, true, TypeContext.NoTypes);\n                        doStmt.limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);\n                        ast = doStmt;\n                        // compatibility; more strict would be to require the \';\'\n                        if (this.currentToken.tokenId == TokenID.Semicolon) {\n                            this.currentToken = this.scanner.scan();\n                        }\n                        break;\n                    }\n                    case TokenID.If: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("if statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n                        var ifStmt = new IfStatement(this.parseExpr(errorRecoverySet |\n                                                             ErrorRecoverySet.LParen,\n                                                             OperatorPrecedence.None, true,\n                                                             TypeContext.NoTypes));\n                        ifStmt.minChar = minChar;\n                        ifStmt.statement.minChar = minChar;\n                        ifStmt.statement.limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.StmtStart);\n                        this.pushStmt(ifStmt, labelList);\n                        ifStmt.thenBod = this.parseStatement(ErrorRecoverySet.Else | errorRecoverySet,\n                                                      allowedElements, parentModifiers);\n                        ifStmt.limChar = ifStmt.thenBod.limChar;\n                        if (this.currentToken.tokenId == TokenID.Else) {\n                            this.currentToken = this.scanner.scan();\n                            ifStmt.elseBod = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                            ifStmt.limChar = ifStmt.elseBod.limChar;\n                        }\n                        this.popStmt();\n                        ast = ifStmt;\n                        break;\n                    }\n                    case TokenID.Try: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("try statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        ast = this.parseTryCatchFinally(errorRecoverySet, parentModifiers, labelList);\n                        break;\n                    }\n                    case TokenID.OpenBrace: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("block does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var block = new Block(new ASTList(), true);\n                        this.pushStmt(block, labelList);\n                        this.parseStatementList(\n                            errorRecoverySet | ErrorRecoverySet.RCurly, block.statements,\n                            /*sourceElements:*/ false, /*noLeadingCase:*/ false, AllowedElements.None, modifiers);\n                        this.popStmt();\n                        block.statements.minChar = minChar;\n                        block.statements.limChar = this.scanner.pos;\n                        block.minChar = block.statements.minChar;\n                        block.limChar = block.statements.limChar;\n                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n                        ast = block;\n                        break;\n                    }\n                    case TokenID.Semicolon:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifier can not appear here");\n                        }\n                        ast = new AST(NodeType.Empty);\n                        this.currentToken = this.scanner.scan();\n                        break;\n                    case TokenID.Break:\n                    case TokenID.Continue: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before jump statement");\n                        }\n                        var jump =\n                            new Jump((this.currentToken.tokenId == TokenID.Break) ? NodeType.Break : NodeType.Cont';
var v27583 = v27584 + 'inue);\n                        this.currentToken = this.scanner.scan();\n                        if ((this.currentToken.tokenId == TokenID.Identifier) && (!this.scanner.lastTokenHadNewline())) {\n                            // Labeled break or continue.\n                            jump.target = this.currentToken.getText();\n                            this.currentToken = this.scanner.scan();\n                        }\n                        this.resolveJumpTarget(jump);\n                        ast = jump;\n                        needTerminator = true;\n                        break;\n                    }\n                    case TokenID.Return: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before return statement");\n                        }\n                        if (!this.inFunction) {\n                            this.reportParseError("return statement outside of function body");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var retStmt = new ReturnStatement();\n                        retStmt.minChar = minChar;\n                        if ((this.currentToken.tokenId != TokenID.Semicolon) &&\n                            (this.currentToken.tokenId != TokenID.CloseBrace) &&\n                            (!(this.scanner.lastTokenHadNewline()))) {\n                            retStmt.returnExpression = this.parseExpr(errorRecoverySet |\n                                                               ErrorRecoverySet.SColon,\n                                                               OperatorPrecedence.None,\n                                                               true, TypeContext.NoTypes);\n                        }\n                        needTerminator = true;\n                        retStmt.limChar = this.scanner.lastTokenLimChar();\n                        ast = retStmt;\n                        break;\n                    }\n                    case TokenID.Throw:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before a throw statement");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        if ((this.currentToken.tokenId != TokenID.Semicolon) &&\n                            (this.currentToken.tokenId != TokenID.CloseBrace) &&\n                            (!(this.scanner.lastTokenHadNewline()))) {\n                            temp = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                           OperatorPrecedence.None, true, TypeContext.NoTypes);\n                        }\n                        else {\n                            this.reportParseError("throw with no target");\n                            temp = null;\n                        }\n                        ast = new UnaryExpression(NodeType.Throw, temp);\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        needTerminator = true;\n                        break;\n                    case TokenID.Enum:\n                        // TODO: check module allowed here\n                        //minChar=scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        ast = this.parseEnumDecl(errorRecoverySet, modifiers);\n                        ast.minChar = minChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                            (<ModuleDeclaration>ast).modFlags |= ModuleFlags.Ambient;\n                        }\n                        if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                            (<ModuleDeclaration>ast).modFlags |= ModuleFlags.Exported;\n                        }\n                        break;\n                    case TokenID.Debugger:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before debugger statement");\n                        }\n                        \n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var debuggerStmt = new DebuggerStatement();\n                        debuggerStmt.minChar = minChar;\n                        needTerminator = true;\n                        debuggerStmt.limChar = this.scanner.lastTokenLimChar();\n                        ast = debuggerStmt;\n                       ';
var v27582 = v27583 + ' break;\n                    default:\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before an expression statement or label");\n                        }\n                        minChar = this.scanner.startPos;\n                        var svPos = this.scanner.pos;\n                        temp = this.parseExpr(ErrorRecoverySet.Colon | ErrorRecoverySet.StmtStart |\n                                       errorRecoverySet, OperatorPrecedence.None, true,\n                                       TypeContext.NoTypes);\n                        if (this.scanner.pos == svPos) {\n                            // no progress\n                            this.currentToken = this.scanner.scan();\n                            ast = temp;\n                        }\n                        else if ((this.currentToken.tokenId == TokenID.Colon) && (!this.scanner.lastTokenHadNewline()) &&\n                                        temp && (temp.nodeType == NodeType.Name)) {\n                                            // It\'s a label\n                            if (labelList == null) {\n                                labelList = new ASTList();\n                            }\n                            labelList.append(new Label(<Identifier>temp));\n                            this.currentToken = this.scanner.scan();\n                        }\n                        else {\n                            // expression statement\n                            ast = temp;\n                            needTerminator = true;\n                        }\n                }\n                if (ast) {\n                    break;\n                }\n            }\n            if (needTerminator) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.Semicolon:\n                        this.currentToken = this.scanner.scan();\n                        ast.flags |= ASTFlags.ExplicitSemicolon;\n                        break;\n                    case TokenID.EndOfFile:\n                        // Extend any incomplete statements to include EOF token. This makes sure that this node is in the path \n                        // when completion or parameter help is requested.\n                        ast.limChar = this.scanner.pos;\n                        // IntentionaCloseBracethrough\n                    case TokenID.CloseBrace:\n                        ast.flags |= ASTFlags.AutomaticSemicolon;\n                        if (this.style_requireSemi) {\n                            this.reportParseStyleError("no automatic semicolon");\n                        }\n                        break;\n                    default:\n                        if (!this.scanner.lastTokenHadNewline()) {\n                            this.reportParseError("Expected \';\'");\n                        }\n                        else {\n                            ast.flags |= ASTFlags.AutomaticSemicolon;\n                            if (this.style_requireSemi) {\n                                this.reportParseStyleError("no automatic semicolon");\n                            }\n                        }\n                        break;\n                }\n            }\n            if (labelList) {\n                ast = new LabeledStatement(labelList, ast);\n            }\n\n            ///////////////////////////////////////////////////////////\n            //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,\n            //      as they are sometimes not specific enough for each statement kind.\n            ast.minChar = minChar;\n            // Only update "limChar" if it is not better than "lastTokenLimChar()"\n            ast.limChar = max(ast.limChar, this.scanner.lastTokenLimChar());\n            //\n            ///////////////////////////////////////////////////////////\n\n            if (preComments) {\n                ast.preComments = preComments;\n            }\n            if (this.ambientModule && (!this.okAmbientModuleMember(ast))) {\n                this.reportParseError("statement not permitted within ambient module");\n            }\n            ast.flags |= ASTFlags.IsStatement;\n            return ast;\n        }\n\n        private okAmbientModuleMember(ast: AST) {\n            var nt = ast.nodeType;\n            return (nt == NodeType.ClassDeclaration) || (nt == NodeType.ImportDeclaration) || (nt == NodeType.InterfaceDeclaration) || (nt == NodeType.ModuleDeclaration) ||\n                (nt == NodeType.Empty) || (nt == NodeType.VarDecl) || \n                ((nt == NodeType.Block) && !(<Block>ast).isStatementBlock) ||\n                ((nt == NodeType.FuncDecl) && ((<FuncDecl>ast).isMethod()));\n        }\n\n        private parseStatementList(errorRecoverySet: ErrorRecoverySet,\n                                   statements: ASTList,\n                                   sourceElms: bool,\n                                   noLeadingCase: bool,\n                                   allowedElements: A';
var v27581 = v27582 + 'llowedElements,\n                                   parentModifiers: Modifiers): void {\n            var directivePrologue = sourceElms;\n            statements.minChar = this.scanner.startPos;\n            var limChar = this.scanner.pos;\n            var innerStmts = (allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None;\n            var classNope = (allowedElements & AllowedElements.ClassDeclarations) == AllowedElements.None;\n\n            errorRecoverySet |= ErrorRecoverySet.TypeScriptS | ErrorRecoverySet.RCurly;\n\n            this.state = ParseState.StartStatementList;\n            var oldStrictMode = this.strictMode;\n            this.nestingLevel++;\n            for (; ;) {\n                if ((this.currentToken.tokenId == TokenID.CloseBrace) ||\n                    (noLeadingCase && ((this.currentToken.tokenId == TokenID.Case) || (this.currentToken.tokenId == TokenID.Default))) ||\n                    (innerStmts && (this.currentToken.tokenId == TokenID.Export)) ||\n                    (classNope && (this.currentToken.tokenId == TokenID.Class)) ||\n                    (this.currentToken.tokenId == TokenID.EndOfFile)) {\n                    this.state = ParseState.EndStmtList;\n                    statements.limChar = limChar;\n                    if (statements.members.length == 0) {\n                        statements.preComments = this.parseComments();\n                    }\n                    else {\n                        statements.postComments = this.parseComments();\n                    }\n                    this.strictMode = oldStrictMode;\n                    this.nestingLevel--;\n                    return;\n                }\n\n                var stmt = this.parseStatement(errorRecoverySet &\n                                        (~(ErrorRecoverySet.Else | ErrorRecoverySet.RParen |\n                                           ErrorRecoverySet.Catch | ErrorRecoverySet.Colon)),\n                                        allowedElements, parentModifiers);\n\n\n                if (stmt) {\n                    stmt.postComments = this.combineComments(stmt.postComments, this.parseCommentsForLine(this.scanner.prevLine));\n                    statements.append(stmt);\n                    limChar = stmt.limChar;\n                    if (directivePrologue) {\n                        if (stmt.nodeType == NodeType.QString) {\n                            var qstring = <StringLiteral>stmt;\n                            if (qstring.text == "\\"use strict\\"") {\n                                statements.flags |= ASTFlags.StrictMode;\n                                this.strictMode = true;\n                            }\n                            else {\n                                directivePrologue = false;\n                            }\n                        }\n                        else {\n                            directivePrologue = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        private fname = "";\n\n        public quickParse(sourceText: ISourceText, filename: string, unitIndex: number): QuickParseResult {\n            //TODO: REVIEW: We set this to avoid adding a "module" decl in the resulting script (see parse() method)\n            var svGenTarget = TypeScript.moduleGenTarget;\n            try {\n                TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Local;\n                var script = this.parse(sourceText, filename, unitIndex, AllowedElements.QuickParse);\n                return new QuickParseResult(script, this.scanner.lexState);\n            }\n            finally {\n                TypeScript.moduleGenTarget = svGenTarget;\n            }\n        }\n\n        public parse(sourceText: ISourceText, filename: string, unitIndex: number, allowedElements = AllowedElements.Global): Script {\n            // Reset all parser state here.  This allows us to be resilient to reentrancy if an \n            // exception is thrown.\n            this.fname = filename;\n            this.currentUnitIndex = unitIndex;\n\n            this.currentToken = null;\n            this.needTerminator = false;\n            this.inFunction = false;\n            this.inInterfaceDecl = false;\n            this.inFncDecl = false;\n            this.state = ParseState.StartStatementList;\n            this.ambientModule = false;\n            this.ambientClass = false;\n            this.topLevel = true;\n            this.allowImportDeclaration = true;\n            this.prevIDTok = null;\n            this.statementInfoStack = new IStatementInfo[];\n            this.hasTopLevelImportOrExport = false;\n            this.strictMode = false;\n            this.nestingLevel = 0;\n            this.prevExpr = null;\n            this.currentClassDefinition = null;\n            this.parsingClassConstructorDefinition = false;\n            this.parsingDeclareFile = false;\n            this.amdDependencies = [];\n            this.inferPropertiesFromThisAssignment = false;\n            this.requiresExtendsBlock = false;\n\n';
var v27580 = v27581 + '            this.scanner.resetComments();\n            this.scanner.setErrorHandler((message) =>this.reportParseError(message));\n            this.scanner.setSourceText(sourceText, LexMode.File);\n\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var minChar = this.scanner.pos;\n            this.currentToken = this.scanner.scan();\n            this.pushDeclLists();\n            var bod = new ASTList();\n            bod.minChar = minChar;\n\n            this.state = ParseState.StartScript;\n            this.parsingDeclareFile = isDSTRFile(filename) || isDTSFile(filename);\n\n            while (true) {\n                this.parseStatementList(\n                    ErrorRecoverySet.EOF | ErrorRecoverySet.Func,\n                    bod, /*sourceElements:*/ true, /*noLeadingCase:*/ false,\n                    allowedElements, Modifiers.None);\n\n                if (this.currentToken.tokenId === TokenID.EndOfFile) {\n                    break;\n                }\n\n                // Still have remaining tokens in the file.  Report error for this unexpected token,\n                // skip it, and continue trying to parse statements until we\'re done. \n                var badToken = tokenTable[this.currentToken.tokenId];\n                this.reportParseError("Unexpected statement block terminator \'" + badToken.text + "\'");\n\n                this.currentToken = this.scanner.scan();\n            }\n\n            this.state = ParseState.EndScript;\n\n            bod.limChar = this.scanner.pos;\n\n            var topLevelMod: ModuleDeclaration = null;\n            if (moduleGenTarget != ModuleGenTarget.Local && this.hasTopLevelImportOrExport) {\n                var correctedFileName = switchToForwardSlashes(filename);\n                var id: Identifier = new Identifier(correctedFileName);\n                topLevelMod = new ModuleDeclaration(id, bod, this.topVarList(), this.topScopeList(), null);\n\n                topLevelMod.modFlags |= ModuleFlags.IsDynamic;\n                topLevelMod.modFlags |= ModuleFlags.IsWholeFile;\n                topLevelMod.modFlags |= ModuleFlags.Exported;\n\n                if (this.parsingDeclareFile) {\n                    topLevelMod.modFlags |= ModuleFlags.Ambient;\n                }\n\n                topLevelMod.minChar = minChar;\n                topLevelMod.limChar = this.scanner.pos;\n                topLevelMod.prettyName = getPrettyName(correctedFileName);\n                topLevelMod.containsUnicodeChar = this.scanner.seenUnicodeChar;\n                topLevelMod.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;\n\n                topLevelMod.amdDependencies = this.amdDependencies;\n\n                bod = new ASTList();\n                bod.minChar = topLevelMod.minChar;\n                bod.limChar = topLevelMod.limChar;\n                bod.append(topLevelMod);\n            }\n\n            var script = new Script(this.topVarList(), this.topScopeList());\n            script.bod = bod;\n            this.popDeclLists();\n            script.minChar = minChar;\n            script.limChar = this.scanner.pos;\n            script.locationInfo = new LocationInfo(filename, this.scanner.lineMap, unitIndex);\n            script.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            script.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            script.isDeclareFile = this.parsingDeclareFile;\n            script.topLevelMod = topLevelMod;\n            script.containsUnicodeChar = this.scanner.seenUnicodeChar;\n            script.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;\n            script.requiresExtendsBlock = this.requiresExtendsBlock;\n            return script;\n        }\n    }\n\n    export function quickParse(logger: TypeScript.ILogger, scopeStartAST: AST, sourceText: ISourceText, minChar: number, limChar: number,\n        errorCapture: (minChar: number, charLen: number, message: string, unitIndex: number) => void ): QuickParseResult {\n\n        var fragment = sourceText.getText(minChar, limChar);\n        logger.log("Quick parse range (" + minChar + "," + limChar + "): \\"" + TypeScript.stringToLiteral(fragment, 100) + "\\"");\n\n        var quickParser = new Parser();\n        quickParser.setErrorRecovery(null);\n        quickParser.errorCallback = errorCapture;\n\n        // REVIEW: use enclosing scope to determine this\n        // REVIEW: Why even use class here?\n        var quickClassDecl = new ClassDeclaration(null, null, null, null);\n        quickParser.currentClassDecl = quickClassDecl;\n\n        var result = quickParser.quickParse(new StringSourceText(fragment), "", 0);\n        return result;\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/license';
var v27579 = v27580 + 's/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    // We need to catch both left and right quotes\n    // (depending on your editor\'s font, this may not be clear...)    \n    export function stripQuotes(str: string) {\n        return str.replace("\\"", "").replace("\'", "").replace("\'", "").replace("\\"", "")\n    }\n\n    export function isQuoted(str: string) {\n        return str.indexOf("\\"") != -1 || str.indexOf("\'") != -1 || str.indexOf("\'") != -1 || str.indexOf("\\"") != -1;\n    }\n\n    export function quoteStr(str: string) {\n        return "\\"" + str + "\\"";\n    }\n\n    export function swapQuotes(str: string) {\n\n        if (str.indexOf("\\"") != -1) {\n            str = str.replace("\\"", "\'");\n            str = str.replace("\\"", "\'");\n        }\n        else {\n            str = str.replace("\'", "\\"");\n            str = str.replace("\'", "\\"");\n        }\n\n        return str;\n    }\n\n    export function switchToForwardSlashes(path: string) {\n        return path.replace(/\\\\/g, "/");\n    }\n\n    export function trimModName(modName: string) {\n        // in case\'s it\'s a declare file...\n        if (modName.length > 6 && modName.substring(modName.length - 6, modName.length) == ".d.str") {\n            return modName.substring(0, modName.length - 6);\n        }\n        if (modName.length > 4 && modName.substring(modName.length - 4, modName.length) == ".str") {\n            return modName.substring(0, modName.length - 4);\n        }\n        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) == ".d.ts") {\n            return modName.substring(0, modName.length - 5);\n        }\n        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".ts") {\n            return modName.substring(0, modName.length - 3);\n        }\n        // in case\'s it\'s a .js file\n        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".js") {\n            return modName.substring(0, modName.length - 3);\n        }\n\n        return modName;\n    }\n\n    export function getDeclareFilePath(fname: string) {\n        return isSTRFile(fname) ? changePathToDSTR(fname) : isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);\n    }\n\n    function isFileOfExtension(fname: string, ext: string) {\n        var invariantFname = fname.toLocaleUpperCase();\n        var invariantExt = ext.toLocaleUpperCase();\n        var extLength = invariantExt.length;\n        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) == invariantExt;\n    }\n\n    export function isJSFile(fname: string) {\n        return isFileOfExtension(fname, ".js");\n    }\n\n    export function isSTRFile(fname: string) {\n        return isFileOfExtension(fname, ".str");\n    }\n\n    export function isTSFile(fname: string) {\n        return isFileOfExtension(fname, ".ts");\n    }\n\n    export function isDSTRFile(fname: string) {\n        return isFileOfExtension(fname, ".d.str");\n    }\n\n    export function isDTSFile(fname: string) {\n        return isFileOfExtension(fname, ".d.ts");\n    }\n\n    export function getPrettyName(modPath: string, quote?=true, treatAsFileName?=false) { \n        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripQuotes(modPath));\n        var components = this.getPathComponents(modName);\n        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;\n    }\n\n    export function getPathComponents(path: string) {\n        return path.split("/");\n    }\n\n    export function getRelativePathToFixedPath(fixedModFilePath: string, absoluteModPath: string) {\n        absoluteModPath = switchToForwardSlashes(absoluteModPath);\n\n        var modComponents = this.getPathComponents(absoluteModPath);\n        var fixedModComponents = this.getPathComponents(fixedModFilePath);\n\n        // Find the component that differs\n        var joinStartIndex = 0;\n        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length ; joinStartIndex++) {\n            if (fixedModComponents[joinStartIndex] != modComponents[joinStartIndex]) {\n                break;\n            }\n        }\n\n        // Get the relative path\n        if (joinStartIndex != 0) {\n            var relativePath = "";\n            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);\n            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {\n                if (fixedModComponents[joinStartIndex] != "") {\n                    relativePath = relativePath + "../";\n      ';
var v27578 = v27579 + '          }\n            }\n\n            return relativePath + relativePathComponents.join("/");\n        }\n\n        return absoluteModPath;\n    }\n\n    export function quoteBaseName(modPath: string) {\n        var modName = trimModName(stripQuotes(modPath));\n        var path = getRootFilePath(modName);\n        if (path == "") {\n            return modPath;\n        }\n        else {\n            var components = modName.split(path);\n            var fileIndex = components.length > 1 ? 1 : 0;\n            return quoteStr(components[fileIndex]);\n        }\n    }\n\n    export function changePathToSTR(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".str";\n    }\n\n    export function changePathToDSTR(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".d.str";\n    }\n\n    export function changePathToTS(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".ts";\n    }\n\n    export function changePathToDTS(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".d.ts";\n    }\n\n    export function isRelative(path: string) {\n        return path.charAt(0) == ".";\n    }\n    export function isRooted(path: string) {\n        return path.charAt(0) == "\\\\" || path.charAt(0) == "/" || (path.indexOf(":\\\\") != -1) || (path.indexOf(":/") != -1);\n    }\n\n    export function getRootFilePath(outFname: string) {\n        if (outFname == "") {\n            return outFname;\n        }\n        else {\n            var isPath = outFname.indexOf("/") != -1;\n            return isPath ? filePath(outFname) : "";\n        }\n    }\n\n    export function filePathComponents(fullPath: string) {\n        fullPath = switchToForwardSlashes(fullPath);\n        var components = getPathComponents(fullPath);\n        return components.slice(0, components.length - 1);\n    }\n\n    export function filePath(fullPath: string) {\n        var path = filePathComponents(fullPath);\n        return path.join("/") + "/";\n    }\n\n    export function normalizeURL(url: string): string {\n        var hostDomainAndPortRegex = /^(https?:\\/\\/[\\-\\w\\.]+(:\\d+)?\\/)(.*)$/i;\n        var matches = hostDomainAndPortRegex.exec(url);\n        if (matches) {\n            var hostDomainAndPort = matches[1];\n            var actualPath = matches[3];\n            return hostDomainAndPort + normalizePath(actualPath);\n        }\n        return normalizePath(url);\n    }\n\n    export var pathNormalizeRegExp = /\\//g;\n\n    export function normalizePath(path: string): string {\n        path = switchToForwardSlashes(path);\n        var startedWithSep = path.charAt(0) === "/";\n        var parts = this.getPathComponents(path);\n        for (var i = 0; i < parts.length; i++) {\n            if (parts[i] === "." || parts[i] === "") {\n                parts.splice(i, 1);\n                i--;\n            }\n            if (i > 0 && parts[i] === ".." && parts[i - 1] !== "..") {\n                parts.splice(i - 1, 2);\n                i -= 2;\n            }\n        }\n        return (startedWithSep ? "/" : "") + parts.join("/");\n    }\n\n    export function normalizeImportPath(path: string): string {\n        return normalizePath(path);\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    /// Compiler settings\n\n    export class StyleSettings {\n        // bitwise operations not permitted\n        public bitwise = false;  \n        // disallow non-block statements as bodies of compound statements\n        public blockInCompoundStmt = false;\n        // disallow == and !=\n        public eqeqeq = false;\n        // require body of for in loop to start with a filter\n        public forin = false;\n        // empty blocks permitted\n        public emptyBlocks = true;\n        // require result of new expression to be used (no new just for side-effects)\n        public newMustBeUsed = false;\n        // require semicolons to terminate statements\n        public requireSemi = false;\n        // no top-level assignment in conditionals if (a=b) { ...\n        public assignmentInCond = false;\n        // no == null or != null\n        public eqnull = false;\n        // permit eval\n        public evalOK = true;\n        // permit var use if decl in inner scope as in if (c) { var v=10; } v=11;\n        public innerScopeDeclEscape = true;\n        // permit functions in loops\n        public funcInLoop = true;\n        // permit re-declaration of local variable \n        public reDecl';
var v27577 = v27578 + 'areLocal = true;\n        // permit obj[\'x\'] in addition to obj.x\n        public literalSubscript = true;\n        // flag implicit \'any\'\n        public implicitAny = false;\n\n        public setOption(opt: string, val: bool): bool {\n            var optExists = this[opt];\n            if (optExists !== undefined) {\n                this[opt] = val;\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        \n        public parseOptions(str: string) {\n            var opts=str.split(";");\n            for (var i = 0, len = opts.length; i < len; i++) {\n                var opt = opts[i];\n                var val = true;\n                var colonIndex=opt.lastIndexOf(":");\n                if (colonIndex >= 0) {\n                    var valStr = opt.substring(colonIndex+1);\n                    opt = opt.substring(0, colonIndex);\n                    if (valStr == "off") {\n                        val = false;\n                    }\n                }\n                if (!this.setOption(opt, val)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    \n    export class CompilationSettings {\n        public styleSettings = new StyleSettings();\n        public propagateConstants = false;\n        public minWhitespace = false;\n        public parseOnly = false;\n        public errorRecovery = false;\n        public emitComments = false;\n        public watch = false;\n        public exec = false;\n        public resolve = true;\n        public controlFlow = false;\n        public printControlFlow = false;\n        public controlFlowUseDef = false;\n        public errorOnWith = true;\n        public preprocess = true;\n        public canCallDefinitionSignature = false;\n\n        public inferPropertiesFromThisAssignment = false;\n        public useDefaultLib = true;\n\n        public codeGenTarget = CodeGenTarget.ES3;\n        public moduleGenTarget = ModuleGenTarget.Synchronous;\n        // --out option passed. \n        // Default is the "" which leads to multiple files generated next to the.ts files\n        public outputOption: string = "";\n        public mapSourceFiles = false;\n        public generateDeclarationFiles = false;\n\n        public useCaseSensitiveFileResolution = false;\n\n        public setStyleOptions(str: string) {\n            this.styleSettings.parseOptions(str);\n        }\n    }\n\n    ///\n    /// Preprocessing\n    ///\n    export interface IPreProcessedFileInfo {\n        settings: CompilationSettings;\n        referencedFiles: IFileReference[];\n        importedFiles: IFileReference[];\n        isLibFile: bool;\n    }\n\n    function getFileReferenceFromReferencePath(comment: string): IFileReference {\n        var referencesRegEx = /^(\\/\\/\\/\\s*<reference\\s+path=)(\'|")(.+?)\\2\\s*(static=(\'|")(.+?)\\2\\s*)*\\/>/gim;\n        var match = referencesRegEx.exec(comment);\n\n        if (match) {\n            var path: string = normalizePath(match[3]);\n            var adjustedPath = normalizePath(path);\n    \n            var isResident = match.length >= 7 && match[6] == "true";\n            if (isResident) {\n                CompilerDiagnostics.debugPrint(path + " is resident");\n            }\n            return { minChar: 0, limChar: 0, path: switchToForwardSlashes(adjustedPath), isResident: isResident };\n        }\n        else {\n            return null;\n        }\n    }\n\n    // used in the parser, but kept here in case we want to reintegrate it with preprocessing\n    export function getAdditionalDependencyPath(comment: string): string {\n        var amdDependencyRegEx = /^(\\/\\/\\/\\s*<amd-dependency\\s+path=)(\'|")(.+?)\\2\\s*(static=(\'|")(.+?)\\2\\s*)*\\/>/gim;\n        var match = amdDependencyRegEx.exec(comment);\n\n        if (match) {\n            var path: string = match[3];\n            return path;\n        }\n        else {\n            return null;\n        }\n    }\n\n    export function getImplicitImport(comment: string): bool {\n        var implicitImportRegEx = /^(\\/\\/\\/\\s*<implicit-import\\s*)*\\/>/gim;\n        var match = implicitImportRegEx.exec(comment);\n\n        if (match) {\n            return true;\n        }\n        \n        return false;\n    }\n\n    export function getStyleSettings(comment: string, styleSettings: StyleSettings) {\n        var styleRegEx = /^(\\/\\/\\/\\s*<style\\s+)(([a-zA-Z])+=(\'|").+(\'|"))\\s*\\/>/gim;\n\n        var settings = styleRegEx.exec(comment);\n\n        if (settings) {\n            var settingsRegEx = /^([a-zA-Z]+=[\'"]on[\'|"])/gim;\n            settings = settingsRegEx.exec(settings[2]);\n                \n            if (settings) {\n                for (var i = 0; i < settings.length; i++) {\n                    var setting = (<string>settings[i]).split("=");\n                    var on = "\\"on\\"";\n\n                    switch (setting[0]) {\n                        case "blockInCompoundStmt": styleSettings.blockInCompoundStmt = setting[1] == on; break;\n                        case "eqeqeq": styleSettings.eqeqeq = setting[1] == on; break;';
var v27576 = v27577 + '\n                        case "forin": styleSettings.forin = setting[1] == on; break;\n                        case "emptyBlocks": styleSettings.emptyBlocks = setting[1] == on; break;\n                        case "newMustBeUsed": styleSettings.newMustBeUsed = setting[1] == on; break;\n                        case "requireSemi": styleSettings.requireSemi = setting[1] == on; break;\n                        case "assignmentInCond": styleSettings.assignmentInCond = setting[1] == on; break;\n                        case "eqnull": styleSettings.eqnull = setting[1] == on; break;\n                        case "evalOK": styleSettings.evalOK = setting[1] == on; break;\n                        case "innerScopeDeclEscape": styleSettings.innerScopeDeclEscape = setting[1] == on; break;\n                        case "funcInLoop": styleSettings.funcInLoop = setting[1] == on; break;\n                        case "reDeclareLocal": styleSettings.reDeclareLocal = setting[1] == on; break;\n                        case "literalSubscript": styleSettings.literalSubscript = setting[1] == on; break;\n                        case "implicitAny": styleSettings.implicitAny = setting[1] == on; break;                               \n                    }\n                }\n            }\n        }\n    }\n\n    export function getReferencedFiles(sourceText: ISourceText): IFileReference[] {\n        var preProcessInfo = preProcessFile(sourceText, null, false);\n        return preProcessInfo.referencedFiles;\n    }\n\n    export function preProcessFile(sourceText: ISourceText, options=new CompilationSettings(), readImportFiles? = true): IPreProcessedFileInfo {\n        var scanner = new Scanner();\n        scanner.resetComments();\n        scanner.setSourceText(sourceText, LexMode.File);\n\n        var tok: Token = scanner.scan();\n        var comments: CommentToken[] = [];\n        var comment: CommentToken = null;\n        var leftCurlies: Token[] = [];\n\n        var settings: CompilationSettings = options;\n        var referencedFiles: IFileReference[] = [];\n        var importedFiles: IFileReference[] = [];\n        var isLibFile: bool = false;\n\n        // only search out dynamic mods\n        // if you find a dynamic mod, ignore every other mod inside, until you balance rcurlies\n\n        while (tok.tokenId != TokenID.EndOfFile) {\n\n            if (readImportFiles && tok.tokenId == TokenID.Import) {\n\n                tok = scanner.scan();\n\n                if (tok.tokenId == TokenID.Identifier || convertTokToID(tok, false)) {\n                    tok = scanner.scan();\n\n                    if (tok.tokenId == TokenID.Equals) {\n                        tok = scanner.scan();\n\n                        if (tok.tokenId == TokenID.Module) {\n                            tok = scanner.scan();\n                            if (tok.tokenId == TokenID.OpenParen) {\n                                tok = scanner.scan();\n\n                                // import foo = module("foo")\n                                if (tok.tokenId == TokenID.StringLiteral) {\n                                    var ref = { minChar: scanner.startPos, limChar: scanner.pos, path: stripQuotes(switchToForwardSlashes(tok.getText())), isResident: false };\n                                    importedFiles.push(ref);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (tok.tokenId == TokenID.OpenBrace) {\n                leftCurlies.push(tok);\n            }\n\n            if (tok.tokenId == TokenID.CloseBrace) {\n                leftCurlies.pop();\n            }\n\n            tok = scanner.scan();\n        }\n\n        // deal with comment references, amd dependencies and style settings\n        // REVIEW: We could potentially do this inline with the above, if we\n        // set Scanner::scanComments to \'true\'\n        comments = scanner.getComments();\n\n        for (var iComment = 0; iComment < comments.length; iComment++) {\n            comment = comments[iComment];\n            \n            if (!comment.isBlock) {\n                var referencedCode = getFileReferenceFromReferencePath(comment.getText());\n                if (referencedCode) {\n                    referencedCode.minChar = comment.startPos;\n                    referencedCode.limChar = referencedCode.minChar + comment.value.length;\n                    referencedFiles.push(referencedCode);\n                }\n\n                if (settings) {\n                    getStyleSettings(comment.getText(), settings.styleSettings);\n\n                    // is it a lib file?\n                    var isNoLibRegex = /^(\\/\\/\\/\\s*<reference\\s+no-default-lib=)(\'|")(.+?)\\2\\s*\\/>/gim;\n                    var isNoLibMatch: any = isNoLibRegex.exec(comment.getText());\n                    if (isNoLibMatch) {\n                        isLibFile = (isNoLibMatch[3] == "true");\n                    }\n                }\n            }\n        }\n\n        return { settings: settings, referencedFiles: refere';
var v27575 = v27576 + 'ncedFiles, importedFiles: importedFiles, isLibFile: isLibFile };\n    }\n\n} // Tools//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    // TODO: refactor indent logic for use in emit\n    export class PrintContext {\n        public builder = "";\n        public indent1 = "  ";\n        public indentStrings: string[] = [];\n        public indentAmt = 0;\n\n        constructor (public outfile: ITextWriter, public parser: Parser) {\n        }\n\n        public increaseIndent() {\n            this.indentAmt++;\n        }\n\n        public decreaseIndent() {\n            this.indentAmt--;\n        }\n\n        public startLine() {\n            if (this.builder.length > 0) {\n                CompilerDiagnostics.Alert(this.builder);\n            }\n            var indentString = this.indentStrings[this.indentAmt];\n            if (indentString === undefined) {\n                indentString = "";\n                for (var i = 0; i < this.indentAmt; i++) {\n                    indentString += this.indent1;\n                }\n                this.indentStrings[this.indentAmt] = indentString;\n            }\n            this.builder += indentString;\n        }\n\n        public write(s) {\n            this.builder += s;\n        }\n\n        public writeLine(s) {\n            this.builder += s;\n            this.outfile.WriteLine(this.builder);\n            this.builder = "";\n        }\n\n    }\n\n    export function prePrintAST(ast: AST, parent: AST, walker: IAstWalker) {\n        var pc: PrintContext = <PrintContext>walker.state;\n\n        ast.print(pc);\n        pc.increaseIndent();\n        return ast;\n    }\n\n\n    export function postPrintAST(ast: AST, parent: AST, walker: IAstWalker) {\n        var pc: PrintContext = <PrintContext>walker.state;\n        pc.decreaseIndent();\n        return ast;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export interface IResolvedFile {\n        content: string;\n        path: string;\n    }\n\n    /// This class acts as a convenience class to store path and content information in places\n    /// where we need an ISourceText object\n    export class SourceUnit implements ISourceText, IResolvedFile {\n        public referencedFiles: IFileReference[] = null;\n        constructor(public path: string, public content: string) {\n        }\n\n        public getText(start: number, end: number): string { return this.content.substring(start, end); }\n        public getLength(): number { return this.content.length; }\n    }\n\n    export interface IFileReference {\n        minChar: number;\n        limChar: number;\n        path: string;\n        isResident: bool;\n    }\n\n    /// Limited API for file system manipulation\n    export interface IFileSystemObject {\n        resolvePath(path: string): string;\n        readFile(path: string): string;\n        findFile(rootPath: string, partialFilePath: string): IResolvedFile;\n        dirName(path: string): string;\n    }\n\n    export class CompilationEnvironment {\n        constructor (public compilationSettings: CompilationSettings, public ioHost: IFileSystemObject) { }\n        public residentCode: SourceUnit[] = [];\n        public code: SourceUnit[] = [];\n    }\n\n    export interface IResolutionDispatcher {\n        postResolutionError(errorFile: string, errorMessage: string, errorObject: any): void;\n        postResolution(path: string, source: ISourceText): void;\n    }\n\n    export interface ICodeResolver {\n        resolveCode(referencePath: string, rootPath: string, performSearch:bool, state: IResolutionDispatcher): void;\n    }\n\n    export interface IResolverHost {\n        resolveCompilationEnvironment(preEnvironment: CompilationEnvironment, resolver: ICodeResolver, traceDependencies: bool): CompilationEnvironment;\n    }\n\n    export class CodeResolver implements T';
var v27574 = v27575 + 'ypeScript.ICodeResolver {\n        public visited: any = { };\n\n        constructor (public environment: CompilationEnvironment) { }\n\n        public resolveCode(referencePath: string, parentPath: string, performSearch: bool, resolutionDispatcher: TypeScript.IResolutionDispatcher): void {\n            \n            var resolvedFile: IResolvedFile = { content: null, path: referencePath };\n            \n            var ioHost = this.environment.ioHost;\n            \n            // If the path is relative, normalize it, based on the root\n            var isRelativePath = TypeScript.isRelative(referencePath);\n            var isRootedPath = isRelativePath ? false : isRooted(referencePath);\n            var normalizedPath: string = \n                isRelativePath ? ioHost.resolvePath(parentPath + "/" + referencePath) : \n                // we only follow the second clause if the path is a non-rooted triple-slash reference path\n                (isRootedPath || !parentPath || performSearch ? referencePath : parentPath + "/" + referencePath);\n\n            // We use +=.ts to make sure we don\'t accidentally pick up ".js" files or the like\n            if (!isSTRFile(normalizedPath) && !isTSFile(normalizedPath)) {\n                normalizedPath += ".ts";  //changePathToSTR(normalizedPath);\n            }\n\n            normalizedPath = switchToForwardSlashes(stripQuotes(normalizedPath));\n            var absoluteModuleID = this.environment.compilationSettings.useCaseSensitiveFileResolution ? normalizedPath : normalizedPath.toLocaleUpperCase();\n            // read the file contents - if it doesn\'t exist, trigger a resolution error\n            if (!this.visited[absoluteModuleID]) {\n\n                // if the path is relative, or came from a reference tag, we don\'t perform a search\n                if (isRelativePath || isRootedPath || !performSearch) {\n                    try {\n                        CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n                            \n                        // Look for the .ts file first - if not present, use the .ts, the .d.str and the .d.ts\n                        try {\n                            resolvedFile.content = ioHost.readFile(normalizedPath);\n                        }\n                        catch (err) {\n                            try {\n                                if (isSTRFile(normalizedPath)) {\n                                    normalizedPath = changePathToTS(normalizedPath);\n                                }\n                                else if (isTSFile(normalizedPath)) {\n                                    normalizedPath = changePathToSTR(normalizedPath);\n                                }\n                                CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n                                resolvedFile.content = ioHost.readFile(normalizedPath);\n                            }\n                            catch (err) {\n                                normalizedPath = changePathToDSTR(normalizedPath);\n                                CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n\n                                try {\n                                    resolvedFile.content = ioHost.readFile(normalizedPath);\n                                }\n                                catch (err) {\n                                    normalizedPath = changePathToDTS(normalizedPath);\n                                    CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n                                    resolvedFile.content = ioHost.readFile(normalizedPath);\n                                }\n                            }\n                        }\n                        CompilerDiagnostics.debugPrint("   Found code at " + normalizedPath);\n\n                        resolvedFile.path = normalizedPath;\n                        this.visited[absoluteModuleID] = true;\n                    }\n                    catch (err) {\n                        CompilerDiagnostics.debugPrint("   Did not find code for " + referencePath);\n                    }\n                }\n                else {\n\n                    // if the path is non-relative, we should attempt to search on the relative path\n                    resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n\n                    if (!resolvedFile) {\n                        if (isSTRFile(normalizedPath)) {\n                            normalizedPath = changePathToTS(normalizedPath);\n                        }\n                        else if (isTSFile(normalizedPath)) {\n                            normalizedPath = changePathToSTR(normalizedPath);\n                        }\n                        resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n                    }\n\n                    if (!resolvedFile) {\n                        normalizedPath = changePathToDTS(normalizedPath);\n                        resolvedFile = ioHo';
var v27573 = v27574 + "st.findFile(parentPath, normalizedPath);\n                        if (!resolvedFile) {\n                            normalizedPath = changePathToDSTR(normalizedPath);\n                            resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n                        }\n                    }\n\n                    if (resolvedFile) {\n                        resolvedFile.path = switchToForwardSlashes(TypeScript.stripQuotes(resolvedFile.path));\n                        CompilerDiagnostics.debugPrint(referencePath + \" resolved to: \" + resolvedFile.path);\n                        resolvedFile.content = resolvedFile.content;\n                        this.visited[absoluteModuleID] = true;\n                    }\n                    else {\n                        CompilerDiagnostics.debugPrint(\"Could not find \" + referencePath);\n                    }\n                }\n\n                if (resolvedFile && resolvedFile.content != null) {\n                    // preprocess the file, to gather dependencies\n                    var rootDir = ioHost.dirName(resolvedFile.path);\n                    var sourceUnit = new SourceUnit(resolvedFile.path, resolvedFile.content);\n                    var preProcessedFileInfo = preProcessFile(sourceUnit, this.environment.compilationSettings);\n                    sourceUnit.referencedFiles = preProcessedFileInfo.referencedFiles;\n\n                    // resolve explicit references\n                    for (var i = 0; i < preProcessedFileInfo.referencedFiles.length; i++) {\n                        var referencedFile = preProcessedFileInfo.referencedFiles[i];\n                        var normalizedPath = isRooted(referencedFile.path) ? referencedFile.path : rootDir + \"/\" + referencedFile.path;\n                        normalizedPath = ioHost.resolvePath(normalizedPath);\n                        if (referencePath == normalizedPath) {\n                            resolutionDispatcher.postResolutionError(normalizedPath, \"File contains reference to itself\", null);\n                            continue;\n                        }\n                        this.resolveCode(referencedFile.path, rootDir, false, resolutionDispatcher);\n                    }\n                    \n                    // resolve imports\n                    for (var i = 0; i < preProcessedFileInfo.importedFiles.length; i++) {\n                        this.resolveCode(preProcessedFileInfo.importedFiles[i].path, rootDir, true, resolutionDispatcher);\n                    }\n\n                    // add the file to the appropriate code list\n                    resolutionDispatcher.postResolution(sourceUnit.path, sourceUnit);\n                }\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path='typescript.ts' />\n\nmodule TypeScript {\n\n    export var LexEOF = (-1);\n\n    export var LexCodeNWL = 0x0A;\n    export var LexCodeRET = 0x0D;\n    export var LexCodeLS =  0x2028;\n    export var LexCodePS =  0x2029;\n    export var LexCodeTAB = 0x09;\n    export var LexCodeVTAB = 0x0B;\n    export var LexCode_e = 'e'.charCodeAt(0);\n    export var LexCode_E = 'E'.charCodeAt(0);\n    export var LexCode_x = 'x'.charCodeAt(0);\n    export var LexCode_X = 'X'.charCodeAt(0);\n    export var LexCode_a = 'a'.charCodeAt(0);\n    export var LexCode_A = 'A'.charCodeAt(0);\n    export var LexCode_f = 'f'.charCodeAt(0);\n    export var LexCode_F = 'F'.charCodeAt(0);\n\n    export var LexCode_g = 'g'.charCodeAt(0);\n    export var LexCode_m = 'm'.charCodeAt(0);\n    export var LexCode_i = 'i'.charCodeAt(0);\n\n    export var LexCode_u = 'u'.charCodeAt(0);\n\n    export var LexCode_0 = '0'.charCodeAt(0);\n    export var LexCode_9 = '9'.charCodeAt(0);\n    export var LexCode_8 = '8'.charCodeAt(0);\n    export var LexCode_7 = '7'.charCodeAt(0);\n\n    export var LexCodeBSL = '\\\\'.charCodeAt(0);\n    export var LexCodeSHP = '#'.charCodeAt(0);\n    export var LexCodeBNG = '!'.charCodeAt(0);\n    export var LexCodeQUO = '\"'.charCodeAt(0);\n    export var LexCodeAPO = '\\''.charCodeAt(0);\n    export var LexCodePCT = '%'.charCodeAt(0);\n    export var LexCodeAMP = '&'.charCodeAt(0);\n    export var LexCodeLPR = '('.charCodeAt(0);\n    export var LexCodeRPR = ')'.charCodeAt(0);\n    export var LexCodePLS = '+'.charCodeAt(0);\n    export var LexCodeMIN = '-'.charCodeAt(0);\n    export var LexCodeMUL = '*'.charCodeAt(0);\n    export var LexCodeSLH = '/'.charCodeAt(0);\n    export var LexCodeXOR = '^'.";
var v27572 = v27573 + "charCodeAt(0);\n    export var LexCodeCMA = ','.charCodeAt(0);\n    export var LexCodeDOT = '.'.charCodeAt(0);\n    export var LexCodeLT = '<'.charCodeAt(0);\n    export var LexCodeEQ = '='.charCodeAt(0);\n    export var LexCodeGT = '>'.charCodeAt(0);\n    export var LexCodeQUE = '?'.charCodeAt(0);\n    export var LexCodeLBR = '['.charCodeAt(0);\n    export var LexCodeRBR = ']'.charCodeAt(0);\n    export var LexCodeUSC = '_'.charCodeAt(0);\n    export var LexCodeLC = '{'.charCodeAt(0);\n    export var LexCodeRC = '}'.charCodeAt(0);\n    export var LexCodeBAR = '|'.charCodeAt(0);\n    export var LexCodeTIL = '~'.charCodeAt(0);\n    export var LexCodeCOL = ':'.charCodeAt(0);\n    export var LexCodeSMC = ';'.charCodeAt(0);\n    export var LexCodeUnderscore = '_'.charCodeAt(0);\n    export var LexCodeDollar = '$'.charCodeAt(0);\n    export var LexCodeSpace = 32;\n    export var LexCodeAtSign = '@'.charCodeAt(0);\n    export var LexCodeASCIIChars = 128;\n\n    export var LexKeywordTable = undefined;\n    // TODO: use new Token[128];\n    var autoToken: Token[] = new Array(LexCodeASCIIChars);\n    var lexIdStartTable: bool[] = new Array(LexCodeASCIIChars);\n\n    // Unicode range maps\n    // REVIEW: These range maps have been extracted from the Unicode specifications, they might be missing values, and/or include \n    //         incorrect ranges. but for the most they seem to be correct. A more accurate and thorough review is needed.\n\n    /*\n        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers\n        IdentifierStart :: Can contain Unicode 3.0.0  categories Uppercase letter (Lu), Lowercase letter (Ll), Titlecase letter (Lt), Modifier letter (Lm), Other letter (Lo), or Letter number (Nl).\n        IdentifierPart :: Can contain IdentifierStart + Unicode 3.0.0  categories Non-spacing mark (Mn), Combining spacing mark (Mc), Decimal number (Nd), or Connector punctuation (Pc).\n                    \n        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:\n        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt\n    */\n    var unicodeES3IdStart = [\n\t\t170, 170,181, 181,186, 186,192, 214,216, 246,248, 543,546, 563,592, 685,688, 696,699, 705,720, 721,736, 740,750, 750,890, 890,902, 902,904, 906,908, 908,910, 929,931, 974,976, 983,986, 1011,1024, 1153,1164, 1220,1223, 1224,1227, 1228,1232, 1269,1272, 1273,1329, 1366,1369, 1369,1377, 1415,1488, 1514,\n\t\t1520, 1522,1569, 1594,1600, 1610,1649, 1747,1749, 1749,1765, 1766,1786, 1788,1808, 1808,1810, 1836,1920, 1957,2309, 2361,2365, 2365,2384, 2384,2392, 2401,2437, 2444,2447, 2448,2451, 2472,2474, 2480,2482, 2482,2486, 2489,2524, 2525,2527, 2529,2544, 2545,2565, 2570,2575, 2576,2579, 2600,2602, 2608,2610, 2611,\n\t\t2613, 2614,2616, 2617,2649, 2652,2654, 2654,2674, 2676,2693, 2699,2701, 2701,2703, 2705,2707, 2728,2730, 2736,2738, 2739,2741, 2745,2749, 2749,2768, 2768,2784, 2784,2821, 2828,2831, 2832,2835, 2856,2858, 2864,2866, 2867,2870, 2873,2877, 2877,2908, 2909,2911, 2913,2949, 2954,2958, 2960,2962, 2965,2969, 2970,\n\t\t2972, 2972,2974, 2975,2979, 2980,2984, 2986,2990, 2997,2999, 3001,3077, 3084,3086, 3088,3090, 3112,3114, 3123,3125, 3129,3168, 3169,3205, 3212,3214, 3216,3218, 3240,3242, 3251,3253, 3257,3294, 3294,3296, 3297,3333, 3340,3342, 3344,3346, 3368,3370, 3385,3424, 3425,3461, 3478,3482, 3505,3507, 3515,3517, 3517,\n\t\t3520, 3526,3585, 3632,3634, 3635,3648, 3654,3713, 3714,3716, 3716,3719, 3720,3722, 3722,3725, 3725,3732, 3735,3737, 3743,3745, 3747,3749, 3749,3751, 3751,3754, 3755,3757, 3760,3762, 3763,3773, 3773,3776, 3780,3782, 3782,3804, 3805,3840, 3840,3904, 3911,3913, 3946,3976, 3979,4096, 4129,4131, 4135,4137, 4138,\n\t\t4176, 4181,4256, 4293,4304, 4342,4352, 4441,4447, 4514,4520, 4601,4608, 4614,4616, 4678,4680, 4680,4682, 4685,4688, 4694,4696, 4696,4698, 4701,4704, 4742,4744, 4744,4746, 4749,4752, 4782,4784, 4784,4786, 4789,4792, 4798,4800, 4800,4802, 4805,4808, 4814,4816, 4822,4824, 4846,4848, 4878,4880, 4880,4882, 4885,\n\t\t4888, 4894,4896, 4934,4936, 4954,5024, 5108,5121, 5740,5743, 5750,5761, 5786,5792, 5866,6016, 6067,6176, 6263,6272, 6312,7680, 7835,7840, 7929,7936, 7957,7960, 7965,7968, 8005,8008, 8013,8016, 8023,8025, 8025,8027, 8027,8029, 8029,8031, 8061,8064, 8116,8118, 8124,8126, 8126,8130, 8132,8134, 8140,8144, 8147,\n\t\t8150, 8155,8160, 8172,8178, 8180,8182, 8188,8319, 8319,8450, 8450,8455, 8455,8458, 8467,8469, 8469,8473, 8477,8484, 8484,8486, 8486,8488, 8488,8490, 8493,8495, 8497,8499, 8505,8544, 8579,12293, 12295,12321, 12329,12337, 12341,12344, 12346,12353, 12436,12445, 12446,12449, 12538,12540, 12542,12549, 12588,\n\t\t12593, 12686,12704, 12727,13312, 13312,19893, 19893,19968, 19968,40869, 40869,40960, 42124,44032, 44032,55203, 55203,63744, 64045,64256, 64262,64275, 64279,64285, 64285,64287, 64296,64298, 64310,64312, 64316,64318, 64318,64320, 64321,64323, 64324,64326, 64433,64467, 64829,64848, 64911,64914, 64967,\n\t\t65008, 65019,65136, 65138,65140, 65140,65142, 65276,65313, 65338,65345, 65370,65382, 654";
var v27571 = v27572 + "70,65474, 65479,65482, 65487,65490, 65495,65498, 65500\n\t];\n\n\tvar unicodeES3IdCont = [\n\t\t768, 846,864, 866,1155, 1158,1425, 1441,1443, 1465,1467, 1469,1471, 1471,1473, 1474,1476, 1476,1611, 1621,1632, 1641,1648, 1648,1750, 1756,1759, 1764,1767, 1768,1770, 1773,1776, 1785,1809, 1809,1840, 1866,1958, 1968,2305, 2307,2364, 2364,2366, 2381,2385, 2388,2402, 2403,2406, 2415,2433, 2435,2492, 2492,\n\t\t2494, 2500,2503, 2504,2507, 2509,2519, 2519,2530, 2531,2534, 2543,2562, 2562,2620, 2620,2622, 2626,2631, 2632,2635, 2637,2662, 2673,2689, 2691,2748, 2748,2750, 2757,2759, 2761,2763, 2765,2790, 2799,2817, 2819,2876, 2876,2878, 2883,2887, 2888,2891, 2893,2902, 2903,2918, 2927,2946, 2947,3006, 3010,3014, 3016,\n\t\t3018, 3021,3031, 3031,3047, 3055,3073, 3075,3134, 3140,3142, 3144,3146, 3149,3157, 3158,3174, 3183,3202, 3203,3262, 3268,3270, 3272,3274, 3277,3285, 3286,3302, 3311,3330, 3331,3390, 3395,3398, 3400,3402, 3405,3415, 3415,3430, 3439,3458, 3459,3530, 3530,3535, 3540,3542, 3542,3544, 3551,3570, 3571,3633, 3633,\n\t\t3636, 3642,3655, 3662,3664, 3673,3761, 3761,3764, 3769,3771, 3772,3784, 3789,3792, 3801,3864, 3865,3872, 3881,3893, 3893,3895, 3895,3897, 3897,3902, 3903,3953, 3972,3974, 3975,3984, 3991,3993, 4028,4038, 4038,4140, 4146,4150, 4153,4160, 4169,4182, 4185,4969, 4977,6068, 6099,6112, 6121,6160, 6169,6313, 6313,\n\t\t8255, 8256,8400, 8412,8417, 8417,12330, 12335,12441, 12442,12539, 12539,64286, 64286,65056, 65059,65075, 65076,65101, 65103,65296, 65305,65343, 65343,65381, 65381\n\t];\n\n\n    /*\n        As per ECMAScript Language Specification 5th Edition, Section 7.6: Identifier Names and Identifiers\n        IdentifierStart :: Can contain Unicode 6.2  categories Uppercase letter (Lu), Lowercase letter (Ll), Titlecase letter (Lt), Modifier letter (Lm), Other letter (Lo), or Letter number (Nl).\n        IdentifierPart :: Can contain IdentifierStart + Unicode 6.2  categories Non-spacing mark (Mn), Combining spacing mark (Mc), Decimal number (Nd), Connector punctuation (Pc), <ZWNJ>, or <ZWJ>.\n                    \n        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:\n        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt\n    */\n\tvar unicodeES5IdStart = [\n\t\t170, 170,181, 181,186, 186,192, 214,216, 246,248, 705,710, 721,736, 740,748, 748,750, 750,880, 884,886, 887,890, 893,902, 902,904, 906,908, 908,910, 929,931, 1013,1015, 1153,1162, 1319,1329, 1366,1369, 1369,1377, 1415,1488, 1514,1520, 1522,1568, 1610,1646, 1647,1649, 1747,1749, 1749,1765, 1766,1774, 1775,\n\t\t1786, 1788,1791, 1791,1808, 1808,1810, 1839,1869, 1957,1969, 1969,1994, 2026,2036, 2037,2042, 2042,2048, 2069,2074, 2074,2084, 2084,2088, 2088,2112, 2136,2208, 2208,2210, 2220,2308, 2361,2365, 2365,2384, 2384,2392, 2401,2417, 2423,2425, 2431,2437, 2444,2447, 2448,2451, 2472,2474, 2480,2482, 2482,2486, 2489,\n\t\t2493, 2493,2510, 2510,2524, 2525,2527, 2529,2544, 2545,2565, 2570,2575, 2576,2579, 2600,2602, 2608,2610, 2611,2613, 2614,2616, 2617,2649, 2652,2654, 2654,2674, 2676,2693, 2701,2703, 2705,2707, 2728,2730, 2736,2738, 2739,2741, 2745,2749, 2749,2768, 2768,2784, 2785,2821, 2828,2831, 2832,2835, 2856,2858, 2864,\n\t\t2866, 2867,2869, 2873,2877, 2877,2908, 2909,2911, 2913,2929, 2929,2947, 2947,2949, 2954,2958, 2960,2962, 2965,2969, 2970,2972, 2972,2974, 2975,2979, 2980,2984, 2986,2990, 3001,3024, 3024,3077, 3084,3086, 3088,3090, 3112,3114, 3123,3125, 3129,3133, 3133,3160, 3161,3168, 3169,3205, 3212,3214, 3216,3218, 3240,\n\t\t3242, 3251,3253, 3257,3261, 3261,3294, 3294,3296, 3297,3313, 3314,3333, 3340,3342, 3344,3346, 3386,3389, 3389,3406, 3406,3424, 3425,3450, 3455,3461, 3478,3482, 3505,3507, 3515,3517, 3517,3520, 3526,3585, 3632,3634, 3635,3648, 3654,3713, 3714,3716, 3716,3719, 3720,3722, 3722,3725, 3725,3732, 3735,3737, 3743,\n\t\t3745, 3747,3749, 3749,3751, 3751,3754, 3755,3757, 3760,3762, 3763,3773, 3773,3776, 3780,3782, 3782,3804, 3807,3840, 3840,3904, 3911,3913, 3948,3976, 3980,4096, 4138,4159, 4159,4176, 4181,4186, 4189,4193, 4193,4197, 4198,4206, 4208,4213, 4225,4238, 4238,4256, 4293,4295, 4295,4301, 4301,4304, 4346,4348, 4680,\n\t\t4682, 4685,4688, 4694,4696, 4696,4698, 4701,4704, 4744,4746, 4749,4752, 4784,4786, 4789,4792, 4798,4800, 4800,4802, 4805,4808, 4822,4824, 4880,4882, 4885,4888, 4954,4992, 5007,5024, 5108,5121, 5740,5743, 5759,5761, 5786,5792, 5866,5870, 5872,5888, 5900,5902, 5905,5920, 5937,5952, 5969,5984, 5996,5998, 6000,\n\t\t6016, 6067,6103, 6103,6108, 6108,6176, 6263,6272, 6312,6314, 6314,6320, 6389,6400, 6428,6480, 6509,6512, 6516,6528, 6571,6593, 6599,6656, 6678,6688, 6740,6823, 6823,6917, 6963,6981, 6987,7043, 7072,7086, 7087,7098, 7141,7168, 7203,7245, 7247,7258, 7293,7401, 7404,7406, 7409,7413, 7414,7424, 7615,7680, 7957,\n\t\t7960, 7965,7968, 8005,8008, 8013,8016, 8023,8025, 8025,8027, 8027,8029, 8029,8031, 8061,8064, 8116,8118, 8124,8126, 8126,8130, 8132,8134, 8140,8144, 8147,8150, 8155,8160, 8172,8178, 8180,8182, 8188,8305, 8305,8319, 8319,8336, 8348,8450, 8450,8455, 8455,8458, 8467,8469, 8469,8473, 8477,84";
var v27570 = v27571 + "84, 8484,8486, 8486,\n\t\t8488, 8488,8490, 8493,8495, 8505,8508, 8511,8517, 8521,8526, 8526,8544, 8584,11264, 11310,11312, 11358,11360, 11492,11499, 11502,11506, 11507,11520, 11557,11559, 11559,11565, 11565,11568, 11623,11631, 11631,11648, 11670,11680, 11686,11688, 11694,11696, 11702,11704, 11710,11712, 11718,11720, 11726,\n\t\t11728, 11734,11736, 11742,11823, 11823,12293, 12295,12321, 12329,12337, 12341,12344, 12348,12353, 12438,12445, 12447,12449, 12538,12540, 12543,12549, 12589,12593, 12686,12704, 12730,12784, 12799,13312, 13312,19893, 19893,19968, 19968,40908, 40908,40960, 42124,42192, 42237,42240, 42508,42512, 42527,\n\t\t42538, 42539,42560, 42606,42623, 42647,42656, 42735,42775, 42783,42786, 42888,42891, 42894,42896, 42899,42912, 42922,43000, 43009,43011, 43013,43015, 43018,43020, 43042,43072, 43123,43138, 43187,43250, 43255,43259, 43259,43274, 43301,43312, 43334,43360, 43388,43396, 43442,43471, 43471,43520, 43560,\n\t\t43584, 43586,43588, 43595,43616, 43638,43642, 43642,43648, 43695,43697, 43697,43701, 43702,43705, 43709,43712, 43712,43714, 43714,43739, 43741,43744, 43754,43762, 43764,43777, 43782,43785, 43790,43793, 43798,43808, 43814,43816, 43822,43968, 44002,44032, 44032,55203, 55203,55216, 55238,55243, 55291,\n\t\t63744, 64109,64112, 64217,64256, 64262,64275, 64279,64285, 64285,64287, 64296,64298, 64310,64312, 64316,64318, 64318,64320, 64321,64323, 64324,64326, 64433,64467, 64829,64848, 64911,64914, 64967,65008, 65019,65136, 65140,65142, 65276,65313, 65338,65345, 65370,65382, 65470,65474, 65479,65482, 65487,\n\t\t65490, 65495,65498, 65500\n\t];\n\n\tvar unicodeES5IdCont = [\n\t\t768, 879,1155, 1159,1425, 1469,1471, 1471,1473, 1474,1476, 1477,1479, 1479,1552, 1562,1611, 1641,1648, 1648,1750, 1756,1759, 1764,1767, 1768,1770, 1773,1776, 1785,1809, 1809,1840, 1866,1958, 1968,1984, 1993,2027, 2035,2070, 2073,2075, 2083,2085, 2087,2089, 2093,2137, 2139,2276, 2302,2304, 2307,2362, 2364,\n\t\t2366, 2383,2385, 2391,2402, 2403,2406, 2415,2433, 2435,2492, 2492,2494, 2500,2503, 2504,2507, 2509,2519, 2519,2530, 2531,2534, 2543,2561, 2563,2620, 2620,2622, 2626,2631, 2632,2635, 2637,2641, 2641,2662, 2673,2677, 2677,2689, 2691,2748, 2748,2750, 2757,2759, 2761,2763, 2765,2786, 2787,2790, 2799,2817, 2819,\n\t\t2876, 2876,2878, 2884,2887, 2888,2891, 2893,2902, 2903,2914, 2915,2918, 2927,2946, 2946,3006, 3010,3014, 3016,3018, 3021,3031, 3031,3046, 3055,3073, 3075,3134, 3140,3142, 3144,3146, 3149,3157, 3158,3170, 3171,3174, 3183,3202, 3203,3260, 3260,3262, 3268,3270, 3272,3274, 3277,3285, 3286,3298, 3299,3302, 3311,\n\t\t3330, 3331,3390, 3396,3398, 3400,3402, 3405,3415, 3415,3426, 3427,3430, 3439,3458, 3459,3530, 3530,3535, 3540,3542, 3542,3544, 3551,3570, 3571,3633, 3633,3636, 3642,3655, 3662,3664, 3673,3761, 3761,3764, 3769,3771, 3772,3784, 3789,3792, 3801,3864, 3865,3872, 3881,3893, 3893,3895, 3895,3897, 3897,3902, 3903,\n\t\t3953, 3972,3974, 3975,3981, 3991,3993, 4028,4038, 4038,4139, 4158,4160, 4169,4182, 4185,4190, 4192,4194, 4196,4199, 4205,4209, 4212,4226, 4237,4239, 4253,4957, 4959,5906, 5908,5938, 5940,5970, 5971,6002, 6003,6068, 6099,6109, 6109,6112, 6121,6155, 6157,6160, 6169,6313, 6313,6432, 6443,6448, 6459,6470, 6479,\n\t\t6576, 6592,6600, 6601,6608, 6617,6679, 6683,6741, 6750,6752, 6780,6783, 6793,6800, 6809,6912, 6916,6964, 6980,6992, 7001,7019, 7027,7040, 7042,7073, 7085,7088, 7097,7142, 7155,7204, 7223,7232, 7241,7248, 7257,7376, 7378,7380, 7400,7405, 7405,7410, 7412,7616, 7654,7676, 7679,8204, 8205,8255, 8256,8276, 8276,\n\t\t8400, 8412,8417, 8417,8421, 8432,11503, 11505,11647, 11647,11744, 11775,12330, 12335,12441, 12442,42528, 42537,42607, 42607,42612, 42621,42655, 42655,42736, 42737,43010, 43010,43014, 43014,43019, 43019,43043, 43047,43136, 43137,43188, 43204,43216, 43225,43232, 43249,43264, 43273,43302, 43309,43335, 43347,\n\t\t43392, 43395,43443, 43456,43472, 43481,43561, 43574,43587, 43587,43596, 43597,43600, 43609,43643, 43643,43696, 43696,43698, 43700,43703, 43704,43710, 43711,43713, 43713,43755, 43759,43765, 43766,44003, 44010,44012, 44013,44016, 44025,64286, 64286,65024, 65039,65056, 65062,65075, 65076,65101, 65103,\n\t\t65296, 65305,65343, 65343\n\t];\n\n    export function LexLookUpUnicodeMap(code: number, map: number[]) : bool {\n        // Perform binary search in one of the unicode range maps\n        var lo: number = 0;\n        var hi: number = map.length;\n        var mid: number;\n\n        while (lo + 1 < hi)\n        {\n            mid = lo + (hi - lo) / 2;\n            // mid has to be even to catch a range's beginning\n            mid -= mid % 2;\n            if (map[mid] <= code && code <= map[mid + 1])\n                return true;\n            if (code < map[mid])\n                hi = mid;\n            else\n                lo = mid + 2;\n        }\n        return false;\n    }\n\n    export function LexIsUnicodeDigit(code: number): bool {\n        if (codeGenTarget == CodeGenTarget.ES3) {\n            return LexLookUpUnicodeMap(code, unicodeES3IdCont);\n        } else {\n            return LexLookUpUnicodeMap(code, unicodeES5IdCont);\n        }\n    ";
var v27569 = v27570 + "}\n\n    export function LexIsUnicodeIdStart(code: number): bool {\n        if (codeGenTarget == CodeGenTarget.ES3) {\n            return LexLookUpUnicodeMap(code, unicodeES3IdStart);\n        } else {\n            return LexLookUpUnicodeMap(code, unicodeES5IdStart);\n        }\n    }\n    export function LexInitialize() {\n        initializeStaticTokens();\n        autoToken[LexCodeLPR] = staticTokens[TokenID.OpenParen];\n        autoToken[LexCodeRPR] = staticTokens[TokenID.CloseParen];\n        autoToken[LexCodeCMA] = staticTokens[TokenID.Comma];\n        autoToken[LexCodeSMC] = staticTokens[TokenID.Semicolon];\n        autoToken[LexCodeLBR] = staticTokens[TokenID.OpenBracket];\n        autoToken[LexCodeRBR] = staticTokens[TokenID.CloseBracket];\n        autoToken[LexCodeTIL] = staticTokens[TokenID.Tilde];\n        autoToken[LexCodeQUE] = staticTokens[TokenID.Question];\n        autoToken[LexCodeLC] = staticTokens[TokenID.OpenBrace];\n        autoToken[LexCodeRC] = staticTokens[TokenID.CloseBrace];\n        autoToken[LexCodeCOL] = staticTokens[TokenID.Colon];\n        LexKeywordTable = new StringHashTable();\n        for (var i in (<any>TokenID)._map) {\n            if ((<number><any>i) <= TokenID.LimKeyword) {\n                LexKeywordTable.add((<any>TokenID)._map[i].toLowerCase(), i);\n            }\n        }\n        for (var j = 0; j < LexCodeASCIIChars; j++) {\n            if (LexIsIdentifierStartChar(j)) {\n                lexIdStartTable[j] = true;\n            }\n            else {\n                lexIdStartTable[j] = false;\n            }\n        }\n    }\n\n    export function LexAdjustIndent(code, indentAmt) {\n        if ((code == LexCodeLBR) || (code == LexCodeLC) || (code == LexCodeLPR)) {\n            return indentAmt + 1;\n        }\n        else if ((code == LexCodeRBR) || (code == LexCodeRC) || (code == LexCodeRPR)) {\n            return indentAmt - 1;\n        }\n        else return indentAmt;\n    }\n\n    export function LexIsIdentifierStartChar(code): bool {\n        return (((code >= 97) && (code <= 122)) ||\n                ((code >= 65) && (code <= 90)) ||\n                (code == LexCodeDollar) ||\n                (code == LexCodeUnderscore));\n    }\n\n    export function LexIsDigit(code): bool {\n        return ((code >= 48) && (code <= 57));\n    }\n\n    export function LexIsIdentifierChar(code:number) {\n        return lexIdStartTable[code] || LexIsDigit(code);\n    }\n\n    export function LexMatchingOpen(code) {\n        if (code == LexCodeRBR)\n            return LexCodeLBR;\n        else if (code == LexCodeRC)\n            return LexCodeLC;\n        else if (code == LexCodeRPR)\n            return LexCodeLPR;\n        else return 0;\n    }\n\n    export enum NumberScanState {\n        Start,\n        InFraction,\n        InEmptyFraction,\n        InExponent\n    }\n\n    export enum LexState {\n        Start,\n        InMultilineComment,\n        InMultilineSingleQuoteString,\n        InMultilineDoubleQuoteString,\n    }\n\n    export enum LexMode {\n        Line,\n        File,\n    }\n\n    export enum CommentStyle {\n        Line,\n        Block\n    }\n\n    // Represent a piece of source code which can be read in multiple segments\n    export interface ISourceText {\n        getText(start: number, end: number): string;\n        getLength(): number;\n    }\n\n    // Implementation on top of a contiguous string\n    export class StringSourceText implements ISourceText {\n        constructor (public text: string) {\n        }\n\n        public getText(start: number, end: number): string {\n            return this.text.substring(start, end);\n        }\n\n        public getLength(): number {\n            return this.text.length;\n        }\n    }\n\n    export class SourceTextSegment implements ISourceTextSegment {\n        constructor (public segmentStart: number,\n                    public segmentEnd: number,\n                    public segment: string) {\n        }\n\n        charCodeAt(index: number): number {\n            return this.segment.charCodeAt(index - this.segmentStart);\n        }\n\n        substring(start: number, end: number): string {\n            return this.segment.substring(start - this.segmentStart, end - this.segmentStart);\n        }\n    }\n\n    export class AggerateSourceTextSegment implements ISourceTextSegment {\n\n        constructor (public seg1: SourceTextSegment, public seg2: SourceTextSegment) { }\n\n        public charCodeAt(index: number): number {\n            if (this.seg1.segmentStart <= index && index < this.seg1.segmentEnd)\n                return this.seg1.segment.charCodeAt(index - this.seg1.segmentStart);\n\n            return this.seg2.segment.charCodeAt(index - this.seg2.segmentStart);\n        }\n\n        public substring(start: number, end: number): string {\n            if (this.seg1.segmentStart <= start && end <= this.seg1.segmentEnd)\n                return this.seg1.segment.substring(start - this.seg1.segmentStart, end - this.seg1.segmentStart);\n\n            return this.seg2.segment.substring(start - this.seg2.segmentStart) + this.seg1.segment.substri";
var v27568 = v27569 + 'ng(0, end - this.seg1.segmentStart);\n        }\n    }\n\n    export interface ISourceTextSegment {\n        charCodeAt(index: number): number;\n        substring(start: number, end: number): string;\n    }\n\n    export class ScannerTextStream {\n        static emptySegment = new SourceTextSegment(0, 0, "");\n        public agg: AggerateSourceTextSegment;\n        public len: number;\n\n        constructor (public sourceText: ISourceText) {\n            this.agg = new AggerateSourceTextSegment(ScannerTextStream.emptySegment, ScannerTextStream.emptySegment);\n            this.len = this.sourceText.getLength();\n        }\n\n        public max(a: number, b: number): number {\n            return a >= b ? a : b;\n        }\n\n        public min(a: number, b: number): number {\n            return a <= b ? a : b;\n        }\n\n        public fetchSegment(start: number, end: number): ISourceTextSegment {\n            // Common case\n            if (this.agg.seg1.segmentStart <= start && end <= this.agg.seg1.segmentEnd)\n                return this.agg.seg1;\n\n            // Common overlap case\n            if (this.agg.seg2.segmentStart <= start && end <= this.agg.seg1.segmentEnd)\n                return this.agg;\n\n            // if overlapping outside of fetched segment(s), fetch a new segment\n            var prev = this.agg.seg1;\n\n            var s = prev.segmentEnd;\n            var e = max(s + 512, end); // ensure we move forward at least 512 characters or "end"\n            e = min(e, this.len);    // but don\'t go past the end of the source text\n\n            var src = this.sourceText.getText(s, e);\n            var newSeg = new SourceTextSegment(s, e, src);\n            this.agg.seg2 = prev;\n            this.agg.seg1 = newSeg;\n            return this.agg;\n        }\n\n        public charCodeAt(index: number): number {\n            return this.fetchSegment(index, index + 1).charCodeAt(index);\n        }\n\n        public substring(start: number, end: number) {\n            return this.fetchSegment(start, end).substring(start, end);\n        }\n    }\n\n    export interface IScanner {\n        startPos: number;\n        pos: number;\n        scan(): Token;\n        previousToken(): Token;\n        prevLine: number;\n        line: number;\n        col: number;\n        leftCurlyCount: number;\n        rightCurlyCount: number;\n        lastTokenLimChar(): number;\n        lastTokenHadNewline(): bool;\n        lexState: number;\n        getComments(): CommentToken[];\n        getCommentsForLine(line: number): CommentToken[];\n        resetComments(): void;\n        lineMap: number[];\n        setSourceText(newSrc: ISourceText, textMode: number): void;\n        setErrorHandler(reportError: (message: string) => void): void;\n        seenUnicodeChar: bool;\n        seenUnicodeCharInComment: bool;\n        getLookAheadToken(): Token;\n    }\n\n    export class SavedTokens implements IScanner {\n        public prevToken: Token = null;\n        public curSavedToken: SavedToken = null;\n        public prevSavedToken: SavedToken = null;\n        public currentTokenIndex: number;\n        public currentTokens: SavedToken[];\n        public tokensByLine: SavedToken[][];\n        public lexStateByLine: LexState[];\n        private prevToken: SavedToken = null;\n        public previousToken(): Token { return this.prevToken; }\n        public currentToken = 0;\n        public tokens = new SavedToken[];\n        public startPos: number;\n        public pos: number;\n        public seenUnicodeChar: bool = false;\n        seenUnicodeCharInComment: bool = false;\n\n        public close() {\n            this.currentToken = 0;\n        }\n\n        public addToken(tok: Token, scanner: IScanner) {\n            this.tokens[this.currentToken++] = new SavedToken(tok, scanner.startPos, scanner.pos);\n        }\n\n        public scan(): Token {\n            // TODO: curly count\n            this.startLine = this.line;\n            this.startPos = this.col;\n            if (this.currentTokenIndex == this.currentTokens.length) {\n                if (this.line < this.lineMap.length) {\n                    this.line++;\n                    this.col = 0;\n                    this.currentTokenIndex = 0;\n                    this.currentTokens = this.tokensByLine[this.line];\n                }\n                else {\n                    return staticTokens[TokenID.EndOfFile];\n                }\n            }\n            if (this.currentTokenIndex < this.currentTokens.length) {\n                this.prevToken = this.curSavedToken.tok;\n                this.prevSavedToken = this.curSavedToken;\n                this.curSavedToken = this.currentTokens[this.currentTokenIndex++];\n                var curToken = this.curSavedToken.tok;\n                this.pos = this.curSavedToken.limChar;\n                this.col += (this.curSavedToken.limChar - this.curSavedToken.minChar);\n                this.startPos = this.curSavedToken.minChar;\n                this.prevLine = this.line;\n                return curToken;\n            }\n            else {\n                retur';
var v27567 = v27568 + 'n staticTokens[TokenID.EndOfFile];\n            }\n        }\n        public startLine: number;\n        public prevLine = 1;\n        public line = 1;\n        public col = 0;\n        public leftCurlyCount: number;\n        public rightCurlyCount: number;\n\n        public syncToTok(offset: number): number {\n            this.line = getLineNumberFromPosition(this.lineMap, offset);\n            this.currentTokenIndex = 0;\n            var tmpCol = offset - this.lineMap[this.line];\n            while ((this.lexStateByLine[this.line] == LexState.InMultilineComment) && (this.line > 0)) {\n                this.line--;\n                tmpCol = 0;\n            }\n            var lenMin1 = this.lineMap.length - 1;\n            this.currentTokens = this.tokensByLine[this.line];\n            while ((this.currentTokens.length == 0) && (this.line < lenMin1)) {\n                this.line++;\n                this.currentTokens = this.tokensByLine[this.line];\n                tmpCol = 0;\n            }\n            if (this.line <= lenMin1) {\n                while ((this.currentTokenIndex < this.currentTokens.length) &&\n                       (tmpCol > this.currentTokens[this.currentTokenIndex].limChar)) {\n                    this.currentTokenIndex++;\n                }\n                if (this.currentTokenIndex < this.currentTokens.length) {\n                    this.col = this.currentTokens[this.currentTokenIndex].minChar;\n                    return this.col + this.lineMap[this.line];\n                }\n            }\n            return -1;\n        }\n\n        public lastTokenLimChar(): number {\n            if (this.prevSavedToken !== null) {\n                return this.prevSavedToken.limChar;\n            }\n            else {\n                return 0;\n            }\n        }\n\n        public lastTokenHadNewline(): bool {\n            return this.prevLine != this.startLine;\n        }\n\n        public lexState = LexState.Start;\n\n        public commentStack: CommentToken[] = new CommentToken[];\n\n        public pushComment(comment: CommentToken) {\n            this.commentStack.push(comment);\n        }\n\n        public getComments() {\n            var stack = this.commentStack;\n            this.commentStack = [];\n            return stack;\n        }\n\n        public getCommentsForLine(line: number) {\n            var comments: CommentToken[] = null;\n            while ((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {\n                if (comments == null) {\n                    comments = [this.commentStack.shift()];\n                }\n                else {\n                    comments = comments.concat([this.commentStack.shift()]);\n                }\n\n            }\n            return comments;\n        }\n\n        public resetComments() {\n            this.commentStack = [];\n        }\n\n        public lineMap: number[] = [];\n        public setSourceText(newSrc: ISourceText, textMode: number) {\n        }\n        public setErrorHandler(reportError: (message: string) => void ) { \n        }\n        public getLookAheadToken(): Token {\n            throw new Error("Invalid operation.");\n        }\n    }\n\n    export class Scanner implements IScanner {\n        // REVIEW: When adding new variables make sure to handle storing them in getLookAheadToken. \n        //         The method works by storing the state before scanning and restoring it later on, missing a member variable \n        //         could result in an inconsistent state.\n        public prevLine = 1;\n        public line = 1;\n        public col = 0;\n        public pos = 0;\n        public startPos = 0;\n        public startCol: number;\n        public startLine: number;\n        public src: string;\n        public len = 0;\n        public lineMap: number[] = [];\n        \n        public ch = LexEOF;\n        public lexState = LexState.Start;\n        public mode = LexMode.File;\n        public scanComments: bool = true;\n        public interveningWhitespace = false; // Was there a whitespace token between the last token and the current one?\n        private interveningWhitespacePos = 0; //  If yes, this contains the start position of the whitespace\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public commentStack: CommentToken[] = new CommentToken[];\n        public saveScan: SavedTokens = null;\n        public seenUnicodeChar: bool = false;\n        seenUnicodeCharInComment: bool = false;\n\n        private reportError: (message: string) =>void;\n\n        constructor () {\n            this.startCol = this.col;\n            this.startLine = this.line;            \n            this.lineMap[1] = 0;\n            \n            if (!LexKeywordTable) {\n                LexInitialize();\n            }            \n        }\n\n        private prevTok = staticTokens[TokenID.EndOfFile];\n        public previousToken() { return this.prevTok; }\n\n        public setSourceText(newSrc: ISourceText, textMode: number) {\n            this.mode = textMode;\n            this.scanComments = (this.mode === LexMo';
var v27566 = v27567 + "de.Line);\n            this.pos = 0;\n            this.interveningWhitespacePos = 0;\n            this.startPos = 0;\n            this.line = 1;\n            this.col = 0;\n            this.startCol = this.col;\n            this.startLine = this.line;\n            this.len = 0;\n            this.src = newSrc.getText(0, newSrc.getLength());\n            this.len = this.src.length;\n            this.lineMap = [];\n            this.lineMap[1] = 0;\n            this.commentStack = [];\n            this.leftCurlyCount = 0;\n            this.rightCurlyCount = 0;\n            this.seenUnicodeChar = false;\n            this.seenUnicodeCharInComment = false;\n        }\n\n        public setErrorHandler(reportError: (message: string) => void ) { \n            this.reportError = reportError;\n        }\n\n        public setSaveScan(savedTokens: SavedTokens) {\n            this.saveScan = savedTokens;\n        }\n\n        public setText(newSrc: string, textMode: number) {\n            this.setSourceText(new StringSourceText(newSrc), textMode);\n        }\n\n        public setScanComments(value: bool) {\n            this.scanComments = value;\n        }\n\n        public getLexState(): number {\n            return this.lexState;\n        }\n\n        public tokenStart() {\n            this.startPos = this.pos;\n            this.startLine = this.line;\n            this.startCol = this.col;\n            this.interveningWhitespace = false;\n        }\n\n        public peekChar(): number {\n            if (this.pos < this.len) {\n                return this.src.charCodeAt(this.pos);\n            }\n            else {\n                return LexEOF;\n            }\n        }\n\n        public peekCharAt(index: number): number {\n            if (index < this.len) {\n                return this.src.charCodeAt(index);\n            }\n            else {\n                return LexEOF;\n            }\n        }\n\n        public IsHexDigit(c: number) {\n            return ((c >= LexCode_0) && (c <= LexCode_9)) || ((c >= LexCode_A) && (c <= LexCode_F)) ||\n                ((c >= LexCode_a) && (c <= LexCode_f));\n        }\n\n        public IsOctalDigit(c: number) {\n            return ((c >= LexCode_0) && (c <= LexCode_7)) ||\n                ((c >= LexCode_a) && (c <= LexCode_f));\n        }\n\n        public scanHexDigits(): Token {\n            var atLeastOneDigit = false;\n            for (; ;) {\n                if (this.IsHexDigit(this.ch)) {\n                    this.nextChar();\n                    atLeastOneDigit = true;\n                }\n                else {\n                    if (atLeastOneDigit) {\n                        return new NumberLiteralToken(parseInt(this.src.substring(this.startPos, this.pos)));\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            }\n\n        }\n\n        public scanOctalDigits(): Token {\n            var atLeastOneDigit = false;\n            for (; ;) {\n                if (this.IsOctalDigit(this.ch)) {\n                    this.nextChar();\n                    atLeastOneDigit = true;\n                }\n                else {\n                    if (atLeastOneDigit) {\n                        return new NumberLiteralToken(parseInt(this.src.substring(this.startPos, this.pos)));\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            }\n\n        }\n\n        public scanDecimalNumber(state: number): Token {\n            var atLeastOneDigit = false;\n            var svPos = this.pos;\n            var svCol = this.col;\n            for (; ;) {\n                if (LexIsDigit(this.ch)) {\n                    atLeastOneDigit = true;\n                    if (this.ch != LexCode_0 && state == NumberScanState.InEmptyFraction) {\n                        state = NumberScanState.InFraction;\n                    }\n                    this.nextChar();\n                }\n                else if (this.ch == LexCodeDOT) {\n                    if (state == NumberScanState.Start) {\n                        // DecimalDigit* .\n                        this.nextChar();\n                        state = NumberScanState.InEmptyFraction;\n                    }\n                    else {\n                        // dot not part of number\n                        if (atLeastOneDigit) {\n                            // DecimalDigit* . DecimalDigit+\n                            return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)), state == NumberScanState.InEmptyFraction);\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                } else if ((this.ch == LexCode_e) || (this.ch == LexCode_E)) {\n                    if (state == NumberScanState.Start) {\n                        if (atLeastOneDigit) {\n                            // DecimalDigit+ (.";
var v27565 = v27566 + " DecimalDigit*) [eE] [+-]DecimalDigit+\n                            atLeastOneDigit = false;\n                            this.nextChar();\n                            state = NumberScanState.InExponent;\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                    else if (state == NumberScanState.InFraction || state == NumberScanState.InEmptyFraction) {\n                        // DecimalDigit+ . DecimalDigit* [eE]\n                        this.nextChar();\n                        state = NumberScanState.InExponent;\n                        atLeastOneDigit = false;\n                    }\n                    else {\n                        // DecimalDigit+ . DecimalDigit* [eE] DecimalDigit+\n                        if (atLeastOneDigit) {\n                            return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                }\n                else if ((this.ch == LexCodePLS) || (this.ch == LexCodeMIN)) {\n                    if (state == NumberScanState.InExponent) {\n                        if (!atLeastOneDigit) {\n                            this.nextChar();\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                    else if (state == NumberScanState.InEmptyFraction || state == NumberScanState.InFraction) {\n                        // This case will not generate bad javascript if we miss the fractional part, but we just want to be consistent with the dot case\n                        return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)), state == NumberScanState.InEmptyFraction);\n                    }\n                    else {\n                        if (!atLeastOneDigit) {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                        else {\n                            return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                        }\n                    }\n                }\n                else {\n                    if (!atLeastOneDigit) {\n                        this.pos = svPos;\n                        this.col = svCol;\n                        return null;\n                    }\n                    else {\n                        return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)), state == NumberScanState.InEmptyFraction);\n                    }\n                }\n            }\n        }\n\n        // 0 [xX] hexDigits\n        // 0 octalDigits\n        // 0 [89] decimalDigits\n        // decimalDigits? fraction? exponent?\n\n        public scanNumber(): Token {\n            if (this.peekChar() == LexCode_0) {\n                switch (this.peekCharAt(this.pos + 1)) {\n                    case LexCode_x:\n                    case LexCode_X:\n                        // Hex\n                        this.advanceChar(2);\n                        return this.scanHexDigits();\n                    case LexCode_8:\n                    case LexCode_9:\n                    case LexCodeDOT:\n                        return this.scanDecimalNumber(NumberScanState.Start);\n                    default:\n                        // Octal\n                        return this.scanOctalDigits();\n                }\n            }\n            else {\n                return this.scanDecimalNumber(NumberScanState.Start);\n            }\n        }\n\n        public scanFraction(): Token {\n            return this.scanDecimalNumber(NumberScanState.InFraction);\n        }\n\n        public newLine() {\n            this.col = 0;\n            if (this.mode == LexMode.File) {\n                this.line++;\n                this.lineMap[this.line] = this.pos + 1;\n            }\n        }\n\n        public finishMultilineComment(): bool {\n            var ch2: number;\n            this.lexState = LexState.InMultilineComment;\n            while (this.pos < this.len) {\n                if (this.ch == LexCodeMUL) {\n                    ch2 = this.peekCharAt(this.pos + 1);\n                    if (ch2 == LexCodeSLH) {\n                        this.advanceChar(2);\n                        if (this.mode == LexMode.File) {\n                            this.tokenStart();\n                        }\n                        this.lexState = LexState.Start;\n                        return true;\n                    }\n        ";
var v27564 = v27565 + "        }\n                else if (this.ch == LexCodeNWL) {\n                    this.newLine();\n                    if (this.mode == LexMode.Line) {\n                        this.nextChar();\n                        return false;\n                    }\n                } \n                else if (this.ch >= LexCodeASCIIChars) { \n                    this.seenUnicodeCharInComment = true;\n                }\n                this.nextChar();\n            }\n            return false;\n        }\n\n        public pushComment(comment: CommentToken) {\n            this.commentStack.push(comment);\n        }\n\n        public getComments() {\n            var stack = this.commentStack;\n            this.commentStack = [];\n            return stack;\n        }\n\n        public getCommentsForLine(line: number) {\n            var comments: CommentToken[] = null;\n            while ((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {\n                if (comments == null) {\n                    comments = [this.commentStack.shift()];\n                }\n                else {\n                    comments = comments.concat([this.commentStack.shift()]);\n                }\n\n            }\n            return comments;\n        }\n\n        public resetComments() {\n            this.commentStack = [];\n        }\n\n        public endsLine(c: number) {\n            return (c == LexCodeNWL) || (c == LexCodeRET) || (c == LexCodeLS) || (c == LexCodePS);\n        }\n\n        public finishSinglelineComment() {\n            while (this.pos < this.len) {\n                if (this.endsLine(this.ch))\n                    break;\n                if (this.ch >= LexCodeASCIIChars) { \n                    this.seenUnicodeCharInComment = true;\n                }\n                this.nextChar();\n            }\n\n            if (this.mode == LexMode.File) {\n                this.tokenStart();\n            }\n        }\n\n        public tokenText(): string {\n            return this.src.substring(this.startPos, this.pos);\n        }\n\n        public findClosingSLH() {\n            var index = this.pos;\n            var ch2 = this.src.charCodeAt(index);\n            var prevCh = 0;\n            var liveEsc = false;\n            while (!this.endsLine(ch2) && (index < this.len)) {\n                if ((ch2 == LexCodeSLH) && (!liveEsc)) {\n                    return index;\n                }\n                prevCh = ch2;\n                index++;\n                if (liveEsc) {\n                    liveEsc = false;\n                }\n                else {\n                    liveEsc = (prevCh == LexCodeBSL);\n                }\n\n                ch2 = this.src.charCodeAt(index);\n            }\n            return -1;\n        }\n\n        public speculateRegex(): Token {\n            if (noRegexTable[this.prevTok.tokenId] != undefined) {\n                return null;\n            }\n            var svPos = this.pos;\n            var svCol = this.col;\n            // first char is '/' and has been skipped\n            var index = this.findClosingSLH();\n            if (index > 0) {\n                // found closing /\n                var pattern = this.src.substring(svPos, index);\n                var flags = \"\";\n                this.pos = index + 1;\n                this.ch = this.peekChar();\n                var flagsStart = this.pos;\n                // TODO: check for duplicate flags\n                while ((this.ch == LexCode_i) || (this.ch == LexCode_g) || (this.ch == LexCode_m)) {\n                    this.nextChar();\n                }\n                if ((this.pos - flagsStart) > 3) {\n                    return null;\n                }\n                else {\n                    flags = this.src.substring(flagsStart, this.pos);\n                }\n                var regex = undefined;\n                try {\n                    regex = new RegExp(pattern, flags);\n                }\n                catch (regexException) {\n                }\n                if (regex) {\n                    // no line boundary in regex string\n                    this.col = svCol + (this.pos - this.startPos);\n                    return new RegularExpressionLiteralToken(regex);\n                }\n            }\n            this.pos = svPos;\n            this.col = svCol;\n            return null;\n        }\n\n        public lastTokenHadNewline() {\n            return this.prevLine != this.startLine;\n        }\n\n        public lastTokenLimChar() {\n            return this.interveningWhitespace ? this.interveningWhitespacePos : this.startPos;\n        }\n\n        // use only when known not to skip line terminators\n        public advanceChar(amt: number) {\n            this.pos += amt;\n            this.col += amt;\n            this.ch = this.peekChar();\n        }\n\n        public nextChar() {\n            this.pos++;\n            this.col++;\n            this.ch = this.peekChar();\n        }\n\n        public getLookAheadToken(): Token {\n            // REVIEW: This method is only used for parsing varargs in lambda expressions. If this functionality is neede";
var v27563 = v27564 + 'd for more common cases, \n            //         it needs to be designed. \n            //         Look-ahead token needs to be integrated in the scanner design to allow for an efficient lookup.\n\n            // Store the scanner state\n            var prevLine = this.prevLine;\n            var line = this.line;\n            var col = this.col;\n            var pos = this.pos;\n            var startPos = this.startPos;\n            var startCol = this.startCol;\n            var startLine = this.startLine;\n            var ch = this.ch;\n            var prevTok = this.prevTok;\n            var lexState = this.lexState;\n            var interveningWhitespace = this.interveningWhitespace;\n            var interveningWhitespacePos = this.interveningWhitespacePos;\n            var leftCurlyCount = this.leftCurlyCount;\n            var rightCurlyCount = this.rightCurlyCount;\n            var seenUnicodeChar = this.seenUnicodeChar;\n            var seenUnicodeCharInComment = this.seenUnicodeCharInComment;\n            var commentStackLength = this.commentStack.length;\n\n            var lookAheadToken = this.scan();\n\n            // Restore state\n            this.prevLine = prevLine;\n            this.line = line;\n            this.col = col;\n            this.pos = pos;\n            this.startPos = startPos;\n            this.startCol = startCol;\n            this.startLine = startLine;\n            this.ch = ch;\n            this.prevTok = prevTok;\n            this.lexState = lexState;\n            this.interveningWhitespace = interveningWhitespace;\n            this.interveningWhitespacePos = interveningWhitespacePos;\n            this.leftCurlyCount = leftCurlyCount;\n            this.rightCurlyCount = rightCurlyCount;\n            this.seenUnicodeChar = seenUnicodeChar;\n            this.seenUnicodeCharInComment = seenUnicodeCharInComment;\n            this.commentStack.length = commentStackLength;\n\n            return lookAheadToken;\n        }\n\n        public scanInLine(): Token {\n            if ((this.lexState == LexState.InMultilineComment) && (this.scanComments)) {\n                this.ch = this.peekChar();\n                var commentLine = this.line;\n                this.finishMultilineComment();\n                if (this.startPos < this.pos) {\n                    var commentText = this.src.substring(this.startPos, this.pos);\n                    this.tokenStart();\n                    return new CommentToken(TokenID.Comment, commentText,/*isBlock*/true, this.startPos, commentLine,/*endsLine*/true);\n                }\n                else {\n                    return staticTokens[TokenID.EndOfFile];\n                }\n            } \n            else if (this.lexState == LexState.InMultilineSingleQuoteString && this.pos < this.len) { \n                this.ch = LexCodeAPO;\n                this.lexState = LexState.Start;\n                return this.scanStringConstant();\n            }\n            else if (this.lexState == LexState.InMultilineDoubleQuoteString && this.pos < this.len) { \n                this.ch = LexCodeQUO;\n                this.lexState = LexState.Start;\n                return this.scanStringConstant();\n            }\n            this.prevLine = this.line;\n            var prevTok = this.innerScan();\n\n            // Ingore white spaces\n            if (prevTok.tokenId != TokenID.Whitespace) {\n                this.prevTok = prevTok;\n            }\n            return prevTok;\n        }\n\n        public scan(): Token {\n            this.prevLine = this.line;\n            this.prevTok = this.innerScan();\n            if (this.saveScan) {\n                this.saveScan.addToken(this.prevTok, this);\n            }\n            return this.prevTok;\n        }\n\n        private isValidUnicodeIdentifierChar(): bool {\n            var valid = LexIsUnicodeIdStart(this.ch) || LexIsUnicodeDigit(this.ch);\n            this.seenUnicodeChar = this.seenUnicodeChar || valid;\n            return valid;\n        }\n\n        private scanStringConstant(): Token {\n            var endCode = this.ch;\n            \n            // Skip the first quote\n            this.nextChar();\n            \n            // Accumulate with escape characters\n            scanStringConstantLoop:\n            for (;;) {\n                switch (this.ch) {\n                    case LexEOF:\n                        // Unexpected end of file\n                        this.reportScannerError("Unterminated string constant");\n                        break scanStringConstantLoop;\n\n                    case LexCodeLS:\n                    case LexCodePS:\n                        this.seenUnicodeChar = true;\n                    // Intentional fall through\n                    case LexCodeRET:\n                    case LexCodeNWL:\n                        this.reportScannerError("Unterminated string constant");\n                        break scanStringConstantLoop;\n\n                    case LexCodeAPO:\n                    case LexCodeQUO:\n                        if (this.ch == endCode) {\n                            // Foun';
var v27562 = v27563 + 'd string terminator. Skip past end code.\n                            this.nextChar();\n                            break scanStringConstantLoop;\n                        }\n                        break;\n\n                    case LexCodeBSL:\n                        // Consume the current slash\n                        this.nextChar();\n\n                        switch (this.ch) {\n                            case LexCodeAPO:\n                            case LexCodeQUO:\n                            case LexCodeBSL:\n                                // Valid escape sequences\n                                this.nextChar();\n                                continue scanStringConstantLoop;\n\n                            case LexCodeLS:\n                            case LexCodePS:\n                                this.seenUnicodeChar = true;\n                            // Intentional fall through\n                            case LexCodeRET:\n                            case LexCodeNWL:\n                                // Skip /r in a /r/n sequence\n                                if (this.ch == LexCodeRET && this.peekCharAt(this.pos + 1) == LexCodeNWL) {\n                                    this.nextChar();\n                                }\n\n                                // Consume the new line char\n                                this.nextChar();\n\n                                // Record new line\n                                this.newLine();\n\n                                if (this.mode == LexMode.Line) {\n                                    this.lexState = endCode == LexCodeAPO ? LexState.InMultilineSingleQuoteString : LexState.InMultilineDoubleQuoteString;\n                                    break scanStringConstantLoop;\n                                }\n                                break;\n\n                            case LexCode_x:\n                            case LexCode_u:\n                                var expectedHexDigits = this.ch == LexCode_x ? 2 : 4;\n                                this.nextChar();\n                                for (var i = 0; i < expectedHexDigits; i++) {\n                                    if (this.IsHexDigit(this.ch)) {\n                                        this.nextChar();\n                                    }\n                                    else {\n                                        this.reportScannerError("Invalid Unicode escape sequence");\n                                        break;\n                                    }\n                                }\n                                continue scanStringConstantLoop;\n                        }\n                        break;\n                }\n\n                // Record seeing a Unicode char\n                if (this.ch >= LexCodeASCIIChars) {\n                    this.seenUnicodeChar = true;\n                }\n\n                this.nextChar();\n            }\n\n            return new StringLiteralToken(this.src.substring(this.startPos, this.pos));\n        }\n\n        private scanIdentifier(): Token {\n            var hasEscape = false;\n            var isFirstChar = (this.ch == LexCodeBSL);\n            var hasUnicode: any = false;\n\n            for (; ;) {\n                while (lexIdStartTable[this.ch] || LexIsDigit(this.ch) || \n                      (this.ch >= LexCodeASCIIChars && this.isValidUnicodeIdentifierChar())) {\n                    this.nextChar();\n                }\n                if (this.ch == LexCodeBSL) {\n                    this.nextChar();\n                    if (this.ch == LexCode_u) {\n                        // 4 hex digits\n                        this.nextChar();\n                        for (var h = 0; h < 4 ; h++) {\n                            if (this.IsHexDigit(this.ch)) {\n                                this.nextChar();\n                            }\n                            else {\n                                this.reportScannerError("Invalid Unicode escape sequence");\n                                return staticTokens[TokenID.Error];\n                            }\n                        }\n                        var hexChar = parseInt(this.src.substring(this.pos - 4, this.pos), 16);\n\n                        // Verify is valid ID char \n                        if (lexIdStartTable[hexChar] || (!isFirstChar && LexIsDigit(hexChar)) ||\n                            (hexChar >= LexCodeASCIIChars && (LexIsUnicodeIdStart(hexChar) || (!isFirstChar && LexIsUnicodeDigit(hexChar))))) {\n                        }\n                        else { \n                            this.reportScannerError("Invalid identifier character");\n                            return staticTokens[TokenID.Error];\n                        }\n\n                        hasEscape = true;\n                        isFirstChar = false;\n                        continue;\n                    }\n\n                    this.reportScannerError("Invalid Unicode escape sequence");\n                    return staticTokens[TokenID.Error];\n                }\n        ';
var v27561 = v27562 + '        break;\n            }\n\n            var id: number;\n            var text = this.src.substring(this.startPos, this.pos);\n            if (!hasEscape && (id = LexKeywordTable.lookup(text)) != null) {\n                return staticTokens[id];\n            }\n            else {\n                return new IdentifierToken(text, hasEscape);\n            }\n        }\n\n        public innerScan(): Token {\n            var rtok;\n            this.tokenStart();\n            this.ch = this.peekChar();\n\n            start: while (this.pos < this.len) {\n                 if (lexIdStartTable[this.ch] || this.ch == LexCodeBSL || (this.ch >= LexCodeASCIIChars && LexIsUnicodeIdStart(this.ch))) {\n                    // identifier or keyword\n                    return this.scanIdentifier();\n                }\n                else if (this.ch == LexCodeSpace) {\n                    if (!this.interveningWhitespace) {\n                        this.interveningWhitespacePos = this.pos;\n                    }\n                    do {\n                        this.nextChar();\n                    } while (this.ch == LexCodeSpace);\n                    if (this.mode == LexMode.Line) {\n                        var whitespaceText = this.src.substring(this.startPos, this.pos);\n                        return new WhitespaceToken(TokenID.Whitespace, whitespaceText);\n                    }\n                    else {\n                        this.tokenStart();\n                        this.interveningWhitespace = true;\n                    }\n                }\n                else if (this.ch == LexCodeSLH) {\n                    this.nextChar();\n                    var commentText;\n                    if (this.ch == LexCodeSLH) {\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos - 1;\n                        }\n                        var commentStartPos = this.pos - 1;\n                        var commentStartLine = this.line;\n                        this.finishSinglelineComment();\n                        var commentText = this.src.substring(commentStartPos, this.pos);\n                        var commentToken = new CommentToken(TokenID.Comment, commentText,/*isBlock*/false, commentStartPos, commentStartLine,/*endsLine*/false);\n                        if (this.scanComments) {\n                            // respect scanner contract: when returning a token, startPos is the start position of the token\n                            this.startPos = commentStartPos;\n                            return commentToken;\n                        }\n                        else {\n                            this.pushComment(commentToken);\n                        }\n\n                        this.interveningWhitespace = true;\n                    }\n                    else if (this.ch == LexCodeMUL) {\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos - 1;\n                        }\n                        var commentStartPos = this.pos - 1;\n                        var commentStartLine = this.line;\n                        this.nextChar();  // Skip the "*"\n                        this.finishMultilineComment();\n                        var commentText = this.src.substring(commentStartPos, this.pos);\n                        var endsLine = this.endsLine(this.peekChar());\n                        var commentToken = new CommentToken(TokenID.Comment, commentText,/*isBlock*/true, commentStartPos, commentStartLine, endsLine);\n                        if (this.scanComments) {\n                            // respect scanner contract: when returning a token, startPos is the start position of the token\n                            this.startPos = commentStartPos;\n                            return commentToken;\n                        }\n                        else {\n                            this.pushComment(commentToken);\n                        }\n                        this.interveningWhitespace = true;\n                    }\n                    else {\n                        var regexTok = this.speculateRegex();\n                        if (regexTok) {\n                            return regexTok;\n                        }\n                        else {\n                            if (this.peekCharAt(this.pos) == LexCodeEQ) {\n                                this.nextChar();\n                                return staticTokens[TokenID.SlashEquals];\n                            }\n                            else {\n                                return staticTokens[TokenID.Slash];\n                            }\n                        }\n                    }\n                }\n                else if (this.ch == LexCodeSMC) {\n                    this.nextChar();\n                    return staticTokens[TokenID.Semicolon];\n                }\n                else if ((this.ch == LexCodeAPO) || (this.ch == LexCodeQUO)) {\n                    return this.scanSt';
var v27560 = v27561 + "ringConstant();\n                }\n                else if (autoToken[this.ch]) {\n                    var atok = autoToken[this.ch];\n                    if (atok.tokenId == TokenID.OpenBrace) {\n                        this.leftCurlyCount++;\n                    }\n                    else if (atok.tokenId == TokenID.CloseBrace) {\n                        this.rightCurlyCount++;\n                    }\n                    this.nextChar();\n                    return atok;\n                }\n                else if ((this.ch >= LexCode_0) && (this.ch <= LexCode_9)) {\n                    rtok = this.scanNumber();\n                    if (rtok) {\n                        return rtok;\n                    }\n                    else {\n                        this.nextChar();\n                        return staticTokens[TokenID.Error];\n                    }\n                }\n                else switch (this.ch) {\n                    // TAB\n                    case LexCodeTAB:\n                    case LexCodeVTAB:\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos;\n                        }\n                        if (this.mode == LexMode.Line) {\n                            do {\n                                this.nextChar();\n                            } while ((this.ch == LexCodeSpace) || (this.ch == 9));\n                            var wsText = this.src.substring(this.startPos, this.pos);\n                            return new WhitespaceToken(TokenID.Whitespace, wsText);\n                        }\n                        else {\n                            this.interveningWhitespace = true;\n                        }\n                     // Newlines and BOM\n                    case 0xFF: // UTF16 SEQUENCE\n                    case 0xFE:\n                    case 0xEF:    // UTF8 SEQUENCE\n                    case 0xBB:\n                    case 0xBF:\n                    case LexCodeLS:\n                    case LexCodePS:\n                    case LexCodeNWL:\n                    case LexCodeRET:\n                        if (this.ch == LexCodeNWL) {\n                            this.newLine();\n                            if (this.mode == LexMode.Line) {\n                                return staticTokens[TokenID.EndOfFile];\n                            }\n                        }\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos;\n                        }\n                        this.nextChar();\n                        this.tokenStart();\n                        this.interveningWhitespace = true;\n                        break;\n                    case LexCodeDOT: {\n                        if (this.peekCharAt(this.pos + 1) == LexCodeDOT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeDOT) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.DotDotDot];\n                            }\n                            else {\n                                this.nextChar();\n                                return staticTokens[TokenID.Dot];\n                            }\n                        }\n                        else {\n                            this.nextChar();\n                            rtok = this.scanFraction();\n                            if (rtok) {\n                                return rtok;\n                            }\n                            else {\n                                return staticTokens[TokenID.Dot];\n                            }\n                        }\n                        // break;\n                    }\n                    case LexCodeEQ:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.EqualsEqualsEquals];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.EqualsEquals];\n                            }\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeGT) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.EqualsGreaterThan];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Equals];\n                        }\n                    // break;\n                    case LexCodeBNG:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTo";
var v27559 = v27560 + "kens[TokenID.ExclamationEqualsEquals];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.ExclamationEquals];\n                            }\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Exclamation];\n                        }\n                    // break;\n                    case LexCodePLS:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.PlusEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodePLS) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.PlusPlus];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Plus];\n                        }\n                    // break;\n                    case LexCodeMIN:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.MinusEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeMIN) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.MinusMinus];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Minus];\n                        }\n                    // break;\n                    case LexCodeMUL:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AsteriskEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Asterisk];\n                        }\n                    // break;\n                    case LexCodePCT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.PercentEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Percent];\n                        }\n                    // break;\n                    case LexCodeLT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeLT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.LessThanLessThanEquals];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.LessThanLessThan];\n                            }\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.LessThanEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.LessThan];\n                        }\n                    //  break;\n                    case LexCodeGT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeGT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.GreaterThanGreaterThanEquals];\n                            }\n                            else if (this.peekCharAt(this.pos + 2) == LexCodeGT) {\n                                if (this.peekCharAt(this.pos + 3) == LexCodeEQ) {\n                                    this.advanceChar(4);\n                                    return staticTokens[TokenID.GreaterThanGreaterThanGreaterThanEquals];\n                                }\n                                else {\n                                    this.advanceChar(3);\n                                    return staticTokens[TokenID.GreaterThanGreaterThanGreaterThan];\n                                }\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.GreaterThanGreaterThan];\n                            }\n                        }\n                        ";
var v27558 = v27559 + 'else if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.GreaterThanEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.GreaterThan];\n                        }\n                    // break;\n                    case LexCodeXOR:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.CaretEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Caret];\n                        }\n                    //  break;\n                    case LexCodeBAR:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.BarEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeBAR) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.BarBar];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Bar];\n                        }\n                    //  break;\n                    case LexCodeAMP:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AmpersandEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeAMP) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AmpersandAmpersand];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.And];\n                        }\n                    //  break;\n                    default:\n                        // Report error\n                        this.reportScannerError("Invalid character");\n                        this.nextChar();\n\n                        continue start;\n                }\n            }\n            return staticTokens[TokenID.EndOfFile];\n        }\n\n        private reportScannerError(message: string) { \n            if (this.reportError) { \n                this.reportError(message);\n            }\n        }\n    }\n\n    // Reseverved words only apply to Identifiers, not IdentifierNames\n    export function convertTokToIDName(tok: Token): bool {\n        return convertTokToIDBase(tok, true, false);\n    }\n\n    export function convertTokToID(tok: Token, strictMode: bool): bool {\n        return convertTokToIDBase(tok, false, strictMode);\n    }\n\n    function convertTokToIDBase(tok: Token, identifierName: bool, strictMode: bool): bool {\n        if (tok.tokenId <= TokenID.LimKeyword) {\n            var tokInfo = lookupToken(tok.tokenId);\n            if (tokInfo != undefined) {\n                var resFlags = Reservation.Javascript | Reservation.JavascriptFuture;\n                if (strictMode) {\n                    resFlags |= Reservation.JavascriptFutureStrict;\n                }\n                if (identifierName || !hasFlag(tokInfo.reservation, resFlags)) {\n                    return true;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n\n    // Return the (1-based) line number from a character offset using the provided linemap.\n    export function getLineNumberFromPosition(lineMap: number[], position: number): number {\n        if (position === -1)\n            return 0;\n\n        // Binary search\n        var min = 0;\n        var max = lineMap.length - 1;\n        while (min < max) {\n            var med = (min + max) >> 1;\n            if (position < lineMap[med]) {\n                max = med - 1;\n            }\n            else if (position < lineMap[med + 1]) {\n                min = max = med; // found it\n            }\n            else {\n                min = med + 1;\n            }\n        }\n\n        return min;\n    }\n\n    /// Return the [line, column] data for a given offset and a lineMap.\n    /// Note that the returned line is 1-based, while the column is 0-based.\n    export function getSourceLineColFromMap(lineCol: ILineCol, minChar: number, lineMap: number[]): void {\n        var line = getLineNumberFromPosition(lineMap, minChar);\n\n        if (line > 0) {\n            lineCol.line = line;\n            lineCol.col = (minChar - lineMap[line]);\n        }\n    }\n\n    // Return the [line, column] (both 1 based) corresponding to a given position in a given script.\n    export funct';
var v27557 = v27558 + 'ion getLineColumnFromPosition(script: TypeScript.Script, position: number): ILineCol {\n        var result = { line: -1, col: -1 };\n        getSourceLineColFromMap(result, position, script.locationInfo.lineMap);\n        if (result.col >= 0) {\n            result.col++;   // Make it 1-based\n        }\n        return result;\n    }\n\n    //\n    // Return the position (offset) corresponding to a given [line, column] (both 1-based) in a given script.\n    //\n    export function getPositionFromLineColumn(script: TypeScript.Script, line: number, column: number): number {\n        return script.locationInfo.lineMap[line] + (column - 1);\n    }\n    \n    // Return true if the token is a primitive type\n    export function isPrimitiveTypeToken(token: Token) {\n        switch (token.tokenId) {\n            case TokenID.Any:\n            case TokenID.Bool:\n            case TokenID.Number:\n            case TokenID.String:\n                return true;\n        }\n        return false;\n    }\n\n    // Return true if the token is a primitive type\n    export function isModifier(token: Token) {\n        switch (token.tokenId) {\n            case TokenID.Public:\n            case TokenID.Private:\n            case TokenID.Static:\n                return true;\n        }\n        return false;\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export class AssignScopeContext {\n        constructor (public scopeChain: ScopeChain,\n                     public typeFlow: TypeFlow,\n                     public modDeclChain: ModuleDeclaration[]) {\n        }\n    }\n\n    export function pushAssignScope(scope: SymbolScope,\n        context: AssignScopeContext,\n        type: Type,\n        classType: Type,\n        fnc: FuncDecl) {\n\n        var chain = new ScopeChain(null, context.scopeChain, scope);\n        chain.thisType = type;\n        chain.classType = classType;\n        chain.fnc = fnc;\n        context.scopeChain = chain;\n    }\n\n    export function popAssignScope(context: AssignScopeContext) {\n        context.scopeChain = context.scopeChain.previous;\n    }\n\n    export function instanceCompare(a: Symbol, b: Symbol) {\n        if (((a == null) || (!a.isInstanceProperty()))) {\n            return b;\n        }\n        else {\n            return a;\n        }\n    }\n\n    export function instanceFilterStop(s: Symbol) {\n        return s.isInstanceProperty();\n    }\n\n    export class ScopeSearchFilter {\n\n        constructor (public select: (a: Symbol, b: Symbol) =>Symbol,\n                            public stop: (s: Symbol) =>bool) { }\n\n        public result: Symbol = null;\n\n        public reset() {\n            this.result = null;\n        }\n\n        public update(b: Symbol): bool {\n            this.result = this.select(this.result, b);\n            if (this.result) {\n                return this.stop(this.result);\n            }\n            else {\n                return false;\n            }\n        }\n    }\n\n    export var instanceFilter = new ScopeSearchFilter(instanceCompare, instanceFilterStop);\n\n    export function preAssignModuleScopes(ast: AST, context: AssignScopeContext) {\n        var moduleDecl = <ModuleDeclaration>ast;\n        var memberScope: SymbolTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (moduleDecl.name && moduleDecl.mod) {\n            moduleDecl.name.sym = moduleDecl.mod.symbol;\n        }\n\n        var mod = moduleDecl.mod;\n\n        // We\'re likely here because of error recovery\n        if (!mod) {\n            return;\n        }\n\n        memberScope = new SymbolTableScope(mod.members, mod.ambientMembers, mod.enclosedTypes, mod.ambientEnclosedTypes, mod.symbol);\n        mod.memberScope = memberScope;\n        context.modDeclChain.push(moduleDecl);\n        context.typeFlow.checker.currentModDecl = moduleDecl;\n        aggScope = new SymbolAggregateScope(mod.symbol);\n        aggScope.addParentScope(memberScope);\n        aggScope.addParentScope(context.scopeChain.scope);\n        pushAssignScope(aggScope, context, null, null, null);\n        mod.containedScope = aggScope;\n        if (mod.symbol) {\n            context.typeFlow.addLocalsFromScope(mod.containedScope, mod.symbol, moduleDecl.vars, mod.members.privateMembers, true);\n        }\n    }\n\n    export function preAssignClassScopes(ast: AST, context: AssignScopeContext) {\n        var classDecl = <InterfaceDeclaration>ast;\n        var memberScope: Symb';
var v27556 = v27557 + "olTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (classDecl.name && classDecl.type) {\n            classDecl.name.sym = classDecl.type.symbol;\n        }\n\n        var classType = ast.type;\n\n        if (classType) {\n            var classSym = classType.symbol;\n            memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(classType);\n\n            aggScope = new SymbolAggregateScope(classType.symbol);\n            aggScope.addParentScope(memberScope);\n            aggScope.addParentScope(context.scopeChain.scope);\n\n            classType.containedScope = aggScope;\n            classType.memberScope = memberScope;\n\n            var instanceType = classType.instanceType;\n            memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(instanceType);\n            instanceType.memberScope = memberScope;\n\n            aggScope = new SymbolAggregateScope(instanceType.symbol);\n            aggScope.addParentScope(context.scopeChain.scope);\n\n            pushAssignScope(aggScope, context, instanceType, classType, null);\n            instanceType.containedScope = aggScope;\n        }\n        else {\n            ast.type = context.typeFlow.anyType;\n        }\n    }\n\n    export function preAssignInterfaceScopes(ast: AST, context: AssignScopeContext) {\n        var interfaceDecl = <InterfaceDeclaration>ast;\n        var memberScope: SymbolTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (interfaceDecl.name && interfaceDecl.type) {\n            interfaceDecl.name.sym = interfaceDecl.type.symbol;\n        }\n\n        var interfaceType = ast.type;\n        memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(interfaceType);\n        interfaceType.memberScope = memberScope;\n        aggScope = new SymbolAggregateScope(interfaceType.symbol);\n        aggScope.addParentScope(memberScope);\n        aggScope.addParentScope(context.scopeChain.scope);\n        pushAssignScope(aggScope, context, null, null, null);\n        interfaceType.containedScope = aggScope;\n    }\n\n    export function preAssignWithScopes(ast: AST, context: AssignScopeContext) {\n        var withStmt = <WithStatement>ast;\n        var withType = withStmt.type;\n\n        var members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n        var ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n        var withType = new Type();\n        var withSymbol = new WithSymbol(withStmt.minChar, context.typeFlow.checker.locationInfo.unitIndex, withType);\n        withType.members = members;\n        withType.ambientMembers = ambientMembers;\n        withType.symbol = withSymbol;\n        withType.setHasImplementation();\n        withStmt.type = withType;\n\n        var withScope = new TypeScript.SymbolScopeBuilder(withType.members, withType.ambientMembers, null, null, context.scopeChain.scope, withType.symbol);\n\n        pushAssignScope(withScope, context, null, null, null);\n        withType.containedScope = withScope;\n    }\n\n    export function preAssignFuncDeclScopes(ast: AST, context: AssignScopeContext) {\n        var funcDecl = <FuncDecl>ast;\n\n        var container: Symbol = null;\n        var localContainer: Symbol = null;\n        if (funcDecl.type) {\n            localContainer = ast.type.symbol;\n        }\n\n        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n        var isInnerStatic = isStatic && context.scopeChain.fnc != null;\n        // for inner static functions, use the parent's member scope, so local vars cannot be captured\n        var parentScope = isInnerStatic ? context.scopeChain.fnc.type.memberScope : context.scopeChain.scope;\n\n        // if this is not a method, but enclosed by class, use constructor as\n        // the enclosing scope\n        // REVIEW: Some twisted logic here - this needs to be cleaned up once old classes are removed\n        //  - if it's a new class, always use the contained scope, since we initialize the constructor scope below\n        if (context.scopeChain.thisType &&\n            (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod))) {\n            var instType = context.scopeChain.thisType;\n\n            if (!(instType.typeFlags & TypeFlags.IsClass) && !hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n                if (!funcDecl.isMethod() || isStatic) {\n                    parentScope = instType.constructorScope;\n                }\n                else {\n                    // use constructor scope if a method as well\n                    parentScope = instType.containedScope;\n                }\n            }\n            else {\n                if (context.scopeChain.previous.scope.container &&\n                    context.scopeChain.previous.scope.container.declAST &&\n                    context.scopeChain.previous.scope.container.declAST.nodeType == NodeType.FuncDecl &&\n                    (<FuncDecl>context.scopeChain.previous.sco";
var v27555 = v27556 + "pe.container.declAST).isConstructor) {\n\n                        // if the parent is the class constructor, use the constructor scope\n                    parentScope = instType.constructorScope;\n                }\n                else if (isStatic && context.scopeChain.classType) {\n                    parentScope = context.scopeChain.classType.containedScope;\n                }\n                else {\n                    // else, use the contained scope\n                    parentScope = instType.containedScope;\n                }\n            }\n            container = instType.symbol;\n        }\n        else if (funcDecl.isConstructor && context.scopeChain.thisType) {\n            // sets the container to the class type's symbol (which is shared by the instance type)\n            container = context.scopeChain.thisType.symbol;\n        }\n\n        if (funcDecl.type == null || hasFlag(funcDecl.type.symbol.flags, SymbolFlags.TypeSetDuringScopeAssignment)) {\n            if (context.scopeChain.fnc && context.scopeChain.fnc.type) {\n                container = context.scopeChain.fnc.type.symbol;\n            }\n\n            var funcScope = null;\n            var outerFnc: FuncDecl = context.scopeChain.fnc;\n            var nameText = funcDecl.name ? funcDecl.name.actualText : null;\n            var fgSym: TypeSymbol = null;\n\n            if (isStatic) {\n                // In the case of function-nested statics, no member list will have bee initialized for the function, so we need\n                // to copy it over.  We don't set this by default because having a non-null member list will throw off assignment\n                // compatibility tests\n                if (outerFnc.type.members == null && container.getType().memberScope) {\n                    outerFnc.type.members = (<SymbolScopeBuilder>(<TypeSymbol>container).type.memberScope).valueMembers;\n                }\n                funcScope = context.scopeChain.fnc.type.memberScope;\n                outerFnc.innerStaticFuncs[outerFnc.innerStaticFuncs.length] = funcDecl;\n            }\n            else {\n                funcScope = context.scopeChain.scope;\n            }\n\n            // REVIEW: We don't search for another sym for accessors to prevent us from\n            // accidentally coalescing function signatures with the same name (E.g., a function\n            // 'f' the outer scope and a setter 'f' in an object literal within that scope)\n            if (nameText && nameText != \"__missing\" && !funcDecl.isAccessor()) {\n                if (isStatic) {\n                    fgSym = funcScope.findLocal(nameText, false, false);\n                }\n                else {\n                    // REVIEW: This logic should be symmetric with preCollectClassTypes\n                    fgSym = funcScope.findLocal(nameText, false, false);\n                }\n            }\n\n            context.typeFlow.checker.createFunctionSignature(funcDecl, container,\n                                                            funcScope, fgSym, fgSym == null);\n\n            // it's a getter or setter for a class property                     \n            if (!funcDecl.accessorSymbol && \n                (funcDecl.fncFlags & FncFlags.ClassMethod) &&\n                container && \n                ((!fgSym || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || \n                    (fgSym && fgSym.isAccessor())) \n            {\n                funcDecl.accessorSymbol = context.typeFlow.checker.createAccessorSymbol(funcDecl, fgSym, container.getType(), (funcDecl.isMethod() && isStatic), true, funcScope, container);\n            }\n\n            funcDecl.type.symbol.flags |= SymbolFlags.TypeSetDuringScopeAssignment;\n        }\n\n        // Set the symbol for functions and their overloads\n        if (funcDecl.name && funcDecl.type) {\n            funcDecl.name.sym = funcDecl.type.symbol;\n        }\n\n        // Keep track of the original scope type, because target typing might override\n        // the \"type\" member. We need the original \"Scope type\" for completion list, etc.\n        funcDecl.scopeType = funcDecl.type;\n\n        // Overloads have no scope, so bail here\n        if (funcDecl.isOverload) {\n            return;\n        }\n\n        var funcTable = new StringHashTable();\n        var funcMembers = new ScopedMembers(new DualStringHashTable(funcTable, new StringHashTable()));\n        var ambientFuncTable = new StringHashTable();\n        var ambientFuncMembers = new ScopedMembers(new DualStringHashTable(ambientFuncTable, new StringHashTable()));\n        var funcStaticTable = new StringHashTable();\n        var funcStaticMembers = new ScopedMembers(new DualStringHashTable(funcStaticTable, new StringHashTable()));\n        var ambientFuncStaticTable = new StringHashTable();\n        var ambientFuncStaticMembers = new ScopedMembers(new DualStringHashTable(ambientFuncStaticTable, new StringHashTable()));\n\n        // REVIEW: Is it a problem that this is being set twice for properties and constructors?\n        funcDe";
var v27554 = v27555 + "cl.unitIndex = context.typeFlow.checker.locationInfo.unitIndex;\n\n        var locals = new SymbolScopeBuilder(funcMembers, ambientFuncMembers, null, null, parentScope, localContainer);\n        var statics = new SymbolScopeBuilder(funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null);\n\n        if (funcDecl.isConstructor && context.scopeChain.thisType) {\n            context.scopeChain.thisType.constructorScope = locals;\n        }\n\n        // basically, there are two problems\n        // - Above, for new classes, we were overwriting the constructor scope with the containing scope.  This caused constructor params to be\n        // in scope everywhere\n        // - Below, we're setting the contained scope table to the same table we were overwriting the constructor scope with, which we need to\n        // fish lambda params, etc, out (see funcTable below)\n        //\n        // A good first approach to solving this would be to change addLocalsFromScope to take a scope instead of a table, and add to the\n        // constructor scope as appropriate\n\n        funcDecl.symbols = funcTable;\n\n        if (!funcDecl.isSpecialFn()) {\n            var group = funcDecl.type;\n            var signature = funcDecl.signature;\n\n            if (!funcDecl.isConstructor) {\n                group.containedScope = locals;\n                locals.container = group.symbol;\n\n                group.memberScope = statics;\n                statics.container = group.symbol;\n            }\n            funcDecl.enclosingFnc = context.scopeChain.fnc;\n            group.enclosingType = isStatic ? context.scopeChain.classType : context.scopeChain.thisType;\n            // for mapping when type checking\n            var fgSym = <TypeSymbol>ast.type.symbol;\n            if (((funcDecl.fncFlags & FncFlags.Signature) == FncFlags.None) && funcDecl.vars) {\n                context.typeFlow.addLocalsFromScope(locals, fgSym, funcDecl.vars,\n                                                    funcTable, false);\n                context.typeFlow.addLocalsFromScope(statics, fgSym, funcDecl.statics,\n                                                    funcStaticTable, false);\n            }\n            if (signature.parameters) {\n                var len = signature.parameters.length;\n                for (var i = 0; i < len; i++) {\n                    var paramSym: ParameterSymbol = signature.parameters[i];\n                    context.typeFlow.checker.resolveTypeLink(locals,\n                                                                paramSym.parameter.typeLink, true);\n                }\n            }\n            context.typeFlow.checker.resolveTypeLink(locals, signature.returnType,\n                                                        funcDecl.isSignature());\n        }\n\n        if (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n            var thisType = (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) ? context.scopeChain.thisType : null;\n            pushAssignScope(locals, context, thisType, null, funcDecl);\n        }\n\n        if (funcDecl.name && hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression)) {\n            // If the function is an expression, the name will not be visible in the enclosing scope.\n            // Add the function symbol under its name to the local scope to allow for recursive calls.\n            if (funcDecl.name.sym) {\n                funcTable.add(funcDecl.name.actualText, funcDecl.name.sym);\n            }\n        }\n    }\n\n    export function preAssignCatchScopes(ast: AST, context: AssignScopeContext) {\n        var catchBlock = <Catch>ast;\n        if (catchBlock.param) {\n            var catchTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable())); // REVIEW: Should we be allocating a public table instead of a private one?\n            var catchLocals = new SymbolScopeBuilder(catchTable, null, null, null, context.scopeChain.scope,\n                                                   context.scopeChain.scope.container);\n            catchBlock.containedScope = catchLocals;\n            pushAssignScope(catchLocals, context, context.scopeChain.thisType, context.scopeChain.classType, context.scopeChain.fnc);\n        }\n    }\n\n    export function preAssignScopes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context:AssignScopeContext = walker.state;\n        var go = true;\n\n        if (ast) {\n            if (ast.nodeType == NodeType.List) {\n                var list = <ASTList>ast;\n                list.enclosingScope = context.scopeChain.scope;\n            }\n            else if (ast.nodeType == NodeType.ModuleDeclaration) {\n                preAssignModuleScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.ClassDeclaration) {\n                preAssignClassScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n                preAssignInterfaceScopes(";
var v27553 = v27554 + 'ast, context);\n            }\n            else if (ast.nodeType == NodeType.With) {\n                preAssignWithScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n                preAssignFuncDeclScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.Catch) {\n                preAssignCatchScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.TypeRef) {\n                go = false;\n            }\n        }\n        walker.options.goChildren = go;\n        return ast;\n    }\n\n    export function postAssignScopes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context:AssignScopeContext = walker.state;\n        var go = true;\n        if (ast) {\n            if (ast.nodeType == NodeType.ModuleDeclaration) {\n                var prevModDecl = <ModuleDeclaration>ast;\n\n                popAssignScope(context);\n\n                context.modDeclChain.pop();\n                if (context.modDeclChain.length >= 1) {\n                    context.typeFlow.checker.currentModDecl = context.modDeclChain[context.modDeclChain.length - 1];\n                }\n            }\n            else if (ast.nodeType == NodeType.ClassDeclaration) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.With) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n                var funcDecl = <FuncDecl>ast;\n                if ((!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) && !funcDecl.isOverload) {\n                    popAssignScope(context);\n                }\n            }\n            else if (ast.nodeType == NodeType.Catch) {\n                var catchBlock = <Catch>ast;\n                if (catchBlock.param) {\n                    popAssignScope(context);\n                }\n            }\n            else {\n                go = false;\n            }\n        }\n        walker.options.goChildren = go;\n        return ast;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class TypeCollectionContext {\n        public script: Script = null;\n\n        constructor (public scopeChain: ScopeChain, public checker: TypeChecker) {\n        }\n    }\n\n    export class MemberScopeContext {\n        public type: Type = null;\n        public ast: AST = null;\n        public scope: SymbolScope;\n        public options = new AstWalkOptions();\n\n        constructor (public flow: TypeFlow, public pos: number, public matchFlag: ASTFlags) {\n        }\n    }\n\n    export class EnclosingScopeContext {\n\n        public scopeGetter: () => SymbolScope = null;\n        public objectLiteralScopeGetter: () => SymbolScope = null;\n        public scopeStartAST: AST = null;\n        public skipNextFuncDeclForClass = false;\n        public deepestModuleDecl: ModuleDeclaration = null;\n        public enclosingClassDecl: TypeDeclaration = null;\n        public enclosingObjectLit: UnaryExpression = null;\n        public publicsOnly = true;\n        public useFullAst = false;\n        private scriptFragment: Script;\n\n        constructor (public logger: ILogger,\n                    public script: Script,\n                    public text: ISourceText,\n                    public pos: number,\n                    public isMemberCompletion: bool) {\n        }\n\n        public getScope(): SymbolScope {\n            return this.scopeGetter();\n        }\n\n        public getObjectLiteralScope(): SymbolScope {\n            return this.objectLiteralScopeGetter();\n        }\n\n        public getScopeAST() {\n            return this.scopeStartAST;\n        }\n\n        public getScopePosition() {\n            return this.scopeStartAST.minChar;\n        }\n\n        public getScriptFragmentStartAST(): AST {\n            return this.scopeStartAST;\n        }\n\n        public getScriptFragmentPosition(): number {\n            return this.getScriptFragmentStartAST().minChar;\n        }\n\n        public getScriptFragment(): Script {\n            if (this.scriptFragment == null) {\n                var ast = this.getScriptFragmentStartAST();\n                var minChar = ast.minChar;\n                var limChar = (this.isMemberCompletion ? this.pos : this.po';
var v27552 = v27553 + "s + 1);\n                this.scriptFragment = TypeScript.quickParse(this.logger, ast, this.text, minChar, limChar, null/*errorCapture*/).Script;\n            }\n            return this.scriptFragment;\n        }\n    }\n\n    export function preFindMemberScope(ast: AST, parent: AST, walker: IAstWalker) {\n        var memScope: MemberScopeContext = walker.state;\n        if (hasFlag(ast.flags, memScope.matchFlag) && ((memScope.pos < 0) || (memScope.pos == ast.limChar))) {\n            memScope.ast = ast;\n            if ((ast.type == null) && (memScope.pos >= 0)) {\n                memScope.flow.inScopeTypeCheck(ast, memScope.scope);\n            }\n            memScope.type = ast.type;\n            memScope.options.stopWalk();\n        }\n        return ast;\n    }\n\n    export function pushTypeCollectionScope(container: Symbol,\n        valueMembers: ScopedMembers,\n        ambientValueMembers: ScopedMembers,\n        enclosedTypes: ScopedMembers,\n        ambientEnclosedTypes: ScopedMembers,\n        context: TypeCollectionContext,\n        thisType: Type,\n        classType: Type,\n        moduleDecl: ModuleDeclaration) {\n        var builder = new SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container);\n        var chain: ScopeChain = new ScopeChain(container, context.scopeChain, builder);\n        chain.thisType = thisType;\n        chain.classType = classType;\n        chain.moduleDecl = moduleDecl;\n        context.scopeChain = chain;\n    }\n\n    export function popTypeCollectionScope(context: TypeCollectionContext) {\n        context.scopeChain = context.scopeChain.previous;\n    }\n\n    export function preFindEnclosingScope(ast: AST, parent: AST, walker: IAstWalker) {\n        var context: EnclosingScopeContext = walker.state;\n        var minChar = ast.minChar;\n        var limChar = ast.limChar;\n\n        // Account for the fact completion list may be called at the end of a file which\n        // is has not been fully re-parsed yet.\n        if (ast.nodeType == NodeType.Script && context.pos > limChar)\n            limChar = context.pos;\n\n        if ((minChar <= context.pos) &&\n            (limChar >= context.pos)) {\n            switch (ast.nodeType) {\n                case NodeType.Script:\n                    var script = <Script>ast;\n                    context.scopeGetter = function () {\n                        return script.bod === null ? null : script.bod.enclosingScope;\n                    };\n                    context.scopeStartAST = script;\n                    break;\n\n                case NodeType.ClassDeclaration:\n                    context.scopeGetter = function () {\n                        return (ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    context.enclosingClassDecl = <TypeDeclaration>ast;\n                    break;\n\n                case NodeType.ObjectLit:\n                    var objectLit = <UnaryExpression>ast;\n                    // Only consider target-typed object literals\n                    if (objectLit.targetType) {\n                        context.scopeGetter = function () {\n                            return objectLit.targetType.containedScope;\n                        };\n                        context.objectLiteralScopeGetter = function () {\n                            return objectLit.targetType.memberScope;\n                        }\n                        context.enclosingObjectLit = objectLit;\n                    }\n                    break;\n\n                case NodeType.ModuleDeclaration:\n                    context.deepestModuleDecl = <ModuleDeclaration>ast;\n                    context.scopeGetter = function () {\n                        return ast.type === null ? null : ast.type.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    break;\n\n                case NodeType.InterfaceDeclaration:\n                    context.scopeGetter = function () {\n                        return (ast.type === null) ? null : ast.type.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    break;\n\n                case NodeType.FuncDecl: {\n                    var funcDecl = <FuncDecl>ast;\n                    if (context.skipNextFuncDeclForClass) {\n                        context.skipNextFuncDeclForClass = false;\n                    }\n                    else {\n                        context.scopeGetter = function () {\n                            // The scope of a class constructor is hidden somewhere we don't expect :-S\n                            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n                                if (ast.type && ast.type.enclosingType) {\n                                    return ast.type.enclosingType.constructorScope;\n                              ";
var v27551 = v27552 + '  }\n                            }\n\n                            if (funcDecl.scopeType) {\n                                return funcDecl.scopeType.containedScope;\n                            }\n\n                            if (funcDecl.type) {\n                                return funcDecl.type.containedScope;\n                            }\n                            return null;\n                        };\n                        context.scopeStartAST = ast;\n                    }\n                }\n                    break;\n            }\n            walker.options.goChildren = true;\n        }\n        else {\n            walker.options.goChildren = false;\n        }\n        return ast;\n    }\n\n    //\n    // Find the enclosing scope context from a position inside a script AST.\n    // The "scopeStartAST" of the returned scope is always valid.\n    // Return "null" if the enclosing scope can\'t be found.\n    //\n    export function findEnclosingScopeAt(logger: ILogger, script: Script, text: ISourceText, pos: number, isMemberCompletion: bool): EnclosingScopeContext {\n        var context = new EnclosingScopeContext(logger, script, text, pos, isMemberCompletion);\n\n        TypeScript.getAstWalkerFactory().walk(script, preFindEnclosingScope, null, null, context);\n\n        if (context.scopeStartAST === null)\n            return null;\n        return context;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class Signature {\n        public hasVariableArgList = false;\n        public returnType: TypeLink;\n        public parameters: ParameterSymbol[] = null;\n        public declAST: FuncDecl = null;\n        public typeCheckStatus = TypeCheckStatus.NotStarted;\n        public nonOptionalParameterCount = 0;\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Signature {\n            var result = new Signature();\n            if (this.hasVariableArgList) {\n                result.hasVariableArgList = true;\n            }\n            result.returnType = new TypeLink();\n            if (this.returnType.type) {\n                result.returnType.type =\n                    this.returnType.type.specializeType(pattern, replacement, checker, false);\n            }\n            else {\n                result.returnType.type = checker.anyType;\n            }\n\n            if (this.parameters) {\n                result.parameters = [];\n                for (var i = 0, len = this.parameters.length; i < len; i++) {\n                    var oldSym:ParameterSymbol = this.parameters[i];\n                    var paramDef = new ValueLocation();\n                    var paramSym = new ParameterSymbol(oldSym.name, oldSym.location,\n                                                     checker.locationInfo.unitIndex,\n                                                     paramDef);\n\n                    paramSym.declAST = this.declAST;\n                    paramDef.symbol = paramSym;\n                    paramDef.typeLink = new TypeLink();\n                    result.parameters[i] = paramSym;\n                    var oldType = oldSym.getType();\n                    if (oldType) {\n                        paramDef.typeLink.type = oldType.specializeType(pattern, replacement, checker, false);\n                        paramSym.declAST.type = paramDef.typeLink.type;\n                    }\n                    else {\n                        paramDef.typeLink.type = checker.anyType;\n                    }\n                }\n            }\n            result.nonOptionalParameterCount = this.nonOptionalParameterCount;\n            result.declAST = this.declAST;\n\n            return result;\n        }\n\n        public toString() {\n            return this.toStringHelper(false, false, null);\n        }\n\n        public toStringHelper(shortform: bool, brackets: bool, scope: SymbolScope) {\n            return this.toStringHelperEx(shortform, brackets, scope).toString();\n        }\n\n        public toStringHelperEx(shortform: bool, brackets: bool, scope: SymbolScope, prefix? : string = "") : MemberName {\n            var builder = new MemberNameArray();\n            if (brackets) {\n                builder.prefix =  prefix + "[";\n            }\n            else {\n                builder.prefix = prefix + "(";\n            }\n\n            var paramLen = this.parameters.length;\n            var len = this.hasVariableArgList ? paramLen - 1 : par';
var v27550 = v27551 + 'amLen;\n            for (var i = 0; i < len; i++) {\n                builder.add(MemberName.create(this.parameters[i].name + (this.parameters[i].isOptional() ? "?" : "") + ": "));\n                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));\n                if (i < paramLen - 1) {\n                    builder.add(MemberName.create(", "));\n                }\n            }\n\n            if (this.hasVariableArgList) {\n                builder.add(MemberName.create("..." + this.parameters[i].name + ": "));\n                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));\n            }\n\n            if (shortform) {\n                if (brackets) {\n                    builder.add(MemberName.create("] => "));\n                }\n                else {\n                    builder.add(MemberName.create(") => "));\n                }\n            }\n            else {\n                if (brackets) {\n                    builder.add(MemberName.create("]: "));\n                }\n                else {\n                    builder.add(MemberName.create("): "));\n                }\n            }\n\n            if (this.returnType.type) {\n                 builder.add(this.returnType.type.getScopedTypeNameEx(scope));\n            }\n            else {\n                builder.add(MemberName.create("any"));\n            }\n            return builder;\n        }\n    }\n\n    export class SignatureGroup {\n        public signatures: Signature[] = [];\n        public hasImplementation = true;\n        public definitionSignature: Signature = null;\n        public hasBeenTypechecked = false;\n        public flags: SignatureFlags = SignatureFlags.None;\n        public addSignature(signature: Signature) {\n            if (this.signatures == null) {\n                this.signatures = new Signature[];\n            }\n            this.signatures[this.signatures.length] = signature;\n            \n            // REVIEW: duplicates should be found within createFunctionSignature,\n            // so we won\'t check for them here\n            if (signature.declAST &&\n                !signature.declAST.isOverload &&\n                !signature.declAST.isSignature() && \n                !hasFlag(signature.declAST.fncFlags, FncFlags.Ambient) &&\n                hasFlag(signature.declAST.fncFlags, FncFlags.Definition)) {\n                this.definitionSignature = signature;\n            }\n        }\n\n        public toString() { return this.signatures.toString(); }\n        public toStrings(prefix: string, shortform: bool, scope: SymbolScope) {\n            var result : MemberName[] = [];  \n            var len = this.signatures.length;\n            if (len > 1) {\n                shortform = false;\n            }\n            for (var i = 0; i < len; i++) {\n                // the definition signature shouldn\'t be printed if there are overloads\n                if (len > 1 && this.signatures[i] == this.definitionSignature) {\n                    continue;\n                }\n                if (this.flags & SignatureFlags.IsIndexer) {\n                    result.push(this.signatures[i].toStringHelperEx(shortform, true, scope));\n                }\n                else {\n                    result.push(this.signatures[i].toStringHelperEx(shortform, false, scope, prefix));\n                }\n            }\n            \n            return result;\n        }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): SignatureGroup {\n            var result = new SignatureGroup();\n            if (this.signatures) {\n                for (var i = 0, len = this.signatures.length; i < len; i++) {\n                    result.addSignature(this.signatures[i].specializeType(pattern, replacement, checker));\n                }\n            }\n            return result;\n        }\n\n        // verifies that signatures are\n        //  - unique within a given group\n        //  - compatible with the declaration signature\n        public verifySignatures(checker: TypeChecker) {\n\n            var len = 0;\n            \n            // TODO: verify no signature pair with identical parameters\n            if (this.signatures && ((len = this.signatures.length) > 0)) {\n                \n                for (var i = 0; i < len; i++) {\n                    \n                    for (var j = i + 1; j < len; j++) {\n                        // next check for equivalence between overloads - no two can be exactly the same                     \n                        if (this.signatures[i].declAST && this.signatures[j].declAST &&\n                            (!hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Definition) && !hasFlag(this.signatures[j].declAST.fncFlags, FncFlags.Definition)) &&\n                            checker.signaturesAreIdentical(this.signatures[i], this.signatures[j])) {\n                            checker.errorReporter.simpleError(this.signatures[i].declAST, (this.signatures[i].declAST && this.signatures[i].declAST.name) ? "Signature for \'" + this.signatures';
var v27549 = v27550 + '[i].declAST.name.actualText + "\' is duplicated" :"Signature is duplicated");\n                        }\n                    }\n                    \n                    // finally, ensure that the definition is assignable to each signature\n                    if (this.definitionSignature) {\n                        if (!checker.signatureIsAssignableToTarget(this.definitionSignature, this.signatures[i])) {\n                            checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload signature is not compatible with function definition");\n                        }\n                    }\n                }\n            }\n        }\n\n        public typeCheck(checker: TypeChecker, ast: AST, hasConstruct:bool) {\n            \n            if (this.hasBeenTypechecked) {\n                return;\n            }\n            \n            // set here to prevent us from recursively invoking typeCheck again\n            this.hasBeenTypechecked = true;\n            \n            var len = 0;\n            \n            if (this.signatures && ((len = this.signatures.length) > 0)) {\n                \n                // first, typecheck each signature\n                for (var i = 0; i < len; i++) {\n\n                    if (!hasConstruct && !this.definitionSignature && this.signatures[i].declAST && this.signatures[i].declAST.isOverload && !hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Ambient)) {\n                        checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload declaration lacks definition");\n                    }\n\n                    // If we\'re typechecking a constructor via one of its overloads, ensure that the outer class is typechecked, since we need to validate its inheritance properties\n                    // to properly check that \'super\' is being used correctly\n                    if (this.signatures[i].declAST && this.signatures[i].declAST.isConstructor && this.signatures[i].declAST.classDecl && this.signatures[i].declAST.classDecl.type.symbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                        checker.typeFlow.typeCheck(this.signatures[i].declAST.classDecl);\n                    }\n\n                    checker.typeFlow.typeCheck(this.signatures[i].declAST);\n                }\n\n                this.verifySignatures(checker);\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n///<reference path=\'..\\harness\\external\\json2.ts\' />\n\nmodule TypeScript {\n    export class SourceMapPosition {\n        public sourceLine: number;\n        public sourceColumn: number;\n        public emittedLine: number;\n        public emittedColumn: number;\n    }\n\n    export class SourceMapping {\n        public start = new SourceMapPosition();\n        public end = new SourceMapPosition();\n        public nameIndex: number = -1;\n        public childMappings: SourceMapping[] = [];\n    }\n\n    export class SourceMapper {\n        static MapFileExtension = ".map";\n        \n        public sourceMappings: SourceMapping[] = [];\n        public currentMappings: SourceMapping[][] = [];\n\n        public names: string[] = [];\n        public currentNameIndex: number[] = [];\n\n        public jsFileName: string;\n        public tsFileName: string;\n\n        constructor(tsFileName: string, jsFileName: string, public jsFile: ITextWriter, public sourceMapOut: ITextWriter, public errorReporter: ErrorReporter) {\n            this.currentMappings.push(this.sourceMappings);\n\n            jsFileName = switchToForwardSlashes(jsFileName);\n            this.jsFileName = TypeScript.getPrettyName(jsFileName, false, true);\n\n            var removalIndex = jsFileName.lastIndexOf(this.jsFileName);\n            var fixedPath = jsFileName.substring(0, removalIndex);\n\n            this.tsFileName = TypeScript.getRelativePathToFixedPath(fixedPath, tsFileName);\n        }\n        \n        // Generate source mapping\n        static EmitSourceMapping(allSourceMappers: SourceMapper[]) {\n            // At this point we know that there is at least one source mapper present.\n            // If there are multiple source mappers, all will correspond to same map file but different sources\n\n            // Output map file name into the js file\n            var sourceMapper = allSourceMappers[0];\n            sourceMapper.jsFile.WriteLine("//@ sourceMappingURL=" + sourceMapper.jsFileName + SourceMapper.MapFileExtension);\n\n  ';
var v27548 = v27549 + '          // Now output map file\n            var sourceMapOut = sourceMapper.sourceMapOut;\n            var mappingsString = "";\n            var tsFiles: string[] = [];\n\n            var prevEmittedColumn = 0;\n            var prevEmittedLine = 0;\n            var prevSourceColumn = 0;\n            var prevSourceLine = 0;\n            var prevSourceIndex = 0;\n            var prevNameIndex = 0;\n            var namesList: string[] = [];\n            var namesCount = 0;\n            var emitComma = false;\n\n            var recordedPosition: SourceMapPosition = null;\n            for (var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {\n                sourceMapper = allSourceMappers[sourceMapperIndex];\n\n                // If there are any mappings generated\n                var currentSourceIndex = tsFiles.length;\n                tsFiles.push(sourceMapper.tsFileName);\n\n                // Join namelist\n                if (sourceMapper.names.length > 0) {\n                    namesList.push.apply(namesList, sourceMapper.names);\n                }\n\n                var recordSourceMapping = (mappedPosition: SourceMapPosition, nameIndex: number) => {\n                    if (recordedPosition != null &&\n                        recordedPosition.emittedColumn == mappedPosition.emittedColumn &&\n                        recordedPosition.emittedLine == mappedPosition.emittedLine) {\n                        // This position is already recorded\n                        return;\n                    }\n\n                    // Record this position\n                    if (prevEmittedLine !== mappedPosition.emittedLine) {\n                        while (prevEmittedLine < mappedPosition.emittedLine) {\n                            prevEmittedColumn = 0;\n                            mappingsString = mappingsString + ";";\n                            prevEmittedLine++;\n                        }\n                        emitComma = false;\n                    }\n                    else if (emitComma) {\n                        mappingsString = mappingsString + ",";\n                    }\n\n                    // 1. Relative Column\n                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);\n                    prevEmittedColumn = mappedPosition.emittedColumn;\n\n                    // 2. Relative sourceIndex \n                    mappingsString = mappingsString + Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex);\n                    prevSourceIndex = currentSourceIndex;\n\n                    // 3. Relative sourceLine 0 based\n                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);\n                    prevSourceLine = mappedPosition.sourceLine - 1;\n\n                    // 4. Relative sourceColumn 0 based \n                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);\n                    prevSourceColumn = mappedPosition.sourceColumn;\n\n                    // 5. Relative namePosition 0 based\n                    if (nameIndex >= 0) {\n                        mappingsString = mappingsString + Base64VLQFormat.encode(namesCount + nameIndex - prevNameIndex);\n                        prevNameIndex = namesCount + nameIndex;\n                    }\n\n                    emitComma = true;\n                    recordedPosition = mappedPosition;\n                }\n\n                // Record starting spans\n                var recordSourceMappingSiblings = (sourceMappings: SourceMapping[]) => {\n                    for (var i = 0; i < sourceMappings.length; i++) {\n                        var sourceMapping = sourceMappings[i];\n                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);\n                        recordSourceMappingSiblings(sourceMapping.childMappings);\n                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);\n                    }\n                }\n\n                recordSourceMappingSiblings(sourceMapper.sourceMappings, -1);\n                namesCount = namesCount + sourceMapper.names.length;\n            }\n\n            // Write the actual map file\n            if (mappingsString != "") {\n                sourceMapOut.Write(JSON2.stringify({\n                    version: 3,\n                    file: sourceMapper.jsFileName,\n                    sources: tsFiles,\n                    names: namesList,\n                    mappings: mappingsString\n                }));\n            }\n\n            // Done, close the file\n            try {\n                // Closing files could result in exceptions, report them if they occur\n                sourceMapOut.Close();\n            } catch (ex) {\n                sourceMapper.errorReporter.emitterError(null, ex.message);\n            }\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under';
var v27547 = v27548 + ' the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    // private members are private to the scope\n    // public members are public to the scope\n    export class ScopedMembers {\n\n        public allMembers: IHashTable;\n        public publicMembers: IHashTable;\n        public privateMembers: IHashTable;\n\n        constructor (public dualMembers: DualStringHashTable) { \n            this.allMembers = this.dualMembers;\n            this.publicMembers = this.dualMembers.primaryTable;\n            this.privateMembers = this.dualMembers.secondaryTable;\n        }\n\n        // add a public member\n        public addPublicMember(key: string, data) { return this.dualMembers.primaryTable.add(key, data); }\n\n        // add a private member \n        public addPrivateMember(key: string, data) { return this.dualMembers.secondaryTable.add(key, data); }\n    }\n\n    export enum SymbolKind {\n        None,\n        Type,\n        Field,\n        Parameter,\n        Variable,\n    }\n\n    export class SymbolScope {\n        constructor (public container: Symbol) { }\n        public printLabel() { return "base"; }\n        public getAllSymbolNames(members: bool): string[]{\n            return ["please", "implement", "in", "derived", "classes"];\n        }\n        public getAllTypeSymbolNames(members: bool): string[]{\n            return ["please", "implement", "in", "derived", "classes"];\n        }\n        public getAllValueSymbolNames(members: bool): string[]{\n            return ["please", "implement", "in", "derived", "classes"];\n        }\n        // advanced search using a filter\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // find in this immediate scope\n        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // find in value namespace \n        public find(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // find symbol that supplies an implementation\n        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // restrict the search to ambient values\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        public print(outfile: ITextWriter) {\n            if (this.container) {\n                outfile.WriteLine(this.printLabel() + " scope with container: " + this.container.name + "...");\n            }\n            else {\n                outfile.WriteLine(this.printLabel() + " scope...");\n            }\n        }\n\n        public enter(container: Symbol, ast: AST, symbol: Symbol, errorReporter: ErrorReporter, publicOnly: bool,\n            typespace: bool, ambient: bool): void {\n            throw new Error("please implement in derived class");\n        }\n\n        public getTable(): IHashTable {\n            throw new Error("please implement in derived class");\n        }\n    }\n\n    function symbolCanBeUsed(sym: Symbol, publicOnly) {\n        return publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                            (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                          : true;\n    }\n\n    export class SymbolAggregateScope extends SymbolScope {\n        public printLabel() { return "agg"; }\n        public valueCache: IHashTable = null;\n        public valueImplCache: IHashTable = null;\n        public valueAmbientCache: IHashTable = null;\n        public typeCache: IHashTable = null;\n        public typeImplCache: IHashTable = null;\n        public typeAmbientCache: IHashTable = null;\n        public parents: SymbolScope[] = null;\n        public container: Symbol;\n\n        constructor (container: Symbol) {\n            super(container);\n            this.container = container;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var sym = this.parents[i].search(filter, name, publicOnly, typespace);\n                    if (sym) {\n                        if (filter.update(sym)) {\n                            return sym;\n                        }\n                    }\n                }\n            }\n            return filter.result;\n        }\n\n        public getAllSymbolNames(members';
var v27546 = v27547 + ": bool): string[]{\n            var result: string[] = [];\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllSymbolNames(members);\n                    if (parentResult) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public getAllTypeSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllTypeSymbolNames(members);\n                    if (parentResult) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public getAllValueSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllValueSymbolNames(members);\n                    if (parentResult) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    this.parents[i].print(outfile);\n                }\n            }\n        }\n\n        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var implCache = this.valueImplCache;\n\n            if (typespace) {\n                implCache = this.typeImplCache;\n            }\n            if (implCache &&\n                ((sym = implCache.lookup(name)) != null) &&\n                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                                        (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                                        : true)) {\n                return sym;\n            }\n            if (this.parents) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym = this.parents[i].findImplementation(name, publicOnly, typespace);\n                    if (sym) {\n                        break;\n                    }\n                }\n            }\n            if (implCache) {\n                if (typespace) {\n                    this.typeImplCache = new StringHashTable();\n                    implCache = this.typeImplCache;\n                }\n                else {\n                    this.valueImplCache = new StringHashTable();\n                    implCache = this.valueImplCache;\n                }\n            }\n            implCache.add(name, sym);\n            return sym;\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var cache = this.valueCache;\n\n            if (typespace) {\n                cache = this.typeCache;\n            }\n            if (cache &&\n                ((sym = cache.lookup(name)) != null) &&\n                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                                        (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                                        : true)) {\n                return sym;\n            }\n            if (this.parents) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym = this.parents[i].find(name, publicOnly, typespace);\n                    if (sym) {\n                        break;\n                    }\n                }\n            }\n            if (cache == null) {\n                if (typespace) {\n                    this.typeCache = new StringHashTable();\n                    cache = this.typeCache;\n                }\n                else {\n                    this.valueCache = new StringHashTable();\n                    cache = this.valueCache;\n                }\n            }\n            cache.add(name, sym);\n            return sym;\n        }\n\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var cache = this.valueAmbientCache;\n            if (typespace) {\n                cache = this.typeAmbientCache;\n            }\n            if (cache && ((sym = cache.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parents) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym =";
var v27545 = v27546 + ' this.parents[i].findAmbient(name, publicOnly, typespace);\n                    if (sym) {\n                        break;\n                    }\n                }\n            }\n            if (cache == null) {\n                if (typespace) {\n                    this.typeAmbientCache = new StringHashTable();\n                    cache = this.typeAmbientCache;\n                }\n                else {\n                    this.valueAmbientCache = new StringHashTable();\n                    cache = this.valueAmbientCache;\n                }\n            }\n            cache.add(name, sym);\n            return sym;\n        }\n\n        public addParentScope(parent: SymbolScope): void {\n            if (this.parents == null) {\n                this.parents = new SymbolScope[];\n            }\n            this.parents[this.parents.length] = parent;\n        }\n    }\n\n    export class SymbolTableScope extends SymbolScope {\n        public container: Symbol;\n\n        constructor(public valueMembers: ScopedMembers,\n                            public ambientValueMembers: ScopedMembers,\n                            public enclosedTypes: ScopedMembers,\n                            public ambientEnclosedTypes: ScopedMembers,\n                            container: Symbol)\n        {\n            super(container);\n            this.container = container;\n        }\n\n        public printLabel() { return "table"; }\n\n        public getAllSymbolNames(members: bool): string[]{\n            var result = this.getAllTypeSymbolNames(members);\n\n            return result.concat(this.getAllValueSymbolNames(members));\n        }\n\n        public getAllTypeSymbolNames(members: bool): string[]{\n            var result = [];\n            if (this.ambientEnclosedTypes) {\n                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());\n            }\n            if (this.enclosedTypes) {\n                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());\n            }\n            return result;\n        }\n\n        public getAllValueSymbolNames(members: bool): string[]{\n            var result = [];\n            if (this.ambientValueMembers) {\n                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());\n            }\n            if (this.valueMembers) {\n                result = result.concat(this.valueMembers.allMembers.getAllKeys());\n            }\n            return result;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            var sym = this.find(name, publicOnly, typespace);\n            filter.update(sym);\n            return filter.result;\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var table: IHashTable = null;\n            var ambientTable: IHashTable = null;\n\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            else {\n                table = (this.valueMembers == null) ? null :\n                                publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n                ambientTable = (this.ambientValueMembers == null) ? null :\n                                    publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            }\n            if (ambientTable) {\n                var s = ambientTable.lookup(name);\n                if (s) { return s; }\n            }\n            if (table) {\n                var s = table.lookup(name);\n                if (s) { return s; }\n            }\n\n            return null;\n        }\n\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable) {\n                var s = ambientTable.lookup(name);\n                if (s) { return s; }\n            }\n\n            return null;\n        }\n\n        public print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.ambientValueMembers) {\n                this.ambientValueMembers.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.valueMembers) {\n   ';
var v27544 = v27545 + '             this.valueMembers.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.ambientEnclosedTypes) {\n                this.ambientEnclosedTypes.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.enclosedTypes) {\n                this.enclosedTypes.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n        }\n\n        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = this.find(name, publicOnly, typespace);\n            if (sym) {\n                if (sym.kind() == SymbolKind.Type) {\n                    var typeSym = <TypeSymbol>sym;\n                    if (!typeSym.type.hasImplementation()) {\n                        sym = null;\n                    }\n                }\n                else if (sym.container) {\n                    if (sym.container.kind() == SymbolKind.Type) {\n                        var ctypeSym = <TypeSymbol>sym.container;\n                        if (!ctypeSym.type.hasImplementation()) {\n                            sym = null;\n                        }\n                    }\n                }\n            }\n            return sym;\n        }\n\n        public getTable() {\n            return this.valueMembers.publicMembers;\n        }\n    }\n\n    export class SymbolScopeBuilder extends SymbolScope {\n        public container: Symbol;\n        \n        constructor (public valueMembers: ScopedMembers,\n                    public ambientValueMembers: ScopedMembers,\n                    public enclosedTypes: ScopedMembers,\n                    public ambientEnclosedTypes: ScopedMembers,\n                    public parent: SymbolScope,\n                    container: Symbol)\n        {\n            super(container);\n            this.container = container;\n        }\n\n        public printLabel() { return "builder"; }\n        public getAllSymbolNames(members: bool): string[]{\n            var result: string[] = this.getAllTypeSymbolNames(members);\n            return result.concat(this.getAllValueSymbolNames(members));\n        }\n\n        public getAllTypeSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.ambientEnclosedTypes) {\n                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());\n            }\n            if (this.enclosedTypes) {\n                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());\n            }\n            if (!members && this.parent) {\n                var parentResult = this.parent.getAllTypeSymbolNames(members);\n                if (parentResult) {\n                    result = result.concat(parentResult);\n                }\n            }\n            return result;\n        }\n\n        public getAllValueSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.ambientValueMembers) {\n                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());\n            }\n            if (this.valueMembers) {\n                result = result.concat(this.valueMembers.allMembers.getAllKeys());\n            }\n            if (!members && this.parent) {\n                var parentResult = this.parent.getAllValueSymbolNames(members);\n                if (parentResult) {\n                    result = result.concat(parentResult);\n                }\n            }\n            return result;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable) {\n                if ((sym = ambientTable.lookup(name)) != null) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n                }\n            }\n            if (table) {\n                if ((sym = table.lookup(name)) != null) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n        ';
var v27543 = v27544 + '        }\n            }\n            if (this.parent) {\n                sym = this.parent.search(filter, name, publicOnly, typespace);\n                if (sym) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n                }\n            }\n            return filter.result;\n        }\n\n        public print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.ambientValueMembers) {\n                this.ambientValueMembers.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.valueMembers) {\n                this.valueMembers.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.ambientEnclosedTypes) {\n                this.ambientEnclosedTypes.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.enclosedTypes) {\n                this.enclosedTypes.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.parent) {\n                this.parent.print(outfile);\n            }\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {\n                return sym;\n            }\n            if (table && ((sym = table.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parent) {\n                return this.parent.find(name, publicOnly, typespace);\n            }\n            return null;\n        }\n\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parent) {\n                return this.parent.findAmbient(name, publicOnly, typespace);\n            }\n            return null;\n        }\n\n        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (table) {\n                if ((sym = table.lookup(name)) != null) {\n                    if (sym) { return sym; }\n                }\n            }\n            if (ambientTable) {\n                if ((sym = ambientTable.lookup(name)) != null) {\n                    if (sym) { return sym; }\n                }\n            }\n            return null;\n        }\n\n        public enter(container: Symbol, ast: AST, symbol: Symbol, ';
var v27542 = v27543 + 'errorReporter: ErrorReporter, insertAsPublic: bool, typespace: bool, ambient: bool): void {\n            var table = null;\n\n            if (ambient) {\n                if (typespace) {\n                    table = (this.ambientEnclosedTypes == null) ? null :\n                                    insertAsPublic ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.privateMembers;\n                }\n                else {\n                    table = (this.ambientValueMembers == null) ? null :\n                                insertAsPublic ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.privateMembers;\n                }\n            }\n            else {\n                if (typespace) {\n                    table = (this.enclosedTypes == null) ? null :\n                                insertAsPublic ? this.enclosedTypes.publicMembers : this.enclosedTypes.privateMembers;\n                }\n                else {\n                    table = (this.valueMembers == null) ? null :\n                                insertAsPublic ? this.valueMembers.publicMembers : this.valueMembers.privateMembers;\n                }\n            }\n\n            if (table) {\n                if (!table.add(symbol.name, symbol)) {\n                    errorReporter.duplicateIdentifier(ast, symbol.name);\n                }\n            }\n            else {\n                CompilerDiagnostics.Alert("YYYYY");  // REVIEW: Surely we can do better than this...\n            }\n            symbol.container = container;\n        }\n\n        public getTable() { return this.valueMembers.allMembers; }\n    }\n\n    export class FilteredSymbolScope extends SymbolScope {\n        constructor (public scope: SymbolScope, container: Symbol, public filter: ScopeSearchFilter) {\n            super(container);\n        }\n        public print(outfile: ITextWriter) {\n            this.scope.print(outfile);\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool) {\n            this.filter.reset();\n            return this.scope.search(this.filter, name, publicOnly, typespace);\n        }\n        public findLocal(name: string, publicOnly: bool, typespace: bool) { return this.scope.findLocal(name, publicOnly, typespace); }\n    }\n\n    export class FilteredSymbolScopeBuilder extends SymbolScopeBuilder {\n        constructor (valueMembers: ScopedMembers, parent: SymbolScope, container: Symbol, public filter: (sym: Symbol) =>bool) {\n            super(valueMembers, null, null, null, parent, container);\n        }\n        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = super.findLocal(name, publicOnly, typespace);\n            if (sym) {\n                if (!this.filter(sym)) {\n                    return null;\n                }\n            }\n            return sym;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool):Symbol {\n            throw new Error("please implement");\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = super.findLocal(name, publicOnly, typespace);\n            if (sym) {\n                if (!this.filter(sym)) {\n                    return null;\n                }\n            }\n            return super.find(name, publicOnly, typespace);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum TypeCheckStatus {\n        NotStarted,\n        Started,\n        Finished,\n    }\n\n    // For lexically-scoped constructs\n    export function aLexicallyEnclosesB(a: Symbol, b: Symbol) {\n        if (a.declAST && b && b.declAST && a.declAST.nodeType == NodeType.FuncDecl) {\n            return a.declAST.minChar <= b.declAST.minChar && a.declAST.limChar >= b.declAST.limChar;\n        }\n        else {\n            return false;\n        }\n    }\n\n    export function aEnclosesB(a: Symbol, b: Symbol) {\n        while (a.container) {\n            if (a == b || aLexicallyEnclosesB(a.container, b)) {\n                return true;\n            }\n            a = a.container;\n        }\n        return false;\n    }\n\n    export interface PhasedTypecheckObject {\n        typeCheckStatus: TypeCheckStatus;\n    }\n\n    export class Symbol {\n        public bound = false;\n        public container: Symbol;\n        public instanceScope(): SymbolScope { return null;';
var v27541 = v27542 + ' }\n        public isVariable() { return false; }\n        public isMember() { return false; }\n        public isInferenceSymbol() { return false; }\n        public isWith() { return false; }\n        public writeable() { return false; }\n        public isType(): bool { return false; }\n        public getType(): Type { return null; }\n        public flags: SymbolFlags = SymbolFlags.None;\n        public refs: Identifier[];\n        public isAccessor() { return false; }\n        public isObjectLitField = false;\n\n        public declAST: AST = null;\n        public declModule: ModuleDeclaration = null;  // if child of module, this is the module that declared it\n\n        public passSymbolCreated: number = CompilerDiagnostics.analysisPass;\n\n        constructor(public name: string, public location: number, public length: number,\n                 public unitIndex: number) { }\n\n        public isInstanceProperty() {\n            return hasFlag(this.flags, SymbolFlags.Property) && (!hasFlag(this.flags, SymbolFlags.ModuleMember));\n        }\n\n        public getTypeName(scope: SymbolScope): string {\n            return this.getTypeNameEx(scope).toString();\n        }\n        \n        public getTypeNameEx(scope: SymbolScope): MemberName {\n            return MemberName.create(this.toString());\n        }\n\n        public getOptionalNameString() {\n            return hasFlag(this.flags, SymbolFlags.Optional) ? "?" : "";\n        }\n\n        public pathToRoot() {\n            var path = new Symbol[];\n            var node = this;\n            while (node && (node.name != globalId)) {\n                path[path.length] = node;\n                node = node.container;\n            }\n            return path;\n        }\n\n        public findCommonAncestorPath(b: Symbol) {\n            if (this.container == null) {\n                return new Symbol[];\n            }\n            var aPath = this.container.pathToRoot();\n            var bPath: Symbol[];\n            if (b) {\n                bPath = b.pathToRoot();\n            }\n            else {\n                bPath = new Symbol[];\n            }\n            var commonNodeIndex = -1;\n            for (var i = 0, aLen = aPath.length; i < aLen; i++) {\n                var aNode = aPath[i];\n                for (var j = 0, bLen = bPath.length; j < bLen; j++) {\n                    var bNode = bPath[j];\n                    if (aNode == bNode) {\n                        commonNodeIndex = i;\n                        break;\n                    }\n                }\n                if (commonNodeIndex >= 0) {\n                    break;\n                }\n            }\n            if (commonNodeIndex >= 0) {\n                return aPath.slice(0, commonNodeIndex);\n            }\n            else {\n                return aPath;\n            }\n        }\n\n        // Gets the pretty Name for the symbol withing the scope\n        public getPrettyName(scopeSymbol: Symbol) {\n            return this.name;\n        }\n\n        public scopeRelativeName(scope: SymbolScope): string {\n            if (scope == null) {\n                return this.getPrettyName(null) + this.getOptionalNameString();\n            }\n            var lca = this.findCommonAncestorPath(scope.container);\n            var builder = "";\n            for (var i = 0, len = lca.length; i < len; i++) {\n                var prettyName = lca[i].getPrettyName(i == len - 1 ? scope.container : lca[i + 1]);\n                builder = prettyName + "." + builder;\n            }\n            builder += this.getPrettyName(len == 0 ? scope.container : lca[0]) + this.getOptionalNameString();\n            return builder;\n        }\n\n        public fullName(): string {\n            var builder = this.name;\n            var ancestor = this.container;\n            while (ancestor && (ancestor.name != globalId)) {\n                builder = ancestor.name + "." + builder;\n                ancestor = ancestor.container;\n            }\n            return builder;\n        }\n\n        public isExternallyVisible(checker: TypeChecker) {\n            // Global module is not hidden\n            if (this == checker.gloMod) {\n                return true;\n            }\n\n            // private symbol\n            if (hasFlag(this.flags, SymbolFlags.Private)) {\n                return false;\n            }\n\n            // If the current container is not exported\n            // If its in global - it is visible, otherwise it isn\'t\n            if (!hasFlag(this.flags, SymbolFlags.Exported)) {\n                return this.container == checker.gloMod;\n            }\n\n            // It is visible if its container is visible too\n            return this.container.isExternallyVisible(checker);\n        }\n\n        public visible(scope: SymbolScope, checker: TypeChecker) {\n            if (checker == null || this.container == checker.gloMod) {\n                return true;\n            }\n\n            if (hasFlag(this.flags, SymbolFlags.ModuleMember)) {\n\n                if (hasFlag(this.flags, SymbolFlags.Exported)) {\n                    if (!hasFlag';
var v27540 = v27541 + '(this.flags, SymbolFlags.Private)) {\n                        return true;\n                    }\n                    else {\n                        return aEnclosesB(this, scope.container);\n                    }\n                }\n                else {\n                    // REVIEW:\n                    // Note that in the scope-assignment and binding phases,\n                    // currentModDecl will point to the "master" module decl,\n                    // and not necessarily the one that the symbol in question\n                    // was declared in.\n                    // That\'s ok - there\'s no harm done in attributing the symbol\n                    // to the master mod decl in either of those phases, so long\n                    // as we reference the actual module fragment of declaration\n                    // during typecheck.  Doing this also prevents us from printing\n                    // multiple error messages if the symbol is not visible.\n                    return checker && (checker.currentModDecl == this.declModule) ||\n                                                (checker.currentModDecl &&\n                                                    checker.currentModDecl.mod &&\n                                                    checker.currentModDecl.mod.symbol &&\n                                                    this.declModule &&\n                                                    this.declModule.mod &&\n                                                    this.declModule.mod.symbol &&\n                                                    aEnclosesB(checker.currentModDecl.mod.symbol, this.declModule.mod.symbol));\n                }\n            }\n            else {\n                // field or method\n                var isFunction = this.declAST && this.declAST.nodeType == NodeType.FuncDecl;\n                var isMethod = isFunction && (<FuncDecl>this.declAST).isMethod();\n                var isStaticFunction = isFunction && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Static)\n                var isPrivateMethod = isMethod && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Private);\n                var isAlias = this.isType() && (<TypeSymbol>this).aliasLink;\n\n                if (this.isMember() || isMethod || isStaticFunction || isAlias) {\n                    if (hasFlag(this.flags, SymbolFlags.Private) || isPrivateMethod) {\n                        if (scope.container == null && this.container != scope.container) {\n                            return false; // it\'s an inner member being accessed by the global scope\n                        }\n                        else {\n                            return this.container == null ? true : aEnclosesB(scope.container, this.container);\n                        }\n                    }\n                    else {\n                        return true;\n                    }\n                }\n                else if (this.container) {\n                    return aEnclosesB(this, scope.container);\n                }\n                else {\n                    return true;\n                }\n            }\n        }\n\n        public addRef(identifier: Identifier) {\n            if (!this.refs) {\n                this.refs = [];\n            }\n            this.refs[this.refs.length] = identifier;\n        }\n\n        public toString() {\n            if (this.name) {\n                return this.name;\n            }\n            else {\n                return "_anonymous";\n            }\n        }\n\n        public print(outfile) {\n            outfile.Write(this.toString());\n        }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            throw new Error("please implement in derived class");\n        }\n\n        public setType(type: Type) {\n            throw new Error("please implement in derived class");\n        }\n\n        public kind(): SymbolKind {\n            throw new Error("please implement in derived class");\n        }\n\n        public getInterfaceDeclFromSymbol(checker: TypeChecker) {\n            if (this.declAST != null) {\n                if (this.declAST.nodeType == NodeType.InterfaceDeclaration) {\n                    return <InterfaceDeclaration>this.declAST;\n                } else if (this.container != null && this.container != checker.gloMod && this.container.declAST.nodeType == NodeType.InterfaceDeclaration) {\n                    return <InterfaceDeclaration>this.container.declAST;\n                }\n            }\n\n            return null;\n        }\n\n        public getVarDeclFromSymbol() {\n            if (this.declAST != null && this.declAST.nodeType == NodeType.VarDecl) {\n                return <VarDecl>this.declAST;\n            }\n\n            return null;\n        }\n\n        public getDocComments() : Comment[] {\n            if (this.declAST != null) {\n                return this.declAST.getDocComments();\n            }\n\n            return [];\n        }\n\n        public isStatic() {\n            return hasFlag(this.fla';
var v27539 = v27540 + 'gs, SymbolFlags.Static);\n        }\n    }\n\n    export class ValueLocation {\n        public symbol: Symbol;\n        public typeLink: TypeLink;\n    }\n\n    export class InferenceSymbol extends Symbol {\n        constructor (name: string, location: number, length: number, unitIndex: number) {\n            super(name, location, length, unitIndex);\n        }\n\n        public typeCheckStatus = TypeCheckStatus.NotStarted;\n        public isInferenceSymbol() { return true; }\n        public transferVarFlags(varFlags: VarFlags) {\n            if (hasFlag(varFlags, VarFlags.Ambient)) {\n                this.flags |= SymbolFlags.Ambient;\n            }\n            if (hasFlag(varFlags, VarFlags.Constant)) {\n                this.flags |= SymbolFlags.Constant;\n            }\n            if (hasFlag(varFlags, VarFlags.Static)) {\n                this.flags |= SymbolFlags.Static;\n            }\n            if (hasFlag(varFlags, VarFlags.Property)) {\n                this.flags |= SymbolFlags.Property;\n            }\n            if (hasFlag(varFlags, VarFlags.Private)) {\n                this.flags |= SymbolFlags.Private;\n            }\n            if (hasFlag(varFlags, VarFlags.Public)) {\n                this.flags |= SymbolFlags.Public;\n            }\n            if (hasFlag(varFlags, VarFlags.Readonly)) {\n                this.flags |= SymbolFlags.Readonly;\n            }\n            if (hasFlag(varFlags, VarFlags.Exported)) {\n                this.flags |= SymbolFlags.Exported;\n            }\n        }\n    }\n\n    export class TypeSymbol extends InferenceSymbol {\n        public additionalLocations: number[];\n        public expansions: Type[] = []; // For types that may be "split", keep track of the subsequent definitions\n        public expansionsDeclAST: AST[] = [];\n        public isDynamic = false;\n\n        constructor (locName: string, location: number, length: number, unitIndex: number, public type: Type) {\n            super(locName, location, length, unitIndex);\n            this.prettyName = this.name;\n        }\n\n        public addLocation(loc: number) {\n            if (this.additionalLocations == null) {\n                this.additionalLocations = [];\n            }\n            this.additionalLocations[this.additionalLocations.length] = loc;\n        }\n        public isMethod = false;\n        public aliasLink:ImportDeclaration = null;\n        public kind() { return SymbolKind.Type; }\n        public isType(): bool { return true; }\n        public getType() { return this.type; }\n        public prettyName: string;\n        public onlyReferencedAsTypeRef = optimizeModuleCodeGen;\n\n        public getTypeNameEx(scope: SymbolScope) {\n            return this.type.getMemberTypeNameEx(this.name ? this.name + this.getOptionalNameString() : "", false, false, scope);\n        }\n\n        public instanceScope(): SymbolScope {\n            // Don\'t use the constructor scope for a class body or methods - use the contained scope\n            if (!(this.type.typeFlags & TypeFlags.IsClass) && this.type.isClass()) {\n                return this.type.instanceType.constructorScope;\n            }\n            else {\n                return this.type.containedScope;\n            }\n        }\n        // corresponding instance type if this is a class\n        public instanceType: Type;\n\n        public toString() {\n            var result = this.type.getTypeName();\n            if (this.name) {\n                result = this.name + ":" + result;\n            }\n            return result;\n        }\n\n        public isClass() { return this.instanceType != null; }\n        public isFunction() { return this.declAST != null && this.declAST.nodeType == NodeType.FuncDecl; }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            if (this.type == pattern) {\n                return replacement.symbol;\n            }\n            else {\n                var replType = this.type.specializeType(pattern, replacement, checker, false);\n                if (replType != this.type) {\n                    var result = new TypeSymbol(this.name, -1, 0, -1, replType);\n                    return result;\n                }\n                else {\n                    return this;\n                }\n            }\n        }\n\n        // Gets the pretty name of the symbol with respect to symbol of the scope (scopeSymbol)\n        // searchTillRoot specifies if the name need to searched in the root path of the scope\n        public getPrettyName(scopeSymbol: Symbol) {\n            if (!!scopeSymbol && isQuoted(this.prettyName) && this.type.isModuleType()) {\n                // Its a dynamic module - and need to be specialized with the scope\n                // Check in exported module members in each scope\n                var symbolPath = scopeSymbol.pathToRoot();\n                var prettyName = this.getPrettyNameOfDynamicModule(symbolPath);\n                if (prettyName != null) {\n                    return prettyName.name;\n                }\n            }\n\n            retur';
var v27538 = v27539 + 'n this.prettyName;\n        }\n\n        public getPrettyNameOfDynamicModule(scopeSymbolPath: Symbol[]) {\n            var scopeSymbolPathLength = scopeSymbolPath.length;\n            var externalSymbol: { name: string; symbol: Symbol; } = null;\n            if (scopeSymbolPath.length > 0 &&\n                scopeSymbolPath[scopeSymbolPathLength - 1].getType().isModuleType() &&\n                (<TypeSymbol>scopeSymbolPath[scopeSymbolPathLength - 1]).isDynamic) {\n\n                // Check if submodule is dynamic\n                if (scopeSymbolPathLength > 1 &&\n                    scopeSymbolPath[scopeSymbolPathLength - 2].getType().isModuleType() &&\n                    (<TypeSymbol>scopeSymbolPath[scopeSymbolPathLength - 2]).isDynamic) {\n                    var moduleType = <ModuleType>scopeSymbolPath[scopeSymbolPathLength - 2].getType();\n                    externalSymbol = moduleType.findDynamicModuleName(this.type);\n\n                }\n\n                if (externalSymbol == null) {\n                    // Check in this module\n                    var moduleType = <ModuleType>scopeSymbolPath[scopeSymbolPathLength - 1].getType();\n                    externalSymbol = moduleType.findDynamicModuleName(this.type);\n                }\n            }\n\n            return externalSymbol;\n        }\n\n        public getDocComments(): Comment[]{\n            var comments : Comment[] = [];\n            if (this.declAST != null) {\n                comments = comments.concat(this.declAST.getDocComments());\n            }\n\n            for (var i = 0; i < this.expansionsDeclAST.length; i++) {\n                comments = comments.concat(this.expansionsDeclAST[i].getDocComments());\n            }\n\n            return comments;\n        }\n    }\n\n    export class WithSymbol extends TypeSymbol {\n        constructor (location: number, unitIndex: number, withType: Type) {\n            super("with", location, 4, unitIndex, withType);\n        }\n        public isWith() { return true; }\n    }\n\n    export class FieldSymbol extends InferenceSymbol {\n        public name: string;\n        public location: number;\n\n        constructor (name: string, location: number, unitIndex: number, public canWrite: bool,\n                      public field: ValueLocation) {\n\n            super(name, location, name.length, unitIndex);\n            this.name = name;\n            this.location = location;\n        }\n        public kind() { return SymbolKind.Field; }\n        public writeable() { return this.isAccessor() ? this.setter != null : this.canWrite; }\n        public getType() { return this.field.typeLink.type; }\n        public getTypeNameEx(scope: SymbolScope) {\n            return MemberName.create(this.field.typeLink.type.getScopedTypeNameEx(scope), this.name + this.getOptionalNameString() + ": ", "");\n        }\n\n        public isMember() { return true; }\n        public setType(type: Type) {\n            this.field.typeLink.type = type;\n        }\n\n        public getter: TypeSymbol = null;\n        public setter: TypeSymbol = null;\n        public hasBeenEmitted = false; // since getters and setters are emitted together, need to track if one has been emitted\n\n        public isAccessor() { return this.getter != null || this.setter != null; }\n\n        public isVariable() { return true; }\n        public toString() { return this.getTypeNameEx(null).toString(); }\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            var rType = this.field.typeLink.type.specializeType(pattern, replacement, checker, false);\n            if (rType != this.field.typeLink.type) {\n                var fieldDef = new ValueLocation();\n                var result = new FieldSymbol(this.name, 0, checker.locationInfo.unitIndex,\n                                           this.canWrite, fieldDef);\n                result.flags = this.flags;\n                fieldDef.symbol = result;\n                fieldDef.typeLink = new TypeLink();\n                result.setType(rType);\n                result.typeCheckStatus = TypeCheckStatus.Finished;\n                return result;\n            }\n            else {\n                return this;\n            }\n        }\n\n        public getDocComments(): Comment[] {\n            if (this.getter != null || this.setter != null) {\n                var comments : Comment[] = [];\n                if (this.getter != null) {\n                    comments = comments.concat(this.getter.getDocComments());\n                }\n                if (this.setter != null) {\n                    comments = comments.concat(this.setter.getDocComments());\n                }\n                return comments;\n            }\n            else if (this.declAST != null) {\n                return this.declAST.getDocComments();\n            }\n\n            return [];\n        }\n\n    }\n\n    export class ParameterSymbol extends InferenceSymbol {\n        public name: string;\n        public location: number;\n        private paramDocComment: string = null;\n        public funcDecl';
var v27537 = v27538 + ': AST = null;\n        \n        constructor (name: string, location: number, unitIndex: number,\n                          public parameter: ValueLocation) {\n            super(name, location, name.length, unitIndex);\n\n            this.name = name;\n            this.location = location;\n        }\n        public kind() { return SymbolKind.Parameter; }\n        public writeable() { return true; }\n        public getType() { return this.parameter.typeLink.type; }\n        public setType(type: Type) {\n            this.parameter.typeLink.type = type;\n        }\n        public isVariable() { return true; }\n        public argsOffset = (-1);\n        public isOptional() {\n            if (this.parameter && this.parameter.symbol && this.parameter.symbol.declAST) {\n                return (<ArgDecl>this.parameter.symbol.declAST).isOptional;\n            }\n            else {\n                return false;\n            }\n        }\n\n        public getTypeNameEx(scope: SymbolScope) {\n            return MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + (this.isOptional() ? "?" : "") + ": ", "");\n        }\n\n        public toString() { return this.getTypeNameEx(null).toString(); }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            var rType = this.parameter.typeLink.type.specializeType(pattern, replacement, checker, false);\n            if (this.parameter.typeLink.type != rType) {\n                var paramDef = new ValueLocation();\n                var result = new ParameterSymbol(this.name, 0, checker.locationInfo.unitIndex,\n                                               paramDef);\n                paramDef.symbol = result;\n                result.setType(rType);\n                return result;\n            }\n            else {\n                return this;\n            }\n        }\n\n        public getParameterDocComments() {\n            if (!this.paramDocComment) {\n                var parameterComments: string[] = [];\n                if (this.funcDecl) {\n                    var fncDocComments = this.funcDecl.getDocComments();\n                    var paramComment = Comment.getParameterDocCommentText(this.name, fncDocComments);\n                    if (paramComment != "") {\n                        parameterComments.push(paramComment);\n                    }\n                }\n                var docComments = TypeScript.Comment.getDocCommentText(this.getDocComments());\n                if (docComments != "") {\n                    parameterComments.push(docComments);\n                }\n                \n                this.paramDocComment = parameterComments.join("\\n");\n            }\n\n            return this.paramDocComment;\n        }\n    }\n\n    export class VariableSymbol extends InferenceSymbol {\n\n        constructor (name: string, location: number, unitIndex: number, public variable: ValueLocation) {\n            super(name, location, name.length, unitIndex);\n        }\n        public kind() { return SymbolKind.Variable; }\n        public writeable() { return true; }\n        public getType() { return this.variable.typeLink.type; }\n        public getTypeNameEx(scope: SymbolScope) {\n            return MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + ": ", "");\n        }\n\n        public setType(type: Type) {\n            this.variable.typeLink.type = type;\n        }\n        public isVariable() { return true; }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export enum TokenID {\n        // Keywords\n        Any,\n        Bool,\n        Break,\n        Case,\n        Catch,\n        Class,\n        Const,\n        Continue,\n        Debugger,\n        Default,\n        Delete,\n        Do,\n        Else,\n        Enum,\n        Export,\n        Extends,\n        Declare,\n        False,\n        Finally,\n        For,\n        Function,\n        Constructor,\n        Get,\n        If,\n        Implements,\n        Import,\n        In,\n        InstanceOf,\n        Interface,\n        Let,\n        Module,\n        New,\n        Number,\n        Null,\n        Package,\n        Private,\n        Protected,\n        Public,\n        Return,\n        Set,\n        Static,\n        String,\n        Super,\n        Switch,\n        This,\n        Throw,\n        True,\n        Try,\n        TypeOf,\n        Var,\n        Void,\n        With,\n        While,\n        Yield,\n      ';
var v27536 = v27537 + '  // Punctuation\n        Semicolon,\n        OpenParen,\n        CloseParen,\n        OpenBracket,\n        CloseBracket,\n        OpenBrace,\n        CloseBrace,\n        Comma,\n        Equals,\n        PlusEquals,\n        MinusEquals,\n        AsteriskEquals,\n        SlashEquals,\n        PercentEquals,\n        AmpersandEquals,\n        CaretEquals,\n        BarEquals,\n        LessThanLessThanEquals,\n        GreaterThanGreaterThanEquals,\n        GreaterThanGreaterThanGreaterThanEquals,\n        Question,\n        Colon,\n        BarBar,\n        AmpersandAmpersand,\n        Bar,\n        Caret,\n        And,\n        EqualsEquals,\n        ExclamationEquals,\n        EqualsEqualsEquals,\n        ExclamationEqualsEquals,\n        LessThan,\n        LessThanEquals,\n        GreaterThan,\n        GreaterThanEquals,\n        LessThanLessThan,\n        GreaterThanGreaterThan,\n        GreaterThanGreaterThanGreaterThan,\n        Plus,\n        Minus,\n        Asterisk,\n        Slash,\n        Percent,\n        Tilde,\n        Exclamation,\n        PlusPlus,\n        MinusMinus,\n        Dot,\n        DotDotDot,\n        Error,\n        EndOfFile,\n        EqualsGreaterThan,\n        Identifier,\n        StringLiteral,\n        RegularExpressionLiteral,\n        NumberLiteral,\n        Whitespace,\n        Comment,\n        Lim,\n        LimFixed = EqualsGreaterThan,\n        LimKeyword = Yield,\n    }\n\n    export var tokenTable = new TokenInfo[];\n    export var nodeTypeTable = new string[];\n    export var nodeTypeToTokTable = new number[];\n    export var noRegexTable = new bool[];\n\n    noRegexTable[TokenID.Identifier] = true;\n    noRegexTable[TokenID.StringLiteral] = true;\n    noRegexTable[TokenID.NumberLiteral] = true;\n    noRegexTable[TokenID.RegularExpressionLiteral] = true;\n    noRegexTable[TokenID.This] = true;\n    noRegexTable[TokenID.PlusPlus] = true;\n    noRegexTable[TokenID.MinusMinus] = true;\n    noRegexTable[TokenID.CloseParen] = true;\n    noRegexTable[TokenID.CloseBracket] = true;\n    noRegexTable[TokenID.CloseBrace] = true;\n    noRegexTable[TokenID.True] = true;\n    noRegexTable[TokenID.False] = true;\n\n    export enum OperatorPrecedence {\n        None,\n        Comma,\n        Assignment,\n        Conditional,\n        LogicalOr,\n        LogicalAnd,\n        BitwiseOr,\n        BitwiseExclusiveOr,\n        BitwiseAnd,\n        Equality,\n        Relational,\n        Shift,\n        Additive,\n        Multiplicative,\n        Unary,\n        Lim\n    }\n\n    export enum Reservation {\n        None = 0,\n        Javascript = 1,\n        JavascriptFuture = 2,\n        TypeScript = 4,\n        JavascriptFutureStrict = 8,\n        TypeScriptAndJS = Javascript | TypeScript,\n        TypeScriptAndJSFuture = JavascriptFuture | TypeScript,\n        TypeScriptAndJSFutureStrict = JavascriptFutureStrict | TypeScript,\n    }\n\n    export class TokenInfo {\n        constructor (public tokenId: TokenID, public reservation: Reservation,\n                    public binopPrecedence: number, public binopNodeType: number,\n                    public unopPrecedence: number, public unopNodeType: number,\n                    public text: string, public ers: ErrorRecoverySet) { }\n    }\n\n    function setTokenInfo(tokenId: TokenID, reservation: number, binopPrecedence: number,\n        binopNodeType: number, unopPrecedence: number, unopNodeType: number,\n        text: string, ers: ErrorRecoverySet) {\n        if (tokenId !== undefined) {\n            tokenTable[tokenId] = new TokenInfo(tokenId, reservation, binopPrecedence,\n                                              binopNodeType, unopPrecedence, unopNodeType, text, ers);\n            if (binopNodeType != NodeType.None) {\n                nodeTypeTable[binopNodeType] = text;\n                nodeTypeToTokTable[binopNodeType] = tokenId;\n            }\n            if (unopNodeType != NodeType.None) {\n                nodeTypeTable[unopNodeType] = text;\n            }\n        }\n    }\n\n    setTokenInfo(TokenID.Any, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "any", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Bool, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "bool", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Break, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "break", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Case, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "case", ErrorRecoverySet.SCase);\n    setTokenInfo(TokenID.Catch, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "catch", ErrorRecoverySet.Catch);\n    setTokenInfo(TokenID.Class, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "class", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Const, Reservation.TypeScri';
var v27535 = v27536 + 'ptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "const", ErrorRecoverySet.Var);\n    setTokenInfo(TokenID.Continue, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "continue", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Debugger, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.Debugger, "debugger", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Default, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "default", ErrorRecoverySet.SCase);\n    setTokenInfo(TokenID.Delete, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Delete, "delete", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.Do, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "do", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Else, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "else", ErrorRecoverySet.Else);\n    setTokenInfo(TokenID.Enum, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "enum", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Export, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "export", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Extends, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "extends", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Declare, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "declare", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.False, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "false", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Finally, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "finally", ErrorRecoverySet.Catch);\n    setTokenInfo(TokenID.For, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "for", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Function, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "function", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.Constructor, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "constructor", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.Get, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "get", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.Set, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "set", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.If, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "if", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Implements, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "implements", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Import, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "import", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.In, Reservation.TypeScriptAndJS, OperatorPrecedence.Relational, NodeType.In, OperatorPrecedence.None, NodeType.None, "in", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.InstanceOf, Reservation.TypeScriptAndJS, OperatorPrecedence.Relational, NodeType.InstOf, OperatorPrecedence.None, NodeType.None, "instanceof", ErrorRecoverySet.BinOp);\n    setTokenInfo(TokenID.Interface, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "interface", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Let, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "let", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Module, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "module", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.New, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "new", ErrorRecoverySet.PreOp);\n    setTokenInfo(TokenID.Number, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "number", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Nu';
var v27534 = v27535 + 'll, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "null", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Package, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "package", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Private, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "private", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Protected, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "protected", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Public, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "public", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Return, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "return", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Static, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "static", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.String, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "string", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Super, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "super", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Switch, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "switch", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.This, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "this", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Throw, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "throw", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.True, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "true", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Try, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "try", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.TypeOf, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Typeof, "typeof", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.Var, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "var", ErrorRecoverySet.Var);\n    setTokenInfo(TokenID.Void, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Void, "void", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.With, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.With, "with", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.While, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "while", ErrorRecoverySet.While);\n    setTokenInfo(TokenID.Yield, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "yield", ErrorRecoverySet.None);\n\n    setTokenInfo(TokenID.Identifier, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "identifier", ErrorRecoverySet.ID);\n    setTokenInfo(TokenID.NumberLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "numberLiteral", ErrorRecoverySet.Literal);\n    setTokenInfo(TokenID.RegularExpressionLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "regex", ErrorRecoverySet.RegExp);\n    setTokenInfo(TokenID.StringLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "qstring", ErrorRecoverySet.Literal);\n\n    // Non-operator non-identifier tokens\n    setTokenInfo(TokenID.Semicolon, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ";", ErrorRecoverySet.SColon); // ;\n    setTokenInfo(TokenID.CloseParen, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ")", ErrorRecoverySet.RParen); // )\n    setTokenInfo(TokenID.CloseBracket, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "]", ErrorRecoverySet.RBrack); // ]\n    setTokenInfo(TokenID.OpenBrace, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "{", ErrorRecoverySet.LCurly); // {\n    setToken';
var v27533 = v27534 + 'Info(TokenID.CloseBrace, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "}", ErrorRecoverySet.RCurly); // }\n    setTokenInfo(TokenID.DotDotDot, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "...", ErrorRecoverySet.None); // ...\n\n    // Operator non-identifier tokens\n    setTokenInfo(TokenID.Comma, Reservation.None, OperatorPrecedence.Comma, NodeType.Comma, OperatorPrecedence.None, NodeType.None, ",", ErrorRecoverySet.Comma); // ,\n    setTokenInfo(TokenID.Equals, Reservation.None, OperatorPrecedence.Assignment, NodeType.Asg, OperatorPrecedence.None, NodeType.None, "=", ErrorRecoverySet.Asg); // =\n    setTokenInfo(TokenID.PlusEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgAdd, OperatorPrecedence.None, NodeType.None, "+=", ErrorRecoverySet.BinOp); // +=\n    setTokenInfo(TokenID.MinusEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgSub, OperatorPrecedence.None, NodeType.None, "-=", ErrorRecoverySet.BinOp); // -=\n    setTokenInfo(TokenID.AsteriskEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgMul, OperatorPrecedence.None, NodeType.None, "*=", ErrorRecoverySet.BinOp); // *=\n\n    setTokenInfo(TokenID.SlashEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgDiv, OperatorPrecedence.None, NodeType.None, "/=", ErrorRecoverySet.BinOp); // /=\n    setTokenInfo(TokenID.PercentEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgMod, OperatorPrecedence.None, NodeType.None, "%=", ErrorRecoverySet.BinOp); // %=\n    setTokenInfo(TokenID.AmpersandEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgAnd, OperatorPrecedence.None, NodeType.None, "&=", ErrorRecoverySet.BinOp); // &=\n    setTokenInfo(TokenID.CaretEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgXor, OperatorPrecedence.None, NodeType.None, "^=", ErrorRecoverySet.BinOp); // ^=\n    setTokenInfo(TokenID.BarEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgOr, OperatorPrecedence.None, NodeType.None, "|=", ErrorRecoverySet.BinOp); // |=\n    setTokenInfo(TokenID.LessThanLessThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgLsh, OperatorPrecedence.None, NodeType.None, "<<=", ErrorRecoverySet.BinOp); // <<=\n    setTokenInfo(TokenID.GreaterThanGreaterThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgRsh, OperatorPrecedence.None, NodeType.None, ">>=", ErrorRecoverySet.BinOp); // >>=\n    setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgRs2, OperatorPrecedence.None, NodeType.None, ">>>=", ErrorRecoverySet.BinOp); // >>>=\n    setTokenInfo(TokenID.Question, Reservation.None, OperatorPrecedence.Conditional, NodeType.ConditionalExpression, OperatorPrecedence.None, NodeType.None, "?", ErrorRecoverySet.BinOp); // ?\n    setTokenInfo(TokenID.Colon, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ":", ErrorRecoverySet.Colon); // :\n    setTokenInfo(TokenID.BarBar, Reservation.None, OperatorPrecedence.LogicalOr, NodeType.LogOr, OperatorPrecedence.None, NodeType.None, "||", ErrorRecoverySet.BinOp); // ||\n    setTokenInfo(TokenID.AmpersandAmpersand, Reservation.None, OperatorPrecedence.LogicalAnd, NodeType.LogAnd, OperatorPrecedence.None, NodeType.None, "&&", ErrorRecoverySet.BinOp); // &&\n    setTokenInfo(TokenID.Bar, Reservation.None, OperatorPrecedence.BitwiseOr, NodeType.Or, OperatorPrecedence.None, NodeType.None, "|", ErrorRecoverySet.BinOp); // |\n    setTokenInfo(TokenID.Caret, Reservation.None, OperatorPrecedence.BitwiseExclusiveOr, NodeType.Xor, OperatorPrecedence.None, NodeType.None, "^", ErrorRecoverySet.BinOp); // ^\n    setTokenInfo(TokenID.And, Reservation.None, OperatorPrecedence.BitwiseAnd, NodeType.And, OperatorPrecedence.None, NodeType.None, "&", ErrorRecoverySet.BinOp); // &\n    setTokenInfo(TokenID.EqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Eq, OperatorPrecedence.None, NodeType.None, "==", ErrorRecoverySet.BinOp); // ==\n    setTokenInfo(TokenID.ExclamationEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Ne, OperatorPrecedence.None, NodeType.None, "!=", ErrorRecoverySet.BinOp); // !=\n    setTokenInfo(TokenID.EqualsEqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Eqv, OperatorPrecedence.None, NodeType.None, "===", ErrorRecoverySet.BinOp); // ===\n    setTokenInfo(TokenID.ExclamationEqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.NEqv, OperatorPrecedence.None, NodeType.None, "!==", ErrorRecoverySet.BinOp); // !==\n    setTokenInfo(TokenID.LessThan, Reservation.None, OperatorPrecedence.Relational, NodeType.Lt, OperatorPrecedence.None, NodeType.None, "<", ErrorRecoverySet.BinOp); // <\n    setTokenInfo(TokenID.LessThanEquals, Reservation.None, OperatorPrecedence.Relational, NodeTyp';
var v27532 = v27533 + 'e.Le, OperatorPrecedence.None, NodeType.None, "<=", ErrorRecoverySet.BinOp); // <=\n    setTokenInfo(TokenID.GreaterThan, Reservation.None, OperatorPrecedence.Relational, NodeType.Gt, OperatorPrecedence.None, NodeType.None, ">", ErrorRecoverySet.BinOp); // >\n    setTokenInfo(TokenID.GreaterThanEquals, Reservation.None, OperatorPrecedence.Relational, NodeType.Ge, OperatorPrecedence.None, NodeType.None, ">=", ErrorRecoverySet.BinOp); // >=\n    setTokenInfo(TokenID.LessThanLessThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Lsh, OperatorPrecedence.None, NodeType.None, "<<", ErrorRecoverySet.BinOp); // <<\n    setTokenInfo(TokenID.GreaterThanGreaterThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Rsh, OperatorPrecedence.None, NodeType.None, ">>", ErrorRecoverySet.BinOp); // >>\n    setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Rs2, OperatorPrecedence.None, NodeType.None, ">>>", ErrorRecoverySet.BinOp); // >>>\n    setTokenInfo(TokenID.Plus, Reservation.None, OperatorPrecedence.Additive, NodeType.Add, OperatorPrecedence.Unary, NodeType.Pos, "+", ErrorRecoverySet.AddOp); // +\n    setTokenInfo(TokenID.Minus, Reservation.None, OperatorPrecedence.Additive, NodeType.Sub, OperatorPrecedence.Unary, NodeType.Neg, "-", ErrorRecoverySet.AddOp); // -\n    setTokenInfo(TokenID.Asterisk, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Mul, OperatorPrecedence.None, NodeType.None, "*", ErrorRecoverySet.BinOp); // *\n    setTokenInfo(TokenID.Slash, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Div, OperatorPrecedence.None, NodeType.None, "/", ErrorRecoverySet.BinOp); // /\n    setTokenInfo(TokenID.Percent, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Mod, OperatorPrecedence.None, NodeType.None, "%", ErrorRecoverySet.BinOp); // %\n    setTokenInfo(TokenID.Tilde, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Not, "~", ErrorRecoverySet.PreOp); // ~\n    setTokenInfo(TokenID.Exclamation, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.LogNot, "!", ErrorRecoverySet.PreOp); // !\n    setTokenInfo(TokenID.PlusPlus, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.IncPre, "++", ErrorRecoverySet.PreOp); // ++\n    setTokenInfo(TokenID.MinusMinus, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.DecPre, "--", ErrorRecoverySet.PreOp); // --\n    setTokenInfo(TokenID.OpenParen, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "(", ErrorRecoverySet.LParen); // (\n    setTokenInfo(TokenID.OpenBracket, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "[", ErrorRecoverySet.LBrack); // [\n    setTokenInfo(TokenID.Dot, Reservation.None, OperatorPrecedence.Unary, NodeType.None, OperatorPrecedence.None, NodeType.None, ".", ErrorRecoverySet.Dot); // .\n    setTokenInfo(TokenID.EndOfFile, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "<EOF>", ErrorRecoverySet.EOF); // EOF\n    setTokenInfo(TokenID.EqualsGreaterThan, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "=>", ErrorRecoverySet.None); // =>\n\n    export function lookupToken(tokenId: TokenID): TokenInfo {\n        return tokenTable[tokenId];\n    }\n\n    export enum TokenClass {\n        Punctuation,\n        Keyword,\n        Operator,\n        Comment,\n        Whitespace,\n        Identifier,\n        NumberLiteral,\n        StringLiteral,\n        RegExpLiteral,\n    }\n\n    export class SavedToken {\n        constructor (public tok: Token, public minChar: number, public limChar: number) { }\n    }\n\n    export class Token {\n        constructor (public tokenId: TokenID) {\n        }\n\n        public toString() {\n            return "token: " + this.tokenId + " " + this.getText() + " (" + (<any>TokenID)._map[this.tokenId] + ")";\n        }\n\n        public print(line: number, outfile) {\n            outfile.WriteLine(this.toString() + ",on line" + line);\n        }\n\n        public getText(): string {\n            return tokenTable[this.tokenId].text;\n        }\n\n        public classification(): TokenClass {\n            if (this.tokenId <= TokenID.LimKeyword) {\n                return TokenClass.Keyword;\n            }\n            else {\n                var tokenInfo = lookupToken(this.tokenId);\n                if (tokenInfo != undefined) {\n                    if ((tokenInfo.unopNodeType != NodeType.None) ||\n                        (tokenInfo.binopNodeType != NodeType.None)) {\n                        return TokenClass.Operator;\n                    }\n                }\n            }\n\n            return TokenClass.Punctuation;\n        }\n    }\n\n    export class NumberLiteralToken extends Token {\n        constructor (public value: number,';
var v27531 = v27532 + ' public hasEmptyFraction?: bool) {\n            super(TokenID.NumberLiteral);\n        }\n\n        public getText(): string {\n            return this.hasEmptyFraction ? this.value.toString() + ".0" : this.value.toString();\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.NumberLiteral;\n        }\n    }\n\n    export class StringLiteralToken extends Token {\n        constructor (public value: string) {\n            super(TokenID.StringLiteral);\n        }\n\n        public getText(): string {\n            return this.value;\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.StringLiteral;\n        }\n    }\n\n    export class IdentifierToken extends Token {\n        constructor (public value: string, public hasEscapeSequence : bool) {\n            super(TokenID.Identifier);\n        }\n        public getText(): string {\n            return this.value;\n        }\n        public classification(): TokenClass {\n            return TokenClass.Identifier;\n        }\n    }\n\n    export class WhitespaceToken extends Token {\n        constructor (tokenId: TokenID, public value: string) {\n            super(tokenId);\n        }\n\n        public getText(): string {\n            return this.value;\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.Whitespace;\n        }\n    }\n\n    export class CommentToken extends Token {\n        constructor (tokenID: TokenID, public value: string, public isBlock: bool, public startPos: number, public line: number, public endsLine: bool) {\n            super(tokenID);\n        }\n\n        public getText(): string {\n            return this.value;\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.Comment;\n        }\n    }\n\n    export class RegularExpressionLiteralToken extends Token {\n        constructor(public regex) {\n            super(TokenID.RegularExpressionLiteral);\n        }\n\n        public getText(): string {\n            return this.regex.toString();\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.RegExpLiteral;\n        }\n    }\n\n    // TODO: new with length TokenID.LimFixed\n    export var staticTokens = new Token[];\n    export function initializeStaticTokens() {\n        for (var i = 0; i <= TokenID.LimFixed; i++) {\n            staticTokens[i] = new Token(i);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\'/>\n///<reference path=\'io.ts\'/>\n///<reference path=\'optionsParser.ts\'/>\n\nclass CommandLineHost implements TypeScript.IResolverHost {\n\n    public pathMap: any = {};\n    public resolvedPaths: any = {};\n\n    constructor(public compilationSettings: TypeScript.CompilationSettings) { \n    }\n\n    public getPathIdentifier(path: string) { \n        return this.compilationSettings.useCaseSensitiveFileResolution ? path : path.toLocaleUpperCase();\n    }\n\n    public isResolved(path: string) {\n        return this.resolvedPaths[this.getPathIdentifier(this.pathMap[path])] != undefined;\n    }\n\n    public resolveCompilationEnvironment(preEnv: TypeScript.CompilationEnvironment,\n        resolver: TypeScript.ICodeResolver,\n        traceDependencies: bool): TypeScript.CompilationEnvironment {\n        var resolvedEnv = new TypeScript.CompilationEnvironment(preEnv.compilationSettings, preEnv.ioHost);\n\n        var nCode = preEnv.code.length;\n        var path = "";\n\n        var postResolutionError = \n            (errorFile: string, errorMessage: string) => {\n                TypeScript.CompilerDiagnostics.debugPrint("Could not resolve file \'" + errorFile + "\'" + (errorMessage == "" ? "" : ": " + errorMessage));\n            }\n\n        var resolutionDispatcher: TypeScript.IResolutionDispatcher = {\n            postResolutionError: postResolutionError,\n            postResolution: (path: string, code: TypeScript.ISourceText) => {\n                var pathId = this.getPathIdentifier(path);\n                if (!this.resolvedPaths[pathId]) {\n                    resolvedEnv.code.push(<TypeScript.SourceUnit>code);\n                    this.resolvedPaths[pathId] = true;\n                }\n            }\n        };\n\n        for (var i = 0; i < nCode; i++) {\n            path = TypeScript.switchToForwardSlashes(preEnv.ioHost.resolvePath(preEnv.code[i].path));\n            this.pathMap[preEnv.code[i].path] = path;\n            resolver.resolveCode(path, "", false, r';
var v27530 = v27531 + 'esolutionDispatcher);\n        }\n\n        return resolvedEnv;\n    }\n}\nclass BatchCompiler {\n    public compilationSettings: TypeScript.CompilationSettings;\n    public compilationEnvironment: TypeScript.CompilationEnvironment;\n    public resolvedEnvironment: TypeScript.CompilationEnvironment = null;\n    public hasResolveErrors: bool = false;\n    public compilerVersion = "0.8.2.0";\n    public printedVersion = false;\n\n    constructor (public ioHost: IIO) { \n        this.compilationSettings = new TypeScript.CompilationSettings();\n        this.compilationEnvironment = new TypeScript.CompilationEnvironment(this.compilationSettings, this.ioHost);\n    }\n\n    public resolve() {\n        var resolver = new TypeScript.CodeResolver(this.compilationEnvironment);\n        var commandLineHost = new CommandLineHost(this.compilationSettings);\n        var ret = commandLineHost.resolveCompilationEnvironment(this.compilationEnvironment, resolver, true);\n\n        // Reset resolve error status\n        this.hasResolveErrors = false;\n\n        for (var i = 0; i < this.compilationEnvironment.code.length; i++) {\n            if (!commandLineHost.isResolved(this.compilationEnvironment.code[i].path)) {\n                this.hasResolveErrors = true;\n                var path = this.compilationEnvironment.code[i].path;\n                if (!TypeScript.isSTRFile(path) && !TypeScript.isDSTRFile(path) && !TypeScript.isTSFile(path) && !TypeScript.isDTSFile(path)) {\n                    this.ioHost.stderr.WriteLine("Unknown extension for file: \\""+path+"\\". Only .ts and .d.ts extensions are allowed.");\n                }\n                else {\n                    this.ioHost.stderr.WriteLine("Error reading file \\"" + path + "\\": File not found");\n                }\n            }\n        }\n\n        return ret;\n    }\n    \n    /// Do the actual compilation reading from input files and\n    /// writing to output file(s).\n    public compile(): bool {\n        var compiler: TypeScript.TypeScriptCompiler;\n\n        compiler = new TypeScript.TypeScriptCompiler(this.ioHost.stderr, new TypeScript.NullLogger(), this.compilationSettings);\n        compiler.setErrorOutput(this.ioHost.stderr);\n        compiler.setErrorCallback(\n            (minChar, charLen, message, unitIndex) => {\n                compiler.errorReporter.hasErrors = true;\n                var fname = this.resolvedEnvironment.code[unitIndex].path;\n                var lineCol = { line: -1, col: -1 };\n                compiler.parser.getSourceLineCol(lineCol, minChar);\n                // line is 1-base, col, however, is 0-base. add 1 to the col before printing the message\n                var msg = fname + " (" + lineCol.line + "," + (lineCol.col + 1) + "): " + message;\n                if (this.compilationSettings.errorRecovery) {\n                    this.ioHost.stderr.WriteLine(msg);\n                } else {\n                    throw new SyntaxError(msg);\n                }\n            });\n\n        if (this.compilationSettings.emitComments) {\n            compiler.emitCommentsToOutput();\n        }\n\n        var consumeUnit = (code: TypeScript.SourceUnit, addAsResident: bool) => {\n            try {\n                // if file resolving is disabled, the file\'s content will not yet be loaded\n\n                if (!this.compilationSettings.resolve) {\n                    code.content = this.ioHost.readFile(code.path);\n                    // If declaration files are going to be emitted, \n                    // preprocess the file contents and add in referenced files as well\n                    if (this.compilationSettings.generateDeclarationFiles) {\n                        TypeScript.CompilerDiagnostics.assert(code.referencedFiles == null, "With no resolve option, referenced files need to null");\n                        code.referencedFiles = TypeScript.getReferencedFiles(code);\n                    }\n                }\n\n                if (code.content != null) {\n                    if (this.compilationSettings.parseOnly) {\n                        compiler.parseUnit(code.content, code.path);\n                    }\n                    else {\n                        if (this.compilationSettings.errorRecovery) {\n                            compiler.parser.setErrorRecovery(this.ioHost.stderr);\n                        }\n                        compiler.addUnit(code.content, code.path, addAsResident, code.referencedFiles);\n                    }\n                }\n            }\n            catch (err) {\n                compiler.errorReporter.hasErrors = true;\n                // This includes syntax errors thrown from error callback if not in recovery mode\n                this.ioHost.stderr.WriteLine(err.message);\n            }\n\n        }\n\n        for (var iCode = 0 ; iCode < this.resolvedEnvironment.code.length; iCode++) {\n            if (!this.compilationSettings.parseOnly || (iCode > 0)) {\n                consumeUnit(this.resolvedEnvironment.code[iCode], false);\n            }\n        }\n\n        var emitterIOHost = {\n          ';
var v27529 = v27530 + "  createFile: (fileName: string, useUTF8?: bool) => IOUtils.createFileAndFolderStructure(this.ioHost, fileName, useUTF8),\n            directoryExists: this.ioHost.directoryExists,\n            fileExists: this.ioHost.fileExists,\n            resolvePath: this.ioHost.resolvePath\n        };\n\n        try {\n            if (!this.compilationSettings.parseOnly) {\n                compiler.typeCheck();\n                compiler.emit(emitterIOHost);\n                compiler.emitDeclarations();\n            }\n            else {\n                compiler.emitAST(emitterIOHost);\n            }\n        } catch (err) {\n            compiler.errorReporter.hasErrors = true;\n            // Catch emitter exceptions\n            if (err.message != \"EmitError\") {\n                throw err;\n            }\n        }\n\n        return compiler.errorReporter.hasErrors;\n    }\n\n    // Execute the provided inputs\n    public run() {\n        for (var i = 0; i < this.compilationEnvironment.code.length; i++) {\n            var unit = this.compilationEnvironment.code[i];\n            \n            var outputFileName: string = unit.path;\n            if (TypeScript.isTSFile(outputFileName)) {\n                outputFileName = outputFileName.replace(/\\.ts$/, \".js\");\n            } else if (TypeScript.isSTRFile(outputFileName)) {\n                outputFileName = outputFileName.replace(/\\.str$/, \".js\");\n            }\n            if (this.ioHost.fileExists(outputFileName)) {\n                var unitRes = this.ioHost.readFile(outputFileName)\n                this.ioHost.run(unitRes, outputFileName);\n            }\n        }\n    }\n\n    /// Begin batch compilation\n    public batchCompile() {\n        TypeScript.CompilerDiagnostics.diagnosticWriter = { Alert: (s: string) => { this.ioHost.printLine(s); } }\n\n        var code: TypeScript.SourceUnit;\n\n        var opts = new OptionsParser(this.ioHost);\n\n        opts.option('out', {\n            usage: 'Concatenate and emit output to single file | Redirect output structure to the directory',\n            type: 'file|directory',\n            set: (str) => {\n                this.compilationSettings.outputOption = str;\n            }\n        });\n\n        opts.option('style', {\n            usage: 'Select style checking options (examples --style requireSemi:off or --style \"eqeqeq;bitwise:off\")',\n            experimental: true,\n            set: (str) => {\n                this.compilationSettings.setStyleOptions(str);\n            }\n        });\n\n        opts.flag('sourcemap', {\n            usage: 'Generates corresponding .map file',\n            set: () => {\n                this.compilationSettings.mapSourceFiles = true;\n            }\n        });\n\n        opts.flag('declaration', {\n            usage: 'Generates corresponding .d.ts file',\n            set: () => {\n                this.compilationSettings.generateDeclarationFiles = true;\n            }\n        });\n\n        if (this.ioHost.watchFile) {\n            opts.flag('watch', {\n                usage: 'Watch output files',\n                set: () => {\n                    this.compilationSettings.watch = true;\n                }\n            }, 'w');\n        }\n\n        opts.flag('exec', {\n            usage: 'Execute the script after compilation',\n            set: () => {\n                this.compilationSettings.exec = true;\n            }\n        }, 'e');\n\n        opts.flag('parse', {\n            usage: 'Parse only',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.parseOnly = true;\n            }\n        });\n\n        opts.flag('minw', {\n            usage: 'Minimize whitespace',\n            experimental: true,\n            set: () => { this.compilationSettings.minWhitespace = true; }\n        }, 'mw');\n\n        opts.flag('const', {\n            usage: 'Propagate constants to emitted code',\n            experimental: true,\n            set: () => { this.compilationSettings.propagateConstants = true; }\n        });\n\n        opts.flag('errorrecovery', {\n            usage: 'Enable error recovery',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.errorRecovery = true;\n            }\n        }, 'er');\n\n        opts.flag('comments', {\n            usage: 'Emit comments to output',\n            set: () => {\n                this.compilationSettings.emitComments = true;\n            }\n        }, 'c');\n\n        opts.flag('cflow', {\n            usage: 'Control flow',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.controlFlow = true;\n            }\n        });\n\n        opts.flag('cflowp', {\n            usage: 'Print control flow',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.controlFlow = true;\n                this.compilationSettings.printControlFlow = true;\n            }\n        });\n\n        opts.flag('cflowu', {\n            usage: 'Print Use Def control flow',\n            experimental: true,\n            set: () ";
var v27528 = v27529 + "=> {\n                this.compilationSettings.controlFlow = true;\n                this.compilationSettings.controlFlowUseDef = true;\n            }\n        });\n\n        opts.flag('noerroronwith', {\n            usage: 'Allow with statements',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.errorOnWith = false;\n            }\n        });\n\n        opts.flag('noresolve', {\n            usage: 'Skip resolution and preprocessing',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.resolve = false;\n                this.compilationSettings.preprocess = false;\n            }\n        });\n\n        opts.flag('debug', {\n            usage: 'Print debug output',\n            experimental: true,\n            set: () => {\n                TypeScript.CompilerDiagnostics.debug = true;\n            }\n        });\n\n        opts.flag('canCallDefinitionSignature', {\n            usage: 'Allows you to call the definition signature of an overload group',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.canCallDefinitionSignature = true;\n            }\n        });\n\n        opts.flag('nooptimizemodules', {\n            usage: 'Do not optimize module codegen',\n            experimental: true,\n            set: () => {\n                TypeScript.optimizeModuleCodeGen = false;\n            }\n        });\n\n        opts.flag('nolib', {\n            usage: 'Do not include a default lib.d.ts with global declarations',\n            set: () => {\n                this.compilationSettings.useDefaultLib = false;\n            }\n        });\n\n\n        opts.flag('inferProperties', {\n            usage: 'Infer class properties from top-level assignments to \\'this\\'',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.inferPropertiesFromThisAssignment = true;\n            }\n        });\n\n        opts.option('target', {\n            usage: 'Specify ECMAScript target version: \"ES3\" (default), or \"ES5\"',\n            type: 'VER',\n            set: (type) => {\n                type = type.toLowerCase();\n\n                if (type === 'es3') {\n                    this.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES3;\n                } else if (type === 'es5') {\n                    this.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES5;\n                }\n                else {\n                    this.ioHost.printLine(\"ECMAScript target version '\" + type + \"' not supported.  Using default 'ES3' code generation\");\n                }\n            }\n        });\n\n        opts.option('module', {\n            usage: 'Specify module code generation: \"commonjs\" (default) or \"amd\"',\n            type: 'kind',\n            set: (type) => {\n                type = type.toLowerCase();\n\n                if (type === 'commonjs' || type === 'node') {\n                    TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous;\n                } else if (type === 'amd') {\n                    TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Asynchronous;\n                } else {\n                    this.ioHost.printLine(\"Module code generation '\" + type + \"' not supported.  Using default 'commonjs' code generation\");\n                }\n            }\n        });\n\n        var printedUsage = false;\n\n        opts.flag('help', {\n            usage: 'Print this message',\n            set: () => {\n                this.printVersion();\n                opts.printUsage();\n                printedUsage = true;\n            }\n        }, 'h');\n\n        opts.flag('useCaseSensitiveFileResolution', {\n            usage: 'Force file resolution to be case sensitive',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.useCaseSensitiveFileResolution = true;\n            }\n        });\n\n        opts.flag('version', {\n            usage: 'Print the compiler\\'s version: ' + this.compilerVersion,\n            set: () => {\n                this.printVersion();\n            }\n        }, 'v');\n\n        opts.parse(this.ioHost.arguments);\n        \n        if (this.compilationSettings.useDefaultLib) {\n            var compilerFilePath = this.ioHost.getExecutingFilePath()\n            var binDirPath = this.ioHost.dirName(compilerFilePath);\n            var libStrPath = this.ioHost.resolvePath(binDirPath + \"/lib.d.ts\");\n            code = new TypeScript.SourceUnit(libStrPath, null);\n            this.compilationEnvironment.code.push(code);\n        }\n\n        for (var i = 0; i < opts.unnamed.length; i++) {\n            code = new TypeScript.SourceUnit(opts.unnamed[i], null);\n            this.compilationEnvironment.code.push(code);\n        }\n\n        // If no source files provided to compiler - print usage information\n        if (this.compilationEnvironment.code.length == (this.compilationSettings.useDefaultLib ? 1 : 0)) {\n            if (!printedUsage && !this.printedVersion";
var v27527 = v27528 + ') {\n                this.printVersion();\n                opts.printUsage();\n                this.ioHost.quit(1);\n            }\n            return;\n        }\n\n        var sourceFiles: TypeScript.SourceUnit[] = [];\n        if (this.compilationSettings.watch) {\n            // Capture the state before calling resolve\n            sourceFiles = this.compilationEnvironment.code.slice(0);\n        }\n\n        // Resolve file dependencies, if requested\n        this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;\n\n        var hasCompileErrors = this.compile();\n\n        var hasErrors = hasCompileErrors || this.hasResolveErrors;\n        if (!hasErrors) {\n            if (this.compilationSettings.exec) {\n                this.run();\n            }\n        }\n\n        if (this.compilationSettings.watch) {\n            // Watch will cause the program to stick around as long as the files exist\n            this.watchFiles(sourceFiles);\n        }\n        else {  \n            // Exit with the appropriate error code\n            this.ioHost.quit(hasErrors ? 1 : 0);\n        }\n    }\n\n    public printVersion() {\n        if (!this.printedVersion) {\n            this.ioHost.printLine("Version " + this.compilerVersion);\n            this.printedVersion = true;\n        }\n    }\n\n    public watchFiles(soruceFiles: TypeScript.SourceUnit[]) {\n        if (!this.ioHost.watchFile) {\n            this.ioHost.printLine("Error: Current host does not support -w[atch] option");\n            return;\n        }\n\n        var resolvedFiles: string[] = []\n        var watchers: { [x: string]: IFileWatcher; } = {};\n\n        var addWatcher = (filename: string) => {\n            if (!watchers[filename]) {\n                var watcher = this.ioHost.watchFile(filename, onWatchedFileChange);\n                watchers[filename] = watcher;\n            }\n            else {\n                throw new Error("Cannot watch file, it is already watched.");\n            }\n        };\n\n        var removeWatcher = (filename: string) => {\n            if (watchers[filename]) {\n                watchers[filename].close();\n                delete watchers[filename];\n            }\n            else {\n                throw new Error("Cannot stop watching file, it is not being watched.");\n            }\n        };\n\n        var onWatchedFileChange = () => {\n            // Reset the state\n            this.compilationEnvironment.code = soruceFiles;\n\n            // Resolve file dependencies, if requested\n            this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;\n\n            // Check if any new files were added to the environment as a result of the file change\n            var oldFiles = resolvedFiles;\n            var newFiles: string[] = [];\n            this.resolvedEnvironment.code.forEach((sf) => newFiles.push(sf.path));\n            newFiles = newFiles.sort();\n\n            var i = 0, j = 0;\n            while (i < oldFiles.length && j < newFiles.length) {\n\n                var compareResult = oldFiles[i].localeCompare(newFiles[j]);\n                if (compareResult == 0) {\n                    // No change here\n                    i++;\n                    j++;\n                }\n                else if (compareResult < 0) {\n                    // Entry in old list does not exist in the new one, it was removed\n                    removeWatcher(oldFiles[i]);\n                    i++;\n                }\n                else {\n                    // Entry in new list does exist in the new one, it was added\n                    addWatcher(newFiles[j]);\n                    j++;\n                }\n            }\n\n            // All remaining unmatched items in the old list have been removed\n            for (var k = i; k < oldFiles.length; k++) {\n                removeWatcher(oldFiles[k]);\n            }\n\n            // All remaing unmatched items in the new list have been added\n            for (var k = j; k < newFiles.length; k++) {\n                addWatcher(newFiles[k]);\n            }\n\n            // Update the state\n            resolvedFiles = newFiles;;\n\n            // Print header\n            this.ioHost.printLine("");\n            this.ioHost.printLine("Recompiling (" + new Date() + "): ");\n            resolvedFiles.forEach((f) => this.ioHost.printLine("    " + f));\n\n            // Trigger a new compilation\n            var hasCompileErrors = this.compile();\n\n            var hasErrors = hasCompileErrors || this.hasResolveErrors;\n            if (!hasErrors) {\n                if (this.compilationSettings.exec) {\n                    this.run();\n                }\n            }\n        };\n\n        // Switch to using stdout for all error messages\n        this.ioHost.stderr = this.ioHost.stdout;\n\n        // Initialize the initial list of resolved files, and add watches to them\n        this.resolvedEnvironment.code.forEach((sf) => {\n            resolvedFiles.push(sf.path);\n            addWatcher(sf.path);\n ';
var v27526 = v27527 + '       });\n        resolvedFiles.sort();\n    }\n}\n\n// Start the batch compilation using the current hosts IO\nvar batch = new BatchCompiler(IO);\nbatch.batchCompile();\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class ArrayCache {\n        public arrayType: Type;\n        public arrayBase: Type = null;\n\n        public specialize(arrInstType: Type, checker: TypeChecker): Type {\n            if (this.arrayBase == null) {\n                this.arrayBase = arrInstType.specializeType(checker.wildElm.type, this.arrayType.elementType,\n                                                   checker, true);\n            }\n            return this.arrayBase;\n        }\n    }\n\n    export class TypeComparisonInfo {\n        public onlyCaptureFirstError = false;\n        public flags: TypeRelationshipFlags = TypeRelationshipFlags.SuccessfulComparison;\n        public message = "";\n\n        public addMessageToFront(message) {\n            if (!this.onlyCaptureFirstError) {\n                this.message = this.message ? message + ":\\n\\t" + this.message : message;\n            }\n            else {\n                this.setMessage(message);\n            }\n        }\n\n        public setMessage(message) {\n            this.message = message;\n        }\n    }\n\n    export interface SignatureData {\n        parameters: ParameterSymbol[];\n        nonOptionalParameterCount: number;\n    }\n\n    export interface ApplicableSignature {\n        signature: Signature;\n        hadProvisionalErrors: bool;\n    }\n\n    export enum TypeCheckCollectionMode {\n        Resident,\n        Transient\n    }\n\n    export class PersistentGlobalTypeState {\n        public importedGlobalsTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n        public importedGlobalsTypeTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n        public importedGlobals: SymbolScopeBuilder;\n\n        // transient state\n        public globals: IHashTable = null;\n        public globalTypes: IHashTable = null;\n        public ambientGlobals: IHashTable = null;\n        public ambientGlobalTypes: IHashTable = null;\n\n        // resident state\n        public residentGlobalValues = new StringHashTable();\n        public residentGlobalTypes = new StringHashTable();\n        public residentGlobalAmbientValues = new StringHashTable();\n        public residentGlobalAmbientTypes = new StringHashTable();\n\n        // dual resident/transient state\n\n        // REVIEW: We shouldn\'t need to allocate private hash tables for these, since there\'s no private global scope\n        // REVIEW: In general, we should audit each instance of DualStringHashTable to ensure that both the primary\n        // and secondary tables are necessary.  If it\'s not necessary, we should sub in a constant sentinel value.\n        public dualGlobalValues: DualStringHashTable;\n        public dualGlobalTypes: DualStringHashTable;\n        public dualAmbientGlobalValues: DualStringHashTable;\n        public dualAmbientGlobalTypes: DualStringHashTable;\n\n        public globalScope: SymbolScope;\n\n        public voidType: Type;\n        public booleanType: Type;\n        public doubleType: Type;\n\n        public stringType: Type;\n        public anyType: Type;\n        public nullType: Type;\n        public undefinedType: Type;\n\n        // Use this flag to turn resident checking on and off\n        public residentTypeCheck: bool = true;\n\n        public mod: ModuleType = null;\n        public gloMod: TypeSymbol = null;\n\n        public wildElm: TypeSymbol = null;\n\n        constructor (public errorReporter: ErrorReporter) {\n            this.importedGlobals = new SymbolScopeBuilder(null, this.importedGlobalsTable, null, this.importedGlobalsTypeTable, null, null);\n\n            this.dualGlobalValues = new DualStringHashTable(this.residentGlobalValues, new StringHashTable());\n            this.dualGlobalTypes = new DualStringHashTable(this.residentGlobalTypes, new StringHashTable());\n            this.dualAmbientGlobalValues = new DualStringHashTable(this.residentGlobalAmbientValues, new StringHashTable());\n            this.dualAmbientGlobalTypes = new DualStringHashTable(this.residentGlobalAmbientTypes, new StringHashTable());\n\n            var dualGlobalScopedMembers = new ScopedMembers(new DualStringHashTable(this.dualGlobalValues, new StringHashTable';
var v27525 = v27526 + '()));\n            var dualGlobalScopedAmbientMembers = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalValues, new StringHashTable()));\n            var dualGlobalScopedEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualGlobalTypes, new StringHashTable()));\n            var dualGlobalScopedAmbientEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalTypes, new StringHashTable()));\n\n            this.globalScope = new SymbolScopeBuilder(dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, this.importedGlobals, null);\n\n            this.voidType = this.enterPrimitive(Primitive.Void, "void");\n            this.booleanType = this.enterPrimitive(Primitive.Boolean, "bool");\n            this.doubleType = this.enterPrimitive(Primitive.Double, "number");\n            this.importedGlobals.ambientEnclosedTypes.addPublicMember("number", this.doubleType.symbol);\n\n            this.stringType = this.enterPrimitive(Primitive.String, "string");\n            this.anyType = this.enterPrimitive(Primitive.Any, "any");\n            this.nullType = this.enterPrimitive(Primitive.Null, "null");\n            this.undefinedType = this.enterPrimitive(Primitive.Undefined, "undefined");\n\n            // shared global state is resident\n            this.setCollectionMode(TypeCheckCollectionMode.Resident);\n\n            this.wildElm = new TypeSymbol("_element", -1, 0, -1, new Type());\n            this.importedGlobalsTypeTable.addPublicMember(this.wildElm.name, this.wildElm);\n\n            this.mod = new ModuleType(dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes);\n            this.mod.members = dualGlobalScopedMembers;\n            this.mod.ambientMembers = dualGlobalScopedAmbientMembers;\n            this.mod.containedScope = this.globalScope;\n\n            this.gloMod = new TypeSymbol(globalId, -1, 0, -1, this.mod);\n            this.mod.members.addPublicMember(this.gloMod.name, this.gloMod);\n\n            this.defineGlobalValue("undefined", this.undefinedType);\n        }\n\n\n        public enterPrimitive(flags: number, name: string) {\n            var primitive = new Type();\n            primitive.primitiveTypeClass = flags;\n            var symbol = new TypeSymbol(name, -1, name.length, -1, primitive);\n            symbol.typeCheckStatus = TypeCheckStatus.Finished;\n            primitive.symbol = symbol;\n            this.importedGlobals.enter(null, null, symbol, this.errorReporter, true, true, true);\n            return primitive;\n        }\n\n        public setCollectionMode(mode: TypeCheckCollectionMode) {\n            this.residentTypeCheck =\n                this.dualGlobalValues.insertPrimary =\n                    this.dualGlobalTypes.insertPrimary =\n                        this.dualAmbientGlobalValues.insertPrimary =\n                            this.dualAmbientGlobalTypes.insertPrimary = mode == TypeCheckCollectionMode.Resident;\n        }\n\n        public refreshPersistentState() {\n            this.globals = new StringHashTable();\n            this.globalTypes = new StringHashTable();\n            this.ambientGlobals = new StringHashTable();\n            this.ambientGlobalTypes = new StringHashTable();\n\n            // add global types to the global scope\n            this.globalTypes.add(this.voidType.symbol.name, this.voidType.symbol);\n            this.globalTypes.add(this.booleanType.symbol.name, this.booleanType.symbol);\n            this.globalTypes.add(this.doubleType.symbol.name, this.doubleType.symbol);\n            this.globalTypes.add("number", this.doubleType.symbol);\n            this.globalTypes.add(this.stringType.symbol.name, this.stringType.symbol);\n            this.globalTypes.add(this.anyType.symbol.name, this.anyType.symbol);\n            this.globalTypes.add(this.nullType.symbol.name, this.nullType.symbol);\n            this.globalTypes.add(this.undefinedType.symbol.name, this.undefinedType.symbol);\n\n            this.dualGlobalValues.secondaryTable = this.globals;\n            this.dualGlobalTypes.secondaryTable = this.globalTypes;\n            this.dualAmbientGlobalValues.secondaryTable = this.ambientGlobals;\n            this.dualAmbientGlobalTypes.secondaryTable = this.ambientGlobalTypes;\n        }\n\n        public defineGlobalValue(name: string, type: Type) {\n            var valueLocation = new ValueLocation();\n            valueLocation.typeLink = new TypeLink();\n            var sym = new VariableSymbol(name, 0, -1, valueLocation);\n            sym.setType(type);\n            sym.typeCheckStatus = TypeCheckStatus.Finished;\n            sym.container = this.gloMod;\n            this.importedGlobalsTable.addPublicMember(name, sym);\n        }\n    }\n\n    export class ContextualTypeContext {\n        public targetSig: Signature = null;\n        public targetThis: Type = null;\n        public targetAccessorType: Type = null;\n\n        constructor (public contextualType: Type,\n            public provisional: bool, pu';
var v27524 = v27525 + 'blic contextID: number) { }\n    }\n\n    export class ContextualTypingContextStack {\n        private contextStack: ContextualTypeContext[] = [];\n        static contextID = TypeCheckStatus.Finished + 1;\n        public pushContextualType(type: Type, provisional: bool) { this.contextStack.push(new ContextualTypeContext(type, provisional, ContextualTypingContextStack.contextID++)); this.checker.errorReporter.pushToErrorSink = provisional; }\n        public hadProvisionalErrors = false; // somewhere in the chain a provisional typecheck error was thrown\n        public popContextualType() {\n            var tc = this.contextStack.pop();\n            this.checker.errorReporter.pushToErrorSink = this.isProvisional();\n            this.hadProvisionalErrors = this.hadProvisionalErrors || (tc.provisional && (this.checker.errorReporter.getCapturedErrors().length));\n            this.checker.errorReporter.freeCapturedErrors();\n            return tc;\n        }\n        public getContextualType(): ContextualTypeContext { return (!this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1]); }\n        public getContextID() { return (!this.contextStack.length ? TypeCheckStatus.Finished : this.contextStack[this.contextStack.length - 1].contextID); }\n        public isProvisional() { return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional); }\n\n        constructor (public checker: TypeChecker) { }\n    }\n\n    export class TypeChecker {\n        public errorReporter: ErrorReporter = null;\n        public globalScope: SymbolScope;\n\n        public checkControlFlow = false;\n        public printControlFlowGraph = false;\n        public checkControlFlowUseDef = false;\n        public styleSettings: StyleSettings = null;\n\n        public units: LocationInfo[] = null;\n\n        public voidType: Type;\n        public booleanType: Type;\n        public numberType: Type;\n        public stringType: Type;\n        public anyType: Type;\n        public nullType: Type;\n        public undefinedType: Type;\n\n        public anon = "_anonymous";\n\n        public globals: DualStringHashTable;\n        public globalTypes: DualStringHashTable;\n        public ambientGlobals: DualStringHashTable;\n        public ambientGlobalTypes: DualStringHashTable;\n        public gloModType: ModuleType;\n        public gloMod: TypeSymbol;\n        public wildElm: TypeSymbol;\n\n        public locationInfo: LocationInfo = null;\n        public typeFlow: TypeFlow = null;\n\n        public currentCompareA: Symbol = null;\n        public currentCompareB: Symbol = null;\n\n        public currentModDecl: ModuleDeclaration = null;\n\n        public inBind = false;\n        public inWith = false;\n        public errorsOnWith = true;\n\n        public typingContextStack: ContextualTypingContextStack;\n        public currentContextualTypeContext: ContextualTypeContext = null;\n\n        public resolvingBases = false;\n\n        public canCallDefinitionSignature = false;\n\n        public assignableCache: any[] = <any>{};\n        public subtypeCache: any[] = <any>{};\n        public identicalCache: any[] = <any>{};\n\n        public provisionalStartedTypecheckObjects: PhasedTypecheckObject[] = [];\n\n        public mustCaptureGlobalThis = false;\n\n        constructor (public persistentState: PersistentGlobalTypeState) {\n            this.voidType = this.persistentState.voidType;\n            this.booleanType = this.persistentState.booleanType;\n            this.numberType = this.persistentState.doubleType;\n            this.stringType = this.persistentState.stringType;\n            this.anyType = this.persistentState.anyType;\n            this.nullType = this.persistentState.nullType;\n            this.undefinedType = this.persistentState.undefinedType;\n\n            this.globals = this.persistentState.dualGlobalValues;\n            this.globalTypes = this.persistentState.dualGlobalTypes;\n            this.ambientGlobals = this.persistentState.dualAmbientGlobalValues;\n            this.ambientGlobalTypes = this.persistentState.dualAmbientGlobalTypes;\n            this.gloModType = this.persistentState.mod;\n            this.gloMod = this.persistentState.gloMod;\n            this.wildElm = this.persistentState.wildElm;\n\n            this.globalScope = this.persistentState.globalScope;\n\n            this.typingContextStack = new ContextualTypingContextStack(this);\n        }\n\n        public setStyleOptions(style: StyleSettings) {\n            this.styleSettings = style;\n        }\n\n        // Contextual typing\n        public setContextualType(type: Type, provisional: bool) {\n            this.typingContextStack.pushContextualType(type, provisional);\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\n        }\n\n        public unsetContextualType() {\n            var lastTC = this.typingContextStack.popContextualType();\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\n            return lastTC;\n   ';
var v27523 = v27524 + '     }\n\n        public hadProvisionalErrors() {\n            return this.typingContextStack.hadProvisionalErrors;\n        }\n        public resetProvisionalErrors() {\n            if (!this.typingContextStack.getContextualType()) {\n                this.typingContextStack.hadProvisionalErrors = false;\n            }\n        }\n\n        public typeCheckWithContextualType(contextType: Type, provisional: bool, condition: bool, ast: AST) {\n            if (condition) {\n                this.setContextualType(contextType, this.typingContextStack.isProvisional() || provisional);\n            }\n            this.typeFlow.typeCheck(ast);\n            if (condition) {\n                this.unsetContextualType();\n            }\n        }\n\n        public resetTargetType() {\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\n        }\n\n        // Unset the current contextual type without disturbing the stack, effectively "killing" the contextual typing process\n        public killCurrentContextualType() { this.currentContextualTypeContext = null; this.errorReporter.pushToErrorSink = false; }\n        public hasTargetType() { return this.currentContextualTypeContext && this.currentContextualTypeContext.contextualType; }\n        public getTargetTypeContext() { return this.currentContextualTypeContext; }\n\n        public inProvisionalTypecheckMode() {\n            return this.typingContextStack.isProvisional();\n        }\n\n        public getTypeCheckFinishedStatus() {\n            if (this.inProvisionalTypecheckMode()) {\n                return this.typingContextStack.getContextID();\n            }\n            return TypeCheckStatus.Finished;\n        }\n\n        public typeStatusIsFinished(status: TypeCheckStatus) {\n\n            return status == TypeCheckStatus.Finished ||\n                   (this.inProvisionalTypecheckMode() && status == this.typingContextStack.getContextID());\n        }\n\n        public addStartedPTO(pto: PhasedTypecheckObject) {\n            if (this.inProvisionalTypecheckMode()) {\n                this.provisionalStartedTypecheckObjects[this.provisionalStartedTypecheckObjects.length] = pto;\n            }\n        }\n\n        public cleanStartedPTO() {\n            for (var i = 0; i < this.provisionalStartedTypecheckObjects.length; i++) {\n                if (this.provisionalStartedTypecheckObjects[i].typeCheckStatus >= this.typingContextStack.getContextID()) {\n                    this.provisionalStartedTypecheckObjects[i].typeCheckStatus = TypeCheckStatus.NotStarted;\n                }\n            }\n            this.provisionalStartedTypecheckObjects = [];\n        }\n\n        // type collection      \n        public collectTypes(ast: AST): void {\n            if (ast.nodeType == NodeType.Script) {\n                var script = <Script>ast;\n                this.locationInfo = script.locationInfo;\n            }\n            var globalChain = new ScopeChain(this.gloMod, null, this.globalScope);\n            var context = new TypeCollectionContext(globalChain, this);\n            getAstWalkerFactory().walk(ast, preCollectTypes, postCollectTypes, null, context);\n        }\n\n        public makeArrayType(type: Type): Type {\n            if (type.arrayCache == null) {\n                type.arrayCache = new ArrayCache();\n                type.arrayCache.arrayType = new Type();\n                type.arrayCache.arrayType.elementType = type;\n                type.arrayCache.arrayType.symbol = type.symbol;\n            }\n            return type.arrayCache.arrayType;\n        }\n\n        public getParameterList(funcDecl: FuncDecl, container: Symbol): SignatureData {\n            var args = funcDecl.arguments;\n            var parameterTable = null;\n            var parameterBuilder = null;\n            var len = args.members.length;\n            var nonOptionalParams = 0;\n            var result: ParameterSymbol[] = [];\n\n            if (len > 0) {\n                parameterTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                parameterBuilder = new SymbolScopeBuilder(parameterTable, null, null, null, null, container);\n\n                for (var i = 0; i < len; i++) {\n                    var parameter = <ArgDecl>args.members[i];\n                    var paramDef = new ValueLocation();\n                    var parameterSymbol = new ParameterSymbol(parameter.id.text, parameter.minChar,\n                                                            this.locationInfo.unitIndex, paramDef);\n                    parameterSymbol.declAST = parameter;\n                    parameterSymbol.funcDecl = funcDecl;\n                    parameter.id.sym = parameterSymbol;\n                    parameter.sym = parameterSymbol;\n                    paramDef.symbol = parameterSymbol;\n                    paramDef.typeLink = getTypeLink(parameter.typeExpr, this, false);\n                    parameterBuilder.enter(null, parameter, parameterSymbol, this.errorReporter, true, false, false); // REVIEW: Shoul';
var v27522 = v27523 + "d this be entered into the private scope?\n                    result[result.length] = parameterSymbol;\n                    if (!parameter.isOptionalArg()) {\n                        nonOptionalParams++;\n                    }\n                }\n            }\n            return { parameters: result, nonOptionalParameterCount: nonOptionalParams };\n        }\n\n        // Create a signature for a function definition\n        //  (E.g., has a function body - function declarations, property declarations, lambdas)\n        public createFunctionSignature(funcDecl: FuncDecl, container: Symbol, scope: SymbolScope, overloadGroupSym: Symbol, addToScope: bool): Signature {\n\n            var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported) || container == this.gloMod;\n            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n            var isDefinition = hasFlag(funcDecl.fncFlags, FncFlags.Definition);\n            var isAmbient = hasFlag(funcDecl.fncFlags, FncFlags.Ambient);\n            var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;\n            var isGlobal = container == this.gloMod;\n\n            var signature: Signature = new Signature();\n            var isLambda = funcDecl.fncFlags & FncFlags.IsFunctionExpression;\n\n            // If a return type has been declared for the signature, set the type link.\n            // Otherwise:\n            //  if it's a signature, its type will be 'any'\n            //  if it's a definition, the return type will be inferred  \n            if (funcDecl.returnTypeAnnotation || isDefinition) {\n                signature.returnType = getTypeLink(funcDecl.returnTypeAnnotation, this, false);\n            }\n            else {\n                signature.returnType = new TypeLink();\n                signature.returnType.type = this.anyType;\n            }\n\n            signature.hasVariableArgList = funcDecl.variableArgList;\n\n            var sigData = this.getParameterList(funcDecl, container);\n\n            signature.parameters = sigData.parameters;\n            signature.nonOptionalParameterCount = sigData.nonOptionalParameterCount;\n\n            funcDecl.signature = signature;\n            signature.declAST = funcDecl;\n\n            var useOverloadGroupSym =\n                overloadGroupSym &&\n                overloadGroupSym.getType() &&\n                !overloadGroupSym.isAccessor() &&\n                (funcDecl.isSignature() || (isAmbient == hasFlag(overloadGroupSym.flags, SymbolFlags.Ambient)));\n\n            if (useOverloadGroupSym && isPrivate != hasFlag(overloadGroupSym.flags, SymbolFlags.Private)) {\n                this.errorReporter.simpleError(funcDecl, \"Public/Private visibility of overloads does not agree\");\n            }\n\n            var groupType = useOverloadGroupSym ? overloadGroupSym.getType() : new Type();\n\n            if (isConstructor) {\n                if (groupType.construct == null) {\n                    groupType.construct = new SignatureGroup();\n                }\n                groupType.construct.addSignature(signature);\n                groupType.construct.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.construct.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n            else if (funcDecl.isIndexerMember()) {\n                if (groupType.index == null) {\n                    groupType.index = new SignatureGroup();\n                    groupType.index.flags |= SignatureFlags.IsIndexer;\n                }\n\n                groupType.index.addSignature(signature);\n                groupType.index.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.index.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n            else {\n                if (groupType.call == null) {\n                    groupType.call = new SignatureGroup();\n                }\n                groupType.call.addSignature(signature);\n\n                groupType.call.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.call.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n\n            var instanceType = groupType.instanceType;\n\n            // Ensure that the function's symbol is properly configured\n            // (If there were overloads, we'll already have a symbol, otherwise we need to create one)\n            var funcName: string = null;\n\n            // Set the function's name:\n            //  In the case of anonymous or functions resulting from error\n            //  correction in the parser (isMissing() == true), we do not\n            //  want to set a function name, since they shouldn't be inserted\n            //  into the enclosing scope\n\n            // usedHint prevents functions bound to object literal fields from";
var v27521 = v27522 + " being added to the\n            // enclosing scope\n            var usedHint = false;\n            if (funcDecl.name && !funcDecl.name.isMissing()) {\n                funcName = funcDecl.name.text;\n            }\n            else if (funcDecl.hint) {\n                funcName = funcDecl.hint;\n                usedHint = true;\n            }\n\n            if (groupType.symbol == null) {\n                groupType.symbol =\n                    new TypeSymbol(funcName ? funcName : this.anon,\n                                    funcDecl.minChar, funcDecl.limChar - funcDecl.minChar,\n                                    this.locationInfo.unitIndex,\n                                    groupType);\n                if (!useOverloadGroupSym) {\n                    groupType.symbol.declAST = funcDecl;\n                }\n            }\n\n            // REVIEW: Are we missing any other flags?\n            if (isStatic) {\n                groupType.symbol.flags |= SymbolFlags.Static;\n            }\n\n            if (isAmbient) {\n                groupType.symbol.flags |= SymbolFlags.Ambient;\n            }\n\n            if (isPrivate) {\n                groupType.symbol.flags |= SymbolFlags.Private;\n            }\n\n            groupType.symbol.isMethod = funcDecl.isMethod();\n            if (groupType.symbol.isMethod) {\n                groupType.symbol.flags |= SymbolFlags.Property;\n            }\n\n            funcDecl.type = groupType;\n\n            // Add the function symbol to the appropriate scope\n            // if the funcDecl is a constructor, it will be added to the enclosing scope as a class\n            if (!isConstructor) {\n                // Add the function's symbol to its enclosing scope\n                if (funcName && !isLambda && !funcDecl.isAccessor() && !usedHint) {\n\n                    // REVIEW: We're not setting the isDecl flags for fuctions bound to object literal properties\n                    // so removing the isDefiniton clause would break object literals\n                    if (addToScope) {  // REVIEW: If we combine this with createFunctionDeclarationSignature, we'll need to broaden this for both decls and defs                      \n                        // if it's a static method, enter directly into the container's scope\n                        if (funcDecl.isMethod() && isStatic) {\n\n                            // REVIEW: What about private statics?\n                            if (!(<TypeSymbol>container).type.members.publicMembers.add(funcName, groupType.symbol)) {\n                                this.errorReporter.duplicateIdentifier(funcDecl, funcName);\n                            }\n\n                            groupType.symbol.container = container;\n                        } // REVIEW: Another check for overloads...\n                        else if (overloadGroupSym == null || (overloadGroupSym.declAST && !(<FuncDecl>overloadGroupSym.declAST).isOverload && (container.isType()))) {\n                            scope.enter(container, funcDecl, groupType.symbol, this.errorReporter, !isPrivate && (isExported || isStatic || isGlobal), false, isAmbient);\n                        }\n                    }\n                    else if (!funcDecl.isSpecialFn()) {\n                        groupType.symbol.container = container; // REVIEW: Set container for overloads or anonymous?\n                    }\n                }\n                else if (!funcDecl.isSpecialFn()) {\n                    groupType.symbol.container = container; // REVIEW: Set container for lambdas and accessors?\n                }\n            }\n\n            // If, say, a call signature overload was declared before the class type was, we want to reuse\n            // the type that's already been instantiated for the class type, rather than allocate a new one\n            if (useOverloadGroupSym) {\n                var overloadGroupType = overloadGroupSym ? overloadGroupSym.getType() : null;\n                var classType = groupType;\n\n                if (classType != overloadGroupType) {\n                    if (classType.construct == null) {\n                        if (overloadGroupType && overloadGroupType.construct) {\n                            classType.construct = overloadGroupType.construct;\n                        }\n                        else {\n                            classType.construct = new SignatureGroup();\n                        }\n                    }\n                    else if (overloadGroupType) {\n                        if (overloadGroupType.construct) {\n                            classType.construct.signatures.concat(overloadGroupType.construct.signatures);\n                        }\n                    }\n\n                    // sync call and index signatures as well, but don't allocate should they not\n                    // already exist\n                    if (overloadGroupType) {\n                        if (classType.call == null) {\n                            classType.call = overloadGroupType.call;\n                        }\n                ";
var v27520 = v27521 + '        else if (overloadGroupType.call) {\n                            classType.call.signatures.concat(overloadGroupType.call.signatures);\n                        }\n\n                        // if the function is not static, we need to add any call overloads onto the\n                        // instance type\'s call signature list\n                        if (!isStatic) {\n\n                            if (classType.instanceType == null) {\n                                classType.instanceType = overloadGroupType.instanceType;\n                            }\n\n                            var instanceType = classType.instanceType;\n\n                            if (instanceType) {\n                                if (instanceType.call == null) {\n                                    instanceType.call = overloadGroupType.call;\n                                }\n                                else if (overloadGroupType.call) {\n                                    instanceType.call.signatures.concat(overloadGroupType.call.signatures);\n                                }\n                            }\n                        }\n\n                        if (classType.index == null) {\n                            classType.index = overloadGroupType.index;\n                        }\n                        else if (overloadGroupType.index) {\n                            classType.index.signatures.concat(overloadGroupType.index.signatures);\n                        }\n                    }\n                }\n            }\n\n            return signature;\n        }\n\n        // Creates a new symbol for an accessor property\n        // Note that funcDecl.type.symbol and fgSym may not be the same (E.g., in the case of type collection)\n        public createAccessorSymbol(funcDecl: FuncDecl, fgSym: Symbol, enclosingClass: Type, addToMembers: bool, isClassProperty: bool, scope: SymbolScope, container: Symbol) {\n            var accessorSym: FieldSymbol = null\n            var sig = funcDecl.signature;\n            var nameText = funcDecl.name.text;\n            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n\n            if (fgSym == null) {\n                var field = new ValueLocation();\n                accessorSym = new FieldSymbol(nameText, funcDecl.minChar, this.locationInfo.unitIndex, false, field);\n                field.symbol = accessorSym;\n                accessorSym.declAST = funcDecl; // REVIEW: need to reset for getters and setters\n\n                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                    if (accessorSym.getter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");\n                    }\n                    accessorSym.getter = <TypeSymbol>sig.declAST.type.symbol;\n                }\n                else {\n                    if (accessorSym.setter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");\n                    }\n                    accessorSym.setter = <TypeSymbol>sig.declAST.type.symbol;\n                }\n\n                field.typeLink = getTypeLink(null, this, false);\n\n                // if it\'s static, enter it into the class\'s member list directly\n                if (addToMembers) {\n                    if (enclosingClass) {\n                        if (!enclosingClass.members.publicMembers.add(nameText, accessorSym)) {\n                            this.errorReporter.duplicateIdentifier(funcDecl, accessorSym.name);\n                        }\n                        accessorSym.container = enclosingClass.symbol;\n                    }\n                    else {\n                        this.errorReporter.simpleError(funcDecl, "Accessor property may not be added in this context");\n                    }\n                }\n                else {\n                    scope.enter(container, funcDecl, accessorSym, this.errorReporter, !isPrivate || isStatic, false, false);\n                }\n\n                // We set the flags here, instead of below, because the accessor symbol does not yet have a type\n                if (isClassProperty) {\n                    accessorSym.flags |= SymbolFlags.Property;\n                }\n                if (isStatic) {\n                    accessorSym.flags |= SymbolFlags.Static;\n                }\n\n                if (isPrivate) {\n                    accessorSym.flags |= SymbolFlags.Private;\n                }\n                else {\n                    accessorSym.flags |= SymbolFlags.Public;\n                }\n            }\n            else {\n                accessorSym = <FieldSymbol>(<any>fgSym);\n\n                if (isPrivate != hasFlag(accessorSym.flags, SymbolFlags.Private)) {\n                    this.errorReporter.simpleError(funcDecl, "Getter and setter accessors do not agree in visibility");\n                }\n\n                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n       ';
var v27519 = v27520 + '             if (accessorSym.getter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");\n                    }\n                    accessorSym.getter = <TypeSymbol>funcDecl.type.symbol;\n                }\n                else {\n                    if (accessorSym.setter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");\n                    }\n                    accessorSym.setter = <TypeSymbol>funcDecl.type.symbol;\n                }\n            }\n\n            return accessorSym;\n        }\n\n        public addBases(resultScope: SymbolAggregateScope, type: Type, baseContext: { base: string; baseId: number; }): void {\n            resultScope.addParentScope(new SymbolTableScope(type.members, type.ambientMembers, type.getAllEnclosedTypes(), type.getAllAmbientEnclosedTypes(), type.symbol));\n            var i = 0;\n            var parent: Type;\n            if (type.extendsList) {\n                for (var len = type.extendsList.length; i < len; i++) {\n                    parent = type.extendsList[i];\n                    if (baseContext.baseId == parent.typeID) {\n                        this.errorReporter.reportErrorFromSym(parent.symbol, "Type \'" + baseContext.base + "\' is recursively referenced as a base class of itself");\n                        parent.symbol.flags |= SymbolFlags.RecursivelyReferenced;\n                        break;\n                    }\n                    this.addBases(resultScope, parent, baseContext);\n                }\n            }\n        }\n\n        public scopeOf(type: Type): SymbolScope {\n            var resultScope = new SymbolAggregateScope(type.symbol);\n            var baseContext = { base: type.symbol && type.symbol.name ? type.symbol.name : "{}", baseId: type.typeID };\n            this.addBases(resultScope, type, baseContext);\n            return resultScope;\n        }\n\n        public lookupMemberTypeSymbol(containingType: Type, name: string): Symbol {\n            var symbol: Symbol = null;\n            if (containingType.containedScope) {\n                symbol = containingType.containedScope.find(name, false, true);\n            }\n            else if (containingType.members) {\n                symbol = containingType.members.allMembers.lookup(name);\n\n                if (symbol == null && containingType.ambientMembers) {\n                    symbol = containingType.ambientMembers.allMembers.lookup(name);\n                }\n            }\n            if (symbol == null) {\n                var typeMembers = containingType.getAllEnclosedTypes();\n                var ambientTypeMembers = containingType.getAllAmbientEnclosedTypes();\n                if (typeMembers) {\n                    symbol = typeMembers.allMembers.lookup(name);\n\n                    if (symbol == null && ambientTypeMembers) {\n                        symbol = ambientTypeMembers.allMembers.lookup(name);\n                    }\n\n                }\n            }\n            if (symbol && symbol.isType()) {\n                return symbol;\n            }\n            else {\n                return null;\n            }\n        }\n\n        public findSymbolForDynamicModule(idText: string, currentFileName: string, search: (id: string) =>Symbol): Symbol {\n            var originalIdText = idText;\n            var symbol = search(idText);\n           \n            if (symbol == null) {\n                // perhaps it\'s a dynamic module?\n                if (!symbol) {\n                    idText = swapQuotes(originalIdText);\n                    symbol = search(idText);\n                }\n\n                // Check the literal path first\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".ts";\n                    symbol = search(idText);\n                }\n\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".str";\n                    symbol = search(idText);\n                }\n\n                // Check check for .d.str\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".d.ts";\n                    symbol = search(idText);\n                }\n\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".d.str";\n                    symbol = search(idText);\n                }\n\n                // If the literal path doesn\'t work, begin the search\n                if (!symbol && !isRelative(originalIdText)) {\n                    // check the full path first, as this is the most likely scenario\n                    idText = originalIdText;\n\n                    var strippedIdText = stripQuotes(idText);\n\n                    // REVIEW: Technically, we shouldn\'t have to normalize here - we should normalize in addUnit.\n                    // Still, normalizing here alows any language services to be free of assumptions\n                    var path = getRootFilePath(switchToForwardSlashes(currentFileName));\n\n                    ';
var v27518 = v27519 + 'while (symbol == null && path != "") {\n                        idText = normalizePath(path + strippedIdText + ".ts");\n                        symbol = search(idText);\n\n                        // check for .str\n                        if (symbol == null) {\n                            idText = changePathToSTR(idText);\n                            symbol = search(idText);\n                        }\n\n                        // check for .d.ts\n                        if (symbol == null) {\n                            idText = changePathToDTS(idText);\n                            symbol = search(idText);\n                        }\n\n                        // check for .d.str\n                        if (symbol == null) {\n                            idText = changePathToDSTR(idText);\n                            symbol = search(idText);\n                        }\n\n                        if (symbol == null) {\n\t\t\t\t\t\t\tif(path === \'/\') {\n\t\t\t\t\t\t\t\tpath = \'\';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpath = normalizePath(path + "..");\n\t\t\t\t\t\t\t\tpath = path && path != \'/\' ? path + \'/\' : path;\n\t\t\t\t\t\t\t}\n                        }\n                    }\n                }\n            }\n\n            return symbol;\n        }\n\n        public resolveTypeMember(scope: SymbolScope, dotNode: BinaryExpression): Type {\n            var lhs = dotNode.operand1;\n            var rhs = dotNode.operand2;\n            var resultType = this.anyType;\n            var lhsType = this.anyType;\n\n            if (lhs && rhs && (rhs.nodeType == NodeType.Name)) {\n                if (lhs.nodeType == NodeType.Dot) {\n                    lhsType = this.resolveTypeMember(scope, <BinaryExpression>lhs);\n                }\n                else if (lhs.nodeType == NodeType.Name) {\n                    var identifier = <Identifier>lhs;\n                    var symbol = scope.find(identifier.text, false, true);\n                    if (symbol == null) {\n                        this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);\n                    }\n                    else if (symbol.isType()) {\n\n                        var typeSymbol = <TypeSymbol> symbol;\n\n                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name) {\n                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;\n                            var modSym = this.findSymbolForDynamicModule(modPath, this.locationInfo.filename, (id) => scope.find(id, false, true));\n                            if (modSym) {\n                                typeSymbol.type = modSym.getType();\n                            }\n                        }\n\n                        if (optimizeModuleCodeGen && symbol) {\n                            var symType = symbol.getType();\n                            // Once the type has been referenced outside of a type ref position, there\'s\n                            // no going back                        \n                            if (symType && typeSymbol.aliasLink && typeSymbol.onlyReferencedAsTypeRef) {\n\n                                var modDecl = <ModuleDeclaration>symType.symbol.declAST;\n                                if (modDecl && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic)) {\n                                    typeSymbol.onlyReferencedAsTypeRef = !this.resolvingBases;\n                                }\n                            }\n                        }\n                        if (!symbol.visible(scope, this)) {\n                            this.errorReporter.simpleError(lhs, "The symbol \'" + identifier.actualText + "\' is not visible at this point");\n                        }\n                        lhsType = symbol.getType();\n\n                        identifier.sym = symbol;\n                    }\n                    else {\n                        this.errorReporter.simpleError(lhs, "Expected type");\n                    }\n\n                }\n\n                // if the LHS type is a module alias, we won\'t be able to resolve it until\n                // typecheck type.  If this is called during binding, lhsType will be null\n                if (!lhsType) {\n                    lhsType = this.anyType;\n                }\n\n                if (lhsType != this.anyType) {\n                    var rhsIdentifier = <Identifier>rhs;\n                    var resultSymbol = this.lookupMemberTypeSymbol(lhsType, rhsIdentifier.text);\n                    if (resultSymbol == null) {\n                        resultType = this.anyType;\n                        this.errorReporter.simpleError(dotNode, "Expected type");\n                    }\n                    else {\n                        resultType = resultSymbol.getType();\n                        if (!resultSymbol.visible(scope, this)) {\n                            this.errorReporter.simpleError(lhs, "The symbol \'" + (<Identifier>rhs).actualText + "\' is not visible at this point");\n                        }\n                    }\n                    rhsIdentifier.sym =';
var v27517 = v27518 + ' resultType.symbol;\n                }\n            }\n            if (resultType.isClass()) {\n                resultType = resultType.instanceType;\n            }\n            return resultType;\n        }\n\n        public resolveFuncDecl(funcDecl: FuncDecl, scope: SymbolScope,\n            fgSym: TypeSymbol): Symbol {\n            var functionGroupSymbol = this.createFunctionSignature(funcDecl, scope.container, scope, fgSym, false).declAST.type.symbol;\n            var signatures: Signature[];\n            if (funcDecl.isConstructMember()) {\n                signatures = functionGroupSymbol.type.construct.signatures;\n            }\n            else if (funcDecl.isIndexerMember()) {\n                signatures = functionGroupSymbol.type.getInstanceType().index.signatures;\n            }\n            else {\n                signatures = functionGroupSymbol.type.call.signatures;\n            }\n\n            var signature = signatures[signatures.length - 1];\n            var len = signature.parameters.length;\n            for (var i = 0; i < len; i++) {\n                var paramSym: ParameterSymbol = signature.parameters[i];\n                this.resolveTypeLink(scope, paramSym.parameter.typeLink, true);\n            }\n\n            // If a vararg list is present, check that the type is an array type\n            if (len && funcDecl.variableArgList) {\n                if (!signature.parameters[len - 1].parameter.typeLink.type.elementType) {\n                    this.errorReporter.simpleErrorFromSym(signature.parameters[len - 1].parameter.symbol, "... parameter must have array type");\n                    signature.parameters[len - 1].parameter.typeLink.type = this.makeArrayType(signature.parameters[len - 1].parameter.typeLink.type);\n                }\n            }\n            this.resolveTypeLink(scope, signature.returnType,\n                            funcDecl.isSignature());\n            return functionGroupSymbol;\n        }\n\n        public resolveVarDecl(varDecl: VarDecl, scope: SymbolScope): Symbol {\n            var field = new ValueLocation();\n            var fieldSymbol =\n                new FieldSymbol(varDecl.id.text, varDecl.minChar, this.locationInfo.unitIndex,\n                                (varDecl.varFlags & VarFlags.Readonly) == VarFlags.None,\n                                field);\n            fieldSymbol.transferVarFlags(varDecl.varFlags);\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = varDecl;\n            field.typeLink = getTypeLink(varDecl.typeExpr, this, varDecl.init == null);\n            this.resolveTypeLink(scope, field.typeLink, true);\n            varDecl.sym = fieldSymbol;\n            varDecl.type = field.typeLink.type;\n            return fieldSymbol;\n        }\n\n        public resolveTypeLink(scope: SymbolScope, typeLink: TypeLink, supplyVar: bool): void {\n            var arrayCount = 0;\n            if (typeLink.type == null) {\n                var ast: AST = typeLink.ast;\n                if (ast) {\n                    while (typeLink.type == null) {\n                        switch (ast.nodeType) {\n                            case NodeType.Name:\n                                var identifier = <Identifier>ast;\n                                var symbol = scope.find(identifier.text, false, true);\n                                if (symbol == null) {\n                                    typeLink.type = this.anyType;\n                                    this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);\n                                }\n                                else if (symbol.isType()) {\n                                    if (!symbol.visible(scope, this)) {\n                                        this.errorReporter.simpleError(ast, "The symbol \'" + identifier.actualText + "\' is not visible at this point");\n                                    }\n                                    identifier.sym = symbol;\n                                    typeLink.type = symbol.getType();\n                                    if (typeLink.type) {\n                                        if (typeLink.type.isClass()) {\n                                            typeLink.type = typeLink.type.instanceType;\n                                        }\n                                    }\n                                    else {\n                                        typeLink.type = this.anyType;\n                                    }\n                                }\n                                else {\n                                    typeLink.type = this.anyType;\n                                    this.errorReporter.simpleError(ast, "Expected type");\n                                }\n                                break;\n                            case NodeType.Dot:\n                                typeLink.type = this.resolveTypeMember(scope, <BinaryExpression>ast);\n                                break;\n                            case NodeType.TypeRef:\n                       ';
var v27516 = v27517 + '         var typeRef = <TypeReference>ast;\n                                arrayCount = typeRef.arrayCount;\n                                ast = typeRef.term;\n                                if (ast == null) {\n                                    typeLink.type = this.anyType;\n                                }\n                                break;\n                            case NodeType.InterfaceDeclaration:\n                                var interfaceDecl = <InterfaceDeclaration>ast;\n                                var interfaceType = new Type();\n                                var interfaceSymbol = new TypeSymbol((<Identifier>interfaceDecl.name).text,\n                                                                   ast.minChar,\n                                                                   ast.limChar - ast.minChar,\n                                                                   this.locationInfo.unitIndex,\n                                                                   interfaceType);\n                                interfaceType.symbol = interfaceSymbol;\n                                interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n                                interfaceType.containedScope =\n                                    new SymbolTableScope(interfaceType.members, null, null, null,\n                                                         interfaceSymbol);\n\n                                interfaceType.containedScope.container = interfaceSymbol;\n                                interfaceType.memberScope = interfaceType.containedScope;\n\n                                var memberList = <ASTList>interfaceDecl.members;\n                                var props: AST[] = memberList.members;\n                                var propsLen = props.length;\n\n                                for (var j = 0; j < propsLen; j++) {\n                                    var propDecl = props[j];\n                                    var propSym: Symbol = null;\n                                    var addMember = true;\n                                    var id: Identifier = null;\n                                    if (propDecl.nodeType == NodeType.FuncDecl) {\n                                        var funcDecl = <FuncDecl>propDecl;\n                                        id = funcDecl.name;\n                                        propSym = interfaceType.members.allMembers.lookup(funcDecl.getNameText());\n                                        addMember = (propSym == null);\n                                        if (funcDecl.isSpecialFn()) {\n                                            addMember = false;\n                                            propSym = this.resolveFuncDecl(funcDecl, scope, interfaceSymbol);\n                                        }\n                                        else {\n                                            propSym = this.resolveFuncDecl(funcDecl, scope, <TypeSymbol>propSym);\n                                        }\n                                        funcDecl.type = (<TypeSymbol>propSym).type;\n                                    }\n                                    else {\n                                        id = (<VarDecl>propDecl).id;\n                                        propSym = this.resolveVarDecl(<VarDecl>propDecl, scope);\n\n                                        // Don\'t add the member if it was missing a name.  This \n                                        // generally just leads to cascading errors that make things\n                                        // more confusing for the user.\n                                        addMember = !id.isMissing();\n                                    }\n\n                                    if (addMember) {\n                                        if (id && hasFlag(id.flags, ASTFlags.OptionalName)) {\n                                            propSym.flags |= SymbolFlags.Optional;\n                                        }\n                                        if (!interfaceType.members.allMembers.add(propSym.name, propSym)) {\n                                            this.errorReporter.duplicateIdentifier(ast, propSym.name);\n                                        }\n                                    }\n                                }\n\n                                ast.type = interfaceType;\n                                typeLink.type = interfaceType;\n\n                                break;\n                            case NodeType.FuncDecl:\n                                var tsym = <TypeSymbol>this.resolveFuncDecl(<FuncDecl>ast, scope, null);\n                                typeLink.type = tsym.type;\n                                break;\n                            default:\n                                typeLink.type = this.anyType;\n                                this.errorReporter.simpleError(ast, "Expected type");\n                ';
var v27515 = v27516 + '                break;\n                        }\n                    }\n                }\n                for (var count = arrayCount; count > 0; count--) {\n                    typeLink.type = this.makeArrayType(typeLink.type);\n                }\n                if (supplyVar && (typeLink.type == null)) {\n                    typeLink.type = this.anyType;\n                }\n                if (typeLink.ast) {\n                    typeLink.ast.type = typeLink.type;\n                }\n            }\n            // else wait for type inference\n        }\n\n        public resolveBaseTypeLink(typeLink: TypeLink, scope: SymbolScope) {\n            this.resolvingBases = true;\n            this.resolveTypeLink(scope, typeLink, true);\n            this.resolvingBases = false;\n            var extendsType: Type = null;\n            if (typeLink.type.isClass()) {\n                extendsType = typeLink.type.instanceType;\n            }\n            else {\n                extendsType = typeLink.type;\n            }\n\n            return extendsType;\n        }\n\n        public findMostApplicableSignature(signatures: ApplicableSignature[], args: ASTList): { sig: Signature; ambiguous: bool; } {\n\n            if (signatures.length == 1) {\n                return { sig: signatures[0].signature, ambiguous: false };\n            }\n\n            var best: ApplicableSignature = signatures[0];\n            var Q: ApplicableSignature = null;\n            var AType: Type = null;\n            var PType: Type = null;\n            var QType: Type = null;\n            var ambiguous = false;\n\n            for (var qSig = 1; qSig < signatures.length; qSig++) {\n                Q = signatures[qSig];\n                var i = 0;\n                // find the better conversion\n                for (i = 0; args && i < args.members.length; i++) {\n                    AType = args.members[i].type;\n                    PType = i < best.signature.parameters.length ? best.signature.parameters[i].getType() : best.signature.parameters[best.signature.parameters.length - 1].getType().elementType;\n                    QType = i < Q.signature.parameters.length ? Q.signature.parameters[i].getType() : Q.signature.parameters[Q.signature.parameters.length - 1].getType().elementType;\n\n                    if (this.typesAreIdentical(PType, QType)) {\n                        continue;\n                    }\n                    else if (this.typesAreIdentical(AType, PType)) {\n                        break;\n                    }\n                    else if (this.typesAreIdentical(AType, QType)) {\n                        best = Q;\n                        break;\n                    }\n                    else if (this.sourceIsSubtypeOfTarget(PType, QType)) {\n                        break;\n                    }\n                    else if (this.sourceIsSubtypeOfTarget(QType, PType)) {\n                        best = Q;\n                        break;\n                    }\n                    else if (Q.hadProvisionalErrors) {\n                        break;\n                    }\n                    else if (best.hadProvisionalErrors) {\n                        best = Q;\n                        break;\n                    }\n                }\n\n                if (!args || i == args.members.length) {\n                    var collection: ITypeCollection = {\n                        getLength: () => { return 2; },\n                        setTypeAtIndex: (index: number, type: Type) => { }, // no contextual typing here, so no need to do anything\n                        getTypeAtIndex: (index: number) => { return index ? Q.signature.returnType.type : best.signature.returnType.type; } // we only want the "second" type - the "first" is skipped\n                    }\n                    var bct = this.findBestCommonType(best.signature.returnType.type, null, collection, true);\n                    ambiguous = !bct;\n                }\n                else {\n                    ambiguous = false;\n                }\n            }\n\n            return { sig: best.signature, ambiguous: ambiguous };\n        }\n\n        public getApplicableSignatures(signatures: Signature[], args: ASTList, comparisonInfo: TypeComparisonInfo): ApplicableSignature[] {\n\n            var applicableSigs: ApplicableSignature[] = [];\n            var memberType: Type = null;\n            var miss = false;\n            var cxt: ContextualTypeContext = null;\n            var hadProvisionalErrors = false;\n\n            for (var i = 0; i < signatures.length; i++) {\n                miss = false;\n\n                for (var j = 0; j < args.members.length; j++) {\n\n                    if (j >= signatures[i].parameters.length) {\n                        continue;\n                    }\n                    memberType = signatures[i].parameters[j].getType();\n\n                    // account for varargs\n                    if (signatures[i].declAST.variableArgList && (j >= signatures[i].nonOptionalParameterCount - 1) && memberType.isArray()) {\n                        memberType = mem';
var v27514 = v27515 + 'berType.elementType;\n                    }\n\n                    if (memberType == this.anyType) {\n                        continue;\n                    }\n                    else if (args.members[j].nodeType == NodeType.FuncDecl) {\n                        if (this.typeFlow.functionInterfaceType && memberType == this.typeFlow.functionInterfaceType) {\n                            continue;\n                        }\n                        if (!this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], true)) {\n                            // if it\'s just annotations that are blocking us, typecheck the function and add it to the list\n                            if (this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], false)) {\n                                this.typeFlow.typeCheck(args.members[j]);\n                                if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                                    break;\n                                }\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        else { // if it can be contextually typed, try it out...\n\n                            this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\n                            this.cleanStartedPTO();\n                            hadProvisionalErrors = this.hadProvisionalErrors();\n\n                            if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                                if (comparisonInfo) {\n                                    comparisonInfo.setMessage("Could not apply type \'" + memberType.getTypeName() + "\' to argument " + (j + 1) + ", which is of type \'" + args.members[j].type.getTypeName() + "\'");\n                                }\n                                miss = true;\n                            }\n\n                            // clean the type\n                            //if (hadProvisionalErrors) {\n                            //    cxt = this.currentContextualTypeContext;\n                            //    this.typeCheckWithContextualType(null, true, true, args.members[j]);\n                            //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\n                            //        miss = true;\n                            //    }\n                            //    this.cleanStartedPTO();\n                            //}\n\n                            this.resetProvisionalErrors();\n                            if (miss) {\n                                break;\n                            }\n                        }\n                    }\n                    else if (args.members[j].nodeType == NodeType.ObjectLit) {\n                        // now actually attempt to typecheck as the contextual type\n                        if (this.typeFlow.objectInterfaceType && memberType == this.typeFlow.objectInterfaceType) {\n                            continue;\n                        }\n\n                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\n                        this.cleanStartedPTO();\n                        hadProvisionalErrors = this.hadProvisionalErrors(); \n\n                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                            if (comparisonInfo) {\n                                comparisonInfo.setMessage("Could not apply type \'" + memberType.getTypeName() + "\' to argument " + (j + 1) + ", which is of type \'" + args.members[j].type.getTypeName() + "\'");\n                            }\n                            miss = true;\n                        }\n\n                        // clean the type\n                        //if (hadProvisionalErrors) {\n                        //    this.typeCheckWithContextualType(null, true, true, args.members[j]);\n\n                        //    // is the "cleaned" type even assignable?\n                        //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\n                        //        miss = true;\n                        //    }\n\n                        //    this.cleanStartedPTO();\n                        //}\n\n                        this.resetProvisionalErrors();\n                        if (miss) {\n                            break;\n                        }\n                    }\n                    else if (args.members[j].nodeType == NodeType.ArrayLit) {\n                        // attempt to contextually type the array literal\n                        if (this.typeFlow.arrayInterfaceType && memberType == this.typeFlow.arrayInterfaceType) {\n                            continue;\n                        }\n\n                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\n                        thi';
var v27513 = v27514 + 's.cleanStartedPTO();\n                        hadProvisionalErrors = this.hadProvisionalErrors(); \n\n                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                            if (comparisonInfo) {\n                                comparisonInfo.setMessage("Could not apply type \'" + memberType.getTypeName() + "\' to argument " + (j + 1) + ", which is of type \'" + args.members[j].type.getTypeName() + "\'");\n                            }\n                            break;\n                        }\n\n                        // clean the type\n                        //if (hadProvisionalErrors) {\n                        //    this.typeCheckWithContextualType(null, true, true, args.members[j]);\n                        //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\n                        //        miss = true;\n                        //    }\n\n                        //    this.cleanStartedPTO();\n                        //}\n\n                        this.resetProvisionalErrors();\n                        if (miss) {\n                            break;\n                        }\n                    }\n                }\n\n                if (j == args.members.length) {\n                    applicableSigs[applicableSigs.length] = { signature: signatures[i], hadProvisionalErrors: hadProvisionalErrors };\n                }\n                hadProvisionalErrors = false;\n            }\n\n            return applicableSigs;\n        }\n\n        public canContextuallyTypeFunction(candidateType: Type, funcDecl: FuncDecl, beStringent: bool): bool {\n\n            // in these cases, we do not attempt to apply a contextual type\n            //  RE: isInlineCallLiteral - if the call target is a function literal, we don\'t want to apply the target type\n            //  to its body - instead, it should be applied to its return type\n            if (funcDecl.isParenthesized ||\n                funcDecl.isMethod() ||\n                beStringent && funcDecl.returnTypeAnnotation ||\n                funcDecl.isInlineCallLiteral) {\n                return false;\n            }\n\n            beStringent = beStringent || (this.typeFlow.functionInterfaceType == candidateType);\n\n            // At this point, if we\'re not being stringent, there\'s no need to check for multiple call sigs\n            // or count parameters - we just want to unblock typecheck\n            if (!beStringent) {\n                return true;\n            }\n\n            // If we\'re coming from an in-scope typecheck, lambdas may not have had function signatures created for them\n            // REVIEW: Should we search out the overload group here?\n            if (!funcDecl.signature) {\n                this.createFunctionSignature(funcDecl, this.typeFlow.scope.container, this.typeFlow.scope, null, null);\n                this.typeFlow.typeCheck(funcDecl);\n            }\n\n            var signature = funcDecl.signature;\n            var paramLen = signature.parameters.length;\n\n            // Check that the argument declarations have no type annotations\n            for (var i = 0; i < paramLen; i++) {\n                var param = signature.parameters[i];\n                var symbol = <ParameterSymbol>param;\n                var argDecl = <ArgDecl>symbol.declAST;\n\n                // REVIEW: a valid typeExpr is a requirement for varargs,\n                // so we may want to revise our invariant\n                if (beStringent && argDecl.typeExpr) {\n                    return false;\n                }\n            }\n\n            if (candidateType.construct && candidateType.call) {\n                return false;\n            }\n\n            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;\n\n            if (!candidateSigs || candidateSigs.signatures.length > 1) {\n                return false;\n            }\n\n            // if we\'re here, the contextual type can be applied to the function\n            return true;\n        }\n\n        public canContextuallyTypeObjectLiteral(targetType: Type, objectLit: UnaryExpression): bool {\n\n            if (targetType == this.typeFlow.objectInterfaceType) {\n                return true;\n            }\n\n            var memberDecls = <ASTList>objectLit.operand;\n\n            if (!(memberDecls && targetType.memberScope)) {\n                return false;\n            }\n\n            var id: AST = null;\n            var targetMember: Symbol = null;\n            var text = "";\n            var foundSyms = {};\n\n            // Check that each property in the object literal is present in the target\n            // type\n            for (var i = 0; i < memberDecls.members.length; i++) {\n                id = (<BinaryExpression>memberDecls.members[i]).operand1;\n\n                if (id.nodeType == NodeType.Name) {\n                    text = (<Identifier>id).text;\n                }\n                else if (id.nodeType == NodeType.QString) {\n                    // TODO: set te';
var v27512 = v27513 + "xt to unescaped string\n                    var idText = (<StringLiteral>id).text;\n                    text = idText.substring(1, idText.length - 1);\n                }\n                else {\n                    return false;\n                }\n\n                targetMember = targetType.memberScope.find(text, true, false);\n\n                if (!targetMember) {\n                    return false;\n                }\n\n                foundSyms[text] = true;\n            }\n\n            // Check that all members in the target type are present in the object literal\n            var targetMembers = targetType.memberScope.getAllValueSymbolNames(true);\n\n            for (var i = 0; i < targetMembers.length; i++) {\n                var memberName = targetMembers[i];\n                var memberSym = targetType.memberScope.find(memberName, true, false);\n\n                if (!foundSyms[targetMembers[i]] &&\n                    !hasFlag(memberSym.flags, SymbolFlags.Optional)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        public widenType(t: Type) {\n            if (t == this.undefinedType || t == this.nullType) { // REVIEW: not isNullOrUndefinedType for perf reasons\n                return this.anyType;\n            }\n\n            return t;\n        }\n\n        public isNullOrUndefinedType(t: Type) {\n            return t == this.undefinedType || t == this.nullType;\n        }\n\n        public findBestCommonType(initialType: Type, targetType: Type, collection: ITypeCollection, acceptVoid:bool, comparisonInfo?: TypeComparisonInfo) {\n            var i = 0;\n            var len = collection.getLength();\n            var nlastChecked = 0;\n            var bestCommonType = initialType;\n\n            if (targetType) {\n                bestCommonType = bestCommonType ? bestCommonType.mergeOrdered(targetType, this, acceptVoid) : targetType;\n            }\n\n            // it's important that we set the convergence type here, and not in the loop,\n            // since the first element considered may be the contextual type\n            var convergenceType: Type = bestCommonType;\n\n            while (nlastChecked < len) {\n\n                for (i = 0; i < len; i++) {\n\n                    // no use in comparing a type against itself\n                    if (i == nlastChecked) {\n                        continue;\n                    }\n\n                    if (convergenceType && (bestCommonType = convergenceType.mergeOrdered(collection.getTypeAtIndex(i), this, acceptVoid, comparisonInfo))) {\n                        convergenceType = bestCommonType;\n                    }\n\n                    if (bestCommonType == this.anyType || bestCommonType == null) {\n                        break;\n                    }\n                    else if (targetType) { // set the element type to the target type\n                        collection.setTypeAtIndex(i, targetType);\n                    }\n                }\n\n                // use the type if we've agreed upon it\n                if (convergenceType && bestCommonType) {\n                    break;\n                }\n\n                nlastChecked++;\n                if (nlastChecked < len) {\n                    convergenceType = collection.getTypeAtIndex(nlastChecked);\n                }\n            }\n\n            return acceptVoid ? bestCommonType : (bestCommonType == this.voidType ? null : bestCommonType);\n        }\n\n        // Type Identity\n\n        public typesAreIdentical(t1: Type, t2: Type) {\n\n            // This clause will cover both primitive types (since the type objects are shared),\n            // as well as shared brands\n            if (t1 == t2) {\n                return true;\n            }\n\n            if (!t1 || !t2) {\n                return false;\n            }\n\n            if (t1.isClass() || t1.isClassInstance()) {\n                return false;\n            }\n\n            var comboId = (t2.typeID << 16) | t1.typeID;\n\n            if (this.identicalCache[comboId]) {\n                return true;\n            }\n\n            // If one is an enum, and they're not the same type, they're not identical\n            if ((t1.typeFlags & TypeFlags.IsEnum) || (t2.typeFlags & TypeFlags.IsEnum)) {\n                return false;\n            }\n\n            if (t1.isArray() || t2.isArray()) {\n                if (!(t1.isArray() && t2.isArray())) {\n                    return false;\n                }\n                this.identicalCache[comboId] = false;\n                var ret = this.typesAreIdentical(t1.elementType, t2.elementType);\n                if (ret) {\n                    this.subtypeCache[comboId] = true;\n                }\n                else {\n                    this.subtypeCache[comboId] = undefined;\n                }\n\n                return ret;\n            }\n\n            if (t1.primitiveTypeClass != t2.primitiveTypeClass) {\n                return false;\n            }\n\n            this.identicalCache[comboId] = false;\n\n            // properties are identical in na";
var v27511 = v27512 + "me, optionality, and type\n            // REVIEW: TypeChanges - The compiler does not currently check against the members of parent types!\n            // REVIEW: TypeChanges - What about ambientMembers?\n            if (t1.memberScope && t2.memberScope) {\n                var t1MemberKeys = t1.memberScope.getAllValueSymbolNames(true).sort();\n                var t2MemberKeys = t2.memberScope.getAllValueSymbolNames(true).sort();\n\n                if (t1MemberKeys.length != t2MemberKeys.length) {\n                    this.identicalCache[comboId] = undefined;\n                    return false;\n                }\n\n                var t1MemberSymbol: Symbol = null;\n                var t2MemberSymbol: Symbol = null;\n\n                var t1MemberType: Type = null;\n                var t2MemberType: Type = null;\n\n                for (var iMember = 0; iMember < t1MemberKeys.length; iMember++) {\n                    if (t1MemberKeys[iMember] != t2MemberKeys[iMember]) {\n                        this.identicalCache[comboId] = undefined;\n                        return false;\n                    }\n\n                    t1MemberSymbol = <Symbol>t1.memberScope.find(t1MemberKeys[iMember], false, false);\n                    t2MemberSymbol = <Symbol>t2.memberScope.find(t2MemberKeys[iMember], false, false);\n\n                    if ((t1MemberSymbol.flags & SymbolFlags.Optional) != (t2MemberSymbol.flags & SymbolFlags.Optional)) {\n                        this.identicalCache[comboId] = undefined;\n                        return false;\n                    }\n\n                    t1MemberType = t1MemberSymbol.getType();\n                    t2MemberType = t2MemberSymbol.getType();\n\n                    // catch the mutually recursive or cached cases\n                    if (t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.typeID << 16) | t1MemberType.typeID] != undefined)) {\n                        continue;\n                    }\n\n                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {\n                        this.identicalCache[comboId] = undefined;\n                        return false;\n                    }\n                }\n            }\n            else if (t1.memberScope || t2.memberScope) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            if (!this.signatureGroupsAreIdentical(t1.call, t2.call)) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            if (!this.signatureGroupsAreIdentical(t1.construct, t2.construct)) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            if (!this.signatureGroupsAreIdentical(t1.index, t2.index)) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            this.identicalCache[comboId] = true;\n            return true;\n        }\n\n        public signatureGroupsAreIdentical(sg1: SignatureGroup, sg2: SignatureGroup) {\n\n            // covers the null case\n            if (sg1 == sg2) {\n                return true;\n            }\n\n            // covers the mixed-null case\n            if (!sg1 || !sg2) {\n                return false;\n            }\n\n            if (sg1.signatures.length != sg2.signatures.length) {\n                return false;\n            }\n\n            var sig1: Signature = null;\n            var sig2: Signature = null;\n            var sigsMatch = false;\n\n            // The signatures in the signature group may not be ordered...\n            // REVIEW: Should definition signatures be required to be identical as well?\n            for (var iSig1 = 0; iSig1 < sg1.signatures.length; iSig1++) {\n                sig1 = sg1.signatures[iSig1];\n\n                for (var iSig2 = 0; iSig2 < sg2.signatures.length; iSig2++) {\n                    sig2 = sg2.signatures[iSig2];\n\n                    if (this.signaturesAreIdentical(sig1, sig2)) {\n                        sigsMatch = true;\n                        break;\n                    }\n                }\n\n                if (sigsMatch) {\n                    sigsMatch = false;\n                    continue;\n                }\n\n                // no match found for a specific signature\n                return false;\n            }\n\n            return true;\n        }\n\n        public signaturesAreIdentical(s1: Signature, s2: Signature) {\n\n            if (s1.hasVariableArgList != s2.hasVariableArgList) {\n                return false;\n            }\n\n            if (s1.nonOptionalParameterCount != s2.nonOptionalParameterCount) {\n                return false;\n            }\n\n            if (s1.parameters.length != s2.parameters.length) {\n                return false;\n            }\n\n            if (!this.typesAreIdentical(s1.returnType.type, s2.returnType.type)) {\n                return false;\n            }\n\n            for (var iParam = 0; iParam < s1.parameters.length; iParam++) {\n                if (!thi";
var v27510 = v27511 + "s.typesAreIdentical(s1.parameters[iParam].parameter.typeLink.type, s2.parameters[iParam].parameter.typeLink.type)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        // Subtyping and Assignment compatibility\n\n        public sourceIsSubtypeOfTarget(source: Type, target: Type, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, comparisonInfo); }\n        public signatureGroupIsSubtypeOfTarget(sg1: SignatureGroup, sg2: SignatureGroup, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, comparisonInfo); }\n        public signatureIsSubtypeOfTarget(s1: Signature, s2: Signature, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, comparisonInfo); }\n\n        public sourceIsAssignableToTarget(source: Type, target: Type, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, comparisonInfo); }\n        public signatureGroupIsAssignableToTarget(sg1: SignatureGroup, sg2: SignatureGroup, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, comparisonInfo); }\n        public signatureIsAssignableToTarget(s1: Signature, s2: Signature, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, comparisonInfo); }\n\n        public sourceIsRelatableToTarget(source: Type, target: Type, assignableTo: bool, comparisonCache: any, comparisonInfo: TypeComparisonInfo) {\n\n            // REVIEW: Does this check even matter?\n            //if (this.typesAreIdentical(source, target)) {\n            //    return true;\n            //}\n            if (source == target) {\n                return true;\n            }\n\n            // An error has already been reported in this case\n            if (!(source && target)) {\n                return true;\n            }\n\n            var comboId = (source.typeID << 16) | target.typeID;\n\n            // In the case of a 'false', we want to short-circuit a recursive typecheck\n            if (comparisonCache[comboId] != undefined) {\n                return true;\n            }\n\n            // this is one difference between subtyping and assignment compatibility\n            if (assignableTo) {\n                if (source == this.anyType || target == this.anyType) {\n                    return true;\n                }\n            }\n            else {\n                // This is one difference between assignment compatibility and subtyping\n                if (target == this.anyType) {\n                    return true;\n                }\n            }\n\n            if (source == this.undefinedType) {\n                return true;\n            }\n\n            if ((source == this.nullType) && (target != this.undefinedType && target != this.voidType)) {\n                return true;\n            }\n\n            // REVIEW: enum types aren't explicitly covered in the spec\n            if (target == this.numberType && (source.typeFlags & TypeFlags.IsEnum)) {\n                return true;\n            }\n            if (source == this.numberType && (target.typeFlags & TypeFlags.IsEnum)) {\n                return true;\n            }\n            if ((source.typeFlags & TypeFlags.IsEnum) || (target.typeFlags & TypeFlags.IsEnum)) {\n                return false;\n            }\n\n            if (source.isArray() || target.isArray()) {\n                if (!(source.isArray() && target.isArray())) {\n                    return false;\n                }\n                comparisonCache[comboId] = false;\n                var ret = this.sourceIsRelatableToTarget(source.elementType, target.elementType, assignableTo, comparisonCache, comparisonInfo);\n                if (ret) {\n                    comparisonCache[comboId] = true;\n                }\n                else {\n                    comparisonCache[comboId] = undefined;\n                }\n\n                return ret;\n            }\n\n            // this check ensures that we only operate on object types from this point forward,\n            // since the checks involving primitives occurred above\n            if (source.primitiveTypeClass != target.primitiveTypeClass) {\n\n                if (target.primitiveTypeClass == Primitive.None) {\n                    if (source == this.numberType && this.typeFlow.numberInterfaceType) {\n                        source = this.typeFlow.numberInterfaceType;\n                    }\n                    else if (source == this.stringType && this.typeFlow.stringInterfaceType) {\n                        source = this.typeFlow.stringInterfaceType;\n                    }\n                    else if (source == this.booleanType && this.typeFlow.booleanInterfaceType) {\n                        source = this.typeFlow.booleanInterfaceType;\n           ";
var v27509 = v27510 + '         }\n                    else {\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n\n            comparisonCache[comboId] = false;\n\n            if (source.hasBase(target)) {\n                comparisonCache[comboId] = true;\n                return true;\n            }\n\n            if (this.typeFlow.objectInterfaceType && target == this.typeFlow.objectInterfaceType) {\n                return true;\n            }\n\n            if (this.typeFlow.functionInterfaceType && (source.call || source.construct) && target == this.typeFlow.functionInterfaceType) {\n                return true;\n            }\n\n            // REVIEW: We should perhaps do this, though it wouldn\'t be quite right without generics support\n            //if (this.typeFlow.arrayInterfaceType && (source.index) && target == this.typeFlow.arrayInterfaceType) {\n            //    return true;\n            //}\n\n            // At this point, if the target is a class, but not the source or a parent of the source, bail\n            if (target.isClass() || target.isClassInstance()) {\n                comparisonCache[comboId] = undefined;\n                return false;\n            }\n\n            if (target.memberScope && source.memberScope) {\n                var mPropKeys = target.memberScope.getAllValueSymbolNames(true);\n                var mProp: Symbol = null;\n                var nProp: Symbol = null;\n                var mPropType: Type = null;\n                var nPropType: Type = null;\n                var inferenceSymbol: InferenceSymbol = null;\n\n                for (var iMProp = 0; iMProp < mPropKeys.length; iMProp++) {\n                    mProp = target.memberScope.find(mPropKeys[iMProp], false, false);\n                    nProp = source.memberScope.find(mPropKeys[iMProp], false, false);\n\n                    // methods do not have the "arguments" field\n                    if (mProp.name == "arguments" &&\n                        this.typeFlow.iargumentsInterfaceType &&\n                        (this.typeFlow.iargumentsInterfaceType.symbol.flags & SymbolFlags.CompilerGenerated) &&\n                        mProp.kind() == SymbolKind.Variable &&\n                        (<VariableSymbol>mProp).variable.typeLink.type == this.typeFlow.iargumentsInterfaceType) {\n                        continue;\n                    }\n\n                    if (mProp.isInferenceSymbol()) {\n                        inferenceSymbol = <InferenceSymbol>mProp;\n                        if (inferenceSymbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                            // REVIEW: TypeChanges: Does this ever really happen?  Maybe for out-of-order typecheck?\n                            this.typeFlow.typeCheck(mProp.declAST);\n                        }\n                    }\n                    mPropType = mProp.getType();\n\n                    if (!nProp) {\n                        // If it\'s not present on the type in question, look for the property on \'Object\'\n                        if (this.typeFlow.objectInterfaceType) {\n                            nProp = this.typeFlow.objectInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);\n                        }\n\n                        if (!nProp) {\n                            // Now, the property was not found on Object, but the type in question is a function, look\n                            // for it on function\n                            if (this.typeFlow.functionInterfaceType && (mPropType.call || mPropType.construct)) {\n                                nProp = this.typeFlow.functionInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);\n                            }\n\n                            // finally, check to see if the property is optional\n                            if (!nProp) {\n                                if (!(mProp.flags & SymbolFlags.Optional)) {\n                                    comparisonCache[comboId] = undefined;\n                                    if (comparisonInfo) { // only surface the first error\n                                        comparisonInfo.flags |= TypeRelationshipFlags.RequiredPropertyIsMissing;\n                                        comparisonInfo.addMessageToFront("Type \'" + source.getTypeName() + "\' is missing property \'" + mPropKeys[iMProp] + "\' from type \'" + target.getTypeName() + "\'");\n                                    }\n                                    return false;\n                                }\n                                else {\n                                    continue;\n                                }\n                            }\n                        }\n                    }\n\n                    if (nProp.isInferenceSymbol()) {\n                        inferenceSymbol = <InferenceSymbol>nProp;\n                        if (inferenceSymbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                            this.typeFlow.type';
var v27508 = v27509 + 'Check(nProp.declAST);\n                        }\n                    }\n\n\n                    nPropType = nProp.getType();\n\n                    // catch the mutually recursive or cached cases\n                    if (mPropType && nPropType && (comparisonCache[(nPropType.typeID << 16) | mPropType.typeID] != undefined)) {\n                        continue;\n                    }\n\n                    if (!this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, comparisonInfo)) {\n                        comparisonCache[comboId] = undefined;\n                        if (comparisonInfo) { // only surface the first error\n                            comparisonInfo.flags |= TypeRelationshipFlags.IncompatiblePropertyTypes;\n                            comparisonInfo.addMessageToFront("Types of property \'" + mProp.name + "\' of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        }\n                        return false;\n                    }\n                }\n            }\n\n            // check signature groups\n            if (source.call || target.call) {\n                if (!this.signatureGroupIsRelatableToTarget(source.call, target.call, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        if (source.call && target.call) {\n                            comparisonInfo.addMessageToFront("Call signatures of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        }\n                        else {\n                            var hasSig = target.call ? target.getTypeName() : source.getTypeName();\n                            var lacksSig = !target.call ? target.getTypeName() : source.getTypeName();\n                            comparisonInfo.setMessage("Type \'" + hasSig + "\' requires a call signature, but Type \'" + lacksSig + "\' lacks one");\n                        }\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;\n                    }\n                    comparisonCache[comboId] = undefined;\n                    return false;\n                }\n            }\n\n            if (source.construct || target.construct) {\n                if (!this.signatureGroupIsRelatableToTarget(source.construct, target.construct, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        if (source.construct && target.construct) {\n                            comparisonInfo.addMessageToFront("Construct signatures of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        }\n                        else {\n                            var hasSig = target.construct ? target.getTypeName() : source.getTypeName();\n                            var lacksSig = !target.construct ? target.getTypeName() : source.getTypeName();\n                            comparisonInfo.setMessage("Type \'" + hasSig + "\' requires a construct signature, but Type \'" + lacksSig + "\' lacks one");\n                        }\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;\n                    }\n                    comparisonCache[comboId] = undefined;\n                    return false;\n                }\n            }\n\n            if (target.index) {\n                var targetIndex = !target.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : target.index;\n                var sourceIndex = !source.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : source.index;\n\n                if (!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        comparisonInfo.addMessageToFront("Index signatures of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;\n                    }\n                    comparisonCache[comboId] = undefined;\n                    return false;\n                }\n            }\n\n            comparisonCache[comboId] = true;\n            return true;\n        }\n\n        // REVIEW: TypeChanges: Return an error context object so the user can get better diagnostic info\n        public signatureGroupIsRelatableToTarget(sourceSG: SignatureGroup, targetSG: SignatureGroup, assignableTo: bool, comparisonCache: any, comparisonInfo?: TypeComparisonInfo) {\n            if (sourceSG == targetSG) {\n                return true;\n            }\n\n            if (!(sourceSG && targetSG)) {\n                return false;\n            }\n\n            var mSig: Signature = null;\n            var nSig: Signature = null;\n            var foundMatch = false;\n\n            for (var iMSig = 0; ';
var v27507 = v27508 + 'iMSig < targetSG.signatures.length; iMSig++) {\n                mSig = targetSG.signatures[iMSig];\n\n                for (var iNSig = 0; iNSig < sourceSG.signatures.length; iNSig++) {\n                    nSig = sourceSG.signatures[iNSig];\n                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, comparisonInfo)) {\n                        foundMatch = true;\n                        break;\n                    }\n                }\n\n                if (foundMatch) {\n                    foundMatch = false;\n                    continue;\n                }\n                return false;\n            }\n\n            return true;\n        }\n\n        public signatureIsRelatableToTarget(sourceSig: Signature, targetSig: Signature, assignableTo: bool, comparisonCache: any, comparisonInfo?: TypeComparisonInfo) {\n\n            if (!sourceSig.parameters || !targetSig.parameters) {\n                return false;\n            }\n\n            var targetVarArgCount = targetSig.hasVariableArgList ? targetSig.nonOptionalParameterCount - 1 : targetSig.nonOptionalParameterCount;\n            var sourceVarArgCount = sourceSig.hasVariableArgList ? sourceSig.nonOptionalParameterCount - 1 : sourceSig.nonOptionalParameterCount;\n\n            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableArgList) {\n                if (comparisonInfo) {\n                    comparisonInfo.flags |= TypeRelationshipFlags.SourceSignatureHasTooManyParameters;\n                    comparisonInfo.addMessageToFront("Call signature expects " + targetVarArgCount + " or fewer parameters");\n                }\n                return false;\n            }\n\n            var sourceReturnType = sourceSig.returnType.type;\n            var targetReturnType = targetSig.returnType.type;\n\n            if (targetReturnType != this.voidType) {\n                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleReturnTypes;\n                        // No need to print this one here - it\'s printed as part of the signature error in sourceIsRelatableToTarget\n                        //comparisonInfo.addMessageToFront("Incompatible return types: \'" + sourceReturnType.getTypeName() + "\' and \'" + targetReturnType.getTypeName() + "\'");\n                    }\n                    return false;\n                }\n            }\n\n            var len = (sourceVarArgCount < targetVarArgCount && sourceSig.hasVariableArgList) ? targetVarArgCount : sourceVarArgCount;\n            var sourceParamType: Type = null;\n            var targetParamType: Type = null;\n            var sourceParamName = "";\n            var targetParamName = "";\n\n            for (var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {\n\n                if (!sourceSig.hasVariableArgList || iSource < sourceVarArgCount) {\n                    sourceParamType = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.typeLink.type;\n                    sourceParamName = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.symbol.name;\n                }\n                else if (iSource == sourceVarArgCount) {\n                    sourceParamType = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.typeLink.type;\n                    if (sourceParamType.elementType) {\n                        sourceParamType = sourceParamType.elementType;\n                    }\n                    sourceParamName = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.symbol.name;\n                }\n\n                if (iTarget < targetSig.parameters.length && iTarget < targetVarArgCount) {\n                    targetParamType = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.typeLink.type;\n                    targetParamName = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.symbol.name;\n                }\n                else if (targetSig.hasVariableArgList && iTarget == targetVarArgCount) {\n                    targetParamType = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.typeLink.type;\n                    if (targetParamType.elementType) {\n                        targetParamType = targetParamType.elementType;\n                    }\n                    targetParamName = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.symbol.name;\n                }\n\n                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, comparisonInfo) ||\n                        this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, comparisonInfo))) {\n\n                    if (comparisonInfo) {\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleParameterTypes;\n                    }\n                    return false;\n                }\n            }\n   ';
var v27506 = v27507 + '         return true;\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class Continuation {\n        public exceptionBlock = -1;\n        constructor (public normalBlock: number) { }\n    }\n\n    function getBaseTypeLinks(bases: ASTList, baseTypeLinks: TypeLink[]) {\n        if (bases) {\n            var len = bases.members.length;\n            if (baseTypeLinks == null) {\n                baseTypeLinks = new TypeLink[];\n            }\n            for (var i = 0; i < len; i++) {\n                var baseExpr = bases.members[i];\n                var name = baseExpr;\n                var typeLink = new TypeLink();\n                typeLink.ast = name;\n                baseTypeLinks[baseTypeLinks.length] = typeLink;\n            }\n        }\n        return baseTypeLinks;\n    }\n\n    function getBases(type: Type, typeDecl: TypeDeclaration) {\n        type.extendsTypeLinks = getBaseTypeLinks(typeDecl.extendsList, type.extendsTypeLinks);\n        type.implementsTypeLinks = getBaseTypeLinks(typeDecl.implementsList, type.implementsTypeLinks);\n    }\n\n    function addPrototypeField(classType: Type, ast: AST, context: TypeCollectionContext) {\n        var field = new ValueLocation();\n        field.typeLink = new TypeLink();\n        field.typeLink.ast = ast;\n        field.typeLink.type = classType.instanceType;\n\n        var fieldSymbol =\n            new FieldSymbol("prototype", ast.minChar,\n                            context.checker.locationInfo.unitIndex, true, field);\n        fieldSymbol.flags |= (SymbolFlags.Property | SymbolFlags.BuiltIn);\n        field.symbol = fieldSymbol;\n        fieldSymbol.declAST = ast;\n        classType.members.addPublicMember("prototype", fieldSymbol);\n    }\n\n    export function createNewConstructGroupForType(type: Type) {\n        var signature = new Signature();\n        signature.returnType = new TypeLink();\n        signature.returnType.type = type.instanceType;\n        signature.parameters = [];\n\n        type.construct = new SignatureGroup();\n        type.construct.addSignature(signature);     \n    }\n\n    export function cloneParentConstructGroupForChildType(child: Type, parent: Type) {\n        child.construct = new SignatureGroup();\n        var sig: Signature = null;\n\n        if (!parent.construct) {\n            createNewConstructGroupForType(parent);\n        }\n\n        for (var i = 0; i < parent.construct.signatures.length; i++) { \n            sig = new Signature();\n            sig.parameters = parent.construct.signatures[i].parameters;\n            sig.nonOptionalParameterCount = parent.construct.signatures[i].nonOptionalParameterCount;\n            sig.typeCheckStatus = parent.construct.signatures[i].typeCheckStatus;\n            sig.declAST = parent.construct.signatures[i].declAST;\n            sig.returnType = new TypeLink();\n            sig.returnType.type = child.instanceType;\n            child.construct.addSignature(sig);\n        }\n\n    }\n\n    export var globalId = "__GLO";\n\n    export interface IAliasScopeContext {\n        topLevelScope: ScopeChain;\n        members: IHashTable;\n        tcContext: TypeCollectionContext;\n    }\n\n    function findTypeSymbolInScopeChain(name: string, scopeChain: ScopeChain): Symbol {\n        var symbol = scopeChain.scope.find(name, false, true);\n\n        if (symbol == null && scopeChain.previous) {\n            symbol = findTypeSymbolInScopeChain(name, scopeChain.previous);\n        }\n\n        return symbol;\n    }\n\n    function findSymbolFromAlias(alias: AST, context: IAliasScopeContext): Symbol {\n        var symbol: Symbol = null;\n        switch (alias.nodeType) {\n            case NodeType.Name:\n                var name = (<Identifier>alias).text;\n                var isDynamic = isQuoted(name);\n\n                var findSym = (id: string) => {\n                    if (context.members) {\n                        return context.members.lookup(name);\n                    }\n                    else {\n                        return findTypeSymbolInScopeChain(name, context.topLevelScope);\n                    }\n                }\n\n                if (isDynamic) {\n                    symbol = context.tcContext.checker.findSymbolForDynamicModule(name, context.tcContext.script.locationInfo.filename, findSym);\n                }\n                else {\n                    symbol = findSym(name);\n                }\n\n                break;\n\n     ';
var v27505 = v27506 + "       case NodeType.Dot:\n                var dottedExpr = <BinaryExpression>alias;\n                var op1Sym = findSymbolFromAlias(dottedExpr.operand1, context);\n\n                if (op1Sym && op1Sym.getType()) {\n                    symbol = findSymbolFromAlias(dottedExpr.operand2, context);\n                }\n\n                break;\n\n            default:\n                break;\n        }\n\n        if (symbol) {\n            var symType = symbol.getType();\n            if (symType) {\n                var members = symType.members;\n                if (members) {\n                    context.members = members.publicMembers;\n                }\n            }\n        }\n\n        return symbol;\n    }\n\n    export function preCollectImportTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var typeSymbol: TypeSymbol = null;\n        var modType: ModuleType = null;\n        var importDecl = <ImportDeclaration>ast;\n\n        // REVIEW: technically, this call isn't strictly necessary, since we'll find the type during the call to resolveTypeMembers\n        var aliasedModSymbol = findSymbolFromAlias(importDecl.alias, { topLevelScope: scopeChain, members: null, tcContext: context });\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n\n        if (aliasedModSymbol) {\n            var aliasedModType = aliasedModSymbol.getType();\n\n            if (aliasedModType) {\n                modType = <ModuleType>aliasedModType;\n            }\n        }\n\n        typeSymbol = new TypeSymbol(importDecl.id.text, importDecl.id.minChar, importDecl.limChar - importDecl.minChar,\n                                    context.checker.locationInfo.unitIndex, modType);\n\n        typeSymbol.aliasLink = importDecl;\n\n        if (context.scopeChain.moduleDecl) {\n            typeSymbol.flags |= SymbolFlags.ModuleMember;\n            typeSymbol.declModule = context.scopeChain.moduleDecl;\n        }\n\n        typeSymbol.declAST = importDecl;\n        importDecl.id.sym = typeSymbol;\n        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                context.checker.errorReporter, isGlobal, true, false);\n        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                context.checker.errorReporter, isGlobal, false, false);\n        return true;\n    }\n\n    export function preCollectModuleTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n\n        var moduleDecl: ModuleDeclaration = <ModuleDeclaration>ast;\n\n        var isAmbient = hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient);\n        var isEnum = hasFlag(moduleDecl.modFlags, ModuleFlags.IsEnum);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);\n        var modName = (<Identifier>moduleDecl.name).text;\n\n        var isDynamic = isQuoted(modName);\n\n        var symbol = scopeChain.scope.findLocal(modName, false, false);\n        var typeSymbol: TypeSymbol = null;\n        var modType: ModuleType = null;\n        if ((symbol == null) || (symbol.kind() != SymbolKind.Type)) {\n\n            if (modType == null) {\n                var enclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                var ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);\n                if (isEnum) {\n                    modType.typeFlags |= TypeFlags.IsEnum;\n                }\n                modType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType.setHasImplementation();\n            }\n\n            typeSymbol = new TypeSymbol(modName, moduleDecl.name.minChar, modName.length,\n                                        context.checker.locationInfo.unitIndex, modType);\n            typeSymbol.isDynamic = isQuoted(moduleDecl.prettyName);\n\n            if (context.scopeChain.moduleDecl) {\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\n            }\n            typeSymbol.declAST = moduleDecl;\n            typeSymbol.prettyName = moduleDecl.prettyName;\n            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                    context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\n            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                    context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\n            modType.symbol = typeSymbol;\n        }\n        else {\n            if (symbol && symbol.declAST && symbol.";
var v27504 = v27505 + "declAST.nodeType != NodeType.ModuleDeclaration) {\n                context.checker.errorReporter.simpleError(moduleDecl, \"Conflicting symbol name for module '\" + modName + \"'\");\n            }\n            typeSymbol = <TypeSymbol>symbol;\n\n            // initialize new private scope for the type\n            var publicEnclosedTypes = typeSymbol.type.getAllEnclosedTypes().publicMembers;\n            var publicEnclosedTypesTable = (publicEnclosedTypes == null) ? new StringHashTable() : publicEnclosedTypes;\n            var enclosedTypes = new ScopedMembers(new DualStringHashTable(publicEnclosedTypesTable, new StringHashTable()));\n\n            var publicEnclosedAmbientTypes = typeSymbol.type.getAllAmbientEnclosedTypes().publicMembers;\n            var publicAmbientEnclosedTypesTable = (publicEnclosedAmbientTypes == null) ? new StringHashTable() : publicEnclosedAmbientTypes;\n            var ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(publicAmbientEnclosedTypesTable, new StringHashTable()));\n\n            var publicMembers = typeSymbol.type.members.publicMembers;\n            var publicMembersTable = (publicMembers == null) ? new StringHashTable() : publicMembers;\n            var members = new ScopedMembers(new DualStringHashTable(publicMembersTable, new StringHashTable()));\n\n            var publicAmbientMembers = typeSymbol.type.ambientMembers.publicMembers;\n            var publicAmbientMembersTable = (publicAmbientMembers == null) ? new StringHashTable() : publicAmbientMembers;\n            var ambientMembers = new ScopedMembers(new DualStringHashTable(publicAmbientMembersTable, new StringHashTable()));\n\n            modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);\n            if (isEnum) {\n                modType.typeFlags |= TypeFlags.IsEnum;\n            }\n            modType.members = members;\n            modType.ambientMembers = ambientMembers;\n            modType.setHasImplementation();\n            modType.symbol = typeSymbol;\n\n            typeSymbol.addLocation(moduleDecl.minChar);\n            typeSymbol.expansions.push(modType);\n            typeSymbol.expansionsDeclAST.push(moduleDecl);\n\n        }\n        if (context.scopeChain.moduleDecl) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n        // REVIEW: If multiple disparate module decls for the same module don't agree\n        // in export privileges, how should we handle it?\n        if (isExported) {\n            typeSymbol.flags |= SymbolFlags.Exported;\n        }\n        if ((context.scopeChain.moduleDecl) ||\n            (context.scopeChain.container == context.checker.gloMod)) {\n            typeSymbol.flags |= SymbolFlags.ModuleMember;\n        }\n\n        moduleDecl.mod = modType;\n        pushTypeCollectionScope(typeSymbol, modType.members,\n                                modType.ambientMembers,\n                                modType.enclosedTypes,\n                                modType.ambientEnclosedTypes,\n                                context, null, null, moduleDecl);\n\n        return true;\n    }\n\n    export function preCollectClassTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var classDecl = <ClassDeclaration>ast;\n\n        var classType: Type;\n        var instanceType: Type;\n        var typeSymbol: TypeSymbol = null;\n        var className = (<Identifier>classDecl.name).text;\n        var alreadyInScope = false;\n        var isAmbient = hasFlag(classDecl.varFlags, VarFlags.Ambient);\n        var isExported = hasFlag(classDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var containerMod = <TypeSymbol>scopeChain.container;\n        var foundValSymbol = false;\n\n        typeSymbol = <TypeSymbol>scopeChain.scope.findLocal(className, false, true);\n        \n        // check the value space, since an override may have been declared with the type's name\n        // REVIEW-CLASSES\n        if (!typeSymbol) {\n            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false);\n            \n            if (valTypeSymbol &&\n                valTypeSymbol.isType() &&\n                valTypeSymbol.declAST &&\n                valTypeSymbol.declAST.nodeType == NodeType.FuncDecl &&\n                (<FuncDecl>valTypeSymbol.declAST).isSignature()) {\n                \n                typeSymbol = <TypeSymbol>valTypeSymbol;\n                foundValSymbol = true;\n                \n                if (isExported) {\n                    typeSymbol.flags |= SymbolFlags.Exported;\n                }\n            \n                if (isAmbient) {\n                    typeSymbol.flags |= SymbolFlags.Ambient;\n                }                \n                \n                // the class was never entered into type space, so add it\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checke";
var v27503 = v27504 + "r.errorReporter, isExported || isGlobal, true, isAmbient);                \n            }\n        }\n        \n        if (typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl)) {\n            typeSymbol = null;\n        }\n\n        if (typeSymbol == null) {\n            var valueSymbol = scopeChain.scope.findLocal(className, false, false);\n            classType = new Type();\n            classType.setHasImplementation();\n            instanceType = new Type();\n            instanceType.setHasImplementation();\n            classType.instanceType = instanceType;\n            classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            addPrototypeField(classType, classDecl, context);\n            instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            instanceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            typeSymbol = new TypeSymbol(className, classDecl.name.minChar, className.length,\n                                        context.checker.locationInfo.unitIndex, classType);\n            typeSymbol.declAST = classDecl;\n            typeSymbol.instanceType = instanceType;\n            classType.symbol = typeSymbol;\n            instanceType.symbol = typeSymbol;\n\n            if (context.scopeChain.moduleDecl) {\n                context.scopeChain.moduleDecl.recordNonInterface();\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\n                typeSymbol.flags |= SymbolFlags.ModuleMember;\n            }\n\n            if (isExported) {\n                typeSymbol.flags |= SymbolFlags.Exported;\n            }\n            \n            if (isAmbient) {\n                typeSymbol.flags |= SymbolFlags.Ambient;\n            }\n\n            ast.type = classType;\n\n            // class in both name spaces (type for instance type; constructor representative in value space)\n            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\n\n            if (valueSymbol == null) {\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\n            }\n        }\n        else {                            \n            classType = typeSymbol.type;\n            \n            // If the instance type is null, a call overload was likely declared before the class constructor\n            if (classType.instanceType == null) {\n                classType.instanceType = new Type();\n                classType.instanceType.setHasImplementation();\n                classType.instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                classType.instanceType.symbol = classType.symbol;\n                classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            }\n            \n            instanceType = classType.instanceType;\n            ast.type = classType;\n        }\n        \n        // if the class has no declared constructor, either create a default signature or adapt \n        // it's base class's signature group\n        if (!classDecl.constructorDecl) {\n\n            if (typeSymbol && typeSymbol.declAST && typeSymbol.declAST.type && typeSymbol.declAST.type.call && !(<FuncDecl>typeSymbol.declAST).isOverload) {\n                context.checker.errorReporter.duplicateIdentifier(typeSymbol.declAST, typeSymbol.name);\n            }\n\n            createNewConstructGroupForType(classDecl.type);\n        }\n\n        classType.typeFlags |= TypeFlags.IsClass;\n        instanceType.typeFlags |= TypeFlags.IsClass;\n\n        getBases(instanceType, classDecl);\n        pushTypeCollectionScope(typeSymbol, instanceType.members, instanceType.ambientMembers, null, null,\n                                context, instanceType, classType, null);\n        return true;\n    }\n\n    export function preCollectInterfaceTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var interfaceDecl = <InterfaceDeclaration>ast;\n        var interfaceSymbol: TypeSymbol = null;\n        var interfaceType: Type = null;\n        var isExported = hasFlag(interfaceDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var alreadyInScope = true;\n\n        alreadyInScope = false;\n        var ";
var v27502 = v27503 + 'interfaceName = (<Identifier>interfaceDecl.name).text;\n        interfaceSymbol = <TypeSymbol>scopeChain.scope.findLocal(interfaceName, false, true);\n        if (interfaceSymbol == null) {\n            interfaceType = new Type();\n            interfaceSymbol = new TypeSymbol(interfaceName,\n                                        interfaceDecl.name.minChar,\n                                        interfaceName.length,\n                                        context.checker.locationInfo.unitIndex,\n                                        interfaceType);\n            interfaceType.symbol = interfaceSymbol;\n            // REVIEW: Shouldn\'t allocate another table for interface privates\n            interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            interfaceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            interfaceSymbol.declAST = interfaceDecl;\n            interfaceSymbol.declModule = context.scopeChain.moduleDecl;\n        }\n        else {\n            alreadyInScope = true;\n            interfaceType = interfaceSymbol.type;\n        }\n\n        if (!interfaceType) {\n            interfaceType = context.checker.anyType;\n        }\n\n        ast.type = interfaceType;\n        getBases(interfaceType, interfaceDecl);\n\n        if (isExported) {\n            interfaceSymbol.flags |= SymbolFlags.Exported;\n        }\n\n        if (context.scopeChain.moduleDecl) {\n            interfaceSymbol.flags |= SymbolFlags.ModuleMember;\n        }\n\n        if (!alreadyInScope) {\n            context.scopeChain.scope.enter(context.scopeChain.container, ast,\n                                            interfaceSymbol, context.checker.errorReporter, isGlobal || isExported, true, false); // REVIEW: Technically, interfaces should be ambient\n        }\n        pushTypeCollectionScope(interfaceSymbol, interfaceType.members, interfaceType.ambientMembers, null, null,\n                                context, interfaceType, null, null);\n        return true;\n    }\n\n    export function preCollectArgDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var argDecl = <ArgDecl>ast;\n        if (hasFlag(argDecl.varFlags, VarFlags.Public | VarFlags.Private)) {\n            var field = new ValueLocation();\n            var isPrivate = hasFlag(argDecl.varFlags, VarFlags.Private);\n            var fieldSymbol =\n                new FieldSymbol(argDecl.id.text, argDecl.id.minChar,\n                                context.checker.locationInfo.unitIndex,\n                                !hasFlag(argDecl.varFlags, VarFlags.Readonly),\n                                field);\n            fieldSymbol.transferVarFlags(argDecl.varFlags);\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = ast;\n            argDecl.parameterPropertySym = fieldSymbol;\n\n            context.scopeChain.scope.enter(context.scopeChain.container, ast,\n                                            fieldSymbol, context.checker.errorReporter, !isPrivate, false, false);\n\n            field.typeLink = getTypeLink(argDecl.typeExpr, context.checker, argDecl.init == null);\n            argDecl.sym = fieldSymbol;\n        }\n        return false;\n    }\n\n    export function preCollectVarDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var varDecl = <VarDecl>ast;\n        var isAmbient = hasFlag(varDecl.varFlags, VarFlags.Ambient);\n        var isExported = hasFlag(varDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var isProperty = hasFlag(varDecl.varFlags, VarFlags.Property);\n        var isStatic = hasFlag(varDecl.varFlags, VarFlags.Static);\n        var isPrivate = hasFlag(varDecl.varFlags, VarFlags.Private);\n        var isOptional = hasFlag(varDecl.id.flags, ASTFlags.OptionalName);\n\n        if (context.scopeChain.moduleDecl) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n        if (isProperty ||\n            isExported ||\n            (context.scopeChain.container == context.checker.gloMod) ||\n            context.scopeChain.moduleDecl) {\n            if (isAmbient) {\n                var existingSym =\n                    <FieldSymbol>scopeChain.scope.findLocal(varDecl.id.text, false, false);\n                if (existingSym) {\n                    varDecl.sym = existingSym;\n                    return false;\n                }\n            }\n\n            // Defensive error detection...\n            if (varDecl.id == null) {\n                context.checker.errorReporter.simpleError(varDecl, "Expected variable identifier at this location");\n                return false;\n            }\n\n            var field = new ValueLocation();\n            var fieldSymbol =\n                new FieldSymbol(varDecl.id.text, varDecl.id.minChar,\n         ';
var v27501 = v27502 + '                       context.checker.locationInfo.unitIndex,\n                                (varDecl.varFlags & VarFlags.Readonly) == VarFlags.None,\n                                field);\n            fieldSymbol.transferVarFlags(varDecl.varFlags);\n            if (isOptional) {\n                fieldSymbol.flags |= SymbolFlags.Optional;\n            }\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = ast;\n            if ((context.scopeChain.moduleDecl) ||\n                (context.scopeChain.container == context.checker.gloMod)) {\n                fieldSymbol.flags |= SymbolFlags.ModuleMember;\n                fieldSymbol.declModule = context.scopeChain.moduleDecl;\n            }\n\n            // if it\'s static, enter it into the class\'s member list directly\n            if (hasFlag(varDecl.varFlags, VarFlags.Property) && isStatic && context.scopeChain.classType) {\n                if (!context.scopeChain.classType.members.publicMembers.add(varDecl.id.text, fieldSymbol)) {\n                    context.checker.errorReporter.duplicateIdentifier(ast, fieldSymbol.name);\n                }\n                fieldSymbol.container = context.scopeChain.classType.symbol;\n            }\n            else {\n                context.scopeChain.scope.enter(context.scopeChain.container,\n                                                ast,\n                                                fieldSymbol,\n                                                context.checker.errorReporter,\n                                                !isPrivate && (isProperty || isExported || isGlobal || isStatic),\n                                                false,\n                                                isAmbient);\n            }\n\n            if (hasFlag(varDecl.varFlags, VarFlags.Exported)) {\n                fieldSymbol.flags |= SymbolFlags.Exported;\n            }\n\n            field.typeLink = getTypeLink(varDecl.typeExpr, context.checker,\n                                        varDecl.init == null);\n            varDecl.sym = fieldSymbol;\n        }\n        return false;\n    }\n\n    export function preCollectFuncDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n\n        // REVIEW: This will have to change when we move to "export"\n        if (context.scopeChain.moduleDecl) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n\n        var funcDecl = <FuncDecl>ast;\n        var fgSym: TypeSymbol = null;\n        var nameText = funcDecl.getNameText();\n        var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported);\n        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n        var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n        var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;\n        var containerSym:TypeSymbol = <TypeSymbol> (((funcDecl.isMethod() && isStatic) || funcDecl.isAccessor()) && context.scopeChain.classType ? context.scopeChain.classType.symbol : context.scopeChain.container);\n        var containerScope: SymbolScope = context.scopeChain.scope;\n        var isGlobal = containerSym == context.checker.gloMod;\n        var isOptional = funcDecl.name && hasFlag(funcDecl.name.flags, ASTFlags.OptionalName);\n        var go = false;\n        var foundSymbol = false; \n\n        // If this is a class constructor, the "container" is actually the class declaration\n        if (isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n            containerSym = <TypeSymbol>containerSym.container;\n            containerScope = scopeChain.previous.scope;\n        }\n\n        funcDecl.unitIndex = context.checker.locationInfo.unitIndex;\n        \n        // If the parent is the constructor, and this isn\'t an instance method, skip it.\n        // That way, we\'ll set the type during scope assignment, and can be sure that the\n        // function will be placed in the constructor-local scope\n        if (!funcDecl.isConstructor &&\n            containerSym &&\n            containerSym.declAST &&\n            containerSym.declAST.nodeType == NodeType.FuncDecl &&\n            (<FuncDecl>containerSym.declAST).isConstructor &&\n            !funcDecl.isMethod()) {\n            return go;\n        }        \n\n        // Interfaces and overloads\n        if (hasFlag(funcDecl.fncFlags, FncFlags.Signature)) {\n            var instType = context.scopeChain.thisType;                       \n\n            // If the function is static, search in the class type\'s\n            if (nameText && nameText != "__missing") {\n                if (isStatic) {\n                    fgSym = containerSym.type.members.allMembers.lookup(nameText);\n                }\n                else {\n                    // REVIEW: This logic should be symmetric with preCollectClassTypes\n                    fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, false);\n                    \n                 ';
var v27500 = v27501 + "   // If we could not find the function symbol in the value context, look\n                    // in the type context.\n                    // This would be the case, for example, if a class constructor override\n                    // were declared before a call override for a given class\n                    if (fgSym == null) {\n                        fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, true);\n                    }\n                }\n                \n                if (fgSym) {\n                    foundSymbol = true;\n                    \n                    // We'll combine ambient and non-ambient funcdecls during typecheck (for contextual typing).,\n                    // So, if they don't agree, don't use the symbol we've found                    \n                    if (!funcDecl.isSignature() && (hasFlag(funcDecl.fncFlags, FncFlags.Ambient) != hasFlag(fgSym.flags, SymbolFlags.Ambient))) {\n                       fgSym = null;\n                    }\n                }                \n            }\n            \n            // a function with this symbol has not yet been declared in this scope\n            // REVIEW: In the code below, we need to ensure that only function overloads are considered\n            //  (E.g., if a vardecl has the same id as a function or class, we may use the vardecl symbol\n            //  as the overload.)  Defensively, however, the vardecl won't have a type yet, so it should\n            //  suffice to just check for a null type when considering the overload symbol in\n            //  createFunctionSignature\n            if (fgSym == null) {\n                if (!(funcDecl.isSpecialFn())) {                    \n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, null, !foundSymbol).declAST.type.symbol;\n                }\n                else {\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, containerSym, false).declAST.type.symbol;                                                                         \n                }\n                \n                // set the symbol's declAST, which will point back to the first declaration (symbol or otherwise)\n                // related to this symbol\n                if (fgSym.declAST == null || !funcDecl.isSpecialFn()) {\n                    fgSym.declAST = ast;\n                }\n            }\n            else { // there exists a symbol with this name\n                \n                if ((fgSym.kind() == SymbolKind.Type)) {\n\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, false).declAST.type.symbol;\n                }\n                else {\n                    context.checker.errorReporter.simpleError(funcDecl, \"Function or method '\" + funcDecl.name.actualText + \"' already declared as a property\");\n                }\n            }\n         \n            if (funcDecl.isSpecialFn() && !isStatic) {\n                funcDecl.type = instType ? instType : fgSym.type; \n            }\n            else {\n                funcDecl.type = fgSym.type;\n            }            \n        }\n        else {\n            // declarations\n            \n            if (nameText) {\n                if (isStatic) {\n                    fgSym = containerSym.type.members.allMembers.lookup(nameText);\n                }\n                else {\n                    // in the constructor case, we want to check the parent scope for overloads\n                    if (funcDecl.isConstructor && context.scopeChain.previous) {\n                        fgSym = <TypeSymbol>context.scopeChain.previous.scope.findLocal(nameText, false, false);\n                    }\n                    \n                    if (fgSym == null) {\n                        fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, false);\n                    }\n                }\n                if (fgSym) {\n                    foundSymbol = true;\n                    \n                    if (!isConstructor && fgSym.declAST.nodeType == NodeType.FuncDecl && !(<FuncDecl>fgSym.declAST).isAccessor() && !(<FuncDecl>fgSym.declAST).isSignature()) {\n                        fgSym = null;\n                        foundSymbol = false;\n                    }\n                }                \n            }\n\n            // REVIEW: Move this check into the typecheck phase?  It's only being run over properties...\n            if (fgSym &&\n                !fgSym.isAccessor() &&\n                fgSym.type &&\n                fgSym.type.construct &&\n                fgSym.type.construct.signatures != [] &&\n                (fgSym.type.construct.signatures[0].declAST == null ||\n                    !hasFlag(fgSym.type.construct.signatures[0].declAST.fncFlags, FncFlags.Ambient)) &&\n                !funcDecl.isConstructor) {\n                context.checker.errorReporter.simpleError(funcDecl, \"Functions may not have class overloads\");\n            }\n\n   ";
var v27499 = v27500 + '         if (fgSym && !(fgSym.kind() == SymbolKind.Type) && funcDecl.isMethod() && !funcDecl.isAccessor() && !funcDecl.isConstructor) {\n                context.checker.errorReporter.simpleError(funcDecl, "Function or method \'" + funcDecl.name.actualText + "\' already declared as a property");\n                fgSym.type = context.checker.anyType;\n            }\n            var sig = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, !foundSymbol);\n\n            // it\'s a getter or setter function                                   \n            if (((!fgSym || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || (fgSym && fgSym.isAccessor())) {\n                funcDecl.accessorSymbol = context.checker.createAccessorSymbol(funcDecl, fgSym, containerSym.type, (funcDecl.isMethod() && isStatic), true, containerScope, containerSym);\n            }\n\n            funcDecl.type.symbol.declAST = ast;\n            if (funcDecl.isConstructor) { // REVIEW: Remove when classes completely replace oldclass\n                go = true;\n            };\n        }\n        if (isExported) {\n            if (funcDecl.type.call) {\n                funcDecl.type.symbol.flags |= SymbolFlags.Exported;\n            }\n            \n            // Accessors are set to \'exported\' above\n            if (fgSym && !fgSym.isAccessor() && fgSym.kind() == SymbolKind.Type && fgSym.type.call) {\n                fgSym.flags |= SymbolFlags.Exported;\n            }\n        }\n        if (context.scopeChain.moduleDecl && !funcDecl.isSpecialFn()) {\n            funcDecl.type.symbol.flags |= SymbolFlags.ModuleMember;\n            funcDecl.type.symbol.declModule = context.scopeChain.moduleDecl;\n        }\n\n        if (fgSym && isOptional) {\n            fgSym.flags |= SymbolFlags.Optional;\n        }\n\n        return go;\n    }\n\n    export function preCollectTypes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context: TypeCollectionContext = walker.state;\n        var go = false;\n        var scopeChain = context.scopeChain;\n\n        if (ast.nodeType == NodeType.Script) {\n            var script: Script = <Script>ast;\n            context.script = script;\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.List) {\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.ImportDeclaration) {\n            go = preCollectImportTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.With) {\n            go = false;\n        }\n        else if (ast.nodeType == NodeType.ModuleDeclaration) {\n            go = preCollectModuleTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.ClassDeclaration) {\n            go = preCollectClassTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.Block) {\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n            go = preCollectInterfaceTypes(ast, parent, context);\n        }\n        // This will be a constructor arg because this pass only traverses\n        // constructor arg lists\n        else if (ast.nodeType == NodeType.ArgDecl) {\n            go = preCollectArgDeclTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.VarDecl) {\n            go = preCollectVarDeclTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.FuncDecl) {\n            go = preCollectFuncDeclTypes(ast, parent, context);\n        }\n        else {\n            if (ast.isStatementOrExpression() && context.scopeChain.moduleDecl) {\n                context.scopeChain.moduleDecl.recordNonInterface();\n            }\n        }\n        walker.options.goChildren = go;\n        return ast;\n    }\n\n    export function postCollectTypes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context: TypeCollectionContext = walker.state;\n\n        if (ast.nodeType == NodeType.ModuleDeclaration) {\n            popTypeCollectionScope(context);\n        }\n        else if (ast.nodeType == NodeType.ClassDeclaration) {\n            popTypeCollectionScope(context);\n        }\n        else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n            popTypeCollectionScope(context);\n        }\n        return ast;\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class ScopeChain {\n        ';
var v27498 = v27499 + "public thisType: Type;\n        public classType: Type;\n        public fnc: FuncDecl;\n        public moduleDecl: ModuleDeclaration;\n\n        constructor (public container: Symbol, public previous: ScopeChain,\n                     public scope: SymbolScope) { }\n    }\n\n    export class BBUseDefInfo {\n        public defsBySymbol = new bool[];\n        public gen: BitVector;\n        public kill: BitVector;\n        public top: BitVector;\n        // use lists by symbol \n        public useIndexBySymbol = new number[][];\n\n        constructor (public bb: BasicBlock) { }\n\n        public updateTop() {\n            var temp = new BitVector(this.top.bitCount);\n            for (var i = 0, succLen = this.bb.successors.length; i < succLen; i++) {\n                var succ = this.bb.successors[i];\n                if (succ.useDef) {\n                    temp.union(succ.useDef.top);\n                }\n            }\n            temp.difference(this.kill);\n            temp.union(this.gen);\n            var changed = temp.notEq(this.top);\n            this.top = temp;\n            return changed;\n        }\n\n\n        public initialize(useDefContext: UseDefContext) {\n            var defSym = (sym: Symbol, context: UseDefContext) => {\n                if (context.isLocalSym(sym)) {\n                    var index = context.getSymbolIndex(sym);\n                    // clear pending uses\n                    this.useIndexBySymbol[index] = new number[];\n                    this.defsBySymbol[index] = true;\n                }\n            }\n\n            var useSym = (sym: Symbol, context: UseDefContext, ast: AST) => {\n                if (context.isLocalSym(sym)) {\n                    var symIndex = context.getSymbolIndex(sym);\n                    if (this.useIndexBySymbol[symIndex] == undefined) {\n                        this.useIndexBySymbol[symIndex] = new number[];\n                    }\n                    var symUses = this.useIndexBySymbol[symIndex];\n                    var astIndex = context.getUseIndex(ast);\n                    context.addUse(symIndex, astIndex);\n                    symUses.push(astIndex);\n                }\n            }\n\n            function initUseDefPre(cur: AST, parent: AST, walker: IAstWalker) {\n                var context: UseDefContext = walker.state;\n                if (cur == null) {\n                    cur = null;\n                }\n                if (cur.nodeType == NodeType.VarDecl) {\n                    var varDecl = <BoundDecl>cur;\n                    if (varDecl.init || hasFlag(varDecl.varFlags, VarFlags.AutoInit)) {\n                        defSym(varDecl.sym, context);\n                    }\n                }\n                else if (cur.nodeType == NodeType.Name) {\n                    // use\n                    if (parent) {\n                        if (parent.nodeType == NodeType.Asg) {\n                            var asg = <BinaryExpression>parent;\n                            if (asg.operand1 == cur) {\n                                return cur;\n                            }\n                        }\n                        else if (parent.nodeType == NodeType.VarDecl) {\n                            var parentDecl = <BoundDecl>parent;\n                            if (parentDecl.id == cur) {\n                                return cur;\n                            }\n                        }\n                    }\n                    var id = <Identifier>cur;\n                    useSym(id.sym, context, cur);\n                }\n                else if ((cur.nodeType >= NodeType.Asg) && (cur.nodeType <= NodeType.LastAsg)) {\n                    // def\n                    var asg = <BinaryExpression>cur;\n                    if (asg.operand1 && (asg.operand1.nodeType == NodeType.Name)) {\n                        var id = <Identifier>asg.operand1;\n                        defSym(id.sym, context);\n                    }\n                }\n                else if (cur.nodeType == NodeType.FuncDecl) {\n                    walker.options.goChildren = false;\n                }\n\n                return cur;\n            }\n\n            var options = new AstWalkOptions();\n            // traverse ASTs in reverse order of execution (to match uses with preceding defs)\n            options.reverseSiblings = true;\n\n            getAstWalkerFactory().walk(this.bb.content, initUseDefPre, null, options, useDefContext);\n        }\n\n        public initializeGen(useDefContext: UseDefContext) {\n            var symbolLen = this.useIndexBySymbol.length;\n            var bitCount = useDefContext.uses.length;\n            this.gen = new BitVector(bitCount);\n            for (var s = 0; s < symbolLen; s++) {\n                var symUses = this.useIndexBySymbol[s];\n                if ((symUses != undefined) && (symUses.length > 0)) {\n                    for (var u = 0, uLen = symUses.length; u < uLen; u++) {\n                        this.gen.set(symUses[u], true);\n                    }\n                }\n            }\n            this.top = this.gen;\n        }\n\n     ";
var v27497 = v27498 + "   public initializeKill(useDefContext: UseDefContext) {\n            this.kill = new BitVector(this.gen.bitCount);\n            for (var s = 0, symbolLen = this.defsBySymbol.length; s < symbolLen; s++) {\n                if (this.defsBySymbol[s]) {\n                    var globalSymUses = useDefContext.useIndexBySymbol[s];\n                    if (globalSymUses) {\n                        for (var u = 0, useLen = globalSymUses.length; u < useLen; u++) {\n                            this.kill.set(globalSymUses[u], true);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    export class UseDefContext {\n        // global use lists by symbol\n        public useIndexBySymbol = new number[][];\n        // global list of uses (flat)\n        public uses = new AST[];\n        public symbols = new VariableSymbol[];\n        public symbolMap = new StringHashTable();\n        public symbolCount = 0;\n        public func: Symbol;\n\n        constructor () {\n        }\n\n        public getSymbolIndex(sym: Symbol) {\n            var name = sym.name;\n            var index = <number>(this.symbolMap.lookup(name));\n            if (index == null) {\n                index = this.symbolCount++;\n                this.symbols[index] = <VariableSymbol>sym;\n                this.symbolMap.add(name, index);\n            }\n            return index;\n        }\n\n        public addUse(symIndex: number, astIndex: number) {\n            var useBySym = this.useIndexBySymbol[symIndex];\n            if (useBySym == undefined) {\n                useBySym = new number[];\n                this.useIndexBySymbol[symIndex] = useBySym;\n            }\n            useBySym[useBySym.length] = astIndex;\n        }\n\n        public getUseIndex(ast: AST) {\n            this.uses[this.uses.length] = ast;\n            return this.uses.length - 1;\n        }\n\n        public isLocalSym(sym: Symbol) { return (sym && (sym.container == this.func) && (sym.kind() == SymbolKind.Variable)); }\n\n        public killSymbol(sym: VariableSymbol, bbUses: BitVector) {\n            var index: number = this.symbolMap.lookup(sym.name);\n            var usesOfSym = this.useIndexBySymbol[index];\n            for (var k = 0, len = usesOfSym.length; k < len; k++) {\n                bbUses.set(usesOfSym[k], true);\n            }\n        }\n    }\n\n    export class BitVector {\n        static packBits = 30;\n        public firstBits = 0;\n        public restOfBits: number[] = null;\n\n        constructor (public bitCount: number) {\n            if (this.bitCount > BitVector.packBits) {\n                this.restOfBits = new number[];\n                var len = Math.floor(this.bitCount / BitVector.packBits);\n                for (var i = 0; i < len; i++) {\n                    this.restOfBits[i] = 0;\n                }\n            }\n        }\n\n        public set(bitIndex: number, value: bool) {\n            if (bitIndex < BitVector.packBits) {\n                if (value) {\n                    this.firstBits |= (1 << bitIndex);\n                }\n                else {\n                    this.firstBits &= (~(1 << bitIndex));\n                }\n            }\n            else {\n                var offset = Math.floor(bitIndex / BitVector.packBits) - 1;\n                var localIndex = bitIndex % BitVector.packBits;\n                if (value) {\n                    this.restOfBits[offset] |= (1 << localIndex);\n                }\n                else {\n                    this.restOfBits[offset] &= (~(1 << localIndex));\n                }\n            }\n        }\n\n        public map(fn: (index: number) =>any) {\n            var k: number;\n            for (k = 0; k < BitVector.packBits; k++) {\n                if (k == this.bitCount) {\n                    return;\n                }\n                if (((1 << k) & this.firstBits) != 0) {\n                    fn(k);\n                }\n            }\n            if (this.restOfBits) {\n                var len: number;\n                var cumu = BitVector.packBits;\n                for (k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    for (var j = 0; j < BitVector.packBits; j++) {\n                        if (((1 << j) & myBits) != 0) {\n                            fn(cumu);\n                        }\n                        cumu++;\n                        if (cumu == this.bitCount) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n        // assume conforming sizes\n        public union(b: BitVector) {\n            this.firstBits |= b.firstBits;\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] = myBits | bBits;\n                }\n            }\n        }\n\n        // assume conforming sizes\n        public interse";
var v27496 = v27497 + 'ction(b: BitVector) {\n            this.firstBits &= b.firstBits;\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] = myBits & bBits;\n                }\n            }\n        }\n\n        // assume conforming sizes\n        public notEq(b: BitVector) {\n            if (this.firstBits != b.firstBits) {\n                return true;\n            }\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    if (myBits != bBits) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        public difference(b: BitVector) {\n            var oldFirstBits = this.firstBits;\n            this.firstBits &= (~b.firstBits);\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] &= (~bBits);\n                }\n            }\n        }\n    }\n\n    export class BasicBlock {\n        // blocks that branch to the block after this one\n        public predecessors = new BasicBlock[];\n        public index = -1;\n        public markValue = 0;\n        public marked(markBase: number) { return this.markValue > markBase; }\n        public mark() {\n            this.markValue++;\n        }\n        public successors = new BasicBlock[];\n        public useDef: BBUseDefInfo = null;\n        public content = new ASTList();\n        public addSuccessor(successor: BasicBlock): void {\n            this.successors[this.successors.length] = successor;\n            successor.predecessors[successor.predecessors.length] = this;\n        }\n    }\n\n    export interface ITargetInfo {\n        stmt: AST;\n        continueBB: BasicBlock;\n        breakBB: BasicBlock;\n    }\n\n    export class ControlFlowContext {\n        public entry = null;\n        // first unreachable ast for each unreachable code segment\n        public unreachable: AST[] = null;\n        public noContinuation = false;\n        // statements enclosing the current statement\n        public statementStack = new ITargetInfo[];\n        public currentSwitch = new BasicBlock[];\n        public walker: IAstWalker;\n\n        constructor (public current: BasicBlock,\n                     public exit: BasicBlock) {\n            this.entry = this.current;\n        }\n\n        public walk(ast: AST, parent: AST) {\n            return this.walker.walk(ast, parent);\n        }\n\n        public pushSwitch(bb: BasicBlock) {\n            this.currentSwitch.push(bb);\n        }\n\n        public popSwitch() {\n            return this.currentSwitch.pop();\n        }\n\n        public reportUnreachable(er: ErrorReporter) {\n            if (this.unreachable && (this.unreachable.length > 0)) {\n                var len = this.unreachable.length;\n                for (var i = 0; i < len; i++) {\n                    var unreachableAST = this.unreachable[i];\n                    if (unreachableAST.nodeType != NodeType.EndCode) {\n                        er.simpleError(unreachableAST, "unreachable code");\n                    }\n                }\n            }\n        }\n\n        private printAST(ast: AST, outfile: ITextWriter) {\n            var printContext = new PrintContext(outfile, null);\n\n            printContext.increaseIndent();\n            //ast.walk(prePrintAST, postPrintAST, null, printContext);\n            getAstWalkerFactory().walk(ast, prePrintAST, postPrintAST, null, printContext);\n\n            printContext.decreaseIndent();\n        }\n\n        private printBlockContent(bb: BasicBlock, outfile: ITextWriter) {\n            var content = bb.content;\n            for (var i = 0, len = content.members.length; i < len; i++) {\n                var ast = content.members[i];\n                this.printAST(ast, outfile);\n            }\n        }\n\n        public markBase = 0;\n\n        public bfs(nodeFunc: (bb: BasicBlock) =>void , edgeFunc: (node1: BasicBlock, node2: BasicBlock) =>void ,\n            preEdges: () =>void , postEdges: () =>void ) {\n            var markValue = this.markBase++;\n            var q = new BasicBlock[];\n            q[q.length] = this.entry;\n\n            while (q.length > 0) {\n                var bb = q.pop();\n                if (!(bb.marked(markValue))) {\n                    bb.mark();\n                    if (nodeFunc) {\n                        nodeFunc(bb);\n                    }\n                    var succLen = bb.successors.length;\n                    if (succLen > 0) {\n                        if (preEdges) {\n                            preEdges();\n                        }\n                        for';
var v27495 = v27496 + ' (var j = succLen - 1; j >= 0; j--) {\n                            var successor = bb.successors[j];\n                            if (!(successor.marked(this.markBase))) {\n                                if (edgeFunc) {\n                                    edgeFunc(bb, successor);\n                                }\n                                q[q.length] = successor;\n                            }\n                        }\n                        if (postEdges) {\n                            postEdges();\n                        }\n                    }\n                }\n            }\n        }\n\n        public linearBBs = new BasicBlock[];\n\n        public useDef(er: ErrorReporter, funcSym: Symbol) {\n            var useDefContext = new UseDefContext();\n            useDefContext.func = funcSym;\n            var useDefInit = (bb: BasicBlock) => {\n                bb.useDef = new BBUseDefInfo(bb);\n                bb.useDef.initialize(useDefContext);\n                this.linearBBs[this.linearBBs.length] = bb;\n            }\n            this.bfs(useDefInit, null, null, null);\n            var i: number, bbLen: number;\n            for (i = 0, bbLen = this.linearBBs.length; i < bbLen; i++) {\n                this.linearBBs[i].useDef.initializeGen(useDefContext);\n                this.linearBBs[i].useDef.initializeKill(useDefContext);\n            }\n            var changed = true;\n\n            while (changed) {\n                changed = false;\n                for (i = 0; i < bbLen; i++) {\n                    changed = this.linearBBs[i].useDef.updateTop() || changed;\n                }\n            }\n\n            var top = this.entry.useDef.top;\n            top.map((index) => {\n                var ast = <Identifier>useDefContext.uses[<number>index];\n                er.simpleError(ast, "use of variable \'" + ast.actualText + "\' that is not definitely assigned");\n            });\n        }\n\n        public print(outfile: ITextWriter) {\n            var index = 0;\n            var node = (bb: BasicBlock) => {\n                if (bb.index < 0) {\n                    bb.index = index++;\n                }\n                if (bb == this.exit) {\n                    outfile.WriteLine("Exit block with index " + bb.index);\n                }\n                else {\n                    outfile.WriteLine("Basic block with index " + bb.index);\n                    this.printBlockContent(bb, outfile);\n                }\n            }\n\n            function preEdges() {\n                outfile.Write("  Branches to ");\n            }\n\n            function postEdges() {\n                outfile.WriteLine("");\n            }\n\n            function edge(node1: BasicBlock, node2: BasicBlock) {\n                if (node2.index < 0) {\n                    node2.index = index++;\n                }\n                outfile.Write(node2.index + " ");\n            }\n\n            this.bfs(node, edge, preEdges, postEdges);\n            if (this.unreachable != null) {\n                for (var i = 0, len = this.unreachable.length; i < len; i++) {\n                    outfile.WriteLine("Unreachable basic block ...");\n                    this.printAST(this.unreachable[i], outfile);\n                }\n            }\n        }\n\n        public pushStatement(stmt: Statement, continueBB: BasicBlock, breakBB: BasicBlock) {\n            this.statementStack.push({ stmt: stmt, continueBB: continueBB, breakBB: breakBB });\n        }\n\n        public popStatement() { return this.statementStack.pop(); }\n\n        public returnStmt() {\n            // TODO: make successor finally block if return stmt inside of try/finally \n            this.current.addSuccessor(this.exit);\n            this.setUnreachable();\n        }\n\n        public setUnreachable() {\n            this.current = null;\n            this.noContinuation = true;\n        }\n\n        public addUnreachable(ast: AST) {\n            if (this.unreachable === null) {\n                this.unreachable = new AST[];\n            }\n            this.unreachable[this.unreachable.length] = ast;\n        }\n\n        public unconditionalBranch(target: AST, isContinue: bool) {\n            var targetBB = null;\n            for (var i = 0, len = this.statementStack.length; i < len; i++) {\n                var targetInfo = this.statementStack[i];\n                if (targetInfo.stmt == target) {\n                    if (isContinue) {\n                        targetBB = targetInfo.continueBB;\n                    }\n                    else {\n                        targetBB = targetInfo.breakBB;\n                    }\n                    break;\n                }\n            }\n            if (targetBB) {\n                this.current.addSuccessor(targetBB);\n            }\n            this.setUnreachable();\n        }\n\n        public addContent(ast: AST): void {\n            if (this.current) {\n                this.current.content.append(ast);\n            }\n        }\n    }\n\n    export interface IResolutionData {\n        actuals: Type[];\n        exactCandidates: Signature[];\n        c';
var v27494 = v27495 + 'onversionCandidates: Signature[];\n        id: number;\n    }\n\n    export class ResolutionDataCache {\n        public cacheSize = 16;\n        public rdCache: IResolutionData[] = [];\n        public nextUp: number = 0;\n\n        constructor () {\n            for (var i = 0; i < this.cacheSize; i++) {\n                this.rdCache[i] = {\n                    actuals: new Type[],\n                    exactCandidates: new Signature[],\n                    conversionCandidates: new Signature[],\n                    id: i\n                };\n            }\n        }\n\n        public getResolutionData(): IResolutionData {\n            var rd: IResolutionData = null;\n\n            if (this.nextUp < this.cacheSize) {\n                rd = this.rdCache[this.nextUp];\n            }\n\n            if (rd == null) {\n                this.cacheSize++;\n                rd = {\n                    actuals: new Type[],\n                    exactCandidates: new Signature[],\n                    conversionCandidates: new Signature[],\n                    id: this.cacheSize\n                };\n                this.rdCache[this.cacheSize] = rd;\n            }\n\n            // cache operates as a stack - RD is always served up in-order\n            this.nextUp++;\n\n            return rd;\n        }\n\n        public returnResolutionData(rd: IResolutionData) {\n            // Pop to save on array allocations, which are a bottleneck\n            // REVIEW: On some VMs, Array.pop doesn\'t always pop the last value in the array\n            rd.actuals.length = 0;\n            rd.exactCandidates.length = 0;\n            rd.conversionCandidates.length = 0;\n\n            this.nextUp = rd.id;\n        }\n    }\n\n    export class TypeFlow {\n        public scope: SymbolScope;\n        public globalScope: SymbolScope;\n\n        public thisType: Type;\n        public thisFnc: FuncDecl = null;\n        public thisClassNode: TypeDeclaration = null;\n        public enclosingFncIsMethod = false;\n\n        // REVIEW: Prune in favor of typechecker fields\n        public doubleType: Type;\n        public booleanType: Type;\n        public stringType: Type;\n        public anyType: Type;\n        public regexType: Type;\n        public nullType: Type;\n        public voidType: Type;\n        public arrayAnyType: Type;\n\n        public arrayInterfaceType: Type = null;\n        public stringInterfaceType: Type = null;\n        public objectInterfaceType: Type = null;\n        public functionInterfaceType: Type = null;\n        public numberInterfaceType: Type = null;\n        public booleanInterfaceType: Type = null;\n        public iargumentsInterfaceType: Type = null;\n\n        public currentScript: Script = null;\n\n        public inImportTypeCheck = false;\n        public inTypeRefTypeCheck = false;\n        public inArrayElementTypeCheck = false;\n        public resolutionDataCache = new ResolutionDataCache();\n        public nestingLevel = 0;\n        public inSuperCall = false;\n\n        constructor (public logger: ILogger, public initScope: SymbolScope, public parser: Parser,\n                   public checker: TypeChecker) {\n            this.checker.typeFlow = this;\n            this.scope = this.initScope;\n            this.globalScope = this.initScope;\n            this.doubleType = this.checker.numberType;\n            this.booleanType = this.checker.booleanType;\n            this.stringType = this.checker.stringType;\n            this.anyType = this.checker.anyType;\n            this.regexType = this.anyType;\n            this.nullType = this.checker.nullType;\n            this.voidType = this.checker.voidType;\n            this.arrayAnyType = this.checker.makeArrayType(this.anyType);\n        }\n\n        public initLibs() {\n            var arraySym = this.globalScope.find("Array", false, true);\n            if (arraySym && (arraySym.kind() == SymbolKind.Type)) {\n                this.arrayInterfaceType = (<TypeSymbol>arraySym).type;\n            }\n            var stringSym = this.globalScope.find("String", false, true);\n            if (stringSym && (stringSym.kind() == SymbolKind.Type)) {\n                this.stringInterfaceType = (<TypeSymbol>stringSym).type;\n            }\n            var objectSym = this.globalScope.find("Object", false, true);\n            if (objectSym && (objectSym.kind() == SymbolKind.Type)) {\n                this.objectInterfaceType = (<TypeSymbol>objectSym).type;\n            }\n            var fnSym = this.globalScope.find("Function", false, true);\n            if (fnSym && (fnSym.kind() == SymbolKind.Type)) {\n                this.functionInterfaceType = (<TypeSymbol>fnSym).type;\n            }\n            var numberSym = this.globalScope.find("Number", false, true);\n            if (numberSym && (numberSym.kind() == SymbolKind.Type)) {\n                this.numberInterfaceType = (<TypeSymbol>numberSym).type;\n            }\n            var booleanSym = this.globalScope.find("Boolean", false, true);\n            if (booleanSym && (booleanSym.kind() == SymbolKind.Type)) {\n                this.booleanInterfaceT';
var v27493 = v27494 + 'ype = (<TypeSymbol>booleanSym).type;\n            }\n            var regexSym = this.globalScope.find("RegExp", false, true);\n            if (regexSym && (regexSym.kind() == SymbolKind.Type)) {\n                this.regexType = (<TypeSymbol>regexSym).type;\n            }\n        }\n\n        public cast(ast: AST, type: Type): AST {\n            return this.castWithCoercion(ast, type, true, false);\n        }\n\n        public castWithCoercion(ast: AST, type: Type, applyCoercion: bool, typeAssertion: bool): AST {\n            var comparisonInfo = new TypeComparisonInfo();\n            if (this.checker.sourceIsAssignableToTarget(ast.type, type, comparisonInfo) || (typeAssertion && this.checker.sourceIsAssignableToTarget(type, ast.type, comparisonInfo))) {\n                if (applyCoercion) {\n                    if (type == null) {\n                        ast.type = this.anyType;\n                    }\n                    else if (type.isClass()) {\n                        ast.type = type.instanceType;\n                    }\n                    else {\n                        ast.type = type;\n                    }\n                }\n                return ast;\n            }\n            else {\n                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type, null, this.scope, comparisonInfo);\n                return ast;\n            }\n        }\n\n        public inScopeTypeCheck(ast: AST, enclosingScope: SymbolScope): AST {\n            var prevScope = this.scope;\n            this.scope = enclosingScope;\n            var svThisFnc = this.thisFnc;\n            var svThisType = this.thisType;\n            var svThisClassNode = this.thisClassNode;\n            var svCurrentModDecl = this.checker.currentModDecl;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var container = this.scope.container;\n            var fnc: FuncDecl = null;\n            while (container) {\n                if (container.kind() == SymbolKind.Type) {\n                    var typeSym = <TypeSymbol>container;\n                    var type = typeSym.type;\n                    if (type.call) {\n                        if (fnc == null) {\n                            // use innermost function\n                            this.enclosingFncIsMethod = typeSym.isMethod;\n                            fnc = <FuncDecl>container.declAST;\n                        }\n                    }\n                    if (type.isClass()) {\n                        this.thisType = type.instanceType;\n                        if (typeSym.declAST &&\n                            (typeSym.declAST.nodeType == NodeType.ClassDeclaration)) {\n                            this.thisClassNode = <TypeDeclaration>typeSym.declAST;\n                        }\n                        // use innermost class\n                        break;\n                    }\n                    if (type.isModuleType()) {\n                        this.checker.currentModDecl = <ModuleDeclaration>typeSym.declAST;\n                        // use innermost module\n                        break;\n                    }\n                }\n                container = container.container;\n            }\n            this.thisFnc = fnc;\n\n            var updated = this.typeCheck(ast);\n\n            this.thisFnc = svThisFnc;\n            this.thisType = svThisType;\n            this.thisClassNode = svThisClassNode;\n            this.checker.currentModDecl = svCurrentModDecl;\n            this.enclosingFncIsMethod = prevMethodStatus;\n            this.scope = prevScope;\n            return updated;\n        }\n\n        public typeCheck(ast: AST): AST {\n            if (ast) {\n                return ast.typeCheck(this);\n            }\n            else {\n                return null;\n            }\n        }\n\n        public inScopeTypeCheckDecl(ast: AST) {\n            if (ast.nodeType == NodeType.VarDecl || ast.nodeType == NodeType.ArgDecl) {\n                this.inScopeTypeCheckBoundDecl(<BoundDecl>ast);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n\n                var funcDecl = <FuncDecl>ast;\n\n                if (funcDecl.isAccessor()) {\n                    this.typeCheckFunction(funcDecl);\n                }\n            }\n        }\n\n        public inScopeTypeCheckBoundDecl(varDecl: BoundDecl) {\n            var sym = varDecl.sym;\n            var svThisFnc = this.thisFnc;\n            var svThisType = this.thisType;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var prevLocationInfo = this.checker.locationInfo;\n            if (sym && sym.container) {\n                var instanceScope = hasFlag(varDecl.varFlags, VarFlags.ClassConstructorProperty) ? sym.container.getType().constructorScope : sym.container.instanceScope();\n                if (hasFlag(varDecl.varFlags, VarFlags.Property) && sym.container.declAST.nodeType == NodeType.FuncDecl) {\n                    this.thisFnc = <FuncDecl>sym.container.declAST;\n                }\n                if (instanceScope) {\n                    var';
var v27492 = v27493 + " prevScope = this.scope;\n                    this.scope = instanceScope;\n                    var container = sym.container;\n                    var svCurrentModDecl = this.checker.currentModDecl;\n                    if (this.checker.units &&\n                        (sym.unitIndex >= 0) &&\n                        (sym.unitIndex < this.checker.units.length)) {\n                        this.checker.locationInfo = this.checker.units[sym.unitIndex];\n                    }\n                    else {\n                        this.checker.locationInfo = unknownLocationInfo;\n                    }\n                    // REVIEW: container linkage for function expressions\n                    while (container) {\n                        if (container.kind() == SymbolKind.Type) {\n                            var typeSym = <TypeSymbol>container;\n                            var type = typeSym.type;\n                            if (type.call) {\n                                this.enclosingFncIsMethod = typeSym.isMethod;\n                            }\n                            if (type.isClass()) {\n                                this.thisType = type.instanceType;\n                            }\n                            if (type.isModuleType()) {\n                                this.checker.currentModDecl = <ModuleDeclaration>container.declAST;\n                                break;\n                            }\n                        }\n                        container = container.container;\n                    }\n\n                    this.typeCheckBoundDecl(varDecl);\n                    this.checker.currentModDecl = svCurrentModDecl;\n                    this.scope = prevScope;\n                }\n            }\n            this.thisFnc = svThisFnc;\n            this.thisType = svThisType;\n            this.checker.locationInfo = prevLocationInfo;\n            this.enclosingFncIsMethod = prevMethodStatus;\n        }\n\n        public resolveBoundDecl(varDecl: BoundDecl) {\n            if (varDecl.typeExpr) {\n                if (varDecl.typeExpr.type == null ||\n                    (varDecl.typeExpr.type && varDecl.typeExpr.type == this.anyType && this.scope) ||\n                    varDecl.typeExpr.type.symbol == null ||\n                    !this.checker.typeStatusIsFinished(varDecl.typeExpr.type.symbol.typeCheckStatus)) {\n                    this.typeCheck(varDecl.typeExpr);\n                }\n                varDecl.type = varDecl.typeExpr.type;\n                if (varDecl.sym) {\n                    varDecl.sym.setType(varDecl.type);\n                }\n            }\n            else if (varDecl.init == null) {\n                if (this.checker.styleSettings.implicitAny) {\n                    this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\n                }\n                varDecl.type = this.anyType;\n                if (varDecl.sym) {\n                    if (varDecl.sym.isType()) {\n                        var tsym = <TypeSymbol>varDecl.sym;\n                        if (tsym.isMethod) {\n                            this.checker.errorReporter.simpleError(varDecl, \"Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)\");\n                            return;\n                        }\n                        else {\n                            this.checker.errorReporter.simpleError(varDecl, \"Cannot bind type to variable\");\n                            return;\n                        }\n                    }\n                    varDecl.sym.setType(varDecl.type);\n                }\n            }\n        }\n\n        public typeCheckBoundDecl(varDecl: BoundDecl): VarDecl {\n            // symbol has already been added to the scope\n            var infSym = <InferenceSymbol>varDecl.sym;\n            if (infSym == null) {\n                if (varDecl.init) {\n                    varDecl.init = this.typeCheck(varDecl.init);\n                    varDecl.type = this.checker.widenType(varDecl.init.type);\n                }\n                else {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\n                    }\n                    varDecl.type = this.anyType;\n                }\n            }\n            else {\n                if (infSym.typeCheckStatus == TypeCheckStatus.Started) {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\n                    }\n                    varDecl.type = this.anyType;\n                    infSym.setType(this.anyType);\n                }\n                else if (infSym.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                    infSym.typeCheckStatus = TypeCheckStatus.Started;\n                    this.checker.addStartedPTO(infSym);\n                    var resolved = false;\n                    if (varDecl.type";
var v27491 = v27492 + " == null) {\n                        // propagate declared type\n                        if (varDecl.typeExpr) {\n                            this.resolveBoundDecl(varDecl);\n                            resolved = true;\n                            varDecl.type = varDecl.typeExpr.type;\n                            infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                        }\n                    }\n\n                    if (varDecl.init) {\n                        // if the bound decl is a function-local static, we need to set the\n                        // encapsulating scope to the function's member scope\n                        var isLocalStatic = hasFlag(varDecl.varFlags, VarFlags.LocalStatic);\n                        var prevScope = this.scope;\n                        var applyTargetType = !varDecl.init.isParenthesized;\n                        if (isLocalStatic) {\n                            this.scope = varDecl.sym.container.getType().memberScope;\n                        }\n\n                        // Mark Lambda expressions with IsPropertyBound flag\n                        if (hasFlag(varDecl.varFlags, VarFlags.Property) && this.thisClassNode) {\n                            getAstWalkerFactory().walk(varDecl.init, (ast: AST, parent: AST, walker: IAstWalker) => {\n                                if (ast && ast.nodeType == NodeType.FuncDecl) {\n                                    if (hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                        // Found a Lambda, mark it\n                                        (<FuncDecl>ast).fncFlags |= FncFlags.IsPropertyBound;\n                                    }\n                                    // Only mark the top level functions\n                                    walker.options.goChildren = false;\n                                }\n                                return ast;\n                            });\n                        }\n\n                        this.checker.typeCheckWithContextualType(varDecl.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, varDecl.init);\n\n                        this.scope = prevScope;\n                        if (varDecl.type) {\n                            // If the cast is to a target type, in the case of a funcdecl,\n                            // we may overwrite the init's type with one generated from a signature.\n                            // In that case, we need to preserve the contained scope of the actual decl\n                            var preserveScope = false;\n                            var preservedContainedScope = null;\n\n                            if (varDecl.init.type) {\n                                preservedContainedScope = varDecl.init.type.containedScope;\n                                preserveScope = true;\n                                if (varDecl.init.type == this.voidType) {\n                                    this.checker.errorReporter.simpleError(varDecl, \"Cannot assign type 'void' to variable '\" + varDecl.id.actualText + \"'\");\n                                }\n                            }\n\n                            varDecl.init = this.castWithCoercion(varDecl.init, varDecl.type, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);\n\n                            if (preserveScope && varDecl.init.type.containedScope == null) {\n                                varDecl.init.type.containedScope = preservedContainedScope;\n                            }\n                        }\n                        else {\n                            varDecl.type = this.checker.widenType(varDecl.init.type);\n                            if (varDecl.type == this.voidType) {\n                                this.checker.errorReporter.simpleError(varDecl, \"Cannot assign type 'void' to variable '\" + varDecl.id.actualText + \"'\");\n                                varDecl.type = this.anyType;\n                            }\n                        }\n                        infSym.setType(varDecl.type);\n                    }\n                    else {\n                        if (!resolved) {\n                            this.resolveBoundDecl(varDecl);\n                        }\n                    }\n                    infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                }\n                else if (this.checker.typeStatusIsFinished(infSym.typeCheckStatus) &&\n                         (infSym.declAST != varDecl)) {\n                    if (varDecl.init) {\n                        varDecl.init = this.typeCheck(varDecl.init);\n                        varDecl.type = infSym.getType();\n                        varDecl.init = this.cast(varDecl.init, varDecl.type);\n                    }\n                }\n            }\n            if (varDecl.id && varDecl.sym) {\n                varDecl.id.sym = varDecl.sym;\n            }\n\n            // Check if variable satisfies type privacy\n            if (varDecl.sym && varDecl.sym.con";
var v27490 = v27491 + 'tainer) {\n                this.checkTypePrivacy(varDecl.sym.getType(), varDecl.sym, (typeName: string, isModuleName: bool) => this.varPrivacyErrorReporter(varDecl, typeName, isModuleName));\n            }\n            return <VarDecl>varDecl;\n        }\n\n        private varPrivacyErrorReporter(varDecl: BoundDecl, typeName: string, isModuleName: bool) {\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;\n            } else {\n                typestring = " has or is using private type \'" + typeName + "\'";\n            }\n\n            if (hasFlag(varDecl.varFlags, VarFlags.Public)) {\n                if (varDecl.sym.container.declAST.nodeType == NodeType.InterfaceDeclaration) {\n                    this.checker.errorReporter.simpleError(varDecl, "property \'" + varDecl.sym.name + "\' of exported interface" + typestring);\n                } else {\n                    this.checker.errorReporter.simpleError(varDecl, "public member \'" + varDecl.sym.name + "\' of exported class" + typestring);\n                }\n            } else {\n                this.checker.errorReporter.simpleError(varDecl, "exported variable \'" + varDecl.sym.name + "\'" + typestring);\n            }\n        }\n\n        public typeCheckSuper(ast: AST): AST {\n            if (this.thisType && (this.enclosingFncIsMethod && !this.thisFnc.isStatic()) && this.thisType.baseClass()) {\n                ast.type = this.thisType.baseClass();\n            }\n            else {\n                // redirect \'super\' used within lambdas\n                if (!this.enclosingFncIsMethod &&\n                    this.thisType && this.thisType.baseClass() &&\n                    this.thisFnc && hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n                    // Find the closest non lambda function\n                    var enclosingFnc = this.thisFnc.enclosingFnc;\n                    while (hasFlag(enclosingFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n                        enclosingFnc = enclosingFnc.enclosingFnc;\n                    }\n\n                    // If the lambda is enclosed is a valid member, use the base type\n                    if (enclosingFnc && (enclosingFnc.isMethod() || enclosingFnc.isConstructor) && !enclosingFnc.isStatic()) {\n                        ast.type = this.thisType.baseClass();\n                        enclosingFnc.setHasSuperReferenceInFatArrowFunction();\n                        return ast;\n                    }\n                }\n\n                ast.type = this.anyType;\n                this.checker.errorReporter.invalidSuperReference(ast);\n            }\n            return ast;\n        }\n\n        public typeCheckThis(ast: AST): AST {\n           ast.type = this.anyType;\n            var illegalThisRef = false;\n            if (this.thisFnc == null) {\n                // \'this\' in class bodies should bind to \'any\'\n                if (this.thisType) {\n                    if (this.thisClassNode && this.thisClassNode.nodeType == NodeType.ClassDeclaration) {\n                        illegalThisRef = true;\n                    }\n                    else {\n                        ast.type = this.thisType;\n                    }\n                }\n                else if (this.checker.currentModDecl) {\n                    this.checker.errorReporter.simpleError(ast, "\'this\' may not be referenced within module bodies");\n                }\n            }\n            else {\n                if (this.thisClassNode && (hasFlag(this.thisFnc.fncFlags, FncFlags.IsPropertyBound) || (this.inSuperCall && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor)))) {\n                    illegalThisRef = true;\n                }\n                if (this.thisFnc.isMethod() || this.thisFnc.isConstructor || this.thisFnc.isTargetTypedAsMethod) {\n                    if (this.thisType && !(this.thisFnc.fncFlags & FncFlags.Static)) {\n                        ast.type = this.thisType;\n                    }\n                }\n            }\n\n            // redirect \'this\' used within lambdas\n            if (!this.enclosingFncIsMethod &&\n                this.thisFnc &&\n                hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n\n                    // if the enclosing function was bound to a property,\n                    // checkInitSelf would not have been able to mark the \n                    // function for a self init\n                if (this.thisFnc.boundToProperty) {\n                    var container = this.thisFnc.boundToProperty.sym.container;\n                    if (container.declAST.nodeType == NodeType.FuncDecl) {\n                        (<FuncDecl>container.declAST).setHasSelfReference();\n                    }\n                }\n                else {\n         ';
var v27489 = v27490 + '           var encFnc = this.thisFnc.enclosingFnc;\n                    var firstEncFnc = encFnc;\n\n                    while (encFnc) {\n                        if (this.thisClassNode && hasFlag(encFnc.fncFlags, FncFlags.IsPropertyBound)) {\n                            illegalThisRef = true;\n                        }\n\n                        if (!hasFlag(encFnc.fncFlags, FncFlags.IsFatArrowFunction) || encFnc.hasSelfReference()) {\n                            encFnc.setHasSelfReference();\n                            break;\n                        }\n\n                        encFnc = encFnc.enclosingFnc;\n                    }\n\n                    if (!encFnc && firstEncFnc) {\n                        encFnc = firstEncFnc;\n                        encFnc.setHasSelfReference();\n                    }\n                    else if (!encFnc) { // the lambda is bound at the top-level...\n                        if (this.thisClassNode) {\n                            (<ClassDeclaration>this.thisClassNode).varFlags |= VarFlags.MustCaptureThis;\n                        }\n                        else if (this.checker.currentModDecl) {\n                            this.checker.currentModDecl.modFlags |= ModuleFlags.MustCaptureThis;\n                        }\n                        else {\n                            this.checker.mustCaptureGlobalThis = true;\n                        }\n                    }\n\n                    if (encFnc && (encFnc.isMethod() || encFnc.isConstructor) && this.thisType && !hasFlag(encFnc.fncFlags, FncFlags.Static)) {\n                        ast.type = this.thisType;\n                    }\n                }\n            }\n\n            if (illegalThisRef) {\n                this.checker.errorReporter.simpleError(ast, "Keyword \'this\' cannot be referenced in initializers in a class body, or in super constructor calls");\n            }\n            return ast;\n        }\n\n        public setTypeFromSymbol(ast: AST, symbol: Symbol): void {\n            if (symbol.isVariable()) {\n                if (symbol.isInferenceSymbol()) {\n                    var infSym = <InferenceSymbol>symbol;\n                    if (infSym.declAST &&\n                        !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {\n                        this.inScopeTypeCheckDecl(infSym.declAST);\n                    }\n                    if (!this.checker.styleSettings.innerScopeDeclEscape) {\n                        if (infSym.declAST && (infSym.declAST.nodeType == NodeType.VarDecl)) {\n                            if (this.nestingLevel < (<VarDecl>infSym.declAST).nestingLevel) {\n                                this.checker.errorReporter.styleError(ast, "Illegal reference to a variable defined in more nested scope");\n                            }\n                        }\n                    }\n                }\n                ast.type = symbol.getType();\n                if (!symbol.writeable()) {\n                    ast.flags = ast.flags & (~(ASTFlags.Writeable));\n                }\n            }\n            else if (symbol.isType()) {\n                ast.type = symbol.getType();\n                ast.flags = ast.flags & (~(ASTFlags.Writeable));\n            }\n            else {\n                ast.type = this.anyType;\n                this.checker.errorReporter.symbolDoesNotReferToAValue(ast, symbol.name);\n            }\n        }\n\n        public typeCheckName(ast: AST): AST {\n            var identifier = <Identifier>ast;\n\n            if (this.checker.inWith) {\n                identifier.type = this.anyType;\n            }\n            else {\n                var typespace = this.inTypeRefTypeCheck;\n                var idText = identifier.text;\n                var originalIdText = idText;\n                var isDynamicModuleName = isQuoted(identifier.text);\n\n                var symbol = this.scope.find(idText, false, typespace);\n\n                if (symbol == null && isDynamicModuleName) {\n                    symbol = this.checker.findSymbolForDynamicModule(idText, this.currentScript.locationInfo.filename, (id) => this.scope.find(id, false, typespace));\n                }\n\n                if (!symbol) {\n                    if (!identifier.isMissing()) {\n                        this.checker.errorReporter.unresolvedSymbol(identifier, identifier.text);\n                    }\n                    identifier.type = this.anyType;\n                }\n                else {\n                    if (optimizeModuleCodeGen && symbol && symbol.isType()) {\n                        var symType = symbol.getType();\n                        // Once the type has been referenced outside of a type ref position, there\'s\n                        // no going back                        \n                        if (symType && (<TypeSymbol>symbol).aliasLink && (<TypeSymbol>symbol).onlyReferencedAsTypeRef) {\n\n                            var modDecl = <ModuleDeclaration>symType.symbol.declAST;\n                            if (modDecl && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic';
var v27488 = v27489 + ")) {\n                                (<TypeSymbol>symbol).onlyReferencedAsTypeRef = this.inTypeRefTypeCheck;\n                            }\n                        }\n                    }\n\n                    if (symbol.declAST &&\n                        symbol.declAST.nodeType == NodeType.FuncDecl &&\n                        !(<FuncDecl>symbol.declAST).returnTypeAnnotation &&\n                        (<FuncDecl>symbol.declAST).signature.typeCheckStatus == TypeCheckStatus.Started) {\n                        (<FuncDecl>symbol.declAST).type.symbol.flags |= SymbolFlags.RecursivelyReferenced;\n                        (<FuncDecl>symbol.declAST).signature.returnType.type = this.anyType;\n                    }\n\n                    this.setTypeFromSymbol(ast, symbol);\n                    identifier.sym = symbol;\n                    if (this.thisFnc) {\n                        if (this.thisFnc.type && symbol.container != this.thisFnc.type.symbol) {\n                            this.thisFnc.freeVariables[this.thisFnc.freeVariables.length] = symbol;\n                        }\n                    }\n                }\n            }\n            return ast;\n        }\n\n        public typeCheckScript(script: Script): Script {\n            this.checker.locationInfo = script.locationInfo;\n            this.scope = this.checker.globalScope;\n\n            // if it's a top-level module, the globals have already been added to the implicit\n            // module decl\n            if (!script.topLevelMod) {\n                this.addLocalsFromScope(this.scope, this.checker.gloMod,\n                                   script.vars, this.checker.globals, true);\n            }\n\n            this.currentScript = script;\n            script.bod = <ASTList>this.typeCheck(script.bod);\n            this.currentScript = null;\n            return script;\n        }\n\n        public typeCheckBitNot(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.doubleType;\n            return unex;\n        }\n\n        public typeCheckUnaryNumberOperator(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.doubleType;\n            return ast;\n        }\n\n        public typeCheckLogNot(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.booleanType;\n            return unex;\n        }\n\n        public astIsWriteable(ast: AST): bool {\n            return hasFlag(ast.flags, ASTFlags.Writeable);\n        }\n\n        public typeCheckIncOrDec(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            var lval = unex.operand;\n            if (!this.astIsWriteable(unex)) {\n                this.checker.errorReporter.valueCannotBeModified(unex);\n                unex.type = this.doubleType;\n            }\n            else {\n                unex = <UnaryExpression> this.typeCheckUnaryNumberOperator(ast);\n                if (unex.operand.type != this.checker.numberType && unex.operand.type != this.checker.anyType && !(unex.operand.type.typeFlags & TypeFlags.IsEnum)) {\n                    this.checker.errorReporter.simpleError(ast, \"'++' and '--' may only be applied to operands of type 'number' or 'any'\");\n                }\n            }\n            return unex;\n        }\n\n        public typeCheckBitwiseOperator(ast: AST, assignment: bool): AST {\n            var binex = <BinaryExpression>ast;\n            var resultType: Type = null;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (assignment && (!this.astIsWriteable(binex))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n\n            if (this.checker.styleSettings.bitwise) {\n                this.checker.errorReporter.styleError(ast, \"use of \" + nodeTypeTable[binex.nodeType]);\n            }\n\n            if (this.checker.sourceIsSubtypeOfTarget(leftType, this.doubleType) && (this.checker.sourceIsSubtypeOfTarget(rightType, this.doubleType))) {\n                resultType = this.doubleType;\n            }\n            else if ((leftType == this.booleanType) &&\n                     (rightType == this.booleanType)) {\n                resultType = this.booleanType;\n            }\n            else if (leftType == this.anyType) {\n                if ((rightType == this.anyType) ||\n                    (rightType == this.doubleType) ||\n                    (rightType == this.booleanType)) {\n                    resultType = this.anyType;\n                }\n            }\n            else if (rightType == this.anyType) {\n                if ((leftType == this.anyType) ||\n                    (leftType == this.doubleType) ||\n                    (leftType == th";
var v27487 = v27488 + 'is.booleanType)) {\n                    resultType = this.anyType;\n                }\n            }\n            if (resultType == null) {\n                resultType = this.anyType;\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                        binex.printLabel(), this.scope);\n            }\n            binex.type = resultType;\n            return binex;\n        }\n\n        public typeCheckArithmeticOperator(ast: AST, assignment: bool): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (assignment && (!this.astIsWriteable(binex.operand1))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n\n            if (this.checker.styleSettings.bitwise &&\n                ((binex.nodeType == NodeType.And) ||\n                (binex.nodeType == NodeType.Or) ||\n                (binex.nodeType == NodeType.AsgAnd) ||\n                (binex.nodeType == NodeType.AsgOr))) {\n                this.checker.errorReporter.styleError(ast, "use of " + nodeTypeTable[binex.nodeType]);\n            }\n\n            if (leftType == null || rightType == null) {\n                this.checker.errorReporter.simpleError(binex, "Could not typecheck arithmetic operation.  Possible recursive typecheck error?");\n                binex.type = this.anyType;\n                return binex;\n            }\n            var nodeType = binex.nodeType;\n\n            if (this.checker.isNullOrUndefinedType(leftType)) {\n                leftType = rightType;\n            }\n            if (this.checker.isNullOrUndefinedType(rightType)) {\n                rightType = leftType;\n            }\n            leftType = this.checker.widenType(leftType);\n            rightType = this.checker.widenType(rightType);\n\n            if (nodeType == NodeType.Add || nodeType == NodeType.AsgAdd) {\n\n                if (leftType == this.checker.stringType || rightType == this.checker.stringType) {\n                    binex.type = this.checker.stringType;\n                }\n                else if (leftType == this.checker.numberType && rightType == this.checker.numberType) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (leftType == this.checker.anyType || rightType == this.checker.anyType) {\n                    binex.type = this.checker.anyType;\n                }\n                else {\n                    binex.type = this.anyType;\n                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                            binex.printLabel(), this.scope);\n                }\n            }\n            else {\n                if (leftType == this.checker.numberType && rightType == this.checker.numberType) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (leftType == this.checker.anyType || rightType == this.checker.anyType) {\n                    binex.type = this.checker.numberType;\n                }\n                else {\n                    binex.type = this.anyType;\n                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                            binex.printLabel(), this.scope);\n                }\n            }\n\n            return binex;\n        }\n\n        public typeCheckDotOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            var leftIsFnc = false;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            var leftType = binex.operand1.type;\n            var leftScope: SymbolScope = null;\n            // REVIEW: replace with get member scope\n            if (leftType) {\n                if (leftType == this.anyType) {\n                    binex.type = this.anyType;\n                    return binex;\n                }\n                else if (leftType == this.stringType) {\n                    if (this.stringInterfaceType) {\n                        leftScope = this.stringInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n              ';
var v27486 = v27487 + "  else if (leftType == this.doubleType) {\n                    if (this.numberInterfaceType) {\n                        leftScope = this.numberInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if (leftType == this.booleanType) {\n                    if (this.booleanInterfaceType) {\n                        leftScope = this.booleanInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if ((leftType.call || leftType.construct) && leftType.members == null) {\n                    if (this.functionInterfaceType) {\n                        leftScope = this.functionInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if (leftType.elementType) {\n                    if (this.arrayInterfaceType) {\n                        var arrInstType = leftType.elementType.getArrayBase(this.arrayInterfaceType, this.checker);\n                        leftScope = arrInstType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else {\n                    leftScope = leftType.memberScope;\n                }\n            }\n            if (leftScope == null) {\n                this.checker.errorReporter.expectedClassOrInterface(binex);\n                binex.type = this.anyType;\n            }\n            else {\n                var propertyName = <Identifier>binex.operand2;\n                var lhsIsEnclosingType = (this.thisClassNode && binex.operand1.type == this.thisClassNode.type.instanceType) || this.inTypeRefTypeCheck;\n                var symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, this.inTypeRefTypeCheck); // only search the public members, unless the rhs is a 'this' pointer\n\n                // If the symbol wasn't found, delegate to the appropriate 'virtual' parent type\n                if (!symbol) {\n                    if (this.objectInterfaceType && leftType) {\n                        // check 'Object' for the symbol\n                        if (leftType.isReferenceType()) {\n                            symbol = this.objectInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);\n                        }\n                        if (!symbol) {\n                            // check 'Function', if appropriate\n                            if (this.functionInterfaceType && (leftType.call || leftType.construct)) {\n                                symbol = this.functionInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);\n                            }\n                        }\n                    }\n                }\n\n                if (!symbol || (!symbol.visible(leftScope, this.checker))) {\n                    binex.type = this.anyType;\n\n                    if (symbol == null) {\n                        this.checker.errorReporter.simpleError(propertyName, \"The property '\" + propertyName.actualText + \"' does not exist on value of type '\" + leftType.getScopedTypeName(this.scope) + \"'\");\n                    }\n                    else if (!this.inTypeRefTypeCheck) {  // if it's a dotted type reference, we'll catch the visibility error during binding\n                        this.checker.errorReporter.simpleError(binex, \"The property '\" + propertyName.actualText + \" on type '\" + leftType.getScopedTypeName(this.scope) + \"' is not visible\");\n                    }\n                }\n                else {\n                    if (symbol.isVariable()) {\n                        if (symbol.isInferenceSymbol()) {\n                            var infSym = <InferenceSymbol>symbol;\n                            if (infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {\n                                this.inScopeTypeCheckDecl(infSym.declAST);\n                            }\n                        }\n                    }\n                    propertyName.sym = symbol;\n                    binex.type = symbol.getType();\n                }\n            }\n            if (binex.type == null) {\n                binex.type = this.anyType;\n            }\n\n            return binex;\n        }\n\n        public typeCheckBooleanOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n            if ((!";
var v27485 = v27486 + '(this.checker.sourceIsAssignableToTarget(leftType, rightType))) &&\n                (!(this.checker.sourceIsAssignableToTarget(rightType, leftType)))) {\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);\n            }\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        public typeCheckAsgOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            var applyTargetType = !binex.operand2.isParenthesized;\n            binex.operand1 = this.typeCheck(binex.operand1);\n\n            this.checker.typeCheckWithContextualType(binex.operand1.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, binex.operand2);\n\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (!(this.astIsWriteable(binex.operand1))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n            if (binex.operand1.nodeType == NodeType.Call) {\n                var callEx = <CallExpression>binex.operand1;\n            }\n            var preserveScope = false;\n            var preservedContainedScope = null;\n            if (binex.operand2.type) {\n                preservedContainedScope = binex.operand2.type.containedScope;\n                preserveScope = true;\n            }\n            // Do not re-write the AST in provisional typecheck mode\n            binex.operand2 = this.castWithCoercion(binex.operand2, leftType, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);\n            if (preserveScope && binex.operand2.type.containedScope == null) {\n                binex.operand2.type.containedScope = preservedContainedScope;\n            }\n            binex.type = rightType;\n            return binex;\n        }\n\n        public typeCheckIndex(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1); // ObjExpr\n            binex.operand2 = this.typeCheck(binex.operand2); // IndexExpr\n\n            if (!this.checker.styleSettings.literalSubscript) {\n                if (binex.operand2.nodeType == NodeType.QString) {\n                    this.checker.errorReporter.styleError(ast, "use literal subscript (\'.\') notation instead)");\n                }\n            }\n\n            var objExprType = binex.operand1.type;\n            var indexExprType = binex.operand2.type;\n\n            if (objExprType.elementType) { // arrays\n                if (indexExprType == this.checker.anyType || indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)) {\n                    binex.type = objExprType.elementType;\n                }\n                else if (indexExprType == this.checker.stringType) {\n                    binex.type = this.checker.anyType;\n                }\n                else {\n                    this.checker.errorReporter.simpleError(binex, "Illegal property access");\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if (objExprType.index) { // types with index sigs\n\n                if (indexExprType == this.checker.anyType ||\n                    !((objExprType.index.flags & SignatureFlags.IsStringIndexer) || (objExprType.index.flags & SignatureFlags.IsNumberIndexer)) || // REVIEW: unvalidated type expression\n                    ((objExprType.index.flags & SignatureFlags.IsStringIndexer) && indexExprType == this.checker.stringType) ||\n                    ((objExprType.index.flags & SignatureFlags.IsNumberIndexer) && (indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)))) {\n                    var sig = this.resolveOverload(ast, objExprType.index);\n                    if (sig) {\n                        binex.type = sig.returnType.type;//objExprType.index.signatures[0].returnType.type;\n                    }\n                    else {\n                        binex.type = this.checker.anyType;\n                    }\n                }\n                else if (indexExprType == this.checker.stringType) {\n                    binex.type = this.checker.anyType;\n                }\n                else {\n                    this.checker.errorReporter.simpleError(binex, "Illegal property access");\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if ((objExprType == this.checker.anyType ||\n                     objExprType == this.checker.stringType ||\n                     objExprType == this.checker.numberType ||\n                     objExprType == this.checker.booleanType ||\n                     objExprType.isReferenceType()) &&\n                     (indexExprType == this.checker.anyType ||\n                      indexExprType == this.checker.stringType ||\n                      (indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)))) { // RE';
var v27484 = v27485 + 'VIEW: Do we want to allow indexes of type \'number\'?\n                binex.type = this.checker.anyType;\n            }\n            else {\n                this.checker.errorReporter.simpleError(binex, "Illegal property access");\n                binex.type = this.checker.anyType;\n            }\n\n            return binex;\n        }\n\n        public typeCheckInOperator(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.stringType);\n            binex.operand2 = this.typeCheck(binex.operand2);\n\n            if (!((binex.operand1.type == this.checker.anyType || binex.operand1.type == this.checker.stringType) &&\n                    (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.objectInterfaceType)))) {\n                this.checker.errorReporter.simpleError(binex, "The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type");\n            }\n\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        public typeCheckShift(binex: BinaryExpression, assignment: bool): BinaryExpression {\n            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.doubleType);\n            binex.operand2 = this.cast(this.typeCheck(binex.operand2), this.doubleType);\n            if (assignment && (!(this.astIsWriteable(binex.operand1)))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n            binex.type = this.doubleType;\n            return binex;\n        }\n\n        public typeCheckQMark(trinex: ConditionalExpression): ConditionalExpression {\n            trinex.operand1 = this.typeCheck(trinex.operand1);\n            trinex.operand2 = this.typeCheck(trinex.operand2);\n            trinex.operand3 = this.typeCheck(trinex.operand3);\n            var leftType = trinex.operand2.type;\n            var rightType = trinex.operand3.type;\n\n            if (leftType == rightType) {\n                trinex.type = leftType;\n            }\n            else {\n                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {\n                    trinex.type = rightType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {\n                    trinex.type = leftType;\n                }\n                else {\n                    trinex.type = this.anyType;\n                    this.checker.errorReporter.incompatibleTypes(trinex, leftType, rightType, trinex.printLabel(), this.scope);\n                }\n            }\n\n            return trinex;\n        }\n\n        public addFormals(container: Symbol, signature: Signature,\n            table: IHashTable) {\n            var len = signature.parameters.length;\n            for (var i = 0; i < len; i++) {\n                var symbol = <ParameterSymbol>signature.parameters[i];\n                symbol.container = container;\n                table.add(symbol.name, symbol);\n            }\n        }\n\n        // REVIEW: We use isModContainer instead of container.getType().isModuleType because container.type may be null at this\n        // juncture\n        public addLocalsFromScope(scope: SymbolScope, container: Symbol, vars: ASTList, table: IHashTable, isModContainer: bool) {\n            var len = vars.members.length;\n            var hasArgsDef = false;\n            for (var i = 0; i < len; i++) {\n                var local = <VarDecl>vars.members[i];\n                if (((local.sym == null) || (local.sym.kind() != SymbolKind.Field))) {\n                    var result: Symbol = null;\n                    if ((result = table.lookup(local.id.text)) == null) {\n                        var localVar: ValueLocation = new ValueLocation();\n                        localVar.typeLink = new TypeLink();\n                        var varSym = null;\n\n                        if (hasFlag(local.varFlags, VarFlags.Static)) {\n                            local.varFlags |= VarFlags.LocalStatic;\n                            varSym = new FieldSymbol(local.id.text, local.minChar,\n                                                      this.checker.locationInfo.unitIndex,\n                                                      true, localVar);\n                        }\n                        else {\n                            varSym = new VariableSymbol(local.id.text, local.minChar,\n                                                      this.checker.locationInfo.unitIndex,\n                                                      localVar);\n                        }\n                        varSym.transferVarFlags(local.varFlags);\n                        localVar.symbol = varSym;\n                        varSym.declAST = local;\n                        localVar.typeLink.ast = local.typeExpr;\n                        this.checker.resolveTypeLink(scope, localVar.typeLink, false);\n                        if ((local.type == null) &&';
var v27483 = v27484 + ' (local.init == null)) {\n                            local.type = this.anyType;\n                        }\n                        localVar.typeLink.type = local.type;\n                        localVar.symbol.container = container;\n                        local.sym = localVar.symbol;\n                        table.add(local.id.text, varSym);\n                        if (local.id.text == "arguments") {\n                            hasArgsDef = true;\n                        }\n                    }\n                    else {\n                        local.type = result.getType();\n                        local.sym = result;\n                    }\n                }\n            }\n            if (!isModContainer) {\n                if (!hasArgsDef) {\n                    var argLoc = new ValueLocation();\n                    argLoc.typeLink = new TypeLink();\n                    var theArgSym = new VariableSymbol("arguments", vars.minChar,\n                                                     this.checker.locationInfo.unitIndex,\n                                                     argLoc);\n\n                    // if the user is using a custom lib.d.ts where IArguments has not been defined\n                    // (or they\'re compiling with the --nolib option), use \'any\' as the argument type\n                    if (!this.iargumentsInterfaceType) {\n                        var argumentsSym = scope.find("IArguments", false, true);\n\n                        if (argumentsSym) {\n                            argumentsSym.flags |= SymbolFlags.CompilerGenerated;\n                            this.iargumentsInterfaceType = argumentsSym.getType();\n                        }\n                        else {\n                            this.iargumentsInterfaceType = this.anyType;\n                        }\n                    }\n                    argLoc.typeLink.type = this.iargumentsInterfaceType;\n                    table.add("arguments", theArgSym);\n                }\n            }\n        }\n\n        // REVIEW: isClass param may now be redundant\n        public addConstructorLocalArgs(container: Symbol, args: ASTList, table: IHashTable, isClass: bool): void {\n            if (args) {\n                var len = args.members.length;\n                for (var i = 0; i < len; i++) {\n                    var local = <ArgDecl>args.members[i];\n                    if ((local.sym == null) ||\n                        (isClass || (local.sym.kind() != SymbolKind.Field))) {\n                        var result: Symbol = null;\n                        if ((result = table.lookup(local.id.text)) == null) {\n                            this.resolveBoundDecl(local);\n                            var localVar: ValueLocation = new ValueLocation();\n                            localVar.typeLink = new TypeLink();\n                            var varSym = new ParameterSymbol(local.id.text, local.minChar,\n                                                                   this.checker.locationInfo.unitIndex,\n                                                                   localVar);\n                            varSym.declAST = local;\n                            localVar.symbol = varSym;\n                            localVar.typeLink.type = local.type;\n                            localVar.symbol.container = container;\n                            local.sym = localVar.symbol;\n                            table.add(local.id.text, varSym);\n                        }\n                        else {\n                            local.type = result.getType();\n                            local.sym = result;\n                        }\n                    }\n                }\n            }\n        }\n\n        public checkInitSelf(funcDecl: FuncDecl): bool {\n            if (!funcDecl.isMethod()) {\n                var freeVars = funcDecl.freeVariables;\n                for (var k = 0, len = freeVars.length; k < len; k++) {\n                    var sym = freeVars[k];\n                    if (sym.isInstanceProperty()) {\n                        return true;\n                    }\n                }\n            }\n            var fns = funcDecl.scopes;\n            var fnsLen = fns.members.length;\n\n            for (var j = 0; j < fnsLen; j++) {\n                var fn = <FuncDecl>fns.members[j];\n                if (this.checkInitSelf(fn)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public checkPromoteFreeVars(funcDecl: FuncDecl, constructorSym: Symbol): void {\n            var freeVars = funcDecl.freeVariables;\n            for (var k = 0, len = freeVars.length; k < len; k++) {\n                var sym = freeVars[k];\n                if ((!sym.isInstanceProperty()) && (sym.container == constructorSym)) {\n                    instanceFilter.reset();\n                    if (this.scope.search(instanceFilter, sym.name, false, false)) {\n                        this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variable shadows class property';
var v27482 = v27483 + ' \'" + sym.name + "\'. To access the class property, use \'self." + sym.name + "\'");\n                    }\n\n                    this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable \'" + sym.name + "\' to a class property")\n                }\n            }\n        }\n\n        public allReturnsAreVoid(funcDecl: FuncDecl) {\n            // in the case of a function or method with no declared return type, walk the body to \n            // pre-emptively determine if the function has a return type of void\n            //\n            // REVIEW: Eventually, we\'ll want to perform exit graph analysis to determine\n            // if the function ever "escapes" without a return expression\n            // This would require moving some of this logic into the function\'s typecheck-proper,\n            // which would slow things down a fair bit, but would open up more analysis opportunities\n            var allReturnsAreVoid = true;\n\n            if (funcDecl.signature.returnType.type == null) {\n                var preFindReturnExpressionTypes = function (ast: AST, parent: AST, walker: IAstWalker) {\n                    var go = true;\n                    switch (ast.nodeType) {\n                        case NodeType.FuncDecl:\n                            // don\'t recurse into a function decl - we don\'t want to confuse a nested\n                            // return type with the top-level function\'s return type\n                            go = false;\n                            break;\n                        case NodeType.Return:\n                            var returnStmt: ReturnStatement = <ReturnStatement>ast;\n\n                            if (returnStmt.returnExpression) {\n                                allReturnsAreVoid = false;\n                                go = false;\n                            }\n\n                        default:\n                            break;\n                    }\n                    walker.options.goChildren = go;\n                    walker.options.goNextSibling = go;\n                    return ast;\n                }\n\n                getAstWalkerFactory().walk(funcDecl.bod, preFindReturnExpressionTypes);\n            }\n\n            return allReturnsAreVoid;\n        }\n\n        public classConstructorHasSuperCall(funcDecl: FuncDecl) {\n            var foundSuper = false;\n\n            var preFindSuperCall = function (ast: AST, parent: AST, walker: IAstWalker) {\n\n                var go = true;\n\n                switch (ast.nodeType) {\n                    case NodeType.FuncDecl:\n                        go = false;\n                        break;\n                    case NodeType.Call:\n                        var call = <CallExpression>ast;\n\n                        if (call.target.nodeType == NodeType.Super) {\n                            go = false;\n                            foundSuper = true;\n                            break;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                walker.options.goChildren = go;\n                return ast;\n            }\n\n            getAstWalkerFactory().walk(funcDecl.bod, preFindSuperCall);\n\n            return foundSuper;\n        }\n\n        private baseListPrivacyErrorReporter(bases: ASTList, i: number, declSymbol: Symbol, extendsList: bool, typeName: string, isModuleName: bool) {\n            var baseSymbol = bases.members[i].type.symbol;\n            var declTypeString = (declSymbol.declAST.nodeType == NodeType.InterfaceDeclaration) ? "interface" : "class";\n            var baseListTypeString = extendsList ? "extends" : "implements";\n            var baseTypeString = (baseSymbol.declAST.nodeType == NodeType.InterfaceDeclaration) ? "interface" : "class";\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module ";\n                baseTypeString = " " + baseTypeString + " from private module " + quotestring + typeName + quotestring;\n            } else {\n                baseTypeString = " private " + baseTypeString + " \'" + typeName + "\'";\n            }\n            this.checker.errorReporter.simpleError(bases.members[i], "exported " + declTypeString + " \'" + declSymbol.name + "\' " + baseListTypeString + baseTypeString);\n        }\n\n        // Check if declSymbol can satisfy baselist privacy\n        private typeCheckBaseListPrivacy(bases: ASTList, declSymbol: Symbol, extendsList: bool) {\n            if (bases) {\n                var basesLen = bases.members.length;\n                for (var i = 0; i < basesLen; i++) {\n                    if (!bases.members[i].type || bases.members[i].type == this.checker.anyType) {\n                        // This type is coming from external module so it ha';
var v27481 = v27482 + "s to be exported, or we're recovering from an\n                        // error condition\n                        continue;\n                    }\n\n                    this.checkSymbolPrivacy(bases.members[i].type.symbol, declSymbol, (typeName: string, isModuleName: bool) => this.baseListPrivacyErrorReporter(bases, i, declSymbol, extendsList, typeName, isModuleName));\n                }\n            }\n        }\n\n        // Checks if the privacy is satisfied by typeSymbol that is used in the declaration inside container\n        private checkSymbolPrivacy(typeSymbol: TypeSymbol, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName: bool) => void ) {\n            var externalModuleSymbol: TypeSymbol = null;\n            var declSymbolPath: Symbol[] = null;\n\n            // Type is visible type, so this can be used by anyone.\n            if (typeSymbol.isExternallyVisible(this.checker)) {\n                // Symbol could be from external module, go ahead and find the external module\n                var typeSymbolPath = typeSymbol.pathToRoot();\n                declSymbolPath = declSymbol.pathToRoot();\n                var typeSymbolLength = typeSymbolPath.length;\n                var declSymbolPathLength = declSymbolPath.length;\n\n                if (typeSymbolLength > 0) {\n                    if (typeSymbolPath[typeSymbolLength - 1].getType().isModuleType() &&\n                        (<TypeSymbol>typeSymbolPath[typeSymbolLength - 1]).isDynamic &&\n                        typeSymbolPath[typeSymbolLength - 1] != declSymbolPath[declSymbolPathLength - 1]) {\n                        // Symbol from external module that was imported using one of the import statement\n                        externalModuleSymbol = <TypeSymbol>typeSymbolPath[typeSymbolLength - 1];\n                    } else if (typeSymbolLength > 1) {\n                        // Is symbol from declared quoted module\n                        if (typeSymbolPath[typeSymbolLength - 2].getType().isModuleType() &&\n                            (<TypeSymbol>typeSymbolPath[typeSymbolLength - 2]).isDynamic &&\n                            (declSymbolPathLength == 1 || typeSymbolPath[typeSymbolLength - 2] != declSymbolPath[declSymbolPathLength - 2])) {\n                            // From quoted module name\n                            externalModuleSymbol = <TypeSymbol>typeSymbolPath[typeSymbolLength - 2];\n                        }\n                    }\n                }\n\n                if (externalModuleSymbol == null) {\n                    return;\n                }\n            }\n\n            // Interface symbol doesn't reflect correct Exported state so use AST instead\n            var interfaceDecl: InterfaceDeclaration = declSymbol.getInterfaceDeclFromSymbol(this.checker);\n            if (interfaceDecl && !hasFlag(interfaceDecl.varFlags, VarFlags.Exported)) {\n                return;\n            }\n\n            var checkVisibilitySymbol = declSymbol;\n            // Var decl symbol doesnt reflect correct exported state so use AST instead\n            var varDecl = declSymbol.getVarDeclFromSymbol();\n            if (varDecl) {\n                if (hasFlag(varDecl.varFlags, VarFlags.Private)) {\n                    return;\n                } else if (hasFlag(varDecl.varFlags, VarFlags.Public)) {\n                    // Its a member from class so check visibility of its container\n                    checkVisibilitySymbol = declSymbol.container;\n                }\n            }\n\n            // If the container is visible from global scrope it is error\n            if (checkVisibilitySymbol.isExternallyVisible(this.checker)) {\n                var privateSymbolName = typeSymbol.name;\n\n                // If imported typeSymbol mark it as visible externally and verify that the symbol it imports is visible externally\n                if (externalModuleSymbol != null) {\n                    var prettyName = externalModuleSymbol.getPrettyNameOfDynamicModule(declSymbolPath);\n                    if (prettyName != null) {\n                        this.currentScript.AddExternallyVisibleImportedSymbol(prettyName.symbol, this.checker);\n                        return;\n                    } else {\n                        privateSymbolName = externalModuleSymbol.prettyName;\n                    }\n                }\n\n                // Visible declaration using non visible type.\n                errorCallback(privateSymbolName, typeSymbol.name != privateSymbolName);\n            }\n        }\n\n        // Checks if the privacy is satisfied by type that is used in the declaration inside container\n        private checkTypePrivacy(type: Type, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName : bool) =>void ) {\n            // Primitive types\n            if (!(type && type.primitiveTypeClass == Primitive.None)) {\n                return;\n            }\n\n\n            // If type is array, check element type\n            if (type.isArray()) {\n                return this.checkTypePrivacy(type.elementTyp";
var v27480 = v27481 + 'e, declSymbol, errorCallback);\n            }\n\n            // Going to be printing symbol name, verify if symbol can be emitted\n            if (type.symbol && type.symbol.name && type.symbol.name != "_anonymous" &&\n                        (((type.call == null) && (type.construct == null) && (type.index == null)) ||\n                        (type.members && (!type.isClass())))) {\n                return this.checkSymbolPrivacy(<TypeSymbol>type.symbol, declSymbol, errorCallback);\n            }\n\n            if (type.members) {\n                // Verify symbols for members\n                type.members.allMembers.map((key, s, unused) => {\n                    var sym = <Symbol>s;\n                    if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {\n                        this.checkTypePrivacy(sym.getType(), declSymbol, errorCallback);\n                    }\n                }, null);\n            }\n\n            this.checkSignatureGroupPrivacy(type.call, declSymbol, errorCallback);\n            this.checkSignatureGroupPrivacy(type.construct, declSymbol, errorCallback);\n            this.checkSignatureGroupPrivacy(type.index, declSymbol, errorCallback);\n        }\n\n        // Checks if the privacy is satisfied by typeSymbol that is used in the declaration inside container\n        private checkSignatureGroupPrivacy(sgroup: SignatureGroup, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName : bool) =>void ) {\n            if (sgroup) {\n                var len = sgroup.signatures.length;\n                for (var i = 0; i < sgroup.signatures.length; i++) {\n                    var signature = sgroup.signatures[i];\n                    if (len > 1 && signature == sgroup.definitionSignature) {\n                        // In case of overloads don\'t look up for overload defintion types.\n                        continue;\n                    }\n\n                    if (signature.returnType) {\n                        this.checkTypePrivacy(signature.returnType.type, declSymbol, errorCallback);\n                    }\n\n                    var paramLen = signature.parameters.length;\n                    for (var j = 0; j < paramLen; j++) {\n                        var param = signature.parameters[j];\n                        this.checkTypePrivacy(param.getType(), declSymbol, errorCallback);\n                    }\n                }\n            }\n        }\n\n        private functionArgumentPrivacyErrorReporter(funcDecl: FuncDecl, p: number, paramSymbol: Symbol, typeName: string, isModuleName: bool) {\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var isPublicFunc = hasFlag(funcDecl.fncFlags, FncFlags.Public);\n            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) != null;\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;\n            } else {\n                typestring = " has or is using private type \'" + typeName + "\'";\n            }\n\n            if (!isContainerInterface) {\n                if (funcDecl.isConstructor) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported class\'s constructor parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (isSetter) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " setter parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (!isGetter) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " function parameter \'" + paramSymbol.name + "\'" + typestring);\n                }\n            } else {\n                if (funcDecl.isConstructMember()) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface\'s constructor parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (funcDecl.isCallMember()) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface\'s call parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (!funcDecl.isIndexerMember()) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface\'s function parameter \'" + paramSymbol.name + "\'" + typestring);\n                }\n            }\n        }\n\n        private returnTypePrivacyError(astError: AST, funcDecl: FuncDecl, typeName: string, isModuleName: bool) {\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcD';
var v27479 = v27480 + 'ecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var isPublicFunc = hasFlag(funcDecl.fncFlags, FncFlags.Public);\n            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) != null;\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;\n            } else {\n                typestring = " has or is using private type \'" + typeName + "\'";\n            }\n            if (!isContainerInterface) {\n                if (isGetter) {\n                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " getter return type" + typestring);\n                } else if (!isSetter) {\n                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " function return type" + typestring);\n                }\n            } else {\n                if (funcDecl.isConstructMember()) {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s constructor return type" + typestring);\n                } else if (funcDecl.isCallMember()) {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s call return type" + typestring);\n                } else if (funcDecl.isIndexerMember()) {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s indexer return type" + typestring);\n                } else {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s function return type" + typestring);\n                }\n            }\n        }\n\n        private functionReturnTypePrivacyErrorReporter(funcDecl: FuncDecl, signature: Signature, typeName: string, isModuleName: bool) {\n            var reportOnFuncDecl = false;\n\n            // Error coming from return annotation\n            if (funcDecl.returnTypeAnnotation != null &&\n                funcDecl.returnTypeAnnotation.type == signature.returnType.type) {\n                this.returnTypePrivacyError(funcDecl.returnTypeAnnotation, funcDecl, typeName, isModuleName);\n            }\n\n            // Check if return statement\'s type matches the one that we concluded\n            for (var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {\n                if (funcDecl.returnStatementsWithExpressions[i].type == signature.returnType.type) {\n                    this.returnTypePrivacyError(funcDecl.returnStatementsWithExpressions[i], funcDecl, typeName, isModuleName);\n                } else {\n                    reportOnFuncDecl = true;\n                }\n            }\n\n            if (reportOnFuncDecl) {\n                // Show on function decl\n                this.returnTypePrivacyError(funcDecl, funcDecl, typeName, isModuleName);\n            }\n        }\n\n        public typeCheckFunction(funcDecl: FuncDecl): FuncDecl {\n            this.nestingLevel = 0;\n            var fnType = funcDecl.type;\n\n            var fgSym = fnType.symbol;\n            var signature = funcDecl.signature;\n\n            if (this.checker.typeStatusIsFinished(signature.typeCheckStatus)) {\n                return funcDecl;\n            }\n            else if (signature.typeCheckStatus == TypeCheckStatus.Started) {\n                if (!funcDecl.returnTypeAnnotation &&\n                    funcDecl.bod &&\n                       !funcDecl.isSignature() &&\n                       !(funcDecl.isConstructor) &&\n                       this.allReturnsAreVoid(funcDecl)) {\n\n                    signature.returnType.type = this.voidType;\n                    return funcDecl;\n                }\n                else {\n                    if (funcDecl.returnTypeAnnotation == null) {\n                        if (this.checker.styleSettings.implicitAny) {\n                            this.checker.errorReporter.styleError(funcDecl, "type implicitly set to \'any\'");\n                        }\n                        signature.returnType.type = this.anyType;\n                        fgSym.flags |= SymbolFlags.RecursivelyReferenced;\n                    }\n                    return funcDecl;\n                }\n            }\n\n            signature.typeCheckStatus = TypeCheckStatus.Started;\n            this.checker.addStartedPTO(signature);\n            var prevScope = this.scope;\n            var prevFnc = this.thisFnc;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var prevClassNode = this.thisClassNode;\n            this.enclosingFncIsMethod = funcDecl.isMethod() || funcDecl.isConstructor;\n            this.thisFnc = funcDecl;\n            var container = funcDecl.type.symbol;\n            var prevThisType = this.thisType;\n            var pr';
var v27478 = v27479 + "evLocationInfo = this.checker.locationInfo;\n            var funcTable: IHashTable = null;\n            var acceptedContextualType = false;\n            var targetParams: ParameterSymbol[] = null;\n            var targetReturnType: Type = null;\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var accessorType: Type = (isGetter || isSetter) && funcDecl.accessorSymbol ? funcDecl.accessorSymbol.getType() : null;\n            var prevModDecl = this.checker.currentModDecl;\n\n            if (funcDecl.isConstructor && !funcDecl.isOverload) {\n                if (fnType.instanceType == null) {\n                    this.checker.errorReporter.simpleError(funcDecl, \"Malformed function body (is this a class named the same as an existing interface?)\");\n                    return funcDecl;\n                }\n\n                this.scope = fnType.instanceType.constructorScope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n                funcTable = ssb.valueMembers.allMembers;\n            }\n            else if ((funcDecl.isSpecialFn() && !(funcDecl.fncFlags & FncFlags.Signature)) || funcDecl.isOverload) {\n                funcTable = funcDecl.symbols;\n                // if the function is static, we just want to use the \n                // current scope\n                if (!hasFlag(funcDecl.fncFlags, FncFlags.Static) && fnType.containedScope) {\n                    this.scope = fnType.containedScope;\n                }\n            }\n            else {\n                if (funcDecl.bod) {\n                    this.scope = fnType.containedScope;\n                }\n                var ssb = <SymbolScopeBuilder>this.scope;\n\n                // If it is null, it's an ambient declaration with no body, so it doesn't strictly matter\n                // if funcTable is not set\n                if (ssb && ssb.valueMembers) {\n                    funcTable = ssb.valueMembers.allMembers;\n                }\n            }\n\n            // If it's a class constructor, we need to check for the presence (or absense) of calls\n            // to the 'super' constructor\n            //\n            // A super constructor call must exist if:\n            //  - the class has a base class\n            //\n            // A super constructor call must be the first statement in the function body if:\n            //  - the constructor has parameter properties or\n            //  - the class body has initialized property decls\n            //\n            // A super constructor call may not exist if:\n            //  - The class has no base type, or inherits directly from 'Object'\n            if (funcDecl.isConstructor && funcDecl.bod && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n\n                var hasBaseType = hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseType);\n                var noSuperCallAllowed = !hasBaseType || hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);\n                var superCallMustBeFirst = hasFlag((<ClassDeclaration>funcDecl.classDecl).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);\n\n                if (noSuperCallAllowed && this.classConstructorHasSuperCall(funcDecl)) {\n                    this.checker.errorReporter.simpleError(funcDecl, \"Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class\");\n                }\n                else if (hasBaseType) {\n                    if (superCallMustBeFirst) {\n                        if (!funcDecl.bod ||\n                            !funcDecl.bod.members.length ||\n                            !((funcDecl.bod.members[0].nodeType == NodeType.Call && (<CallExpression>funcDecl.bod.members[0]).target.nodeType == NodeType.Super) ||\n                            (hasFlag(funcDecl.bod.flags, ASTFlags.StrictMode) && funcDecl.bod.members.length > 1 &&\n                             funcDecl.bod.members[1].nodeType == NodeType.Call && (<CallExpression>funcDecl.bod.members[1]).target.nodeType == NodeType.Super))) {\n                            this.checker.errorReporter.simpleError(funcDecl, \"If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor\");\n                        }\n                    }\n                    else if (!this.classConstructorHasSuperCall(funcDecl)) {\n                        this.checker.errorReporter.simpleError(funcDecl, \"Constructors for derived classes must contain a call to the class's 'super' constructor\");\n                    }\n                }\n            }\n\n            // If we've typechecked this method \"out of order\" (not by walking the class, but through a method call somewhere else),\n            // we need to reset the current class node in question, so that vis";
var v27477 = v27478 + "ibility checks on class members don't fail\n            if (funcDecl.isMethod() && funcDecl.type.enclosingType) {\n\n                var enclosingClassNode: TypeDeclaration = null;\n\n                if (funcDecl.type.enclosingType.symbol.declAST.nodeType == NodeType.FuncDecl) {\n                    enclosingClassNode = <TypeDeclaration>(<FuncDecl>funcDecl.type.enclosingType.symbol.declAST).classDecl;\n                }\n                else if (funcDecl.type.enclosingType.symbol.declAST.nodeType == NodeType.ClassDeclaration) {\n                    enclosingClassNode = <TypeDeclaration>funcDecl.type.enclosingType.symbol.declAST;\n                }\n\n                if (enclosingClassNode) {\n                    this.thisClassNode = enclosingClassNode;\n                }\n            }\n\n            // if this function is contained in a module, we may be in the midst of a recursive typecheck operation\n            // should that be the case, we need to properly set the current module (for visibility tests)\n            if (fnType.enclosingType) {;\n                var enclosingSym = fnType.symbol.container;\n\n                // if the enclosing type is a class, grab the parent module\n                if (enclosingSym && enclosingSym.isType() && enclosingSym.getType().isClass()) {\n                    enclosingSym = enclosingSym.container;\n                }\n\n                if (enclosingSym && enclosingSym.declAST && enclosingSym.declAST.nodeType == NodeType.ModuleDeclaration) {\n                    this.checker.currentModDecl = <ModuleDeclaration>enclosingSym.declAST;\n                }\n            }\n\n            if (funcDecl.unitIndex > 0) {\n                if (this.checker.units &&\n                    (funcDecl.unitIndex < this.checker.units.length)) {\n                    this.checker.locationInfo = this.checker.units[funcDecl.unitIndex];\n                }\n                else {\n                    this.checker.locationInfo = unknownLocationInfo;\n                }\n            }\n\n            if (fnType.enclosingType) {\n                this.thisType = fnType.enclosingType;\n            }\n            else {\n                this.thisType = prevThisType;\n            }\n\n            var paramLen = signature.parameters.length;\n\n            if (!funcDecl.isConstructor && funcDecl.bod && !funcDecl.isSignature()) {\n                var tmpParamScope = this.scope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n\n                // Attempt to contextually type the function declaration             \n                if (!funcDecl.isMethod() && funcDecl.returnTypeAnnotation == null) {\n\n                    // the funcDecl may be a candidate for contextual typing                 \n                    // REVIEW: prevScope will only be null in the case of an upstream error\n                    if (prevScope && funcDecl.name && !funcDecl.name.isMissing()) {\n                        // Go ahead and check for an ambient symbol\n                        var considerSym: Symbol = prevScope.findAmbient(funcDecl.name.text, false, false);\n\n                        if (considerSym && considerSym.declAST && considerSym.declAST.type) {\n                            // REVIEW: Ambients beget signatures, and signatures don't need to be typechecked\n                            //typeCheck(considerSym.declAST);\n                            this.checker.setContextualType(considerSym.declAST.type, false);\n                        }\n                    }\n\n                    if (this.checker.hasTargetType()) {\n                        var candidateTypeContext = this.checker.getTargetTypeContext();\n                        var candidateType = candidateTypeContext.contextualType;\n\n                        if (this.checker.canContextuallyTypeFunction(candidateType, funcDecl, true)) {\n\n                            // Safe to do this, since the indices and fields are guaranteed to be\n                            // non-null and valid by the above call to canContextuallyTypeFunction\n                            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;\n                            candidateTypeContext.targetSig = candidateSigs.signatures[0];\n                            var candidateParams = candidateTypeContext.targetSig.parameters;\n\n                            // the target type has been accepted\n                            targetParams = candidateParams;\n                            targetReturnType = candidateTypeContext.targetSig.returnType.type;\n\n                            // Set \"this\" if applicable\n                            if (candidateTypeContext.targetSig.declAST) {\n                                if (candidateTypeContext.targetSig.declAST.isConstructor) {\n                                    //candidateTypeContext.targetThis=candidateType.instanceType;\n                                    //this.thisType = candidateType.instanceType;\n                                    funcDecl.isTargetTypedAsMethod = true;\n               ";
var v27476 = v27477 + "                 }\n                                else if (candidateTypeContext.targetSig.declAST.isMethod()) {\n                                    //candidateTypeContext.targetThis=candidateTypeContext.targetSig.declAST.type.enclosingType;\n                                    //this.thisType = candidateTypeContext.targetSig.declAST.type.enclosingType;\n                                    funcDecl.isTargetTypedAsMethod = true;\n                                }\n                            }\n                            fgSym.type = candidateTypeContext.contextualType;\n                            acceptedContextualType = true;\n                        }\n                        else if (candidateType && funcDecl.isAccessor()) {\n                            accessorType = candidateType;\n                            candidateTypeContext.targetAccessorType = accessorType;\n                        }\n                        else {\n                            this.checker.killCurrentContextualType();\n                        }\n                    }\n                }\n\n                // typecheck parameters\n                // Add parameter symbols to current scope for typechecking (in case default params reference each other)\n                // Order matters here - default parameters can reference previously defined parameters\n                var paramTable = ssb.valueMembers;\n                this.scope = new SymbolScopeBuilder(paramTable, null, null, null, prevScope, container);\n\n                for (var p = 0; p < paramLen; p++) {\n                    var symbol = signature.parameters[p];\n                    var ast = <ArgDecl>symbol.declAST\n\n                    if (this.checker.hasTargetType() && (targetParams && (this.checker.getTargetTypeContext().targetSig.hasVariableArgList || p < targetParams.length))) {\n                        var candidateTypeContext = this.checker.getTargetTypeContext();\n                        var hasVarArgList = candidateTypeContext.targetSig.hasVariableArgList;\n                        ast.type = hasVarArgList && p >= targetParams.length - 1 ? targetParams[targetParams.length - 1].getType().elementType : targetParams[p].getType();\n                        ast.sym.setType(ast.type);\n                        (<InferenceSymbol>ast.sym).typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                    }\n                    else {\n                        this.typeCheck(ast);\n                    }\n\n                    // infer the setter type, if necessary\n                    if (isSetter && accessorType) {\n                        ast = <ArgDecl>this.cast(ast, accessorType);\n                    }\n\n                    symbol.container = container;\n                    // Verify the parameter for the privacy\n                    this.checkTypePrivacy(symbol.getType(), container, (typeName: string, isModuleName: bool) => this.functionArgumentPrivacyErrorReporter(funcDecl, p, symbol, typeName, isModuleName));\n                    paramTable.publicMembers.add(symbol.name, symbol);\n                }\n                this.scope = tmpParamScope;\n            }\n            else {\n                this.typeCheck(funcDecl.arguments)\n\n                // Because some terms were not yet type-checkable during binding, ensure that\n                // param symbols are updated with the proper argument types\n                for (var p = 0; p < paramLen; p++) {\n                    signature.parameters[p].parameter.typeLink.type = funcDecl.arguments.members[p].type;\n                    // Verify the parameter for the privacy\n                    this.checkTypePrivacy(signature.parameters[p].getType(), container, (typeName: string, isModuleName: bool) => this.functionArgumentPrivacyErrorReporter(funcDecl, p, signature.parameters[p], typeName, isModuleName));\n                    if ((<ArgDecl>funcDecl.arguments.members[p]).parameterPropertySym) {\n                        (<ArgDecl>funcDecl.arguments.members[p]).parameterPropertySym.setType(funcDecl.arguments.members[p].type);\n                    }\n                }\n\n                if ((funcDecl.fncFlags & FncFlags.IndexerMember)) {\n                    if (!paramLen || paramLen > 1) {\n                        this.checker.errorReporter.simpleError(funcDecl, \"Index signatures may take one and only one parameter\");\n                    }\n                    else if (funcDecl.arguments.members[0].type == this.checker.numberType) {\n                        fnType.index.flags |= SignatureFlags.IsNumberIndexer;\n                    }\n                    else if (funcDecl.arguments.members[0].type == this.checker.stringType) {\n                        fnType.index.flags |= SignatureFlags.IsStringIndexer;\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(funcDecl.arguments.members[0], \"Index signatures may only take 'string' or 'number' as their parameter\");\n                    }\n\n                }\n            }\n\n       ";
var v27475 = v27476 + "     // typecheck body\n            if (funcDecl.bod && (!funcDecl.isSignature())) {\n                if (!(funcDecl.isConstructor)) {\n                    this.addFormals(container, signature, funcTable);\n                }\n                else {\n                    this.addConstructorLocalArgs(funcDecl.type.symbol, funcDecl.arguments, funcTable, hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod));\n\n                    if (this.thisClassNode && this.thisClassNode.extendsList) {\n                        var tmpScope = this.scope;\n                        var funcMembers = new ScopedMembers(<DualStringHashTable>funcTable);\n                        this.scope = new FilteredSymbolScopeBuilder(funcMembers, prevScope, funcDecl.type.symbol,\n                                                             function (sym) {\n                                                                 return sym.kind() == SymbolKind.Parameter;\n                                                             });\n                        this.typeCheckBaseCalls(this.thisClassNode.extendsList);\n                        this.scope = tmpScope;\n                    }\n                }\n\n                // Because this function may have been typechecked in a different visiblity context as its caller (e.g., this\n                // function is being typechecked as a result of a call, before the declaration could be typechecked), we need\n                // to set the enclosing module\n                var prevMod = this.checker.currentModDecl;\n                if (funcDecl.type &&\n                    funcDecl.type.symbol &&\n                    !funcDecl.isMethod() &&\n                    funcDecl.type.symbol.declModule) {\n                    this.checker.currentModDecl = funcDecl.type.symbol.declModule;\n                }\n\n\n                // unset the contextual type before typechecking the function body\n                if (acceptedContextualType) {\n                    this.checker.setContextualType(null, this.checker.inProvisionalTypecheckMode());\n                }\n\n                this.typeCheck(funcDecl.bod);\n\n                if (acceptedContextualType) {\n                    this.checker.unsetContextualType();\n                }\n\n                this.checker.currentModDecl = prevMod;\n\n                if (this.checker.checkControlFlow) {\n                    var cfg = funcDecl.buildControlFlow();\n                    if (this.checker.printControlFlowGraph) {\n                        cfg.print(this.checker.errorReporter.outfile);\n                    }\n                    cfg.reportUnreachable(this.checker.errorReporter);\n                    if (this.checker.checkControlFlowUseDef) {\n                        cfg.useDef(this.checker.errorReporter, funcDecl.type.symbol);\n                    }\n                }\n\n                if (funcDecl.isConstructor) {\n                    var fns: ASTList = funcDecl.scopes;\n                    var fnsLen = fns.members.length;\n                    var freeVars: Symbol[];\n                    var sym: Symbol;\n                    var j = 0;\n                    for (; j < fnsLen; j++) {\n                        var fn = <FuncDecl>fns.members[j];\n                        if (!fn.isSignature()) {\n                            if (hasFlag(fn.fncFlags, FncFlags.Method) && (!hasFlag(fn.fncFlags, FncFlags.Static))) {\n                                this.checkPromoteFreeVars(fn, funcDecl.type.symbol);\n                            }\n                        }\n                    }\n                }\n            }\n\n            this.scope = prevScope;\n            this.thisFnc = prevFnc;\n            this.thisClassNode = prevClassNode;\n            this.enclosingFncIsMethod = prevMethodStatus;\n            this.thisType = prevThisType;\n            this.checker.locationInfo = prevLocationInfo;\n            this.checker.currentModDecl = prevModDecl;\n\n            signature.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n\n            // set the return type\n            if (funcDecl.returnTypeAnnotation) {\n                this.checkForVoidConstructor(funcDecl.returnTypeAnnotation.type, funcDecl.returnTypeAnnotation);\n\n                if (signature.returnType.type == null) {\n                    this.checker.resolveTypeLink(this.scope, signature.returnType, false);\n                }\n            }\n            else if (targetReturnType) {\n                signature.returnType.type = targetReturnType;\n            }\n\n            // If no return type annotation has been applied to the function declaration\n            // unify the return types from the given return statements\n\n            if (!(fgSym.flags & SymbolFlags.RecursivelyReferenced) && funcDecl.returnStatementsWithExpressions.length > 0) {\n                var collection: ITypeCollection = {\n                    getLength: () => { return funcDecl.returnStatementsWithExpressions.length; },\n                    setTypeAtIndex: (index: number, type: Type) => { funcDecl.returnStatementsWithExpressions[index].t";
var v27474 = v27475 + 'ype = type; },\n                    getTypeAtIndex: (index: number) => { return funcDecl.returnStatementsWithExpressions[index].type; }\n                }\n\n                var bestCommonReturnType = funcDecl.returnStatementsWithExpressions[0].type;\n                bestCommonReturnType = this.checker.findBestCommonType(bestCommonReturnType, null, collection, true);\n\n                if (bestCommonReturnType) {\n                    signature.returnType.type = this.checker.widenType(bestCommonReturnType);\n                }\n                else {\n                    for (var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {\n                        this.checker.errorReporter.simpleError(funcDecl.returnStatementsWithExpressions[i], "Incompatible return type");\n                    }\n                    signature.returnType.type = this.anyType;\n                }\n            }\n\n            var onlyHasThrow = false;\n\n            if (signature.returnType.type == null) {\n                if (hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression)) {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(funcDecl, "type implicitly set to \'any\'");\n                    }\n                    signature.returnType.type = this.anyType;\n                }\n                else {\n                    signature.returnType.type = this.voidType;\n                }\n            }\n            else if (signature.returnType.type == this.nullType || signature.returnType.type == this.checker.undefinedType) {\n                signature.returnType.type = this.anyType;\n            }\n            else if ((signature.returnType.type != this.voidType && signature.returnType.type != this.checker.undefinedType && signature.returnType.type != this.anyType)) {\n                // the signature declared a non-void type, but there\'s no return statement\n                if (!funcDecl.isSignature() &&\n                    !funcDecl.isConstructor &&\n                    !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression) &&\n                    !hasFlag(funcDecl.fncFlags, FncFlags.IsFatArrowFunction)) {\n                        // relax the restriction if the method only contains a single "throw" statement\n                    onlyHasThrow = (funcDecl.bod.members.length > 0) && (funcDecl.bod.members[0].nodeType == NodeType.Throw)\n\n                    if (!onlyHasThrow) {\n                        this.checker.errorReporter.simpleError(funcDecl.returnTypeAnnotation || funcDecl,\n                             "Function declared a non-void return type, but has no return expression");\n                    }\n                }\n\n                // Type check for return type Privacy\n                this.checkTypePrivacy(signature.returnType.type, container, (typeName: string, isModuleName: bool) => this.functionReturnTypePrivacyErrorReporter(funcDecl, signature, typeName, isModuleName));\n            }\n\n            // if the function declaration is a getter or a setter, set the type of the associated getter/setter symbol\n            if (funcDecl.accessorSymbol) {\n                var accessorType = funcDecl.accessorSymbol.getType();\n                if (!onlyHasThrow && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression)) {\n                    this.checker.errorReporter.simpleError(funcDecl, "Getters must return a value");\n                }\n                if (accessorType) {\n                    if ((hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && accessorType != signature.returnType.type) ||\n                        (funcDecl.arguments.members.length > 0 && accessorType != funcDecl.arguments.members[0].type)) {\n                        this.checker.errorReporter.simpleError(funcDecl, "Getter and setter types do not agree");\n                    }\n                }\n                else {\n                    if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                        funcDecl.accessorSymbol.setType(signature.returnType.type);\n                    }\n                    else {\n                        if (funcDecl.arguments.members.length != 1) {\n                            this.checker.errorReporter.simpleError(funcDecl, "Setters may have one and only one argument");\n                        }\n                        else {\n                            funcDecl.accessorSymbol.setType(funcDecl.arguments.members[0].type);\n                        }\n                    }\n                }\n            }\n\n            this.typeCheckOverloadSignatures(fnType, funcDecl);\n            return funcDecl;\n        }\n\n        public typeCheckBases(type: Type) {\n            var seenInterface = false;\n            var bases = type.extendsList;\n            var baseLinks = type.extendsTypeLinks;\n            if (bases) {\n                var len = bases.length;\n\n                if (len > 0) {\n                    type.typeFlags |= TypeFlags.Has';
var v27473 = v27474 + 'BaseType;\n                }\n\n                for (var i = 0; i < len; i++) {\n                    if (bases[i] == this.checker.anyType) {\n                        // This may be the type from imported module and hence the type was not really resolved to the correct one.\n                        // Try resolving it again\n                        baseLinks[i].type = null;\n                        // There are no contextual errors when trying to verify the base class\n                        var oldErrors = this.checker.errorReporter.getCapturedErrors();\n                        CompilerDiagnostics.assert(oldErrors.length == 0, "There shouldnt be any contextual errors when typechecking base type names");\n                        this.checker.errorReporter.pushToErrorSink = true;\n                        bases[i] = this.checker.resolveBaseTypeLink(baseLinks[i], type.containedScope);\n                        this.checker.errorReporter.pushToErrorSink = false;\n                        this.checker.errorReporter.freeCapturedErrors();\n                    }\n\n                    var base = bases[i];\n                    var baseRef = baseLinks[i].ast;\n\n                    // make sure it\'s the global \'Object\' and not some alias\n                    var baseTypeOfObject = base.symbol && base.symbol.name == "Object" && base.symbol.container == this.checker.gloMod;\n\n                    if (baseTypeOfObject) {\n                        type.typeFlags |= TypeFlags.HasBaseTypeOfObject;\n                    }\n\n                    if (base.isClassInstance()) {\n                        if (!(type.isClassInstance())) {\n                            this.checker.errorReporter.simpleError(baseRef, "Interface base type must be interface");\n                        }\n                        else {\n                            if (seenInterface) {\n                                this.checker.errorReporter.simpleError(baseRef, "Class may not follow interface as base type");\n                            }\n                        }\n                    }\n                    else if (base.isModuleType()) {\n                        this.checker.errorReporter.simpleError(baseRef, "Types may not be derived from module types");\n                    }\n                    else if (base.members) {\n                        if (!seenInterface) {\n                            seenInterface = true;\n                        }\n                    }\n                    else {\n                        if (!(type.isClassInstance())) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "Interface base type must be interface");\n                        }\n                        else {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "Base type must be interface or class");\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        public checkMembersImplementInterfaces(implementingType: Type) {\n            var instanceType = implementingType.getInstanceType();\n            if (instanceType.implementsList) {\n                var len = instanceType.implementsList.length;\n\n                for (var i = 0; i < len; i++) {\n                    var interfaceType = instanceType.implementsList[i];\n                    var comparisonInfo = new TypeComparisonInfo();\n                    if (!this.checker.sourceIsSubtypeOfTarget(instanceType, interfaceType, comparisonInfo)) {\n                        var emsg = "Class \'" + instanceType.getTypeName() +\n                              "\' declares interface \'" + interfaceType.getTypeName() +\n                              "\' but does not implement it";\n                        if (!comparisonInfo.message) {\n                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg);\n                        }\n                        else {\n                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg + ": " + comparisonInfo.message);\n                        }\n                    }\n                }\n            }\n        }\n\n        public typeCheckBaseCalls(bases: ASTList) {\n            if (bases == null) {\n                return;\n            }\n            var basesLen = bases.members.length;\n            for (var i = 0; i < basesLen; i++) {\n                var baseExpr = bases.members[i];\n                var baseSymbol: Symbol = null;\n                if (baseExpr.nodeType == NodeType.Call) {\n                    this.typeCheckNew(baseExpr);\n                }\n            }\n        }\n\n        public assertUniqueNamesInBaseTypes(names: IHashTable, type: Type, classDecl: InterfaceDeclaration, checkUnique: bool): void {\n            if (type) {\n                if (type.members) {\n                    type.members.publicMembers.map((key, s, c) => {\n  ';
var v27472 = v27473 + '                      var sym = <Symbol>s;\n                        var dup = names.lookup(sym.name);\n                        if (dup) {\n                            if (checkUnique) {\n                                this.checker.errorReporter.simpleError(classDecl,\n                                                                  "duplicate member name in bases for " + classDecl.name.actualText + ": " + type.symbol.name + " and " + dup.container.name + " both contain member with name " + sym.name);\n                            }\n                        }\n                        else {\n                            names.add(sym.name, sym);\n                        }\n                    }, null);\n                }\n                if (type.extendsList) {\n                    var len = type.extendsList.length;\n                    for (var i = 0; i < len; i++) {\n                        if (!(type.extendsList[i].symbol.flags & SymbolFlags.RecursivelyReferenced)) {\n                            this.assertUniqueNamesInBaseTypes(names, type.extendsList[i], classDecl, checkUnique);\n                        }\n                    }\n                }\n            }\n        }\n\n        public checkBaseTypeMemberInheritance(derivedType: Type, derivedTypeDecl: AST): void {\n            var instanceType = derivedType.getInstanceType();\n            if (instanceType.extendsList == null) {\n                return;\n            }\n\n            var len = instanceType.extendsList.length;\n            if (len > 0) {\n                var names = new StringHashTable();\n                if (instanceType.isClassInstance()) {\n                    for (var i = 0; i < len; i++) {\n                        this.assertUniqueNamesInBaseTypes(names, instanceType.extendsList[i], <InterfaceDeclaration>derivedTypeDecl, i > 0);\n                    }\n                }\n\n                if (instanceType.members) {\n                    instanceType.members.publicMembers.map((key, s, c) => {\n                        var sym = <Symbol>s;\n                        for (var j = 0; j < len; j++) {\n                            var base = instanceType.extendsList[j];\n                            if (base.memberScope == null) {\n                                this.checker.errorReporter.simpleError(derivedTypeDecl, "Base type \'" + base.symbol.name + "\' lacks an implementation.")\n                            }\n                            else {\n                                var bSym = base.memberScope.find(sym.name, false, false);\n                                if (bSym) {\n                                    var aType = sym.getType();\n                                    var bType = bSym.getType();\n                                    if (!(this.checker.sourceIsSubtypeOfTarget(aType, bType))) {\n                                        this.checker.errorReporter.simpleErrorFromSym(sym,\n                                                                          "Type of overridden member \'" + sym.name + "\' is not subtype of original member defined by type \'" + bSym.container.name + "\'");\n                                    }\n                                    else if ((sym.kind() == SymbolKind.Type) &&\n                                             (bSym.kind() == SymbolKind.Field)) {\n                                        this.checker.errorReporter.simpleErrorFromSym(sym,\n                                                                          "Cannot override field \'" + sym.name + "\' with method");\n                                    }\n                                }\n                            }\n                        }\n                    }, null);\n                }\n            }\n        }\n\n        public typeCheckClass(classDecl: ClassDeclaration): ClassDeclaration {\n            var typeSymbol = <TypeSymbol>classDecl.type.symbol;\n\n            if (typeSymbol.typeCheckStatus == TypeCheckStatus.Finished) {\n                return classDecl;\n            }\n            else if (typeSymbol.typeCheckStatus == TypeCheckStatus.Started) {\n                // REVIEW: report this recursion\n                //checker.errorReporter.recursionRequiresTypeAnnotation(classDecl);\n                return classDecl;\n            }\n            else {\n                typeSymbol.typeCheckStatus = TypeCheckStatus.Started;\n                this.checker.addStartedPTO(typeSymbol);\n            }\n\n            var prevScope = this.scope;\n            var svClassNode = this.thisClassNode;\n            this.thisClassNode = classDecl;\n            var classType = classDecl.type;\n            this.typeCheckBases(classType.instanceType);\n\n            this.typeCheckBaseListPrivacy(classDecl.extendsList, typeSymbol, true);\n            this.typeCheckBaseListPrivacy(classDecl.implementsList, typeSymbol, false);\n\n            var prevThisType = this.thisType;\n            this.thisType = classType.instanceType;\n            this.scope = classType.instanceType.containedScope;\n\n            // Add the constructor locals, if necessary\n  ';
var v27471 = v27472 + '          if (classDecl.constructorDecl) {\n                this.scope = classType.instanceType.constructorScope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n                var funcTable = ssb.valueMembers.allMembers;\n\n                this.addConstructorLocalArgs(classDecl.constructorDecl.type.symbol, classDecl.constructorDecl.arguments, funcTable, true);\n            }\n\n            this.typeCheck(classDecl.members);\n            typeSymbol.typeCheckStatus = TypeCheckStatus.Finished;\n            this.checkBaseTypeMemberInheritance(classType, classDecl);\n            this.checkMembersImplementInterfaces(classType);\n\n            this.typeCheckOverloadSignatures(classType, classDecl);\n            this.typeCheckOverloadSignatures(classType.instanceType, classDecl);\n\n            // if the class has no declared constructor, adapt its base class\'s signature group, if necessary\n            if (!classDecl.constructorDecl) {\n                if (classDecl.extendsList &&\n                    classDecl.extendsList.members.length &&\n                    classDecl.extendsList.members[0].type &&\n                    classDecl.extendsList.members[0].type.symbol.type.isClass()) {\n                    cloneParentConstructGroupForChildType(classDecl.type, classDecl.extendsList.members[0].type.symbol.type);\n                }\n            }\n\n            this.thisType = prevThisType;\n            this.thisClassNode = svClassNode;\n            this.scope = prevScope;\n            return classDecl;\n        }\n\n        public typeCheckOverloadSignatures(type: Type, ast: AST) {\n            if (type.call) {\n                type.call.typeCheck(this.checker, ast, type.construct != null);\n            }\n            if (type.construct) {\n                type.construct.typeCheck(this.checker, ast, false);\n            }\n            if (type.index) {\n                type.index.typeCheck(this.checker, ast, false);\n            }\n        }\n\n        public typeCheckInterface(interfaceDecl: InterfaceDeclaration): InterfaceDeclaration {\n            // overloads will be typechecked inline by the members\n            //this.typeCheckOverloadSignatures(interfaceDecl.type, interfaceDecl);\n            this.typeCheckBases(interfaceDecl.type);\n            this.typeCheckBaseListPrivacy(interfaceDecl.extendsList, interfaceDecl.type.symbol, true);\n            this.typeCheck(interfaceDecl.members);\n            this.checkBaseTypeMemberInheritance(interfaceDecl.type, interfaceDecl);\n\n            // propagate base type signatures\n            if (interfaceDecl.extendsList) {\n                for (var i = 0; i < interfaceDecl.extendsList.members.length; i++) {\n                    if (interfaceDecl.extendsList.members[i].type.call) {\n                        if (interfaceDecl.type.call) {\n                            interfaceDecl.type.call.signatures = interfaceDecl.type.call.signatures.concat(interfaceDecl.extendsList.members[i].type.call.signatures);\n                        }\n                        else {\n                            interfaceDecl.type.call = interfaceDecl.extendsList.members[i].type.call;\n                        }\n                    }\n                    if (interfaceDecl.extendsList.members[i].type.construct) {\n                        if (interfaceDecl.type.construct) {\n                            interfaceDecl.type.construct.signatures = interfaceDecl.type.construct.signatures.concat(interfaceDecl.extendsList.members[i].type.construct.signatures);\n                        }\n                        else {\n                            interfaceDecl.type.construct = interfaceDecl.extendsList.members[i].type.construct;\n                        }\n                    }\n                    if (interfaceDecl.extendsList.members[i].type.index) {\n                        if (interfaceDecl.type.index) {\n                            interfaceDecl.type.index.signatures = interfaceDecl.type.index.signatures.concat(interfaceDecl.extendsList.members[i].type.index.signatures);\n                        }\n                        else {\n                            interfaceDecl.type.index = interfaceDecl.extendsList.members[i].type.index;\n                        }\n                    }\n                }\n            }\n\n            return interfaceDecl;\n        }\n\n        public typeCheckImportDecl(importDecl: ImportDeclaration) {\n            var mod: ModuleType = <ModuleType>importDecl.alias.type;\n            var sym: TypeSymbol = null;\n            var prevInImportTC = this.inImportTypeCheck;\n            this.inImportTypeCheck = true;\n\n            this.typeCheck(importDecl.alias);\n            mod = <ModuleType>importDecl.alias.type;\n\n            if (mod == null) {\n                this.checker.errorReporter.simpleError(importDecl.alias, "Could not resolve module alias \'" + importDecl.id.actualText + "\'");\n                mod = <ModuleType>this.checker.anyType;\n                (<TypeSymbol>importDecl.id.sym).type = mod;\n            }\n\n            importDecl.id.type = mod;';
var v27470 = v27471 + '\n            sym = mod.symbol;\n\n            if (!mod.isModuleType()) {\n                this.checker.errorReporter.simpleError(importDecl.alias, "A module cannot be aliased to a non-module type");\n            }\n            else {\n                sym.type = mod;\n                \n                // Add the imported module to the AMD dependency list\n                if (this.checker.typeFlow.currentScript && \n                    this.checker.typeFlow.currentScript.topLevelMod && \n                    this.checker.typeFlow.currentScript.topLevelMod.mod) \n                {\n                    this.checker.typeFlow.currentScript.topLevelMod.mod.importedModules.push(importDecl);\n                }\n\n                (<TypeSymbol>importDecl.id.sym).type = mod;\n\n                if (mod.symbol && mod.symbol.declAST) {\n                    (<ModuleDeclaration>mod.symbol.declAST).modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;\n                }\n\n                //importDecl.id.sym = sym;\n                // REVIEW: Uncomment when you can toggle module codegen targets from the language service\n                //else if (typeFlow.checker.currentModDecl == null && \n                //            hasFlag((<ModuleDecl>sym.declAST).modFlags,ModuleFlags.IsDynamic) &&\n                //            moduleGenTarget == ModuleGenTarget.Asynchronous) \n                //{\n                //    typeFlow.checker.errorReporter.simpleError(alias, "In AMD codegen mode, dynamic modules may not be referenced from global scope.  (Wrap the file in a module declaration.)");\n                //}\n            }\n            this.inImportTypeCheck = prevInImportTC;\n            return importDecl;\n        }\n\n        public typeCheckModule(moduleDecl: ModuleDeclaration): ModuleDeclaration {\n\n            // In some really nasty cases of error recovery, we may not have a type\n            if (!moduleDecl.mod) {\n                return moduleDecl;\n            }\n\n            if (this.currentScript) {\n                this.currentScript.requiresGlobal = true;\n            }\n            var mod = moduleDecl.mod;\n            var sym: TypeSymbol = null;\n\n            var prevScope = this.scope;\n            var prevThisType = this.thisType;\n            var prevCurrentModDecl = this.checker.currentModDecl;\n            this.checker.currentModDecl = moduleDecl;\n\n            this.thisType = null;\n            this.scope = mod.containedScope;\n            this.typeCheck(moduleDecl.members);\n            sym = mod.symbol;\n\n            this.checker.currentModDecl = prevCurrentModDecl;\n            this.thisType = prevThisType;\n            this.scope = prevScope;\n\n            moduleDecl.type = mod;\n\n            if (sym) {\n                sym.typeCheckStatus = TypeCheckStatus.Finished;\n            }\n            return moduleDecl;\n        }\n\n        public typeCheckFor(forStmt: ForStatement): ForStatement {\n            forStmt.init = this.typeCheck(forStmt.init);\n            this.nestingLevel++;\n            forStmt.cond = this.typeCheck(forStmt.cond);\n            this.typeCheckCondExpr(forStmt.cond);\n            forStmt.incr = this.typeCheck(forStmt.incr);\n            this.nestingLevel--;\n            forStmt.body = this.typeCheck(forStmt.body);\n            this.typeCheckCompoundStmtBlock(forStmt.body, "for statement");\n            forStmt.type = this.voidType;\n            return forStmt;\n        }\n\n        public typeCheckWith(withStmt: WithStatement): WithStatement {\n            if (this.checker.errorsOnWith) {\n                this.checker.errorReporter.simpleError(withStmt.expr, "All symbols within a \'with\' block will be typed as \'any\'");\n            }\n            withStmt.expr = this.typeCheck(withStmt.expr);\n            this.checker.inWith = true;\n            withStmt.body = this.typeCheck(withStmt.body);\n            this.typeCheckCompoundStmtBlock(withStmt.body, "with statement");\n            this.checker.inWith = false;\n            return withStmt;\n        }\n\n        public typeCheckForIn(forInStmt: ForInStatement): ForInStatement {\n            forInStmt.obj = this.typeCheck(forInStmt.obj);\n            forInStmt.lval = this.cast(this.typeCheck(forInStmt.lval), this.checker.stringType);\n            if (forInStmt.lval.nodeType == NodeType.VarDecl) {\n\n                var varDecl = <VarDecl>forInStmt.lval;\n                if (varDecl.typeExpr) {\n                    this.checker.errorReporter.simpleError(varDecl, "Variable declarations for for/in expressions may not contain a type annotation");\n                }\n\n                if (varDecl.sym) {\n                    varDecl.sym.setType(this.checker.stringType);\n                }\n            }\n            forInStmt.body = this.typeCheck(forInStmt.body);\n            this.typeCheckCompoundStmtBlock(forInStmt.body, "for in statement");\n            return forInStmt;\n        }\n\n        public typeCheckWhile(whileStmt: WhileStatement): WhileStatement {\n            whileStmt.cond = this.typeCheck(whileStmt.cond);\n            this.typeCheckCondE';
var v27469 = v27470 + 'xpr(whileStmt.cond);\n            whileStmt.body = this.typeCheck(whileStmt.body);\n            this.typeCheckCompoundStmtBlock(whileStmt.body, "while statement");\n            whileStmt.type = this.voidType;\n            return whileStmt;\n        }\n\n        public typeCheckDoWhile(doWhileStmt: DoWhileStatement): DoWhileStatement {\n            doWhileStmt.cond = this.typeCheck(doWhileStmt.cond);\n            this.typeCheckCondExpr(doWhileStmt.cond);\n            doWhileStmt.body = this.typeCheck(doWhileStmt.body);\n            this.typeCheckCompoundStmtBlock(doWhileStmt.body, "do while statement");\n            doWhileStmt.type = this.voidType;\n            return doWhileStmt;\n        }\n\n        public typeCheckCondExpr(cond: AST) {\n            if (this.checker.styleSettings.assignmentInCond) {\n                if ((cond !== null) &&\n                    (cond.nodeType >= NodeType.Asg) &&\n                    (cond.nodeType <= NodeType.LastAsg)) {\n                    this.checker.errorReporter.simpleError(cond, "top-level assignment statement in conditional expression");\n                }\n            }\n        }\n\n        public typeCheckCompoundStmtBlock(stmts: AST, stmtType: string) {\n            if (this.checker.styleSettings.blockInCompoundStmt && stmts) {\n                if (stmts.nodeType != NodeType.Block) {\n                    this.checker.errorReporter.styleError(stmts, stmtType + " requires a block");\n                }\n            }\n        }\n        public typeCheckIf(ifStmt: IfStatement): IfStatement {\n            ifStmt.cond = this.typeCheck(ifStmt.cond);\n            this.typeCheckCondExpr(ifStmt.cond);\n            ifStmt.thenBod = this.typeCheck(ifStmt.thenBod);\n            ifStmt.elseBod = this.typeCheck(ifStmt.elseBod);\n            this.typeCheckCompoundStmtBlock(ifStmt.thenBod, "if statement");\n            this.typeCheckCompoundStmtBlock(ifStmt.elseBod, "if statement");\n            ifStmt.type = this.voidType;\n            return ifStmt;\n        }\n\n        public typeFromAccessorFuncDecl(funcDecl: FuncDecl) {\n            if (!funcDecl.isAccessor()) {\n                return null;\n            }\n\n            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                return funcDecl.type.call.signatures[0].returnType.type;\n            }\n            else {\n                return funcDecl.type.call.signatures[0].parameters[0].getType();\n            }\n        }\n\n        public typeCheckObjectLit(objectLit: UnaryExpression): void {\n\n            var resultType = new Type();\n            resultType.symbol = new TypeSymbol(this.checker.anon, objectLit.minChar,\n                                             objectLit.limChar - objectLit.minChar,\n                                             this.checker.locationInfo.unitIndex,\n                                             resultType);\n\n            resultType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            resultType.memberScope = new SymbolTableScope(resultType.members, null, null, null, null);\n\n            var aggScope = new SymbolAggregateScope(resultType.symbol);\n            aggScope.addParentScope(resultType.memberScope);\n            aggScope.addParentScope(this.scope);\n            resultType.containedScope = aggScope;\n            var memberDecls = <ASTList>objectLit.operand;\n            var prevThisType = this.thisType;\n            var acceptTargetType = false;\n            var targetType: Type = null;\n\n            if (this.checker.hasTargetType()) {\n                targetType = this.checker.getTargetTypeContext().contextualType;\n\n                if (targetType && targetType.symbol && !this.checker.typeStatusIsFinished(targetType.symbol.typeCheckStatus)) {\n                    if (targetType.symbol.declAST) {\n                        this.typeCheck(targetType.symbol.declAST);\n                    }\n                }\n                acceptTargetType = true;\n            }\n\n            if (memberDecls) {\n                for (var i = 0, len = memberDecls.members.length; i < len; i++) {\n\n                    var binex = <BinaryExpression>memberDecls.members[i];\n\n                    var id = binex.operand1;\n                    var text: string;\n                    var targetMember: Symbol = null;\n                    var fieldSymbol: FieldSymbol = null;\n\n                    if (id.nodeType == NodeType.Name) {\n                        text = (<Identifier>id).text;\n                    }\n                    else if (id.nodeType == NodeType.QString) {\n                        // TODO: set text to unescaped string\n                        var idText = (<StringLiteral>id).text;\n                        text = idText.substring(1, idText.length - 1);\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(objectLit,\n                                                          "malformed object literal");\n                        resultType = this.anyType;\n       ';
var v27468 = v27469 + "                 break;\n                    }\n\n                    if (acceptTargetType && targetType.memberScope) {\n                        targetMember = targetType.memberScope.find(text, false, false);\n                    }\n\n                    // before typechecking an accessor function member, we need to initialize its accessor symbol\n                    if (binex.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>binex.operand2).isAccessor()) {\n\n                        var funcDecl = <FuncDecl>binex.operand2;\n                        var accessorSym: FieldSymbol = resultType.members.publicMembers.lookup(text);\n\n                        accessorSym = this.checker.createAccessorSymbol(funcDecl, accessorSym, resultType, true, false, resultType.memberScope, null);\n                        funcDecl.accessorSymbol = accessorSym;\n                        fieldSymbol = accessorSym;\n                        if (id.nodeType == NodeType.Name) {\n                            (<Identifier>id).sym = accessorSym;\n                        }\n                    }\n\n                    this.checker.typeCheckWithContextualType(acceptTargetType && targetMember ? targetMember.getType() : null, false, acceptTargetType, binex.operand2);\n\n                    if (acceptTargetType && targetMember) {\n                        // Note that we accept 'any' in place of a valid subtype                     \n                        if ((binex.operand2.type == this.anyType || this.checker.sourceIsAssignableToTarget(binex.operand2.type, targetMember.getType())) ||\n                            (binex.operand2.nodeType == NodeType.FuncDecl &&\n                            (<FuncDecl>binex.operand2).isAccessor() &&\n                                this.typeFromAccessorFuncDecl(<FuncDecl>binex.operand2) == targetMember.getType())) {\n                                    // set the field type to the proper contextual type\n                                    // this is especially important in the 'any' case, so that\n                                    // fields typed to 'any' aren't accepted for contextual typing,\n                                    // but never properly set to the target type\n                            binex.operand1.type = targetMember.getType();\n                        }\n                    }\n                    else {\n                        // here we sub in 'any' for 'undefined' to account for field initialization to\n                        // 'undefined'  \n                        binex.operand2.type = binex.operand2.type == this.checker.undefinedType ? this.anyType : binex.operand2.type;\n                    }\n\n                    // the field symbol hasn't been set by a getter or setter\n                    if (fieldSymbol == null) {\n                        var memberType = binex.operand2.type;\n                        var field = new ValueLocation();\n                        fieldSymbol =\n                            new FieldSymbol(text, id.minChar,\n                                            this.checker.locationInfo.unitIndex,\n                                            true, field);\n                        fieldSymbol.flags |= SymbolFlags.Property;\n                        field.symbol = fieldSymbol;\n                        fieldSymbol.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                        field.typeLink = new TypeLink();\n                        field.typeLink.type = memberType;\n                        resultType.members.publicMembers.add(text, fieldSymbol);\n                    }\n                    fieldSymbol.isObjectLitField = true;\n                }\n            }\n\n            this.thisType = prevThisType;\n            objectLit.type = resultType;\n            if (targetType) {\n                objectLit.targetType = targetType;\n            }\n        }\n\n        public typeCheckArrayLit(arrayLit: UnaryExpression): void {\n            var elements = <ASTList>arrayLit.operand;\n            var elementType = this.anyType;\n            var targetElementType: Type = null;\n            var comparisonInfo = new TypeComparisonInfo();\n            comparisonInfo.onlyCaptureFirstError = true;\n\n            // if the target type is an array type, extract the element type\n            if (this.checker.hasTargetType()) {\n                var targetType = this.checker.getTargetTypeContext().contextualType;\n                if (targetType.elementType) {\n                    targetElementType = targetType.elementType;\n                }\n            }\n\n            if (elements) {\n\n                var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck;\n\n                this.inArrayElementTypeCheck = true;\n                this.checker.typeCheckWithContextualType(targetElementType, this.checker.inProvisionalTypecheckMode(), targetElementType != null, elements);\n                this.inArrayElementTypeCheck = prevInArrayElemTypeCheck;\n\n                elementType = elements.members[0].type;\n\n                var collection: ITypeCo";
var v27467 = v27468 + 'llection = {\n                    getLength: () => { return elements.members.length; },\n                    setTypeAtIndex: (index: number, type: Type) => { elements.members[index].type = type; },\n                    getTypeAtIndex: (index: number) => { return elements.members[index].type; }\n                }\n\n                elementType = this.checker.findBestCommonType(elementType, targetElementType, collection, false, comparisonInfo);\n\n                // if the array type is the undefined type, we should widen it to any\n                // if it\'s of the null type, only widen it if it\'s not in a nested array element, so as not to \n                // short-circuit any checks for the best common type\n                if (elementType == this.checker.undefinedType || (!prevInArrayElemTypeCheck && elementType == this.nullType)) {\n                    elementType = this.anyType;\n                }\n            }\n            if (!elementType) {\n                var emsg = "Incompatible types in array literal expression";\n                if (!comparisonInfo.message) {\n                    this.checker.errorReporter.simpleError(arrayLit, emsg);\n                }\n                else {\n                    this.checker.errorReporter.simpleError(arrayLit, emsg + ": " + comparisonInfo.message);\n                }\n                elementType = this.anyType;\n            }\n            else if (targetElementType) {\n                // for the case of zero-length \'any\' arrays, we still want to set the contextual type, if\n                // need be\n                if (this.checker.sourceIsAssignableToTarget(elementType, targetElementType)) {\n                    elementType = targetElementType;\n                }\n            }\n\n            arrayLit.type = this.checker.makeArrayType(elementType);\n\n        }\n\n        public checkForVoidConstructor(type: Type, ast: AST) {\n            if (type &&\n                type.construct &&\n                type.construct.signatures.length > 0) {\n\n                for (var i = 0; i < type.construct.signatures.length; i++) {\n                    if (type.construct.signatures[i].returnType.type == this.checker.voidType) {\n                        this.checker.errorReporter.simpleError(ast, "Constructors may not have a return type of \'void\'");\n                        break;\n                    }\n                }\n            }\n        }\n\n        // REVIEW: the code below could set the signature type of the function to the current return\n        // type, which would have a benefit of reducing the risk of a recursive typecheck scenario, but is\n        // is technically wrong - mergeOrdered will only work properly if the best common supertype\n        // comes before any sibling types.  This would mean that if a function, "color()", returned\n        // three types (in order) - "Red", "Blue", and "IColor", an "Incompatible return type" error \n        // would be triggered.  However, if "color()" returned (in order) "Red", "IColor" and "Blue"\n        // no error would be triggered, and the return type of the function would be "IColor"\n        public typeCheckReturn(returnStmt: ReturnStatement): ReturnStatement {\n\n            if (this.thisFnc) {\n                var targetType: Type = null;\n\n                // determine the target type\n                if (this.checker.hasTargetType()) {\n                    var tcContext = this.checker.getTargetTypeContext();\n                    var accessorType = tcContext.targetAccessorType;\n\n                    if (accessorType) {\n                        targetType = accessorType;\n                    }\n                    else {\n                        var targetSig = this.checker.getTargetTypeContext().targetSig;\n                        if (targetSig && targetSig.returnType.type != this.voidType) {\n                            targetType = targetSig.returnType.type;\n                        }\n                    }\n                }\n\n                if (returnStmt.returnExpression) {\n                    this.thisFnc.fncFlags |= FncFlags.HasReturnExpression;\n\n                    if (targetType == null && this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type && this.thisFnc.returnTypeAnnotation.type != this.voidType) {\n                        targetType = this.thisFnc.returnTypeAnnotation.type;\n                    }\n\n                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), targetType != null, returnStmt.returnExpression);\n\n                    var expectedReturnType: Type =\n                        (this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ?\n                            this.thisFnc.returnTypeAnnotation.type :\n                            targetType;\n                    if (expectedReturnType) {\n                        if (expectedReturnType == this.voidType && returnStmt.returnExpression.type != this.voidType) {\n                            this.checker.errorReporter.simp';
var v27466 = v27467 + 'leError(returnStmt,\n                                                              "Return with value expression in void function");\n\n                            // even though we\'ve raised an error, use the more specific type\n                            returnStmt.type = returnStmt.returnExpression.type;\n                        }\n                        else {\n                            returnStmt.returnExpression = this.cast(returnStmt.returnExpression, expectedReturnType);\n                            returnStmt.type = expectedReturnType;\n                        }\n                    }\n                    else {\n                        if (targetType) {\n                            if (returnStmt.returnExpression.type != this.voidType) {\n                                returnStmt.returnExpression = this.cast(returnStmt.returnExpression, targetType);\n                            }\n                            else {\n                                returnStmt.returnExpression.type = targetType;\n                            }\n                        }\n                        returnStmt.type = returnStmt.returnExpression.type;\n                    }\n                    this.thisFnc.returnStatementsWithExpressions[this.thisFnc.returnStatementsWithExpressions.length] = returnStmt;\n                }\n                else {\n                    returnStmt.type = targetType == null ? this.checker.voidType : targetType; //((this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ? this.thisFnc.returnTypeAnnotation.type : this.checker.voidType) : targetType;\n                }\n            }\n\n            return returnStmt;\n        }\n\n        public typeCheckInstOf(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n\n            if (!((binex.operand1.type == this.checker.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand1.type, this.objectInterfaceType)) &&\n                    (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.functionInterfaceType)))) {\n                this.checker.errorReporter.simpleError(ast, "The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type");\n            }\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        public typeCheckCommaOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            binex.type = binex.operand2.type;\n            return binex;\n        }\n\n        public typeCheckLogOr(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (leftType == this.checker.anyType || rightType == this.checker.anyType) {\n                binex.type = this.checker.anyType;\n            }\n            else if (leftType == this.checker.booleanType) {\n                if (rightType == this.checker.booleanType) {\n                    binex.type = this.checker.booleanType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if (leftType == this.checker.numberType) {\n                if (rightType == this.checker.numberType) {\n                    binex.type = this.checker.numberType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if (leftType == this.checker.stringType) {\n                if (rightType == this.checker.stringType) {\n                    binex.type = this.checker.stringType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else {\n                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {\n                    binex.type = rightType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {\n                    binex.type = leftType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            return binex;\n        }\n\n        public typeCheckLogAnd(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            binex.type = binex.operand2.type;\n            return binex;\n        }\n\n        public tryAddCandidates(signature: Signature, actuals: Type[]';
var v27465 = v27466 + ", exactCandidates: Signature[], conversionCandidates: Signature[], comparisonInfo: TypeComparisonInfo): void {\n            var lowerBound = signature.nonOptionalParameterCount; // required parameters\n            var upperBound = signature.parameters.length; // required and optional parameters\n            var formalLen = lowerBound;\n            var acceptable = false;\n\n            if ((actuals.length >= lowerBound) && (signature.hasVariableArgList || actuals.length <= upperBound)) {\n                formalLen = (signature.hasVariableArgList ? signature.parameters.length : actuals.length);\n                acceptable = true;\n            }\n\n            var repeatType: Type = null;\n\n            if (acceptable || signature.hasVariableArgList) {\n                // assumed structure here is checked when signature is formed\n                if (signature.hasVariableArgList) {\n                    formalLen -= 1;\n                    repeatType = (<ParameterSymbol>signature.parameters[formalLen]).parameter.typeLink.type;\n                    repeatType = repeatType.elementType;\n                    acceptable = actuals.length >= formalLen;\n                }\n                var len = actuals.length;\n\n                var exact = acceptable;\n                var convert = acceptable;\n                for (var i = 0; i < len; i++) {\n                    var typeA: Type;\n                    if (i < formalLen) {\n                        typeA =\n                            (<ParameterSymbol>signature.parameters[i]).parameter.typeLink.type;\n                    }\n                    else {\n                        typeA = repeatType;\n                    }\n\n                    var typeB = actuals[i];\n                    if (!typeA || !typeB || !(this.checker.typesAreIdentical(typeA, typeB))) {\n                        exact = false;\n                    }\n                    // is the argument assignable to the parameter?\n                    if (!this.checker.sourceIsAssignableToTarget(typeB, typeA, comparisonInfo)) {\n                        convert = false;\n                    }\n                    if (!(exact || convert)) {\n                        break;\n                    }\n                }\n                if (exact) {\n                    exactCandidates[exactCandidates.length] = signature;\n                }\n                else if (convert && (exactCandidates.length == 0)) {\n                    conversionCandidates[conversionCandidates.length] = signature;\n                }\n\n            }\n        }\n\n        public resolveOverload(application: AST, group: SignatureGroup): Signature {\n            var rd = this.resolutionDataCache.getResolutionData();\n            var actuals = rd.actuals;\n            var exactCandidates = rd.exactCandidates;\n            var conversionCandidates = rd.conversionCandidates;\n            var candidate: Signature = null;\n            var hasOverloads = group.signatures.length > 1;\n            var comparisonInfo = new TypeComparisonInfo();\n            var args: ASTList = null;\n            var target: AST = null;\n\n            if (application.nodeType == NodeType.Call || application.nodeType == NodeType.New) {\n                var callEx = <CallExpression>application;\n                args = callEx.arguments;\n                target = callEx.target;\n                if (callEx.arguments) {\n                    var len = callEx.arguments.members.length;\n                    for (var i = 0; i < len; i++) {\n                        actuals[i] = callEx.arguments.members[i].type;\n                    }\n                }\n            }\n            else if (application.nodeType == NodeType.Index) {\n                var binExp = <BinaryExpression>application;\n                target = binExp.operand1;\n                args = new ASTList();\n                args.members[0] = binExp.operand2;\n                actuals[0] = binExp.operand2.type;\n            }\n\n            for (var j = 0, groupLen = group.signatures.length; j < groupLen; j++) {\n                var signature = group.signatures[j];\n                if (hasOverloads && signature == group.definitionSignature && !this.checker.canCallDefinitionSignature) {\n                    continue;\n                }\n                if (!signature.returnType.type && signature.declAST &&\n                    (signature.typeCheckStatus != TypeCheckStatus.Finished)) {\n                    this.typeCheckFunction(signature.declAST);\n                }\n                this.tryAddCandidates(signature, actuals, exactCandidates, conversionCandidates, comparisonInfo);\n            }\n            if (exactCandidates.length == 0) {\n\n                var applicableCandidates = this.checker.getApplicableSignatures(conversionCandidates, args, comparisonInfo);\n                if (applicableCandidates.length > 0) {\n                    var candidateInfo = this.checker.findMostApplicableSignature(applicableCandidates, args);\n                    if (candidateInfo.ambiguous) {\n                        this.checker.errorR";
var v27464 = v27465 + 'eporter.simpleError(target, "Ambiguous call expression - could not choose overload");\n                    }\n                    candidate = candidateInfo.sig;\n                }\n                else {\n                    var emsg = "Supplied parameters do not match any signature of call target";\n                    if (comparisonInfo.message) {\n                        this.checker.errorReporter.simpleError(target, emsg + ":\\n\\t" + comparisonInfo.message);\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(target, emsg);\n                    }\n                }\n            }\n            else {\n                if (exactCandidates.length > 1) {\n                    var applicableSigs: ApplicableSignature[] = [];\n                    for (var i = 0; i < exactCandidates.length; i++) {\n                        applicableSigs[i] = { signature: exactCandidates[i], hadProvisionalErrors: false };\n                    }\n                    var candidateInfo = this.checker.findMostApplicableSignature(applicableSigs, args);\n                    if (candidateInfo.ambiguous) {\n                        this.checker.errorReporter.simpleError(target, "Ambiguous call expression - could not choose overload");\n                    }\n                    candidate = candidateInfo.sig;\n                }\n                else {\n                    candidate = exactCandidates[0];\n                }\n            }\n\n            this.resolutionDataCache.returnResolutionData(rd);\n            return candidate;\n        }\n\n        public typeCheckNew(ast: AST): AST {\n            var callEx = <CallExpression>ast;\n\n            callEx.target = this.typeCheck(callEx.target);\n            var target = callEx.target;\n            if (target.type.construct || target.type.call) {\n                this.preTypeCheckCallArgs(callEx.arguments);\n            }\n            else {\n                callEx.arguments = <ASTList>this.typeCheck(callEx.arguments);\n            }\n\n            if (target.type == this.anyType) {\n                callEx.type = this.anyType;\n                callEx.arguments = <ASTList>this.typeCheck(callEx.arguments);\n            }\n            else {\n                if (target.type.construct) {\n                    var signature = this.resolveOverload(callEx, target.type.construct);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else if (signature.returnType.type == this.voidType) {\n                        callEx.type = this.anyType;\n                        callEx.signature = signature;\n                    }\n                    else {\n                        callEx.type = signature.returnType.type;\n                        callEx.signature = signature;\n                    }\n                }\n                else if (target.type.call) {\n                    var signature = this.resolveOverload(callEx, target.type.call);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else if ((signature.returnType.type == this.voidType) || (signature.returnType.type == this.anyType)) {\n                        callEx.type = this.anyType;\n                        callEx.signature = signature;\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(callEx.target,\n                           "new expression only valid on constructors");\n                    }\n                }\n                else if (target.type.elementType) {\n                    callEx.type = target.type;\n                }\n                else {\n                    this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);\n                    callEx.type = this.anyType;\n                }\n            }\n\n            this.postTypeCheckCallArgs(callEx);\n\n            return callEx;\n        }\n\n        // Typecheck all args that cannot be affected by contextual typing of overloads\n        public preTypeCheckCallArgs(args: ASTList) {\n\n            if (!args) {\n                return;\n            }\n\n            for (var i = 0; i < args.members.length; i++) {\n                switch (args.members[i].nodeType) {\n                    case NodeType.FuncDecl:\n                    case NodeType.ObjectLit:\n                    case NodeType.ArrayLit:\n                        continue;\n                    default:\n                        this.typeCheck(args.members[i]);\n                        break;\n                }\n            }\n        }\n\n        public postTypeCheckCallArgs(callEx: CallExpression) {\n\n            var acceptedTargetType = false;\n            var i = 0;\n\n            if (callEx.target &&\n                callEx.target.type &&\n                callEx.signature &&\n                callEx.arguments) {\n                var sig = callEx.signature;\n\n                if (sig && callEx.arguments.members.length >= si';
var v27463 = v27464 + 'g.nonOptionalParameterCount) {\n                    acceptedTargetType = true;\n                    var targetType: Type = null;\n                    var nonVarArgFormalParamLength = sig.hasVariableArgList ? sig.parameters.length - 1 : sig.parameters.length;\n                    var nonVarArgActualParamLength = callEx.arguments.members.length < nonVarArgFormalParamLength ? callEx.arguments.members.length : nonVarArgFormalParamLength\n\n                    for (i = 0; i < nonVarArgActualParamLength; i++) {\n                        targetType = sig.parameters[i].getType();\n                        switch (callEx.arguments.members[i].nodeType) {\n                            case NodeType.FuncDecl:\n                            case NodeType.ObjectLit:\n                            case NodeType.ArrayLit:\n                                this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), !sig.parameters[i].declAST.isParenthesized, callEx.arguments.members[i]);\n                                break;\n                        }\n                    }\n\n                    if (sig.hasVariableArgList) {\n                        var varArgParamIndex = sig.nonOptionalParameterCount - 1;\n                        targetType = sig.parameters[varArgParamIndex].getType();\n                        if (targetType) {\n                            targetType = targetType.elementType;\n                        }\n                        var isParenthesized = !sig.parameters[varArgParamIndex].declAST.isParenthesized;\n                        for (i = nonVarArgActualParamLength; i < callEx.arguments.members.length; i++) {\n                            switch (callEx.arguments.members[i].nodeType) {\n                                case NodeType.FuncDecl:\n                                case NodeType.ObjectLit:\n                                case NodeType.ArrayLit:\n                                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), isParenthesized, callEx.arguments.members[i]);\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (!acceptedTargetType && callEx.arguments) {\n                this.checker.killCurrentContextualType();\n\n                for (i = 0; i < callEx.arguments.members.length; i++) {\n                    switch (callEx.arguments.members[i].nodeType) {\n                        case NodeType.FuncDecl:\n                        case NodeType.ObjectLit:\n                        case NodeType.ArrayLit:\n                            this.typeCheck(callEx.arguments.members[i]);\n                            break;\n                        default:\n                            continue;\n                    }\n                }\n            }\n        }\n\n        public typeCheckCall(ast: AST): AST {\n            var callEx = <CallExpression>ast;\n            if (this.checker.styleSettings.newMustBeUsed && (ast.nodeType == NodeType.New)) {\n                if (hasFlag(ast.flags, ASTFlags.IsStatement)) {\n                    this.checker.errorReporter.styleError(ast, "use of new expression as a statement");\n                }\n            }\n            else if ((!this.checker.styleSettings.evalOK) && (ast.nodeType == NodeType.Call)) {\n                if ((callEx.target.nodeType == NodeType.Name) && ((<Identifier>callEx.target).text == "eval")) {\n                    this.checker.errorReporter.styleError(callEx, "eval not permitted");\n                }\n            }\n\n            if (callEx.target.nodeType == NodeType.FuncDecl) {\n                (<FuncDecl>callEx.target).isInlineCallLiteral = true;\n            }\n\n            var prevInSuperCall = this.inSuperCall;\n\n            if (callEx.target.nodeType == NodeType.Super) {\n                this.inSuperCall = true;\n            }\n\n            callEx.target = this.typeCheck(callEx.target);\n            this.preTypeCheckCallArgs(callEx.arguments);\n\n            var target = callEx.target;\n\n            if ((target.type == null) || (target.type == this.anyType) || (this.functionInterfaceType && target.type == this.functionInterfaceType)) {\n                callEx.type = this.anyType;\n            }\n            else {\n                var fnType = target.type;\n                if (fnType.call) {\n                    var signature = this.resolveOverload(callEx, fnType.call);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else {\n                        callEx.type = signature.returnType.type;\n                        callEx.signature = signature;\n                    }\n                }\n                else {\n                    // track calls to class base class\n                    if (callEx.target.nodeType == NodeType.Super &&\n                        this.thisFnc &&\n                        this.thisFnc.isConstructor &&\n        ';
var v27462 = v27463 + '                hasFlag(this.thisFnc.fncFlags, FncFlags.ClassMethod)) {\n\n                            // Need to use the class type for the construct signature, not the instance type\n                        var signature = fnType.symbol.type.construct ? this.resolveOverload(callEx, fnType.symbol.type.construct) : null;\n\n                        if (signature == null) {\n                            callEx.type = this.anyType;\n                        }\n                        else {\n                            callEx.flags |= ASTFlags.ClassBaseConstructorCall;\n                            callEx.type = signature.returnType.type;\n                            callEx.signature = signature;\n                        }\n                    }\n                    else {\n                        callEx.type = this.anyType;\n                        this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);\n                    }\n                }\n            }\n            this.postTypeCheckCallArgs(callEx);\n\n            this.inSuperCall = prevInSuperCall;\n\n            return callEx;\n        }\n\n        public assignScopes(ast: AST) {\n            var script = <Script>ast;\n            this.checker.locationInfo = script.locationInfo;\n            var globalChain = new ScopeChain(this.checker.gloMod, null, this.globalScope);\n            var context = new AssignScopeContext(globalChain, this, [this.checker.currentModDecl]);\n            getAstWalkerFactory().walk(ast, preAssignScopes, postAssignScopes, null, context);\n        }\n\n        public findMemberScope(enclosingScopeContext: EnclosingScopeContext, matchFlag: ASTFlags) {\n            var enclosingScope = enclosingScopeContext.getScope();\n            var pos = enclosingScopeContext.pos - enclosingScopeContext.getScriptFragmentPosition();\n            var scriptFragment = enclosingScopeContext.getScriptFragment();\n\n            var memContext = new MemberScopeContext(this, pos, matchFlag);\n            memContext.scope = enclosingScope;\n            if (scriptFragment.nodeType == NodeType.Name) {\n                return scriptFragment.type.getMemberScope(this);\n            }\n            else {\n                getAstWalkerFactory().walk(scriptFragment, preFindMemberScope, null, null, memContext);\n                if (memContext.ast && enclosingScopeContext.enclosingClassDecl && memContext.ast.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {\n                    enclosingScopeContext.publicsOnly = false;\n                }\n                if (memContext.type) {\n                    return memContext.type.getMemberScope(this);\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n\n        public findMemberScopeAt(enclosingScopeContext: EnclosingScopeContext) {\n            return this.findMemberScope(enclosingScopeContext, ASTFlags.DotLHS);\n        }\n\n        public findMemberScopeAtFullAst(enclosingScopeContext: EnclosingScopeContext) {\n            var matchFlag = ASTFlags.DotLHS;\n            var pos = enclosingScopeContext.pos;\n            var astResult: AST = null;\n\n            var preFindMemberScopeFullAst = function (ast: AST, parent: AST, walker: IAstWalker) {\n                if (isValidAstNode(ast)) {\n                    // Note: pos == ast.limChar       in case of incomplete code (e.g. "foo.")\n                    // Note: (pos - 1) == ast.limChar in case of complete code (e.g. "foo.bar")\n                    if (hasFlag(ast.flags, matchFlag) && (pos == ast.limChar || (pos - 1) == ast.limChar)) {\n                        astResult = ast;\n                        walker.options.stopWalk();\n                    }\n\n                    // Stop traversal if range does not contain position\n                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);\n                }\n                return ast;\n            }\n\n            var preFindMemberScopeFullAstFuzy = function (ast: AST, parent: AST, walker: IAstWalker) {\n                if (isValidAstNode(ast)) {\n                    if (hasFlag(ast.flags, matchFlag) && ((ast.minChar < pos) && (pos <= ast.limChar))) {\n                        astResult = ast;\n                    }\n\n                    // Stop traversal if range does not contain position\n                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);\n                }\n                return ast;\n            }\n\n            getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAst);\n\n            if (astResult == null) {\n                // Perform a more "fusy" match. This is because the limChar of AST nodes is sometimes\n                // not what we expect, for example:\n                //   foo./*comment*/;\n                // In this case, limChar points to ";" instead of "." (because of the trailing comment).\n                getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAstFuzy)';
var v27461 = v27462 + ";\n            }\n\n            if (astResult &&\n                enclosingScopeContext.enclosingClassDecl &&\n                astResult.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {\n                enclosingScopeContext.publicsOnly = false;\n            }\n\n            if (astResult && astResult.type) {\n                return astResult.type.getMemberScope(this);\n            }\n            else {\n                return null;\n            }\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path='diagnostics.ts' />\n///<reference path='flags.ts' />\n///<reference path='nodeTypes.ts' />\n///<reference path='hashTable.ts' />\n///<reference path='ast.ts' />\n///<reference path='astWalker.ts' />\n///<reference path='astWalkerCallback.ts' />\n///<reference path='astPath.ts' />\n///<reference path='astLogger.ts' />\n///<reference path='binder.ts' />\n///<reference path='base64.ts' />\n///<reference path='sourceMapping.ts' />\n///<reference path='emitter.ts' />\n///<reference path='errorReporter.ts' />\n///<reference path='parser.ts' />\n///<reference path='printContext.ts' />\n///<reference path='scanner.ts' />\n///<reference path='scopeAssignment.ts' />\n///<reference path='scopeWalk.ts' />\n///<reference path='signatures.ts' />\n///<reference path='symbols.ts' />\n///<reference path='symbolScope.ts' />\n///<reference path='tokens.ts' />\n///<reference path='typeChecker.ts' />\n///<reference path='typeCollection.ts' />\n///<reference path='typeFlow.ts' />\n///<reference path='types.ts' />\n///<reference path='pathUtils.ts' />\n///<reference path='referenceResolution.ts' />\n///<reference path='precompile.ts' />\n///<reference path='incrementalParser.ts' />\n///<reference path='declarationEmitter.ts' />\n\nmodule TypeScript {\n\n    export enum UpdateUnitKind {\n        Unknown,\n        NoEdits,\n        EditsInsideSingleScope,\n    }\n\n    export class ScriptEditRange {\n        constructor (public minChar: number,\n                     public limChar: number,\n                     public delta: number) { }\n\n        static unknown(): ScriptEditRange {\n            return new ScriptEditRange(-1, -1, -1);\n        }\n\n        public isUnknown() {\n            return this.minChar === -1 && this.limChar === -1 && this.delta === -1;\n        }\n\n        public containsPosition(pos: number) {\n            return (this.minChar <= pos && pos < this.limChar)\n                || (this.minChar <= pos && pos < this.limChar + this.delta);\n        }\n\n        public toString(): string {\n            return \"editRange(minChar=\" + this.minChar + \", limChar=\" + this.limChar + \", delta=\" + this.delta + \")\";\n        }\n    }\n\n    export class UpdateUnitResult {\n\n        constructor (public kind: UpdateUnitKind, public unitIndex: number, public script1: Script, public script2: Script) { }\n\n        public scope1: AST = null;\n        public scope2: AST = null;\n        public editRange: ScriptEditRange = null;\n        public parseErrors: ErrorEntry[] = [];\n\n        static noEdits(unitIndex: number) {\n            return new UpdateUnitResult(UpdateUnitKind.NoEdits, unitIndex, null, null);\n        }\n\n        static unknownEdits(script1: Script, script2: Script, parseErrors: ErrorEntry[]) {\n            var result = new UpdateUnitResult(UpdateUnitKind.Unknown, script1.locationInfo.unitIndex, script1, script2);\n            result.parseErrors = parseErrors;\n            return result;\n        }\n\n        static singleScopeEdits(script1: Script, script2: Script, scope1: AST, scope2: AST, editRange: ScriptEditRange, parseErrors: ErrorEntry[]) {\n            var result = new UpdateUnitResult(UpdateUnitKind.EditsInsideSingleScope, script1.locationInfo.unitIndex, script1, script2);\n            result.scope1 = scope1;\n            result.scope2 = scope2;\n            result.editRange = editRange;\n            result.parseErrors = parseErrors;\n            return result;\n        }\n    }\n\n    export class ErrorEntry {\n        constructor (public unitIndex: number,\n                    public minChar: number,\n                    public limChar: number,\n                    public message: string) { }\n    }\n\n    export var defaultSettings = new CompilationSettings();\n\n    export interface EmitterIOHost {\n        // function that can even create a folder structure if needed\n        createFile(path: string, useUTF8?: bool): ITextWriter;\n\n        // function to check if file exists on the disk\n        fileExi";
var v27460 = v27461 + 'sts(path: string): bool;\n\n        // Function to check if the directory exists on the disk\n        directoryExists(path: string): bool;\n\n        // Resolves the path\n        resolvePath(path: string): string;\n    }\n\n    export class TypeScriptCompiler {\n        public parser = new Parser();\n        public typeChecker: TypeChecker;\n        public typeFlow: TypeFlow = null;\n        public scripts = new ASTList();\n        public units: LocationInfo[] = new LocationInfo[];\n        public errorReporter: ErrorReporter;\n\n        public persistentTypeState: PersistentGlobalTypeState;\n\n\n        public emitSettings: EmitOptions;\n\n        constructor (public errorOutput: ITextWriter, public logger: ILogger = new NullLogger(), public settings: CompilationSettings = defaultSettings) {\n            this.errorReporter = new ErrorReporter(this.errorOutput);\n            this.persistentTypeState = new PersistentGlobalTypeState(this.errorReporter);\n            this.errorReporter.parser = this.parser;\n            this.initTypeChecker(this.errorOutput);\n\n            this.parser.style_requireSemi = this.settings.styleSettings.requireSemi;\n            this.parser.style_funcInLoop = this.settings.styleSettings.funcInLoop;\n            this.parser.inferPropertiesFromThisAssignment = this.settings.inferPropertiesFromThisAssignment;\n            this.emitSettings = new EmitOptions(this.settings);\n            codeGenTarget = settings.codeGenTarget;\n        }\n\n        public timeFunction(funcDescription: string, func: () => any): any {\n            return TypeScript.timeFunction(this.logger, funcDescription, func);\n        }\n\n        public initTypeChecker(errorOutput: ITextWriter) {\n            // The initial "refresh" initializes the persistent type state\n            this.persistentTypeState.refreshPersistentState();\n            this.typeChecker = new TypeChecker(this.persistentTypeState);\n            this.typeChecker.errorReporter = this.errorReporter;\n\n            // REVIEW: These properties should be moved out of the typeCheck object\n            // ideally, CF should be a separate pass, independent of control flow\n            this.typeChecker.checkControlFlow = this.settings.controlFlow;\n            this.typeChecker.checkControlFlowUseDef = this.settings.controlFlowUseDef;\n            this.typeChecker.printControlFlowGraph = this.settings.printControlFlow;\n\n            this.typeChecker.errorsOnWith = this.settings.errorOnWith;\n            this.typeChecker.styleSettings = this.settings.styleSettings;\n            this.typeChecker.canCallDefinitionSignature = this.settings.canCallDefinitionSignature;\n\n            this.errorReporter.checker = this.typeChecker;\n            this.setErrorOutput(this.errorOutput);\n        }\n\n        public setErrorOutput(outerr) {\n            this.errorOutput = outerr;\n            this.errorReporter.setErrOut(outerr);\n            this.parser.outfile = outerr;\n        }\n\n        public emitCommentsToOutput() {\n            this.emitSettings = new EmitOptions(this.settings);\n        }\n\n        public setErrorCallback(fn: (minChar: number, charLen: number, message: string,\n            unitIndex: number) =>void ) {\n            this.parser.errorCallback = fn;\n        }\n\n        public updateUnit(prog: string, filename: string, setRecovery: bool) {\n            return this.updateSourceUnit(new StringSourceText(prog), filename, setRecovery);\n        }\n\n        public updateSourceUnit(sourceText: ISourceText, filename: string, setRecovery: bool): bool {\n            return this.timeFunction("updateSourceUnit(" + filename + ")", () => {\n                var updateResult = this.partialUpdateUnit(sourceText, filename, setRecovery);\n                return this.applyUpdateResult(updateResult);\n            });\n        }\n\n        // Apply changes to compiler state.\n        // Return "false" if the change is empty and nothing was updated.\n        public applyUpdateResult(updateResult: UpdateUnitResult): bool {\n            switch (updateResult.kind) {\n                case UpdateUnitKind.NoEdits:\n                    return false;\n\n                case UpdateUnitKind.Unknown:\n                    this.scripts.members[updateResult.unitIndex] = updateResult.script2;\n                    this.units[updateResult.unitIndex] = updateResult.script2.locationInfo;\n                    for (var i = 0, len = updateResult.parseErrors.length; i < len; i++) {\n                        var e = updateResult.parseErrors[i];\n                        if (this.parser.errorCallback) {\n                            this.parser.errorCallback(e.minChar, e.limChar - e.minChar, e.message, e.unitIndex);\n                        }\n                    }\n                    return true;\n\n                case UpdateUnitKind.EditsInsideSingleScope:\n                    new IncrementalParser(this.logger).mergeTrees(updateResult);\n                    return true;\n            }\n        }\n\n        public partialUpdateUnit(sourceText: ISourceText, filename: string, setRecovery:';
var v27459 = v27460 + ' bool): UpdateUnitResult {\n            return this.timeFunction("partialUpdateUnit(" + filename + ")", () => {\n                for (var i = 0, len = this.units.length; i < len; i++) {\n                    if (this.units[i].filename == filename) {\n                        if ((<Script>this.scripts.members[i]).isResident) {\n                            return UpdateUnitResult.noEdits(i);\n                        }\n\n                        if (setRecovery) {\n                            this.parser.setErrorRecovery(null);\n                        }\n\n                        var updateResult: UpdateUnitResult;\n\n                        // Capture parsing errors so that they are part of "updateResult"\n                        var parseErrors: ErrorEntry[] = [];\n                        var errorCapture = (minChar: number, charLen: number, message: string, unitIndex: number): void => {\n                            parseErrors.push(new ErrorEntry(unitIndex, minChar, minChar + charLen, message));\n                        };\n                        var svErrorCallback = this.parser.errorCallback;\n                        if (svErrorCallback)\n                            this.parser.errorCallback = errorCapture;\n\n                        var oldScript = <Script>this.scripts.members[i];\n                        var newScript = this.parser.parse(sourceText, filename, i);\n\n                        if (svErrorCallback)\n                            this.parser.errorCallback = svErrorCallback;\n\n                        updateResult = UpdateUnitResult.unknownEdits(oldScript, newScript, parseErrors);\n\n                        return updateResult;\n                    }\n                }\n                throw new Error("Unknown file \\"" + filename + "\\"");\n            });\n        }\n\n        public addUnit(prog: string, filename: string, keepResident? = false, referencedFiles?: IFileReference[] = []): Script {\n            return this.addSourceUnit(new StringSourceText(prog), filename, keepResident, referencedFiles);\n        }\n\n        public addSourceUnit(sourceText: ISourceText, filename: string, keepResident:bool, referencedFiles?: IFileReference[] = []): Script {\n            return this.timeFunction("addSourceUnit(" + filename + ", " + keepResident + ")", () => {\n                var script: Script = this.parser.parse(sourceText, filename, this.units.length, AllowedElements.Global);\n                script.referencedFiles = referencedFiles;\n                script.isResident = keepResident;\n                this.persistentTypeState.setCollectionMode(keepResident ? TypeCheckCollectionMode.Resident : TypeCheckCollectionMode.Transient);\n                var index = this.units.length;\n                this.units[index] = script.locationInfo;\n                this.typeChecker.collectTypes(script);\n                this.scripts.append(script);\n                return script\n            });\n        }\n\n        public parseUnit(prog: string, filename: string) {\n            return this.parseSourceUnit(new StringSourceText(prog), filename);\n        }\n\n        public parseSourceUnit(sourceText: ISourceText, filename: string) {\n            this.parser.setErrorRecovery(this.errorOutput);\n            var script: Script = this.parser.parse(sourceText, filename, 0);\n\n            var index = this.units.length;\n            this.units[index] = script.locationInfo;\n            this.typeChecker.collectTypes(script);\n            this.scripts.append(script);\n        }\n\n        public typeCheck() {\n            return this.timeFunction("typeCheck()", () => {\n                var binder = new Binder(this.typeChecker);\n                this.typeChecker.units = this.units;\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.globals);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.ambientGlobals);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.globalTypes);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.ambientGlobalTypes);\n                this.typeFlow = new TypeFlow(this.logger, this.typeChecker.globalScope, this.parser, this.typeChecker);\n                var i = 0;\n                var script: Script = null;\n                var len = this.scripts.members.length;\n\n\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Resident);\n                // first, typecheck resident "lib" scripts, if necessary\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (!script.isResident || script.hasBeenTypeChecked) { continue; }\n\n                    this.typeFlow.assignScopes(script);\n                    this.typeFlow.initLibs();\n                }\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (!script.isResident || script.hasBeenTypeChecked) { continue; }\n\n                    this.typeFlow.typeCheck(script);';
var v27458 = v27459 + '\n                    script.hasBeenTypeChecked = true;\n                }\n\n                // next typecheck scripts that may change\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Transient);\n                len = this.scripts.members.length;\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (script.isResident) { continue; }\n                    this.typeFlow.assignScopes(script);\n                    this.typeFlow.initLibs();\n                }\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (script.isResident) { continue; }\n                    this.typeFlow.typeCheck(script);\n                }\n\n                return null;\n            });\n        }\n\n        public cleanASTTypesForReTypeCheck(ast: AST) {\n            function cleanASTType(ast: AST, parent: AST): AST {\n                ast.type = null;\n                if (ast.nodeType == NodeType.VarDecl) {\n                    var vardecl = <VarDecl>ast;\n                    vardecl.sym = null;\n                }\n                else if (ast.nodeType == NodeType.ArgDecl) {\n                    var argdecl = <ArgDecl>ast;\n                    argdecl.sym = null;\n                }\n                else if (ast.nodeType == NodeType.Name) {\n                    var name = <Identifier>ast;\n                    name.sym = null;\n                }\n                else if (ast.nodeType == NodeType.FuncDecl) {\n                    var funcdecl = <FuncDecl>ast;\n                    funcdecl.signature = null;\n                    funcdecl.freeVariables = new Symbol[]\n                    funcdecl.symbols = null;\n                    funcdecl.accessorSymbol = null;\n                    funcdecl.scopeType = null;\n                }\n                else if (ast.nodeType == NodeType.ModuleDeclaration) {\n                    var modDecl = <ModuleDeclaration>ast;\n                    modDecl.mod = null;\n                }\n                else if (ast.nodeType == NodeType.With) {\n                    (<WithStatement>ast).withSym = null;\n                }\n                else if (ast.nodeType == NodeType.Catch) {\n                    (<Catch>ast).containedScope = null;\n                }\n                return ast;\n            }\n            TypeScript.getAstWalkerFactory().walk(ast, cleanASTType);\n        }\n\n        public cleanTypesForReTypeCheck() {\n            return this.timeFunction("cleanTypesForReTypeCheck()", () => {\n                for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                    var script = this.scripts.members[i];\n                    if ((<Script>script).isResident) {\n                        continue;\n                    }\n                    this.cleanASTTypesForReTypeCheck(script);\n                    this.typeChecker.collectTypes(script);\n                }\n\n                return null;\n            });\n        }\n\n        // Return "true" if the incremental typecheck was successful\n        // Return "false" if incremental typecheck failed, requiring a full typecheck\n        public attemptIncrementalTypeCheck(updateResult: TypeScript.UpdateUnitResult): bool {\n            return this.timeFunction("attemptIncrementalTypeCheck()", () => {\n                // updateResult.kind == editsInsideFunction\n                // updateResult.scope1 == old function\n                // updateResult.scope2 == new function\n                //REVIEW: What about typecheck errors? How do we replace the old ones with the new ones?\n                return false;\n            });\n        }\n\n        public reTypeCheck() {\n            return this.timeFunction("reTypeCheck()", () => {\n                CompilerDiagnostics.analysisPass++;\n                this.initTypeChecker(this.errorOutput);\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Transient);\n                this.cleanTypesForReTypeCheck();\n                return this.typeCheck();\n            });\n        }\n\n        private isDynamicModuleCompilation() {\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (!script.isDeclareFile && script.topLevelMod != null) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private updateCommonDirectoryPath() {\n            var commonComponents: string[] = [];\n            var commonComponentsLength = -1;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (script.emitRequired(this.emitSettings)) {\n                    var fileName = script.locationInfo.filename;\n                    var fileComponents = filePathComponents(fileName);\n                    if (commonComponentsLength == -1) {\n            ';
var v27457 = v27458 + '            // First time at finding common path\n                        // So common path = directory of file\n                        commonComponents = fileComponents;\n                        commonComponentsLength = commonComponents.length;\n                    } else {\n                        var updatedPath = false;\n                        for (var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {\n                            if (commonComponents[j] != fileComponents[j]) {\n                                // The new components = 0 ... j -1\n                                commonComponentsLength = j;\n                                updatedPath = true;\n\n                                if (j == 0) {\n                                    // Its error to not have common path\n                                    this.errorReporter.emitterError(null, "Cannot find the common subdirectory path for the input files");\n                                    return;\n                                }\n\n                                break;\n                            }\n                        }\n\n                        // If the fileComponent path completely matched and less than already found update the length\n                        if (!updatedPath && fileComponents.length < commonComponentsLength) {\n                            commonComponentsLength = fileComponents.length;\n                        }\n                    }\n                }\n            }\n\n            this.emitSettings.commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";\n            if (this.emitSettings.outputOption.charAt(this.emitSettings.outputOption.length - 1) != "/") {\n                this.emitSettings.outputOption += "/";\n            }\n        }\n\n        public parseEmitOption(ioHost: EmitterIOHost) {\n            this.emitSettings.ioHost = ioHost;\n            if (this.emitSettings.outputOption == "") {\n                this.emitSettings.outputMany = true;\n                this.emitSettings.commonDirectoryPath = "";\n                return;\n            }\n\n            this.emitSettings.outputOption = switchToForwardSlashes(this.emitSettings.ioHost.resolvePath(this.emitSettings.outputOption));\n\n            // Determine if output options is directory or file\n            if (this.emitSettings.ioHost.directoryExists(this.emitSettings.outputOption)) {\n                // Existing directory\n                this.emitSettings.outputMany = true;\n            } else if (this.emitSettings.ioHost.fileExists(this.emitSettings.outputOption)) {\n                // Existing file\n                this.emitSettings.outputMany = false;\n            }\n            else {\n                // New File/directory\n                this.emitSettings.outputMany = !isJSFile(this.emitSettings.outputOption);\n            }\n\n            // Verify if options are correct\n            if (this.isDynamicModuleCompilation() && !this.emitSettings.outputMany) {\n                this.errorReporter.emitterError(null, "Cannot compile dynamic modules when emitting into single file");\n            }\n\n            // Parse the directory structure\n            if (this.emitSettings.outputMany) {\n                this.updateCommonDirectoryPath();\n            }\n        }\n\n        public useUTF8ForFile(script: Script) {\n            if (this.emitSettings.outputMany) {\n                return this.outputScriptToUTF8(script);\n            } else {\n                return this.outputScriptsToUTF8(<Script[]>(this.scripts.members));\n            }\n        }\n\n        static mapToDTSFileName(fileName: string, wholeFileNameReplaced: bool) {\n            return getDeclareFilePath(fileName);\n        }\n\n        private canEmitDeclarations(script?: Script) {\n            if (!this.settings.generateDeclarationFiles) {\n                return false;\n            }\n\n            // If its already a declare file or is resident or does not contain body \n            if (!!script && (script.isDeclareFile || script.isResident || script.bod == null)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        public emitDeclarationsUnit(script: Script, reuseEmitter?: bool, declarationEmitter?: DeclarationEmitter) {\n            if (!this.canEmitDeclarations(script)) {\n                return null;\n            }\n\n            if (!declarationEmitter) {\n                var declareFileName = this.emitSettings.mapOutputFileName(script.locationInfo.filename, TypeScriptCompiler.mapToDTSFileName);\n                var declareFile = this.createFile(declareFileName, this.useUTF8ForFile(script));\n                declarationEmitter = new DeclarationEmitter(this.typeChecker, this.emitSettings, this.errorReporter);\n                declarationEmitter.setDeclarationFile(declareFile);\n            }\n\n            declarationEmitter.emitDeclarations(script);\n\n            if (!reuseEmitter) {\n                declarationEmitter.Close();\n                return null;\n            } else {';
var v27456 = v27457 + '\n                return declarationEmitter;\n            }\n        }\n\n        public emitDeclarations() {\n            if (!this.canEmitDeclarations()) {\n                return;\n            }\n\n            if (this.errorReporter.hasErrors) {\n                // There were errors reported, do not generate declaration file\n                return;\n            }\n\n            if (this.scripts.members.length == 0) {\n                return;\n            }\n\n            var declarationEmitter: DeclarationEmitter = null;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (this.emitSettings.outputMany || declarationEmitter == null) {\n                    // Create or reuse file\n                    declarationEmitter = this.emitDeclarationsUnit(script, !this.emitSettings.outputMany);\n                } else {\n                    // Emit in existing emitter\n                    this.emitDeclarationsUnit(script, true, declarationEmitter);\n                }\n            }\n\n            if (declarationEmitter) {\n                declarationEmitter.Close();\n            }\n        }\n\n        static mapToFileNameExtension(extension: string, fileName: string, wholeFileNameReplaced: bool) {\n            if (wholeFileNameReplaced) {\n                // The complete output is redirected in this file so do not change extension\n                return fileName;\n            } else {\n                // Change the extension of the file\n                var splitFname = fileName.split(".");\n                splitFname.pop();\n                return splitFname.join(".") + extension;\n            }\n        }\n\n        static mapToJSFileName(fileName: string, wholeFileNameReplaced: bool) {\n            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);\n        }\n\n        public emitUnit(script: Script, reuseEmitter?: bool, emitter?: Emitter) {\n            if (!script.emitRequired(this.emitSettings)) {\n                return null;\n            }\n\n            var fname = script.locationInfo.filename;\n            if (!emitter) {\n                var outFname = this.emitSettings.mapOutputFileName(fname, TypeScriptCompiler.mapToJSFileName);\n                var outFile = this.createFile(outFname, this.useUTF8ForFile(script));\n                emitter = new Emitter(this.typeChecker, outFname, outFile, this.emitSettings, this.errorReporter);\n                if (this.settings.mapSourceFiles) {\n                    emitter.setSourceMappings(new TypeScript.SourceMapper(fname, outFname, outFile, this.createFile(outFname + SourceMapper.MapFileExtension, false), this.errorReporter));\n                }\n            } else if (this.settings.mapSourceFiles) {\n                emitter.setSourceMappings(new TypeScript.SourceMapper(fname, emitter.emittingFileName, emitter.outfile, emitter.sourceMapper.sourceMapOut, this.errorReporter));\n            }\n\n            this.typeChecker.locationInfo = script.locationInfo;\n            emitter.emitJavascript(script, TokenID.Comma, false);\n            if (!reuseEmitter) {\n                emitter.Close();\n                return null;\n            } else {\n                return emitter;\n            }\n        }\n\n        public emit(ioHost: EmitterIOHost) {\n            this.parseEmitOption(ioHost);\n\n            var emitter: Emitter = null;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (this.emitSettings.outputMany || emitter == null) {\n                    emitter = this.emitUnit(script, !this.emitSettings.outputMany);\n                } else {\n                    this.emitUnit(script, true, emitter);\n                }\n            }\n\n            if (emitter) {\n                emitter.Close();\n            }\n        }\n\n        public emitToOutfile(outputFile: ITextWriter) {\n            if (this.settings.mapSourceFiles) {\n                throw Error("Cannot generate source map");\n            }\n\n            if (this.settings.generateDeclarationFiles) {\n                throw Error("Cannot generate declaration files");\n            }\n\n            if (this.settings.outputOption != "") {\n                throw Error("Cannot parse output option");\n            }\n\n            var emitter: Emitter = emitter = new Emitter(this.typeChecker, "stdout", outputFile, this.emitSettings, this.errorReporter);;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                this.typeChecker.locationInfo = script.locationInfo;\n                emitter.emitJavascript(script, TokenID.Comma, false);\n            }\n        }\n\n        public emitAST(ioHost: EmitterIOHost) {\n            this.parseEmitOption(ioHost);\n\n            var outFile: ITextWriter = null;\n            var context: PrintContext = null;\n\n            for (var i = 0, ';
var v27455 = v27456 + 'len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (this.emitSettings.outputMany || context == null) {\n                    var fname = this.units[i].filename;\n                    var mapToTxtFileName = (fileName: string, wholeFileNameReplaced: bool) => {\n                        return TypeScriptCompiler.mapToFileNameExtension(".txt", fileName, wholeFileNameReplaced);\n                    };\n                    var outFname = this.emitSettings.mapOutputFileName(fname, mapToTxtFileName);\n                    outFile = this.createFile(outFname, this.useUTF8ForFile(script));\n                    context = new PrintContext(outFile, this.parser);\n                }\n                getAstWalkerFactory().walk(script, prePrintAST, postPrintAST, null, context);\n                if (this.emitSettings.outputMany) {\n                    try {\n                        outFile.Close();\n                    } catch (e) {\n                        this.errorReporter.emitterError(null, e.message);\n                    }\n                }\n            }\n\n            if (!this.emitSettings.outputMany) {\n                try {\n                    outFile.Close();\n                } catch (e) {\n                    this.errorReporter.emitterError(null, e.message);\n                }\n            }\n        }\n\n        private outputScriptToUTF8(script: Script): bool {\n            return script.containsUnicodeChar || (this.emitSettings.emitComments && script.containsUnicodeCharInComment);\n        }\n\n        private outputScriptsToUTF8(scripts: Script[]): bool {\n            for (var i = 0, len = scripts.length; i < len; i++) {\n                var script = scripts[i];\n                if (this.outputScriptToUTF8(script)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private createFile(fileName: string, useUTF8: bool): ITextWriter {\n            try {\n                // Creating files can cause exceptions, report them.   \n                return this.emitSettings.ioHost.createFile(fileName, useUTF8);\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n    }\n\n    export class ScopeEntry {\n        constructor (\n            public name: string,\n            public type: string,\n            public sym: Symbol) {\n        }\n    }\n\n    export class ScopeTraversal {\n        constructor (private compiler: TypeScriptCompiler) {\n        }\n\n        public getScope(enclosingScopeContext: EnclosingScopeContext): SymbolScope {\n            if (enclosingScopeContext.enclosingObjectLit && enclosingScopeContext.isMemberCompletion) {\n                return enclosingScopeContext.getObjectLiteralScope();\n            }\n            else if (enclosingScopeContext.isMemberCompletion) {\n                if (enclosingScopeContext.useFullAst) {\n                    return this.compiler.typeFlow.findMemberScopeAtFullAst(enclosingScopeContext)\n                }\n                else {\n                    return this.compiler.typeFlow.findMemberScopeAt(enclosingScopeContext)\n                }\n            }\n            else {\n                return enclosingScopeContext.getScope();\n            }\n        }\n\n        public getScopeEntries(enclosingScopeContext: EnclosingScopeContext): ScopeEntry[] {\n            var scope = this.getScope(enclosingScopeContext);\n            if (scope == null) {\n                return [];\n            }\n\n            var inScopeNames: IHashTable = new StringHashTable();\n            var allSymbolNames: string[] = scope.getAllSymbolNames(enclosingScopeContext.isMemberCompletion);\n\n            // there may be duplicates between the type and value tables, so batch the symbols\n            // getTypeNamesForNames will prefer the entry in the value table\n            for (var i = 0; i < allSymbolNames.length; i++) {\n                var name = allSymbolNames[i];\n\n                // Skip global/internal symbols that won\'t compile in user code\n                if (name == globalId || name == "_Core" || name == "_element") {\n                    continue;\n                }\n\n                inScopeNames.add(name, "");\n            }\n\n            var svModuleDecl = this.compiler.typeChecker.currentModDecl;\n            this.compiler.typeChecker.currentModDecl = enclosingScopeContext.deepestModuleDecl;\n\n            var result = this.getTypeNamesForNames(enclosingScopeContext, inScopeNames.getAllKeys(), scope);\n\n            this.compiler.typeChecker.currentModDecl = svModuleDecl;\n            return result;\n        }\n\n        private getTypeNamesForNames(enclosingScopeContext: EnclosingScopeContext, allNames: string[], scope: SymbolScope): ScopeEntry[] {\n            var result: ScopeEntry[] = [];\n\n            var enclosingScope = enclosingScopeContext.getScope();\n            for (var i = 0; i < allNames.length; i++) {\n                var name = allNames[i];\n                //';
var v27454 = v27455 + ' Search for the id in the value space first\n                // if we don\'t find it, search in the type space.\n                // We don\'t want to search twice, because the first\n                // search may insert the name in the symbol value table\n                // if the scope is aggregate\n                var publicsOnly = enclosingScopeContext.publicsOnly && enclosingScopeContext.isMemberCompletion;\n                var symbol = scope.find(name, publicsOnly, false/*typespace*/);  // REVIEW: Should search public members only?\n                if (symbol == null) {\n                    symbol = scope.find(name, publicsOnly, true/*typespace*/);\n                }\n\n                var displayThisMember = symbol && symbol.flags & SymbolFlags.Private ? symbol.container == scope.container : true;\n\n                if (symbol) {\n                    // Do not add dynamic module names to the list, since they\'re not legal as identifiers\n                    if (displayThisMember && !isQuoted(symbol.name) && !isRelative(symbol.name)) {\n                        var typeName = symbol.getType().getScopedTypeName(enclosingScope);\n                        result.push(new ScopeEntry(name, typeName, symbol));\n                    }\n                }\n                else {\n                    // Special case for "true" and "false"\n                    // REVIEW: This may no longer be necessary?\n                    if (name == "true" || name == "false") {\n                        result.push(new ScopeEntry(name, "bool", this.compiler.typeChecker.booleanType.symbol));\n                    }\n                }\n            }\n\n            return result;\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum Primitive {\n        None = 0,\n        Void = 1,\n        Double = 2,\n        String = 4,\n        Boolean = 8,\n        Any = 16,\n        Null = 32,\n        Undefined = 64,\n    }\n\n    export class MemberName {\n        public prefix: string = "";\n        public suffix: string = "";\n\n        public isString() { return false; }\n        public isArray() { return false; }\n\n        public toString(): string {\n            return MemberName.memberNameToString(this);\n        }\n\n        static memberNameToString(memberName: MemberName): string {\n            var result = memberName.prefix;\n\n            if (memberName.isString()) {\n                result += (<MemberNameString>memberName).text;\n            }\n            else {\n                var ar = <MemberNameArray>memberName;\n                for (var index = 0; index < ar.entries.length; index++) {\n                    result += memberNameToString(ar.entries[index]);\n                    result += ar.delim;\n                }\n            }\n\n            result += memberName.suffix;\n            return result;\n        }\n\n        static create(text: string): MemberName;\n        static create(entry: MemberName, prefix: string, suffix: string): MemberName;\n        static create(arg1: any, arg2?: any, arg3?: any): MemberName {\n            if (typeof arg1 == "string") {\n                return new MemberNameString(arg1);\n            }\n            else {\n                var result = new MemberNameArray();\n                if (arg2)\n                    result.prefix = arg2;\n                if (arg3)\n                    result.suffix = arg3;\n                result.entries.push(arg1);\n                return result;\n            }\n        }\n    }\n\n    export class MemberNameString extends MemberName {\n        constructor (public text: string) {\n            super()\n        }\n\n        public isString() { return true; }\n    }\n\n    export class MemberNameArray extends MemberName {\n        public delim: string = "";\n        public entries: MemberName[] = [];\n\n        public isArray() { return true; }\n\n        public add(entry: MemberName) {\n            this.entries.push(entry);\n        }\n\n        public addAll(entries: MemberName[]) {\n            for (var i = 0 ; i < entries.length; i++) {\n                this.entries.push(entries[i]);\n            }\n        }\n    }\n\n    var currentTypeID = -1;\n\n    export class Type {\n        public typeID = currentTypeID++;\n\n        public members: ScopedMembers;\n        public ambientMembers: ScopedMembers;\n\n        public construct: SignatureGroup = null;\n        public call: SignatureGroup = null;\n        public index: SignatureGroup =';
var v27453 = v27454 + ' null;\n\n        // REVIEW: for either of the below, why do we have lists of types and lists of type links?\n        // interface can only extend\n        public extendsList: Type[];\n        public extendsTypeLinks: TypeLink[];\n\n        // class can also implement\n        public implementsList: Type[];\n        public implementsTypeLinks: TypeLink[];\n\n        public passTypeCreated: number = CompilerDiagnostics.analysisPass;\n\n        public baseClass(): Type {\n            if (this.extendsList && (this.extendsList.length > 0)) {\n                return this.extendsList[0];\n            }\n            else {\n                return null;\n            }\n        }\n\n        public elementType: Type;\n\n        public getArrayBase(arrInstType: Type, checker: TypeChecker): Type {\n            return this.arrayCache.specialize(arrInstType, checker);\n        }\n\n        public primitiveTypeClass: number = Primitive.None;\n\n        // REVIEW: Prune constructorScope\n        public constructorScope: SymbolScope;\n        public containedScope: SymbolScope;\n        public memberScope: SymbolScope;\n\n        public arrayCache: ArrayCache;\n\n        public typeFlags = TypeFlags.None;\n\n        public symbol: TypeSymbol;\n\n        public enclosingType: Type;\n        public instanceType: Type;\n\n        // REVIEW: Prune\n        public isClass() { return this.instanceType != null; }\n        public isArray() { return this.elementType != null; }\n        public isClassInstance() {\n            return this.symbol && !this.elementType && (<TypeSymbol>this.symbol).type.isClass();\n        }\n\n        public getInstanceType() {\n            if (this.isClass()) {\n                return this.instanceType;\n            }\n            else {\n                return this;\n            }\n        }\n\n        public hasImplementation() { return hasFlag(this.typeFlags, TypeFlags.HasImplementation); }\n        public setHasImplementation() { this.typeFlags |= TypeFlags.HasImplementation; }\n\n        public isDouble() { return hasFlag(this.primitiveTypeClass, Primitive.Double); }\n        public isString() { return hasFlag(this.primitiveTypeClass, Primitive.String); }\n        public isBoolean() { return hasFlag(this.primitiveTypeClass, Primitive.Boolean); }\n        public isNull() { return hasFlag(this.primitiveTypeClass, Primitive.Null); }\n\n        // REVIEW: No need for this to be a method\n        public getTypeName(): string {\n            return this.getMemberTypeName("", true, false, null);\n        }\n\n        public getScopedTypeName(scope: SymbolScope) {\n            return this.getMemberTypeName("", true, false, scope);\n        }\n\n        public getScopedTypeNameEx(scope: SymbolScope) {\n            return this.getMemberTypeNameEx("", true, false, scope);\n        }\n\n        // REVIEW: No need for this to be a method\n        public callCount() {\n            var total = 0;\n            if (this.call) {\n                total += this.call.signatures.length;\n            }\n            if (this.construct) {\n                total += this.construct.signatures.length;\n            }\n            if (this.index) {\n                total += this.index.signatures.length;\n            }\n            return total;\n        }\n\n        // REVIEW: No need for this to be a method\n        public getMemberTypeName(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope): string {\n            var memberName = this.getMemberTypeNameEx(prefix, topLevel, isElementType, scope);\n            return memberName.toString();\n        }\n\n        // REVIEW: No need for this to be a method\n        public getMemberTypeNameEx(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope): MemberName {\n            if (this.elementType) {\n                return MemberName.create(this.elementType.getMemberTypeNameEx(prefix, false, true, scope), "", "[]");\n            }\n            else if (this.symbol && this.symbol.name && this.symbol.name != "_anonymous" &&\n                     (((this.call == null) && (this.construct == null) && (this.index == null)) ||\n                      (hasFlag(this.typeFlags, TypeFlags.BuildingName)) ||\n                      (this.members && (!this.isClass())))) {\n                var tn = this.symbol.scopeRelativeName(scope);\n                return MemberName.create(tn == "null" ? "any" : tn); // REVIEW: GROSS!!!\n            }\n            else {\n                if (this.members || this.call || this.construct) {\n                    if (hasFlag(this.typeFlags, TypeFlags.BuildingName)) {\n                        return MemberName.create("this");\n                    }\n                    this.typeFlags |= TypeFlags.BuildingName;\n                    var builder = "";\n                    var allMemberNames = new MemberNameArray();\n                    var curlies = isElementType || this.index != null;\n                    var memCount = 0;\n                    var delim = "; ";\n                    if (this.members) {\n                        this.members.allMembers.map((key, ';
var v27452 = v27453 + 's, unused) => {\n                            var sym = <Symbol>s;\n                            if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {\n                                // Remove the delimiter character from the generated type name, since\n                                // our "allMemberNames" array takes care of storing delimiters\n                                var typeNameMember = sym.getTypeNameEx(scope);\n                                if (typeNameMember.isArray() && (<MemberNameArray>typeNameMember).delim == delim) {\n                                    allMemberNames.addAll((<MemberNameArray>typeNameMember).entries);\n                                } else {\n                                    allMemberNames.add(typeNameMember);\n                                }\n                                memCount++;\n                                curlies = true;\n                            }\n                        }, null);\n                    }\n\n                    var signatureCount = this.callCount();\n                    var j: number;\n                    var len = 0;\n                    var shortform = !curlies && signatureCount == 1 && topLevel;\n                    if (this.call) {\n                        allMemberNames.addAll(this.call.toStrings(prefix, shortform, scope));\n                    }\n\n                    if (this.construct) {\n                        allMemberNames.addAll(this.construct.toStrings("new", shortform, scope));\n                    }\n\n                    if (this.index) {\n                        allMemberNames.addAll(this.index.toStrings("", shortform, scope));\n                    }\n\n                    if ((curlies) || ((signatureCount > 1) && topLevel)) {\n                        allMemberNames.prefix = "{ ";\n                        allMemberNames.suffix = "}";\n                        allMemberNames.delim = delim;\n                    } else if (allMemberNames.entries.length > 1) {\n                        allMemberNames.delim = delim;\n                    }\n\n                    this.typeFlags &= (~TypeFlags.BuildingName);\n                    if ((signatureCount == 0) && (memCount == 0)) {\n                        return MemberName.create("{}");\n                    }\n                    else {\n                        return allMemberNames;\n                    }\n                }\n                else {\n                    return MemberName.create("{}");\n                }\n            }\n        }\n\n        public checkDecl(checker: TypeChecker) {\n            if (this.isClassInstance() || this.isClass()) {\n                if (this.symbol.declAST) {\n                    checker.typeFlow.inScopeTypeCheckDecl(this.symbol.declAST);\n                }\n            }\n        }\n\n        public getMemberScope(flow: TypeFlow) {\n            if (this == flow.anyType) {\n                return null;\n            }\n            else if (this.isDouble()) {\n                if (flow.numberInterfaceType) {\n                    return flow.numberInterfaceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this.isBoolean()) {\n                if (flow.booleanInterfaceType) {\n                    return flow.booleanInterfaceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this == flow.stringType) {\n                if (flow.stringInterfaceType) {\n                    return flow.stringInterfaceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this.elementType) {\n                if (flow.arrayInterfaceType) {\n                    var arrInstType = this.elementType.getArrayBase(flow.arrayInterfaceType, flow.checker);\n                    return arrInstType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return this.memberScope;\n            }\n        }\n\n        public isReferenceType() {\n            return this.members || this.extendsList ||\n                this.construct || this.call || this.index ||\n                this.elementType;\n        }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker, membersOnly: bool): Type {\n            if (pattern == this) {\n                return replacement;\n            }\n            var result = this;\n            if (membersOnly) {\n                // assume interface type without bases\n                if (this.isReferenceType()) {\n                    result = new Type();\n                    if (this.members) {\n                        result.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n                        this.members.publicMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n         ';
var v27451 = v27452 + "                   var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.members.addPublicMember(bSym.name, bSym);\n                        }, null);\n\n                        this.members.privateMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.members.addPrivateMember(bSym.name, bSym);\n                        }, null);\n                    }\n                    if (this.ambientMembers) {\n                        result.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                        this.ambientMembers.publicMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.ambientMembers.addPublicMember(bSym.name, bSym);\n                        }, null);\n\n                        this.ambientMembers.privateMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.ambientMembers.addPrivateMember(bSym.name, bSym);\n                        }, null);\n                    }\n                    result.containedScope = checker.scopeOf(result);\n                    result.memberScope = result.containedScope;\n                }\n            }\n            else {\n                if (this.elementType) {\n                    if (this.elementType == pattern) {\n                        result = checker.makeArrayType(replacement);\n                    }\n                    else {\n                        if (this.elementType.elementType == pattern) {\n                            result = checker.makeArrayType(checker.makeArrayType(replacement));\n                        }\n                    }\n                }\n                else if (this.call) {\n                    result = new Type();\n                    result.call = this.call.specializeType(pattern, replacement, checker);\n                }\n            }\n            return result;\n        }\n\n        public hasBase(baseType: Type): bool {\n            if (baseType == this) {\n                return true;\n            }\n            else {\n                if (this.extendsList) {\n                    for (var i = 0, len = this.extendsList.length; i < len; i++) {\n                        if (this.extendsList[i].hasBase(baseType)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        public mergeOrdered(b: Type, checker: TypeChecker, acceptVoid: bool, comparisonInfo?: TypeComparisonInfo): Type {\n            if ((this == checker.anyType) || (b == checker.anyType)) {\n                return checker.anyType;\n            }\n            else if (this == b) {\n                return this;\n            }\n            else if ((b == checker.nullType) && this != checker.nullType) {\n                return this;\n            }\n            else if ((this == checker.nullType) && (b != checker.nullType)) {\n                return b;\n            }\n            else if (acceptVoid && (b == checker.voidType) && this != checker.voidType) {\n                return this;\n            }\n            else if (acceptVoid && (this == checker.voidType) && (b != checker.voidType)) {\n                return b;\n            }\n            else if ((b == checker.undefinedType) && this != checker.undefinedType) {\n                return this;\n            }\n            else if ((this == checker.undefinedType) && (b != checker.undefinedType)) {\n                return b;\n            }\n            else if (this.elementType && b.elementType) {\n                if (this.elementType == b.elementType) {\n                    return this;\n                }\n                else {\n                    var mergedET = this.elementType.mergeOrdered(b.elementType, checker, acceptVoid, comparisonInfo);\n                    if (mergedET == null) {\n                        return checker.makeArrayType(checker.anyType);\n                    }\n                    else {\n                        return checker.makeArrayType(mergedET);\n                    }\n                }\n            }\n            else if (checker.sourceIsSubtypeOfTarget(this, b, comparisonInfo)) {\n                return b;\n            }\n            else if (checker.sourceIsSubtypeOfTarget(b, this, comparisonInfo)) {\n                return this;\n            }\n            else {\n                return null;\n            }\n        }\n\n        public isModuleType() { return false; }\n        public hasMembers() { return this.members != null; }\n        public getAllEnclosedTypes(): ScopedMembers { return null; }\n        public getAllAmbientEnc";
var v27450 = v27451 + 'losedTypes(): ScopedMembers { return null; }\n        public getPublicEnclosedTypes(): ScopedMembers { return null; }\n        public getpublicAmbientEnclosedTypes(): ScopedMembers { return null; }\n\n        public getDocComments(): Comment[]{\n            if (this.elementType || !this.symbol) {\n                return [];\n            }\n\n            if (this.isClassInstance() || this.isClass()) {\n                if (this.symbol.declAST.nodeType == NodeType.FuncDecl) {\n                    // Its a constructor - use the class declaration instead\n                    return (<FuncDecl>this.symbol.declAST).classDecl.getDocComments();\n                } else {\n                    // Its a class without constructor\n                    return this.symbol.getDocComments();\n                }\n            }\n\n            if (this.symbol.name && this.symbol.name != "_anonymous" &&\n                (((this.call == null) && (this.construct == null) && (this.index == null))\n                  || this.members)) {\n                return this.symbol.getDocComments();\n            }\n\n            return [];\n        }\n    }\n\n    export interface ITypeCollection {\n        // returns null when types are exhausted\n        getLength(): number;\n        setTypeAtIndex(index: number, type: Type): void;\n        getTypeAtIndex(index: number): Type;\n    }\n\n    export class ModuleType extends Type {\n\n        constructor (public enclosedTypes: ScopedMembers, public ambientEnclosedTypes: ScopedMembers) {\n            super();\n        }\n\n        public isModuleType() { return true; }\n        public hasMembers() { return this.members != null || this.enclosedTypes != null; }\n        public getAllEnclosedTypes() { return this.enclosedTypes; }\n        public getAllAmbientEnclosedTypes() { return this.ambientEnclosedTypes; }\n        public getPublicEnclosedTypes(): ScopedMembers { return null; }\n        public getpublicAmbientEnclosedTypes(): ScopedMembers { return null; }\n        public importedModules: ImportDeclaration[] = [];\n\n        // Finds the dynamic module name of moduleType in the members\n        // ignoreSymbols define list of symbols already visited - to avoid recursion\n        static findDynamicModuleNameInHashTable(moduleType: Type, members: IHashTable) {\n            var moduleName: { name: string; symbol: Symbol; } = null;\n            members.map((key, s, c) => {\n                if (moduleName == null && !isQuoted(key)) {\n                    var symbol = <Symbol>s;\n                    var type = symbol.getType();\n                    if (type == moduleType) {\n                        // If this is the module type we were looking for\n                        moduleName = { name: key, symbol: symbol };\n                    }\n                }\n            }, null);\n\n            return moduleName;\n        }\n\n        // Finds the Dynamic module name of the moduleType in this moduleType\n        // onlyPublic tells if we are looking for module name in public members only\n        public findDynamicModuleName(moduleType: Type): { name: string; symbol: Symbol; } {\n            var moduleName: { name: string; symbol: Symbol; } = null;\n            // Not cached, so seach and add to the cache\n            moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.members.allMembers);\n            if (moduleName == null) {\n                moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.ambientMembers.allMembers);\n            }\n            return moduleName;\n        }\n    }\n\n    export class TypeLink {\n        public type: Type = null;\n        public ast: AST = null;\n    }\n\n    export function getTypeLink(ast: AST, checker: TypeChecker, autoVar: bool): TypeLink {\n        var result = new TypeLink();\n\n        result.ast = ast;\n\n        if ((ast == null) && (autoVar)) {\n            result.type = checker.anyType;\n        }\n        else {\n            result.type = null;\n        }\n\n        return result;\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule Tools {\n    export interface IWalkContext {\n        goChildren: bool;\n        goNextSibling: bool;\n        // visit siblings in reverse execution order\n        reverseSiblings: bool;\n    }\n\n    export class BaseWalkContext implements IWalkContext {\n        public goChildren = true;\n        public goNextSibling = true;\n        public reverseSiblings = false;\n    }\n}';
var compiler_input = v27450;
var TypeScript;
var v18791 = TypeScript;
if(!v18791) {
  v18791 = TypeScript = {}
}
v48(v18791);
var v18792 = TypeScript;
if(!v18792) {
  v18792 = TypeScript = {}
}
v49(v18792);
var v18793 = TypeScript;
if(!v18793) {
  v18793 = TypeScript = {}
}
v78(v18793);
var v12343 = this.__extends;
if(!v12343) {
  v12343 = v79
}
var __extends = v12343;
var v18795 = TypeScript;
if(!v18795) {
  v18795 = TypeScript = {}
}
v322(v18795);
var v18796 = TypeScript;
if(!v18796) {
  v18796 = TypeScript = {}
}
v333(v18796);
var v18797 = TypeScript;
if(!v18797) {
  v18797 = TypeScript = {}
}
v335(v18797);
var v18798 = TypeScript;
if(!v18798) {
  v18798 = TypeScript = {}
}
v399(v18798);
var v18799 = TypeScript;
if(!v18799) {
  v18799 = TypeScript = {}
}
v407(v18799);
var v18800 = TypeScript;
if(!v18800) {
  v18800 = TypeScript = {}
}
v417(v18800);
var v18801 = TypeScript;
if(!v18801) {
  v18801 = TypeScript = {}
}
v420(v18801);
var JSON2 = {};
v427();
var v18802 = TypeScript;
if(!v18802) {
  v18802 = TypeScript = {}
}
v433(v18802);
var v18803 = TypeScript;
if(!v18803) {
  v18803 = TypeScript = {}
}
v492(v18803);
var v18804 = TypeScript;
if(!v18804) {
  v18804 = TypeScript = {}
}
v519(v18804);
var v18805 = TypeScript;
if(!v18805) {
  v18805 = TypeScript = {}
}
v592(v18805);
var v18806 = TypeScript;
if(!v18806) {
  v18806 = TypeScript = {}
}
v599(v18806);
var v18807 = TypeScript;
if(!v18807) {
  v18807 = TypeScript = {}
}
v675(v18807);
var v18808 = TypeScript;
if(!v18808) {
  v18808 = TypeScript = {}
}
v680(v18808);
var v18809 = TypeScript;
if(!v18809) {
  v18809 = TypeScript = {}
}
v698(v18809);
var v18810 = TypeScript;
if(!v18810) {
  v18810 = TypeScript = {}
}
v711(v18810);
var v18811 = TypeScript;
if(!v18811) {
  v18811 = TypeScript = {}
}
v794(v18811);
var v18812 = TypeScript;
if(!v18812) {
  v18812 = TypeScript = {}
}
v862(v18812);
var v18813 = TypeScript;
if(!v18813) {
  v18813 = TypeScript = {}
}
v892(v18813);
var v18814 = TypeScript;
if(!v18814) {
  v18814 = TypeScript = {}
}
v964(v18814);
var v18815 = TypeScript;
if(!v18815) {
  v18815 = TypeScript = {}
}
v967(v18815);
var v18816 = TypeScript;
if(!v18816) {
  v18816 = TypeScript = {}
}
v1113(v18816);
var v18817 = TypeScript;
if(!v18817) {
  v18817 = TypeScript = {}
}
v1172(v18817);
var v18818 = TypeScript;
if(!v18818) {
  v18818 = TypeScript = {}
}
v1173(v18818);
var v18819 = TypeScript;
if(!v18819) {
  v18819 = TypeScript = {}
}
v1180(v18819);
var v18820 = TypeScript;
if(!v18820) {
  v18820 = TypeScript = {}
}
v1186(v18820);
var v18821 = TypeScript;
if(!v18821) {
  v18821 = TypeScript = {}
}
v1195(v18821);
var v18822 = TypeScript;
if(!v18822) {
  v18822 = TypeScript = {}
}
v1233(v18822);
var v18823 = TypeScript;
if(!v18823) {
  v18823 = TypeScript = {}
}
v1288(v18823);
var v18824 = TypeScript;
if(!v18824) {
  v18824 = TypeScript = {}
}
v1311(v18824);
var IOUtils;
var v18825 = IOUtils;
if(!v18825) {
  v18825 = IOUtils = {}
}
v1312(v18825);
var IO = v1357();
var OptionsParser = v1365();
var CommandLineHost = v1370();
var BatchCompiler = v1409();
var completed = 0;
var benchmarks = BenchmarkSuite.CountBenchmarks();
var success = true;
var latencyBenchmarks = ["Splay", "Mandreel"];
var v12375;
if(typeof skipBenchmarks === "undefined") {
  v12375 = []
}else {
  v12375 = skipBenchmarks
}
var skipBenchmarks = v12375;

